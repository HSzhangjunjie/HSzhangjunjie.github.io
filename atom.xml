<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jieker&#39;s Blog</title>
  
  <subtitle>Jiker</subtitle>
  <link href="https://jie-blog.icu/atom.xml" rel="self"/>
  
  <link href="https://jie-blog.icu/"/>
  <updated>2020-11-04T04:19:34.169Z</updated>
  <id>https://jie-blog.icu/</id>
  
  <author>
    <name>Zhang Junjie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>plugin包</title>
    <link href="https://jie-blog.icu/posts/mybatis-plugin/"/>
    <id>https://jie-blog.icu/posts/mybatis-plugin/</id>
    <published>2020-11-04T04:18:54.000Z</published>
    <updated>2020-11-04T04:19:34.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="plugin包"><a class="markdownIt-Anchor" href="#plugin包"></a> plugin包</h1><p>Mybatis还提供插件功能，允许其他开发者为Mybatis开发插件以扩展功能。<br /><a name="VZHl8"></a></p><h1 id="责任链模式"><a class="markdownIt-Anchor" href="#责任链模式"></a> 责任链模式</h1><p>责任链模式将多个处理器组成一条链条（单向链表），被处理的对象被放置在链条的起始端后，会自动在整个链条上传递和处理。<br /><a name="ZrZZ6"></a></p><h2 id="案例演示"><a class="markdownIt-Anchor" href="#案例演示"></a> 案例演示</h2><p>处理器定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前处理器的下一个处理器</span></span><br><span class="line">    <span class="keyword">private</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前处理器的处理逻辑，交给子类实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> performer 被处理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Performer performer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 触发当前处理器，并在处理结束后将被处理对象传给后续处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> performer 被处理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">triggerProcess</span><span class="params">(Performer performer)</span> </span>&#123;</span><br><span class="line">        handle(performer);</span><br><span class="line">        <span class="keyword">if</span> (nextHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            nextHandler.triggerProcess(performer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置当前处理器的下一个处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nextHandler 下一个处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Handler <span class="title">setNextHandler</span><span class="params">(Handler nextHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextHandler = nextHandler;</span><br><span class="line">        <span class="keyword">return</span> nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个处理器的实现需要实现自身的handle方法。形成类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603772253772-a9f1f618-4af4-41f9-a501-6e54cec32043.png#align=left&amp;display=inline&amp;height=214&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=428&amp;originWidth=1048&amp;size=693841&amp;status=done&amp;style=none&amp;width=524" alt="image.png" /><br /><a name="zx02f"></a></p><h3 id="使用演示"><a class="markdownIt-Anchor" href="#使用演示"></a> 使用演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用责任链模式</span></span><br><span class="line">System.out.println(<span class="string">&quot;使用责任链模式：&quot;</span>);</span><br><span class="line"><span class="comment">// 创建责任链</span></span><br><span class="line">Handler handlerChain = <span class="keyword">new</span> MailSender();</span><br><span class="line">handlerChain.setNextHandler(<span class="keyword">new</span> MaterialManager()).setNextHandler(<span class="keyword">new</span> ContactOfficer());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次处理每个参与者</span></span><br><span class="line"><span class="keyword">for</span> (Performer performer : performerList) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;process &quot;</span> + performer.getName() + <span class="string">&quot;:&quot;</span>);</span><br><span class="line">    handlerChain.triggerProcess(performer);</span><br><span class="line">    System.out.println(<span class="string">&quot;---------&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="rrbs6"></a></p><h1 id="插件开发"><a class="markdownIt-Anchor" href="#插件开发"></a> 插件开发</h1><p><a name="KcClB"></a></p><h2 id="自定义插件"><a class="markdownIt-Anchor" href="#自定义插件"></a> 自定义插件</h2><p>现创建一个插件在Mybatis查询列表结果时打印结果数目，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;</span></span><br><span class="line"><span class="meta">        @Signature(type = ResultSetHandler.class, method = &quot;handleResultSets&quot;, args = &#123;Statement.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YeecodeInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String info;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 执行原有方法</span></span><br><span class="line">        Object result = invocation.proceed();</span><br><span class="line">        <span class="comment">// 打印原方法输出结果的数目</span></span><br><span class="line">        System.out.println(info + <span class="string">&quot;:&quot;</span> + ((List) result).size());</span><br><span class="line">        <span class="comment">// 返回原有结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 为拦截器设置属性</span></span><br><span class="line">        info = properties.get(<span class="string">&quot;preInfo&quot;</span>).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="EDXHM"></a></p><h2 id="配置解析"><a class="markdownIt-Anchor" href="#配置解析"></a> 配置解析</h2><p>插件实现了一个Interceptor接口的类，该接口的含义是拦截器。拦截器类上有注解Intercepts，其参数是Signature注解数组。每个Signature注解都声明了当前拦截器类要拦截的方法，Signature的参数含义如下：</p><ul><li>type：拦截器要拦截的类型。</li><li>method：拦截器要拦截的type类型中的方法。</li><li>args：拦截器要拦截的type类型的method方法的参数类型列表。</li></ul><p>Interceptor接口内有三个方法可以实现：</p><ul><li>intercept：拦截器必须实现该方法。拦截器拦截到目标方法时，会将操作转接到该intercept上，其中参数的Invocation为拦截到的目标方法。</li><li>plugin：该方法中可以输出一个对象来替换输入参数传入的目标对象。</li><li>setProperties：该方法用来为了拦截器设置属性。</li></ul><p>拦截器配置结束后还要将拦截器配置到配置文件中才生效：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603773500864-690cbf08-02f0-46e7-924b-0b8a9b3f4a51.png#align=left&amp;display=inline&amp;height=82&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=164&amp;originWidth=1183&amp;size=128021&amp;status=done&amp;style=none&amp;width=591.5" alt="image.png" /><br /><a name="m4YtA"></a></p><h1 id="拦截平台"><a class="markdownIt-Anchor" href="#拦截平台"></a> 拦截平台</h1><p>Mybatis在plugin包中搭建了一个拦截器平台，其类图如下图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603773969098-3af658b2-4227-4a0c-9e1f-3a719c1b1570.png#align=left&amp;display=inline&amp;height=327&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=654&amp;originWidth=1298&amp;size=1171281&amp;status=done&amp;style=none&amp;width=649" alt="image.png" /><br />之前实现了自定义插件（拦截器），下面将深入剖析一下其内部原理。<br /><a name="wdjRT"></a></p><h2 id="执行原理"><a class="markdownIt-Anchor" href="#执行原理"></a> 执行原理</h2><p>Plugin类的属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被代理对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"><span class="comment">// 拦截器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Interceptor interceptor;</span><br><span class="line"><span class="comment">// 拦截器要拦截的所有的类，以及类中的方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap;</span><br></pre></td></tr></table></figure><p>其中signatureMap属性为核心，他负责将所有的类和对应的拦截器绑定起来，其获取方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; getSignatureMap(Interceptor interceptor) &#123;</span><br><span class="line">  <span class="comment">// 获取拦截器的Intercepts注解</span></span><br><span class="line">  Intercepts interceptsAnnotation = interceptor.getClass().getAnnotation(Intercepts.class);</span><br><span class="line">  <span class="keyword">if</span> (interceptsAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> PluginException(<span class="string">&quot;No @Intercepts annotation was found in interceptor &quot;</span> + interceptor.getClass().getName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将Intercepts注解的value信息取出，是一个Signature的数组</span></span><br><span class="line">  Signature[] sigs = interceptsAnnotation.value();</span><br><span class="line">  <span class="comment">// 将Signature数组放入一个map。键为Signature的type类型，值为方法集合</span></span><br><span class="line">  Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Signature sig : sigs) &#123;</span><br><span class="line">    Set&lt;Method&gt; methods = signatureMap.computeIfAbsent(sig.type(), k -&gt; <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Method method = sig.type().getMethod(sig.method(), sig.args());</span><br><span class="line">      methods.add(method);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> PluginException(<span class="string">&quot;Could not find method on &quot;</span> + sig.type() + <span class="string">&quot; named &quot;</span> + sig.method() + <span class="string">&quot;. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> signatureMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过该方法，Plugin就可以查看当前类型是否需要被拦截器拦截。如果需要拦截，则会为当前类创建一个代理类，实现位于wrap方法中，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 得到拦截器interceptor要拦截的类型与方法</span></span><br><span class="line">  Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">  <span class="comment">// 被代理对象的类型</span></span><br><span class="line">  Class&lt;?&gt; type = target.getClass();</span><br><span class="line">  <span class="comment">// 逐级寻找被代理对象的父类，将需要被拦截的父类全部找出</span></span><br><span class="line">  Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">  <span class="comment">// 只要有一个父类需要被拦截，那么就为其创建并返回一个代理对象，即Plugin实例</span></span><br><span class="line">  <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">        type.getClassLoader(),</span><br><span class="line">        interfaces,</span><br><span class="line">        <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然代理类，那么就要追寻其invoke方法，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取该类所有需要被拦截的方法</span></span><br><span class="line">    Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">    <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">      <span class="comment">// 方法确实需要被拦截，因此交给拦截器处理</span></span><br><span class="line">      <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法不需要被拦截，交给默认处理</span></span><br><span class="line">    <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以通过Intercepts和Signature两个注解来实现拦截器的功能了。当前也可以通过重写Interceptor的plugin方法来实现更强大的功能。<br /><a name="njzp1"></a></p><h1 id="拦截器链与拦截点"><a class="markdownIt-Anchor" href="#拦截器链与拦截点"></a> 拦截器链与拦截点</h1><p><a name="F1Ta4"></a></p><h2 id="拦截器链"><a class="markdownIt-Anchor" href="#拦截器链"></a> 拦截器链</h2><p>拦截器的插件会在Mybatis初始化阶段写入到InterceptorChain类的interceptors列表中。详见XMLConfigBuilder的pluginElement方法，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pluginElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// &lt;plugins&gt;节点存在</span></span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 读取每一个&lt;plugin&gt;</span></span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="comment">// 读取拦截器类名</span></span><br><span class="line">      String interceptor = child.getStringAttribute(<span class="string">&quot;interceptor&quot;</span>);</span><br><span class="line">      <span class="comment">// 读取拦截器属性</span></span><br><span class="line">      Properties properties = child.getChildrenAsProperties();</span><br><span class="line">       <span class="comment">// 实例化拦截器</span></span><br><span class="line">      Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();</span><br><span class="line">      <span class="comment">// 设置拦截器属性</span></span><br><span class="line">      interceptorInstance.setProperties(properties);</span><br><span class="line">      <span class="comment">// 添加到拦截器链中</span></span><br><span class="line">      configuration.addInterceptor(interceptorInstance);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截器链的定义（List集合的形式）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="02bI6"></a></p><h2 id="拦截点与责任链"><a class="markdownIt-Anchor" href="#拦截点与责任链"></a> 拦截点与责任链</h2><p>Mybatis中并非所有的类都可以被拦截，只有四个类的对象可以被拦截：ParameterHandler、StatementHandler、StatementHandler和Executor，他们的替换只发生在固定的地方，称之为拦截点。<br />以ParameterHandler为例，其拦截点的设置详见Configuration的newParameterHandler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建参数处理器  </span></span><br><span class="line">  ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">  <span class="comment">// 将参数处理器交给拦截器链进行替换，以便拦截器链中的拦截器能注入行为  </span></span><br><span class="line">  parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">  <span class="comment">// 返回最终的参数处理器</span></span><br><span class="line">  <span class="keyword">return</span> parameterHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pluginAll方法会将目标对象交给每个拦截器进行替换处理，最终得到目标对象target汇聚了拦截器链中的每一个拦截器的功能，这就是责任链的形成，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">    target = interceptor.plugin(target);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;plugin包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#plugin包&quot;&gt;&lt;/a&gt; plugin包&lt;/h1&gt;
&lt;p&gt;Mybatis还提供插件功能，允许其他开发者为Mybatis开发插件以扩展功能。&lt;br /&gt;
&lt;a name=&quot;V</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="核心操作包" scheme="https://jie-blog.icu/categories/mybatis/%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C%E5%8C%85/"/>
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>session包</title>
    <link href="https://jie-blog.icu/posts/mybatis-session/"/>
    <id>https://jie-blog.icu/posts/mybatis-session/</id>
    <published>2020-11-04T04:18:40.000Z</published>
    <updated>2020-11-04T04:19:13.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="session包"><a class="markdownIt-Anchor" href="#session包"></a> session包</h1><p>session包是整个Mybatis应用对外接口的包，是离用户最近的包。<br /><a name="iqigS"></a></p><h1 id="sqlsession及其相关类"><a class="markdownIt-Anchor" href="#sqlsession及其相关类"></a> SqlSession及其相关类</h1><p>在数据库查询时，只需操作SqlSession即可，而SqlSession是由SqlSessionFactory产生的，SqlSessionFactory是由SqlSessionFactoryBuilder创建的。SqlSession相关类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603678418599-accd38a5-8d5c-43b7-880b-d0f5bdb8e751.png#align=left&amp;display=inline&amp;height=139&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=277&amp;originWidth=1070&amp;size=511451&amp;status=done&amp;style=none&amp;width=535" alt="image.png" /><br /><a name="YxqkP"></a></p><h2 id="sqlsession生成链"><a class="markdownIt-Anchor" href="#sqlsession生成链"></a> SqlSession生成链</h2><p><a name="a81PS"></a></p><h3 id="sqlsessionfactorybuilder"><a class="markdownIt-Anchor" href="#sqlsessionfactorybuilder"></a> SqlSessionFactoryBuilder</h3><p>SqlSessionFactoryBuilder是SqlSessionFactory的建造者，它可以根据配置文件创建出SqlSessionFactory对象。其核心build源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Reader reader, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 传入配置文件创建一个XMLConfigBuilder对象</span></span><br><span class="line">    XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(reader, environment, properties);</span><br><span class="line">    <span class="comment">// 解析配置文件传入build方法</span></span><br><span class="line">    <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error building SqlSession.&quot;</span>, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      reader.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，给出的SqlSessionFactory的永远是DefaultSqlSessionFactory。<br /><a name="boojU"></a></p><h3 id="defaultsqlsessionfactory"><a class="markdownIt-Anchor" href="#defaultsqlsessionfactory"></a> DefaultSqlSessionFactory</h3><p>DefaultSqlSessionFactory生成SqlSession是由openSessionFromDataSource完成的，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">  Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 找出要使用的指定环境</span></span><br><span class="line">    <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">    <span class="comment">// 从环境中获取事务工厂</span></span><br><span class="line">    <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">    <span class="comment">// 从事务工厂中生产事务</span></span><br><span class="line">    tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">    <span class="comment">// 创建执行器</span></span><br><span class="line">    <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">    <span class="comment">// 创建DefaultSqlSession</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error opening session.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="261uk"></a></p><h3 id="defaultsqlsession"><a class="markdownIt-Anchor" href="#defaultsqlsession"></a> DefaultSqlSession</h3><p>DefaultSqlSession类的主要工作十分简单，即把接口包的工作交给执行器包处理。<br />其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line"><span class="comment">// 执行器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"><span class="comment">// 是否自动提交</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> autoCommit;</span><br><span class="line"><span class="comment">// 缓存是否已经被污染</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> dirty;</span><br><span class="line"><span class="comment">// 游标列表</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Cursor&lt;?&gt;&gt; cursorList;</span><br></pre></td></tr></table></figure><p>其执行流程以selectList为例，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取查询语句</span></span><br><span class="line">    MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">    <span class="comment">// 交由执行器查询</span></span><br><span class="line">    <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error querying database.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="WSzj8"></a></p><h2 id="sqlsessionmanager"><a class="markdownIt-Anchor" href="#sqlsessionmanager"></a> SqlSessionManager</h2><p>该类类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603679935222-aaaba7cb-2d40-48b4-83a1-d9808e2d081e.png#align=left&amp;display=inline&amp;height=268&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=536&amp;originWidth=855&amp;size=676021&amp;status=done&amp;style=none&amp;width=427.5" alt="image.png" /><br />工厂接口和工厂产品接口都交由了这个类处理，这种情况是罕见的。<br />该类的内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法传入的sqlSessionFactory</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"><span class="comment">// 构造方法生成的sqlSessionProxy</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSessionProxy;</span><br><span class="line"><span class="comment">// 存储被代理的SqlSession</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;SqlSession&gt; localSqlSession = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure><p>该类的构造方法是私有的，发布需要通过newInstance来间接调用它，其构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SqlSessionManager</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">  <span class="keyword">this</span>.sqlSessionProxy = (SqlSession) Proxy.newProxyInstance(</span><br><span class="line">      SqlSessionFactory.class.getClassLoader(),</span><br><span class="line">      <span class="keyword">new</span> Class[]&#123;SqlSession.class&#125;,</span><br><span class="line">      <span class="keyword">new</span> SqlSessionInterceptor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，其构造方法中创建了一个sqlSessionProxy，该代理对象可以拦截被代理的SqlSession的方法，被拦截到的方法会交给其内部类SqlSessionInterceptor的invoke处理，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试从当前线程取出SqlSession对象</span></span><br><span class="line">    <span class="keyword">final</span> SqlSession sqlSession = SqlSessionManager.<span class="keyword">this</span>.localSqlSession.get();</span><br><span class="line">    <span class="comment">// 当前线程中确实取出了SqlSession</span></span><br><span class="line">    <span class="keyword">if</span> (sqlSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用取出的对象进行操作</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 使用factory创建一个sqlsession</span></span><br><span class="line">      <span class="keyword">try</span> (SqlSession autoSqlSession = openSession()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 使用新创建的进行操作</span></span><br><span class="line">          <span class="keyword">final</span> Object result = method.invoke(autoSqlSession, args);</span><br><span class="line">          autoSqlSession.commit();</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          autoSqlSession.rollback();</span><br><span class="line">          <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="T1mfQ"></a></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>这种罕见的整合方式提供了以下两点功能：</p><ul><li>总能给出一个产品（从ThreadLocal取出或者创建）并使用该产品完成相关的操作，外部使用者不需要了解细节，因此省略了调用工厂生产产品的过程。</li><li>提供了产品复用功能。工厂生产出来的产品可以放在ThreadLocal中保存，从而实现了实现产品的复用，既保证了线程安全又提升了效率。</li></ul><p>用户使用的是工厂生产出来的产品，而不关心是即时还是之前生产出来缓存的。这种情况下可以参考该类的设计。<br /><a name="a1zyg"></a></p><h1 id="configuration类"><a class="markdownIt-Anchor" href="#configuration类"></a> Configuration类</h1><p>该类是Mybatis配置的主入口，配置文件的根节点就是configuration节点，因此该类保存了所有的配置信息。此外，该类还对配置信息进行了进一步的加工，为许多配置项都设置了默认值，为许多实体定义了别名等。其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// environment节点的信息</span></span><br><span class="line"><span class="keyword">protected</span> Environment environment;</span><br><span class="line"><span class="comment">// setting节点中的配置信息</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> safeRowBoundsEnabled;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> safeResultHandlerEnabled = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> mapUnderscoreToCamelCase;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> aggressiveLazyLoading;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> multipleResultSetsEnabled = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> useGeneratedKeys;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> useColumnLabel = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> cacheEnabled = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> callSettersOnNulls;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> useActualParamName = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> returnInstanceForEmptyRow;</span><br><span class="line"><span class="keyword">protected</span> String logPrefix;</span><br><span class="line"><span class="keyword">protected</span> Class&lt;? extends Log&gt; logImpl;</span><br><span class="line"><span class="keyword">protected</span> Class&lt;? extends VFS&gt; vfsImpl;</span><br><span class="line"><span class="keyword">protected</span> LocalCacheScope localCacheScope = LocalCacheScope.SESSION;</span><br><span class="line"><span class="keyword">protected</span> JdbcType jdbcTypeForNull = JdbcType.OTHER;</span><br><span class="line"><span class="keyword">protected</span> Set&lt;String&gt; lazyLoadTriggerMethods = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">&quot;equals&quot;</span>, <span class="string">&quot;clone&quot;</span>, <span class="string">&quot;hashCode&quot;</span>, <span class="string">&quot;toString&quot;</span>));</span><br><span class="line"><span class="keyword">protected</span> Integer defaultStatementTimeout;</span><br><span class="line"><span class="keyword">protected</span> Integer defaultFetchSize;</span><br><span class="line"><span class="keyword">protected</span> ResultSetType defaultResultSetType;</span><br><span class="line"><span class="keyword">protected</span> ExecutorType defaultExecutorType = ExecutorType.SIMPLE;</span><br><span class="line"><span class="keyword">protected</span> AutoMappingBehavior autoMappingBehavior = AutoMappingBehavior.PARTIAL;</span><br><span class="line"><span class="keyword">protected</span> AutoMappingUnknownColumnBehavior autoMappingUnknownColumnBehavior = AutoMappingUnknownColumnBehavior.NONE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// properties节点</span></span><br><span class="line"><span class="keyword">protected</span> Properties variables = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">// 反射工厂</span></span><br><span class="line"><span class="keyword">protected</span> ReflectorFactory reflectorFactory = <span class="keyword">new</span> DefaultReflectorFactory();</span><br><span class="line"><span class="comment">// 对象工厂</span></span><br><span class="line"><span class="keyword">protected</span> ObjectFactory objectFactory = <span class="keyword">new</span> DefaultObjectFactory();</span><br><span class="line"><span class="comment">// 对象包装工厂</span></span><br><span class="line"><span class="keyword">protected</span> ObjectWrapperFactory objectWrapperFactory = <span class="keyword">new</span> DefaultObjectWrapperFactory();</span><br><span class="line"><span class="comment">// 是否启用懒加载，该配置来自于Setting</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> lazyLoadingEnabled = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 代理工厂</span></span><br><span class="line"><span class="keyword">protected</span> ProxyFactory proxyFactory = <span class="keyword">new</span> JavassistProxyFactory(); <span class="comment">// #224 Using internal Javassist instead of OGNL</span></span><br><span class="line"><span class="comment">// 数据库编号</span></span><br><span class="line"><span class="keyword">protected</span> String databaseId;</span><br><span class="line"><span class="comment">// 配置工厂,创建用于加载反序列化的未读属性的配置</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; configurationFactory;</span><br><span class="line"><span class="comment">// 映射注册表</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> MapperRegistry mapperRegistry = <span class="keyword">new</span> MapperRegistry(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 拦截器链（用于支持插件的插入</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> InterceptorChain interceptorChain = <span class="keyword">new</span> InterceptorChain();</span><br><span class="line"><span class="comment">// 类型处理器注册表，内置很多，可以通过&lt;typeHndler&gt;补充</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry = <span class="keyword">new</span> TypeHandlerRegistry();</span><br><span class="line"><span class="comment">// 类型别名注册表，内置很多，可以通过&lt;typeAliases&gt;</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> TypeAliasRegistry typeAliasRegistry = <span class="keyword">new</span> TypeAliasRegistry();</span><br><span class="line"><span class="comment">// 语言驱动注册表</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> LanguageDriverRegistry languageRegistry = <span class="keyword">new</span> LanguageDriverRegistry();</span><br><span class="line"><span class="comment">// 映射的数据库操作语句</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, MappedStatement&gt; mappedStatements = <span class="keyword">new</span> StrictMap&lt;MappedStatement&gt;(<span class="string">&quot;Mapped Statements collection&quot;</span>)</span><br><span class="line">      .conflictMessageProducer((savedValue, targetValue) -&gt;</span><br><span class="line">          <span class="string">&quot;. please check &quot;</span> + savedValue.getResource() + <span class="string">&quot; and &quot;</span> + targetValue.getResource());</span><br><span class="line"><span class="comment">// 缓存</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, Cache&gt; caches = <span class="keyword">new</span> StrictMap&lt;&gt;(<span class="string">&quot;Caches collection&quot;</span>);</span><br><span class="line"><span class="comment">// 结果映射，即所有的&lt;resuleMap&gt;</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, ResultMap&gt; resultMaps = <span class="keyword">new</span> StrictMap&lt;&gt;(<span class="string">&quot;Result Maps collection&quot;</span>);</span><br><span class="line"><span class="comment">// 参数映射，即所有的&lt;parameterMap&gt;</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, ParameterMap&gt; parameterMaps = <span class="keyword">new</span> StrictMap&lt;&gt;(<span class="string">&quot;Parameter Maps collection&quot;</span>);</span><br><span class="line"><span class="comment">// 主键生成器映射</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, KeyGenerator&gt; keyGenerators = <span class="keyword">new</span> StrictMap&lt;&gt;(<span class="string">&quot;Key Generators collection&quot;</span>);</span><br><span class="line"><span class="comment">// 载入的资源，如映射文件资源</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Set&lt;String&gt; loadedResources = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="comment">// SQL语句片段，即所有的sql节点</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, XNode&gt; sqlFragments = <span class="keyword">new</span> StrictMap&lt;&gt;(<span class="string">&quot;XML fragments parsed from previous mappers&quot;</span>);</span><br><span class="line"><span class="comment">// 暂未处理的节点</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Collection&lt;XMLStatementBuilder&gt; incompleteStatements = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Collection&lt;CacheRefResolver&gt; incompleteCacheRefs = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Collection&lt;ResultMapResolver&gt; incompleteResultMaps = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Collection&lt;MethodResolver&gt; incompleteMethods = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="comment">// 用来存储namesapce的缓存共享设置</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, String&gt; cacheRefMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>Mybatis中的近20个类都内置了Configuration对象，这使得其能为其他对象提供配置信息的查询和更新服务。<br /><a name="75zkE"></a></p><h2 id="scriptmap"><a class="markdownIt-Anchor" href="#scriptmap"></a> ScriptMap</h2><p>为了便于查询，其内部还内置了一个ScriptMap内置类，其有如下几个特点：</p><ul><li>不允许覆盖键值。</li><li>自动尝试使用短名称再次存入给定数据。</li></ul><p>其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(String key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (containsKey(key)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(name + <span class="string">&quot; already contains value for &quot;</span> + key</span><br><span class="line">        + (conflictMessageProducer == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : conflictMessageProducer.apply(<span class="keyword">super</span>.get(key), value)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (key.contains(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">final</span> String shortKey = getShortName(key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">super</span>.get(shortKey) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 以短名为键放置一次</span></span><br><span class="line">      <span class="keyword">super</span>.put(shortKey, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 放入该对象，表示短名会引发歧义</span></span><br><span class="line">      <span class="keyword">super</span>.put(shortKey, (V) <span class="keyword">new</span> Ambiguity(shortKey));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 以长名为key放置一次</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="6IbWD"></a></p><h1 id="其他类"><a class="markdownIt-Anchor" href="#其他类"></a> 其他类</h1><p><a name="3cYn5"></a></p><h2 id="枚举类"><a class="markdownIt-Anchor" href="#枚举类"></a> 枚举类</h2><p>Session中其他类中包含数目最多的就是枚举类，其功能分别如下：</p><ul><li>AutoMappingBehavior：表示自动映射中遇到的一些未知的字段该如何处理。可选不处理、输出报警日志和抛出异常。</li><li>ExecutorType：表示执行器类型。可选有简单执行器、支持复用执行器和支持批量操作的执行器。</li><li>LocalCacheScope：表示本地缓存的作用范围。可选项有会话和语句。</li><li>TransactionIsolationLevel：表示事务隔离级别。有无隔离、读已提交、读未提交、可重复度和串行化。<br /><a name="3851x"></a></li></ul><h2 id="rowbounds"><a class="markdownIt-Anchor" href="#rowbounds"></a> RowBounds</h2><p>该类用于查询结果的分页设置，即表明查询结果的起始位置和条数限制。其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 起始位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line"><span class="comment">// 总长度限制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> limit;</span><br></pre></td></tr></table></figure><p>其实现在DefaultResultSetHandler的skipRows方法中实现，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">skipRows</span><span class="params">(ResultSet rs, RowBounds rowBounds)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (rs.getType() != ResultSet.TYPE_FORWARD_ONLY) &#123;</span><br><span class="line">    <span class="comment">// 进入该分支分页表示结果的游标不是只能单步前进</span></span><br><span class="line">    <span class="keyword">if</span> (rowBounds.getOffset() != RowBounds.NO_ROW_OFFSET) &#123;</span><br><span class="line">      <span class="comment">// 让游标移动到起始位置</span></span><br><span class="line">      rs.absolute(rowBounds.getOffset());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 进入该分支表示结果只能单步前进</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowBounds.getOffset(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!rs.next()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，这种分页是基于内存分页实现的，也就是说Mybatis会向数据库查出所有的数据，然后在内存中掠过一些数据再开始读取，这种请求方式可不是一种高效的方式。因此出现了如PageHeler这样的分页插件来实现真正的分页查询。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;session包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#session包&quot;&gt;&lt;/a&gt; session包&lt;/h1&gt;
&lt;p&gt;session包是整个Mybatis应用对外接口的包，是离用户最近的包。&lt;br /&gt;
&lt;a name=&quot;iq</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="核心操作包" scheme="https://jie-blog.icu/categories/mybatis/%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C%E5%8C%85/"/>
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>executor包（二）</title>
    <link href="https://jie-blog.icu/posts/mybatis-executor_2/"/>
    <id>https://jie-blog.icu/posts/mybatis-executor_2/</id>
    <published>2020-11-04T04:17:29.000Z</published>
    <updated>2020-11-04T04:17:48.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="executor包二"><a class="markdownIt-Anchor" href="#executor包二"></a> executor包（二）</h1><p><a name="7gOgF"></a></p><h1 id="语句处理功能"><a class="markdownIt-Anchor" href="#语句处理功能"></a> 语句处理功能</h1><p><a name="gEvyI"></a></p><h2 id="基础介绍"><a class="markdownIt-Anchor" href="#基础介绍"></a> 基础介绍</h2><p>Mybatis提供了两种定义变量的符号，分别是<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 4: {}和#̲{}，其分别的作用是以字符串/…'>{}和#{}，其分别的作用是以字符串/预编译的形式将变量赋值到SQL语句中。此外，Mybatis还支持三种语句类型，分别是：STATMENT、PREPARED、CALLABLE。除了第一种只支持</span>{}剩下的都可以处理两种定义变量符号。<br />此外，语句类型由statementType定义，如果不指定，则默认采用PREPARED类型。如下所示，即三种语句类型的使用方法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=<span class="string">&quot;com.github.yeecode.mybatisdemo.dao.UserMapper&quot;</span>&gt;</span><br><span class="line">    &lt;!--直接字符串拼接，必须自己加引号，否则会拼接为下面的语句然后失败：：SELECT * FROM `user` WHERE schoolName = Sunny School--&gt;</span><br><span class="line">    &lt;select id=<span class="string">&quot;queryUserBySchoolName_A&quot;</span> resultType=<span class="string">&quot;com.github.yeecode.mybatisdemo.model.User&quot;</span> statementType=<span class="string">&quot;STATEMENT&quot;</span>&gt;</span><br><span class="line">      SELECT * FROM `user` WHERE schoolName = <span class="string">&quot;$&#123;schoolName&#125;&quot;</span></span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--会把变量转为？后进行填入，不能有引号--&gt;</span><br><span class="line">    &lt;select id=<span class="string">&quot;queryUserBySchoolName_B&quot;</span> resultType=<span class="string">&quot;com.github.yeecode.mybatisdemo.model.User&quot;</span> statementType=<span class="string">&quot;PREPARED&quot;</span>&gt;</span><br><span class="line">      SELECT * FROM `user` WHERE schoolName = #&#123;schoolName&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--使用前需要先到数据库创建以下存储过程：--&gt;</span><br><span class="line">    &lt;!--CREATE PROCEDURE `yeecode`(IN `ageMinLimit` <span class="keyword">int</span>,IN `ageMaxLimit` <span class="keyword">int</span>,OUT `count` <span class="keyword">int</span>, OUT `maxAge` <span class="keyword">int</span>)--&gt;</span><br><span class="line">    &lt;!--BEGIN--&gt;</span><br><span class="line">    &lt;!--<span class="function">SELECT <span class="title">COUNT</span><span class="params">(*)</span>,<span class="title">MAX</span><span class="params">(age)</span> INTO count,maxAge FROM user WHERE age &gt;</span>= ageMinLimit AND age &lt;= ageMaxLimit;--&gt;</span><br><span class="line">    &lt;!--END $$--&gt;</span><br><span class="line">    &lt;select id=<span class="string">&quot;runCall&quot;</span> statementType=<span class="string">&quot;CALLABLE&quot;</span>&gt;</span><br><span class="line">      <span class="function">CALL <span class="title">yeecode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      $&#123;ageMinLimit&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">      #&#123;ageMaxLimit,mode=IN,jdbcType=NUMERIC&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">      #&#123;count,mode=OUT,jdbcType=NUMERIC&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">      #&#123;maxAge,mode=OUT,jdbcType=NUMERIC&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">      )</span></span>;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>CALLABLE使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; param = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">param.put(<span class="string">&quot;ageMinLimit&quot;</span>,<span class="number">10</span>);</span><br><span class="line">param.put(<span class="string">&quot;ageMaxLimit&quot;</span>,<span class="number">30</span>);</span><br><span class="line">session.selectOne(<span class="string">&quot;com.github.yeecode.mybatisdemo.dao.UserMapper.runCall&quot;</span>,param);</span><br><span class="line">System.out.println(<span class="string">&quot;proceduce param :&quot;</span> + param);</span><br></pre></td></tr></table></figure><p>在结果中显然是先进行的字符串拼接再进行的变量赋值，在拼接和赋值都完成后再进行了结果的回写。<br /><a name="bdAhQ"></a></p><h2 id="mybatis的语句处理功能"><a class="markdownIt-Anchor" href="#mybatis的语句处理功能"></a> Mybatis的语句处理功能</h2><p>statement子包负责语句功能的处理，其内部类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603594975888-a71ae529-5e0f-4923-add4-a159b63b9bdd.png#align=left&amp;display=inline&amp;height=245&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=490&amp;originWidth=1181&amp;size=898881&amp;status=done&amp;style=none&amp;width=590.5" alt="image.png" /><br /><a name="6S8Nk"></a></p><h3 id="routingstatementhandler"><a class="markdownIt-Anchor" href="#routingstatementhandler"></a> RoutingStatementHandler</h3><p>RoutingStatementHandler是一个代理类，它能够根据MappedStatement的类型然后委派给被代理对象。其核心源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据类型选取被代理对象  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StatementHandler delegate;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span> (ms.getStatementType()) &#123;</span><br><span class="line">     <span class="keyword">case</span> STATEMENT:</span><br><span class="line">       delegate = <span class="keyword">new</span> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> PREPARED:</span><br><span class="line">       delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> CALLABLE:</span><br><span class="line">       delegate = <span class="keyword">new</span> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Unknown statement type: &quot;</span> + ms.getStatementType());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><a name="TBzHC"></a></p><h3 id="basestatementhandler"><a class="markdownIt-Anchor" href="#basestatementhandler"></a> BaseStatementHandler</h3><p>该类是一个抽象父类，其内部实现了类的公共方法，并且用模板模式在prepare方法定义了整个方法的框架。其子类可以通过parameterize方法来区分不同：</p><ul><li>SimpleStatement的parameterize为空，因为他只需要替换字符串即可，不需要进行参数处理。</li><li>PreparedStatementHandler的parameterize通过parameterHandler.setParameters进行了参数赋值。</li><li>CallableStatementHandler的parameterize先是通过registerOutputParameters中转后调用CallableStatement中的输出参数注册方法完成输出参数的注册，再通过parameterHandler.setParameters进行赋值。<br /><a name="A4Sna"></a></li></ul><h2 id="参数处理功能"><a class="markdownIt-Anchor" href="#参数处理功能"></a> 参数处理功能</h2><p>为SQL语句中的参数赋值是由parameter子包完成的，该子包中只有一个ParameterHandler接口，其内部由两个方法：</p><ul><li>getParameterObject：获取SQL语句对应的实参对象。</li><li>setParameters：用来完成SQL语句的变量赋值。<br /><a name="HfOgr"></a></li></ul><h3 id="defaultparameterhandler"><a class="markdownIt-Anchor" href="#defaultparameterhandler"></a> DefaultParameterHandler</h3><p>ParameterHandler只有一个默认实现类DefaultParameterHandler位于scripting包的defaults子包中，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型处理器注册表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry;</span><br><span class="line"><span class="comment">// MappedStatement对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MappedStatement mappedStatement;</span><br><span class="line"><span class="comment">// 参数对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object parameterObject;</span><br><span class="line"><span class="comment">// BoundSql对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BoundSql boundSql;</span><br><span class="line"><span class="comment">// 配置信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br></pre></td></tr></table></figure><p>其核心方法位于setParameters中，该方法只支持一个PreparedStatement类型的参数。因此，该方法只能用来设置PreparedStatement和CallableStatement的参数。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> </span>&#123;</span><br><span class="line">  ErrorContext.instance().activity(<span class="string">&quot;setting parameters&quot;</span>).object(mappedStatement.getParameterMap().getId());</span><br><span class="line">  <span class="comment">// 取出参数列表</span></span><br><span class="line">  List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  <span class="keyword">if</span> (parameterMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">      ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">      <span class="comment">// ParameterMode.OUT是Callable的1输出参数，已单独注册，因此要忽略掉</span></span><br><span class="line">      <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">        Object value;</span><br><span class="line">        <span class="comment">// 取出属性名称</span></span><br><span class="line">        String propertyName = parameterMapping.getProperty();</span><br><span class="line">        <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123; </span><br><span class="line">          <span class="comment">// 从附加参数中读取属性值</span></span><br><span class="line">          value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">          value = <span class="keyword">null</span>;</span><br><span class="line">         <span class="comment">// 如果参数是基本类型，则取出参数对象的该属性值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">          value = parameterObject;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果是复杂类型，取出该对象的属性值</span></span><br><span class="line">          MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">          value = metaObject.getValue(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确定该参数的处理器</span></span><br><span class="line">        TypeHandler typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">        JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span> &amp;&amp; jdbcType == <span class="keyword">null</span>) &#123;</span><br><span class="line">          jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 根据参数类型调用参数赋值方法</span></span><br><span class="line">          typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TypeException | SQLException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">&quot;Could not set parameters for mapping: &quot;</span> + parameterMapping + <span class="string">&quot;. Cause: &quot;</span> + e, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依次取出每个参数的值，然后根据参数类型调用PreparedStatement中的赋值方法完成赋值。<br /><a name="02t8z"></a></p><h1 id="结果处理功能"><a class="markdownIt-Anchor" href="#结果处理功能"></a> 结果处理功能</h1><p>Mybatis查询的结果需要经过步骤有：</p><ul><li>处理结果映射中的嵌套映射等逻辑。</li><li>根据映射关系，生成结果对象。</li><li>根据数据库查询记录对结果对象的属性进行赋值。</li><li>将结果对象汇总为List、Map、Cursor等形式。</li></ul><p>executor包的result子包只负责完成“将结果对象汇总为List、Map、Cursor等形式的工作”。<br />该子包的类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603600846829-5e68c4b4-5b64-48ed-b962-9d7246cd3170.png#align=left&amp;display=inline&amp;height=158&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=316&amp;originWidth=1037&amp;size=454895&amp;status=done&amp;style=none&amp;width=518.5" alt="image.png" /><br />其中ResultContext和ResultHandler是两个父接口：</p><ul><li>ResultContext表示结果上下文，其中存放了数据库操作的一个结果（对应数据库中的一条记录）。</li><li>ResultHandler接口表示结果处理器，数据库操作结果会由其处理。因此ResultHandler会处理ResultContext。<br /><a name="IRiA1"></a></li></ul><h2 id="defaultresultcontext"><a class="markdownIt-Anchor" href="#defaultresultcontext"></a> DefaultResultContext</h2><p>DefaultResultContext用来存储一个结果对象，其对应着数据库中的一条记录。其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果对象</span></span><br><span class="line"><span class="keyword">private</span> T resultObject;</span><br><span class="line"><span class="comment">// 结果计数（表明这个是第几个结果对象）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> resultCount;</span><br><span class="line"><span class="comment">// 使用完毕（结果已经被取走）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> stopped;</span><br></pre></td></tr></table></figure><p>DefaultResultHandler负责将DefaultResultContext类中的结果对象聚合为List，DefaultMapResultHandler负责聚合为一个Map。其中DefaultMapResultHandler的逻辑比较复杂，因此以下以它为例进行分析，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map形式的结果集</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; mappedResults;</span><br><span class="line"><span class="comment">// Map的键。结果对象的属性名</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String mapKey;</span><br><span class="line"><span class="comment">// 对象工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ObjectFactory objectFactory;</span><br><span class="line"><span class="comment">// 对象包装工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ObjectWrapperFactory objectWrapperFactory;</span><br><span class="line"><span class="comment">// 反射工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReflectorFactory reflectorFactory;</span><br></pre></td></tr></table></figure><p>其包装的核心实现位于handleResult，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResult</span><span class="params">(ResultContext&lt;? extends V&gt; context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 从结果上下文中取出结果对象</span></span><br><span class="line">  <span class="keyword">final</span> V value = context.getResultObject();</span><br><span class="line">  <span class="comment">// 获得结果对象的元对象</span></span><br><span class="line">  <span class="keyword">final</span> MetaObject mo = MetaObject.forObject(value, objectFactory, objectWrapperFactory, reflectorFactory);</span><br><span class="line">  <span class="comment">// 基于元对象取出key对应的值</span></span><br><span class="line">  <span class="keyword">final</span> K key = (K) mo.getValue(mapKey);</span><br><span class="line">  mappedResults.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外还有一个ObjectWrapperResultHandler来将ResultContext转换为Cursor返回。<br /><a name="jemKj"></a></p><h1 id="结果集处理功能"><a class="markdownIt-Anchor" href="#结果集处理功能"></a> 结果集处理功能</h1><p>Mybatis查询的结果需要经过步骤还有：</p><ul><li>处理结果映射中的嵌套映射等逻辑。</li><li>根据映射关系，生成结果对象。</li><li>根据数据库查询记录对结果对象的属性进行赋值。</li></ul><p>这些功能均由resultSet子包提供，其内部类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603602105066-bea81113-d7bd-4dbc-80b4-856c88642ba3.png#align=left&amp;display=inline&amp;height=147&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=294&amp;originWidth=913&amp;size=400756&amp;status=done&amp;style=none&amp;width=456.5" alt="image.png" /><br />在进行分析之前，先了解一下Mybatis的结果集。<br /><a name="BmwRS"></a></p><h2 id="mybatis的结果集"><a class="markdownIt-Anchor" href="#mybatis的结果集"></a> Mybatis的结果集</h2><p>首先明确结果集有以下三种情况：</p><ul><li>结果，一条记录对应一个结果，可以映射为一个Java对象。User</li><li>结果集：指结果集合，结果集可以以List、Map、Cursor的形式返回。List<User></li><li>多结果集：即结果集集合，其中包含了多个结果集。List&lt;List<User>&gt;<br /><a name="yDzkI"></a></li></ul><h2 id="结果集封装类"><a class="markdownIt-Anchor" href="#结果集封装类"></a> 结果集封装类</h2><p>Statement操作完数据库以后，对应的操作结果会由ResultSet来返回。ResultSet的方法主要分为如下几大类：</p><ul><li>切换到下一个结果，读取本结果是否为第一个结果、最后一个结果等结果间切换相关的方法。</li><li>读取当前结果某列的值。</li><li>修改当前结果某列的值。</li><li>一些其他的辅助功能。</li></ul><p>而Mybatis的ResultSetWrapper就是对ResultSet的进一步封装。增加的功能包括获取所有列名的列表、获取所有列的类型的列表、获取某列的JDBC类型、获取某列对应的类型处理器等。其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被修饰的resultSet对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ResultSet resultSet;</span><br><span class="line"><span class="comment">// 类型处理器注册表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry;</span><br><span class="line"><span class="comment">// resultSet中各个列对应的列名列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; columnNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// resultSet中各个列对应的Java类型列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; classNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// resultSet中各个列对应的JDBC类型列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;JdbcType&gt; jdbcTypes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 类型与类型处理器的映射表。结构为：Map&lt;列名，Map&lt;Java类型，类型处理器&gt;&gt;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Map&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt;&gt; typeHandlerMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 记录了所有的映射关系列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;String&gt;&gt; mappedColumnNamesMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 记录了所有无映射关系的列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;String&gt;&gt; unMappedColumnNamesMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>ResultSetHandler是结果集处理器接口，其内部有三个抽象方法：</p><ul><li>handleResultSets：将statement执行的结果处理为List</li><li>handleCursorResultSets：将Statement的执行结果处理为Map</li><li>handleOutputParameters：处理存储过程的输出结果</li></ul><p>DefaultResultSetHandler为该接口的唯一实现，以下将以DefaultResultSetHandler的handleCursorResultSets为例分析结果集的封装。该方法可以得到两侧列表，即结果及列表嵌套在其中的结果列表，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   ErrorContext.instance().activity(<span class="string">&quot;handling results&quot;</span>).object(mappedStatement.getId());</span><br><span class="line"><span class="comment">// 用来存储处理结果的列表</span></span><br><span class="line">   <span class="keyword">final</span> List&lt;Object&gt; multipleResults = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 对结果集计数</span></span><br><span class="line">   <span class="keyword">int</span> resultSetCount = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// 获取第一个结果集</span></span><br><span class="line">   ResultSetWrapper rsw = getFirstResultSet(stmt);</span><br><span class="line"><span class="comment">// 查询语句对应的resultMaps节点</span></span><br><span class="line">   List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();</span><br><span class="line">   <span class="comment">// 获取ResultMap的数量</span></span><br><span class="line">   <span class="keyword">int</span> resultMapCount = resultMaps.size();</span><br><span class="line">   <span class="comment">// 合法性校验，如果存在结果resultMapCount不能为0</span></span><br><span class="line">   validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line">   <span class="comment">// 遍历每一个结果集</span></span><br><span class="line">   <span class="keyword">while</span> (rsw != <span class="keyword">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">     <span class="comment">// 获取当前的结果集</span></span><br><span class="line">     ResultMap resultMap = resultMaps.get(resultSetCount);</span><br><span class="line">     <span class="comment">// 结果集处理</span></span><br><span class="line">     handleResultSet(rsw, resultMap, multipleResults, <span class="keyword">null</span>);</span><br><span class="line">     <span class="comment">// 获取下一个结果集</span></span><br><span class="line">     rsw = getNextResultSet(stmt);</span><br><span class="line">     <span class="comment">// 清理上一个结果集</span></span><br><span class="line">     cleanUpAfterHandlingResultSet();</span><br><span class="line">     resultSetCount++;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 获取多个结果集中所有结果集的名称</span></span><br><span class="line">   String[] resultSets = mappedStatement.getResultSets();</span><br><span class="line">   <span class="keyword">if</span> (resultSets != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">// 循环遍历每一个没有设置resultMap的结果集</span></span><br><span class="line">     <span class="keyword">while</span> (rsw != <span class="keyword">null</span> &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</span><br><span class="line">       <span class="comment">// 获取结果集对应的父级resultMap中的ResultMapping</span></span><br><span class="line">       ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);</span><br><span class="line">       <span class="keyword">if</span> (parentMapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 获取被嵌套的resultMap编号</span></span><br><span class="line">         String nestedResultMapId = parentMapping.getNestedResultMapId();</span><br><span class="line">         ResultMap resultMap = configuration.getResultMap(nestedResultMapId);</span><br><span class="line">         <span class="comment">// 处理结果集</span></span><br><span class="line">         handleResultSet(rsw, resultMap, <span class="keyword">null</span>, parentMapping);</span><br><span class="line">       &#125;</span><br><span class="line">       rsw = getNextResultSet(stmt);</span><br><span class="line">       cleanUpAfterHandlingResultSet();</span><br><span class="line">       resultSetCount++;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 判断结果集个数</span></span><br><span class="line">   <span class="keyword">return</span> collapseSingleResultList(multipleResults);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>对于每一个结果集的处理实际都是由handleResultSet处理的，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleResultSet</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 嵌套的resultMap</span></span><br><span class="line">    <span class="keyword">if</span> (parentMapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 向子方法传入parentMapping，处理结果中的记录</span></span><br><span class="line">      handleRowValues(rsw, resultMap, <span class="keyword">null</span>, RowBounds.DEFAULT, parentMapping);</span><br><span class="line">    <span class="comment">// 非嵌套的结果</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将结果聚合为一个对象</span></span><br><span class="line">        DefaultResultHandler defaultResultHandler = <span class="keyword">new</span> DefaultResultHandler(objectFactory);</span><br><span class="line">        <span class="comment">// 处理结果中的属性</span></span><br><span class="line">        handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, <span class="keyword">null</span>);</span><br><span class="line">        multipleResults.add(defaultResultHandler.getResultList());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handleRowValues(rsw, resultMap, resultHandler, rowBounds, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// issue #228 (close resultsets)</span></span><br><span class="line">    closeResultSet(rsw.getResultSet());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了handleRowValues方法进行了进一步的处理，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRowValues</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (resultMap.hasNestedResultMaps()) &#123;</span><br><span class="line">    <span class="comment">// 前置校验</span></span><br><span class="line">    ensureNoRowBounds();</span><br><span class="line">    checkResultHandler();</span><br><span class="line">    <span class="comment">// 处理嵌套映射</span></span><br><span class="line">    handleRowValuesForNestedResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理单层映射</span></span><br><span class="line">    handleRowValuesForSimpleResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以handleRowValuesForSimpleResultMap为例进行源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleRowValuesForSimpleResultMap</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  DefaultResultContext&lt;Object&gt; resultContext = <span class="keyword">new</span> DefaultResultContext&lt;&gt;();</span><br><span class="line">  <span class="comment">// 当前要处理的结果集</span></span><br><span class="line">  ResultSet resultSet = rsw.getResultSet();</span><br><span class="line">  <span class="comment">// 根据分页功能跳过指定的行数</span></span><br><span class="line">  skipRows(resultSet, rowBounds);</span><br><span class="line">  <span class="comment">// 持续处理下一条结果，判断调键位：还有结果要处理且结果集没有关闭且还有下一条结果</span></span><br><span class="line">  <span class="keyword">while</span> (shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; !resultSet.isClosed() &amp;&amp; resultSet.next()) &#123;</span><br><span class="line">    <span class="comment">// 经过鉴别器鉴别</span></span><br><span class="line">    ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(resultSet, resultMap, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 拿到一行记录转换为对象</span></span><br><span class="line">    Object rowValue = getRowValue(rsw, discriminatedResultMap, <span class="keyword">null</span>);</span><br><span class="line">     <span class="comment">// 将对象存储起来</span></span><br><span class="line">    storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getRowValue源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getRowValue</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ResultLoaderMap lazyLoader = <span class="keyword">new</span> ResultLoaderMap();</span><br><span class="line">  <span class="comment">// 创建这一行对应的对象  </span></span><br><span class="line">  Object rowValue = createResultObject(rsw, resultMap, lazyLoader, columnPrefix);</span><br><span class="line">  <span class="keyword">if</span> (rowValue != <span class="keyword">null</span> &amp;&amp; !hasTypeHandlerForResultObject(rsw, resultMap.getType())) &#123;</span><br><span class="line">    <span class="comment">// 生成对应的元对象</span></span><br><span class="line">    <span class="keyword">final</span> MetaObject metaObject = configuration.newMetaObject(rowValue);</span><br><span class="line">    <span class="keyword">boolean</span> foundValues = <span class="keyword">this</span>.useConstructorMappings;</span><br><span class="line">    <span class="comment">// 是否允许自动映射</span></span><br><span class="line">    <span class="keyword">if</span> (shouldApplyAutomaticMappings(resultMap, <span class="keyword">false</span>)) &#123;</span><br><span class="line">       <span class="comment">// 自动映射</span></span><br><span class="line">      foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, columnPrefix) || foundValues;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按明示字段赋值</span></span><br><span class="line">    foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, columnPrefix) || foundValues;</span><br><span class="line">    foundValues = lazyLoader.size() &gt; <span class="number">0</span> || foundValues;</span><br><span class="line">    rowValue = foundValues || configuration.isReturnInstanceForEmptyRow() ? rowValue : <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rowValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>storeObject源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">storeObject</span><span class="params">(ResultHandler&lt;?&gt; resultHandler, DefaultResultContext&lt;Object&gt; resultContext, Object rowValue, ResultMapping parentMapping, ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parentMapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 存在父级则将这一行记录</span></span><br><span class="line">    linkToParents(rs, parentMapping, rowValue);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 使用resultHandler聚合该对象</span></span><br><span class="line">    callResultHandler(resultHandler, resultContext, rowValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="2v3BH"></a></p><h1 id="执行器"><a class="markdownIt-Anchor" href="#执行器"></a> 执行器</h1><p>Executor的类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603674293299-76fe6911-4861-4621-98d6-e3cf8fdf44aa.png#align=left&amp;display=inline&amp;height=179&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=358&amp;originWidth=1122&amp;size=652544&amp;status=done&amp;style=none&amp;width=561" alt="image.png" /><br />Executor内的方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 没有结果处理器的占位符</span></span><br><span class="line">  ResultHandler NO_RESULT_HANDLER = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 数据更新操作，其中增删改都可以由该方法实现</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">  <span class="comment">// 数据库查询操作，返回List</span></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">  <span class="comment">// 数据库查询操作，返回Cursor</span></span><br><span class="line">  &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">queryCursor</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">  <span class="comment">// 清理缓存</span></span><br><span class="line">  <span class="function">List&lt;BatchResult&gt; <span class="title">flushStatements</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">  <span class="comment">// 提交事务</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">  <span class="comment">// 回滚操作</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">  <span class="comment">// 创建当前查询的缓存键值</span></span><br><span class="line">  <span class="function">CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span></span>;</span><br><span class="line">  <span class="comment">// 本地缓存是否有值</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isCached</span><span class="params">(MappedStatement ms, CacheKey key)</span></span>;</span><br><span class="line">  <span class="comment">// 清理本地缓存</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clearLocalCache</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 懒加载</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deferLoad</span><span class="params">(MappedStatement ms, MetaObject resultObject, String property, CacheKey key, Class&lt;?&gt; targetType)</span></span>;</span><br><span class="line">  <span class="comment">// 获取事务</span></span><br><span class="line">  <span class="function">Transaction <span class="title">getTransaction</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 关闭执行器</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">boolean</span> forceRollback)</span></span>;</span><br><span class="line">  <span class="comment">// 判断执行器是否被关闭</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 设置执行器包装</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setExecutorWrapper</span><span class="params">(Executor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，数据库中的所有操作都是通过调用上述方法实现的。<br /><a name="FPB9Y"></a></p><h2 id="baseexecutor"><a class="markdownIt-Anchor" href="#baseexecutor"></a> BaseExecutor</h2><p>其子类分功能如下：</p><ul><li>ClosedExecutor：一个仅能表示自身已经关闭的执行器。</li><li>SimpleExecutor：一个最为简单的执行器。</li><li>BatchExecutor：支持批量执行功能的执行器。</li><li>ReuseExecutor：支持Statement对象复用的执行器。</li></ul><p>除了第一种以外的三种执行器的选择是在配置文件中进行配置的，可选的值由session包的ExecutorType定义。<br /><a name="vDk7t"></a></p><h3 id="查询"><a class="markdownIt-Anchor" href="#查询"></a> 查询</h3><p>从类图中可以看出除了CachingExecutor，其他的执行器的实现类都继承了BaseExecutor。BaseExecutor是一个抽象类，并用到了模板模式，其核心方法query源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="comment">// 执行器已关闭，因此要抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    <span class="comment">// 新的查询栈，故清除本地缓存</span></span><br><span class="line">    clearLocalCache();</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    queryStack++;</span><br><span class="line">    <span class="comment">// 尝试从本地缓存获取结果</span></span><br><span class="line">    list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 本地缓存中有结果，对于CALLABLE语句还需要绑定到IN/INOUT参数上</span></span><br><span class="line">      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 本地缓存没有结果，因此要使用数据库查询</span></span><br><span class="line">      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    queryStack--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 懒加载处理</span></span><br><span class="line">    <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">      deferredLoad.load();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// issue #601</span></span><br><span class="line">    deferredLoads.clear();</span><br><span class="line">    <span class="comment">// 如果本地缓存的作用域为STATEMENT，则立刻清除本地缓存</span></span><br><span class="line">    <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">      <span class="comment">// issue #482</span></span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，如果缓存未命中，则会调用queryFromDatabase查询数据库，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  <span class="comment">// 向缓存中增加占位符，表示正在查询</span></span><br><span class="line">  localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 删除占位符</span></span><br><span class="line">    localCache.removeObject(key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将结果写入缓存</span></span><br><span class="line">  localCache.putObject(key, list);</span><br><span class="line">  <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">    localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的doQuery由其子类进行具体实现，这是典型的模板模式的提现。<br /><a name="MNB8o"></a></p><h3 id="修改"><a class="markdownIt-Anchor" href="#修改"></a> 修改</h3><p>观察完query方法后，可以尝试查看update方法，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing an update&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="comment">// 执行器关闭</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清理缓存</span></span><br><span class="line">  clearLocalCache();</span><br><span class="line">  <span class="comment">// 调用子类的方法</span></span><br><span class="line">  <span class="keyword">return</span> doUpdate(ms, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，这个方法比query（查询）方法要简单的多，因为：</p><ul><li>查询操作的输入参数比较复杂。</li><li>查询操作的输出结果比较复杂，通常还会被映射为对象，甚至还会包含嵌套、结果集操作、懒加载、对象类型鉴别等。</li><li>查询操作的输出结果形式比较复杂，如支持List、Map、Cursor等。</li><li>查询操作的实现比较复杂，例如需要进行缓存处理、懒加载处理、嵌套映射处理等。<br /><a name="ajgBK"></a></li></ul><h1 id="错误上下文"><a class="markdownIt-Anchor" href="#错误上下文"></a> 错误上下文</h1><p>源码中经常会出现类似于如下一段代码的片段：<br /><code>ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing an update&quot;).object(ms.getId());</code><br />其中ErrorConext是错误上下文，它能够提前将背景信息保存，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前操作系统的换行符</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LINE_SEPARATOR = System.getProperty(<span class="string">&quot;line.separator&quot;</span>,<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="comment">// 将自身存储进ThreadLocal，从而实现线程隔离</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ErrorContext&gt; LOCAL = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"><span class="comment">// 存储上一个版本的自身，从而组成错误链</span></span><br><span class="line"><span class="keyword">private</span> ErrorContext stored;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的详细信息</span></span><br><span class="line"><span class="keyword">private</span> String resource;</span><br><span class="line"><span class="keyword">private</span> String activity;</span><br><span class="line"><span class="keyword">private</span> String object;</span><br><span class="line"><span class="keyword">private</span> String message;</span><br><span class="line"><span class="keyword">private</span> String sql;</span><br><span class="line"><span class="keyword">private</span> Throwable cause;</span><br></pre></td></tr></table></figure><p>ErrorContext运用到了单例模式，其单例是绑定到ThreadLocal上的，这保证了每个线程都有唯一的错误上下文。其instance方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ErrorContext <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ErrorContext context = LOCAL.get();</span><br><span class="line">  <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">    context = <span class="keyword">new</span> ErrorContext();</span><br><span class="line">    LOCAL.set(context);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个ErrorContext都可以包装一个ErrorContext，这样错误上下文就形成了一条错误链。其包装功能由store实现，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ErrorContext <span class="title">store</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ErrorContext newContext = <span class="keyword">new</span> ErrorContext();</span><br><span class="line">  newContext.stored = <span class="keyword">this</span>;</span><br><span class="line">  LOCAL.set(newContext);</span><br><span class="line">  <span class="keyword">return</span> LOCAL.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，其也支持逆操作，即将某个ErrorContext对象内部的ErrorContext剥离出来，该方法由recall实现，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ErrorContext <span class="title">recall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (stored != <span class="keyword">null</span>) &#123;</span><br><span class="line">    LOCAL.set(stored);</span><br><span class="line">    stored = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> LOCAL.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，其内部还有很多方法，这些方法的使用场景如下：</p><ul><li>当需要获得当前线程的ErrorContext对象时调用instance方法。</li><li>当线程执行到某一个阶段产生新的上下文时调用resource、activity等方法向ErrorContext补充上下文信息。</li><li>当线程进入下一级操作并处于一个全新的环境时，调用store方法获得一个包装了原有ErrorContext对象的新ErrorContext对象。</li><li>当线程从下一级操作返回上一级时调用recall方法剥离上一级ErrorContext对象。</li><li>当线程进入一个与之前操作无关的新环境时调用reset方法清除ErrorContext对象的所有信息。</li><li>当线程需要打印异常信息时调用toString方法输出错误环境。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;executor包二&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#executor包二&quot;&gt;&lt;/a&gt; executor包（二）&lt;/h1&gt;
&lt;p&gt;&lt;a name=&quot;7gOgF&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;语句处理功能&quot;&gt;&lt;a cl</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="核心操作包" scheme="https://jie-blog.icu/categories/mybatis/%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C%E5%8C%85/"/>
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>executor包（一）</title>
    <link href="https://jie-blog.icu/posts/mybatis-executor_1/"/>
    <id>https://jie-blog.icu/posts/mybatis-executor_1/</id>
    <published>2020-11-04T04:16:18.000Z</published>
    <updated>2020-11-04T04:17:04.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="executor包一"><a class="markdownIt-Anchor" href="#executor包一"></a> executor包（一）</h1><p>executor包是执行器包，它作为Mybatis的核心将其他各个包聚集在了一起，每一个子包都提供一个相对独立的功能项。<br /><a name="DhR8l"></a></p><h1 id="基础回顾"><a class="markdownIt-Anchor" href="#基础回顾"></a> 基础回顾</h1><p><a name="aQZqd"></a></p><h2 id="cglib动态代理"><a class="markdownIt-Anchor" href="#cglib动态代理"></a> cglib动态代理</h2><p>之前回顾过Proxy实现的动态代理，其制约条件是被代理的类必须有一个父接口。之前也回忆过一个类必须通过类加载过程并将类文件加载到JVM后才能使用，cglib就是可以通过直接修改JVM中的字节码信息来修改和创建类。cglib使用字节码处理框架ASM来转换字节码并生成被代理类的子类，然后这个子类就可以作为代理类展开工作。<br />cglib也有限制条件，即由于它是通过给代理类创建一个子类的，因此其无法给final类创建代理对象。<br /><a name="8Uw6y"></a></p><h3 id="使用演示"><a class="markdownIt-Anchor" href="#使用演示"></a> 使用演示</h3><p>首先导入依赖：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.2.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>被拦截类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello &quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截器类：<br />拦截方法后会引入intercept方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before speak&quot;</span>);</span><br><span class="line">        Object ans = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;after speak&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>演示代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置enhancer的回调对象</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> ProxyHandler&lt;&gt;());</span><br><span class="line">        <span class="comment">// 设置enhancer对象的父类</span></span><br><span class="line">        enhancer.setSuperclass(User.class);</span><br><span class="line">        <span class="comment">// 创建代理对象，实际为User的子类</span></span><br><span class="line">        User user = (User) enhancer.create();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过代理对象调用目标方法</span></span><br><span class="line">        String ans = user.sayHello(<span class="string">&quot;Jieker&quot;</span>);</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果演示：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603456920139-21995366-1913-4255-868a-25ad447382ec.png#align=left&amp;display=inline&amp;height=70&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=140&amp;originWidth=406&amp;size=58664&amp;status=done&amp;style=none&amp;width=203" alt="image.png" /><br /><a name="dZkJR"></a></p><h2 id="javassist框架"><a class="markdownIt-Anchor" href="#javassist框架"></a> javassist框架</h2><p>javassist与ASM类似，但是其比ASM的更易上手，可以根据Java代码生成字节码，而不需要直接操作字节码。<br /><a name="kerqK"></a></p><h3 id="使用演示-2"><a class="markdownIt-Anchor" href="#使用演示-2"></a> 使用演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        <span class="comment">// 定义一个类</span></span><br><span class="line">        CtClass userCtClazz = pool.makeClass(<span class="string">&quot;com.github.yeecode.mybatisdemo.User&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建name属性</span></span><br><span class="line">        CtField nameField = <span class="keyword">new</span> CtField(pool.get(<span class="string">&quot;java.lang.String&quot;</span>), <span class="string">&quot;name&quot;</span>, userCtClazz);</span><br><span class="line">        userCtClazz.addField(nameField);</span><br><span class="line">        <span class="comment">// 创建name的setter</span></span><br><span class="line">        CtMethod setMethod = CtNewMethod.make(<span class="string">&quot;public void setName(String name) &#123; this.name = name;&#125;&quot;</span>, userCtClazz);</span><br><span class="line">        userCtClazz.addMethod(setMethod);</span><br><span class="line">        <span class="comment">// 创建sayHello方法</span></span><br><span class="line">        CtMethod sayHello = CtNewMethod.make(<span class="string">&quot;public String sayHello() &#123; return \&quot;Hello, I am \&quot; + this.name ;&#125;&quot;</span>, userCtClazz);</span><br><span class="line">        userCtClazz.addMethod(sayHello);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; userClazz = userCtClazz.toClass();</span><br><span class="line">        <span class="comment">// 创建一个对象</span></span><br><span class="line">        Object user = userClazz.newInstance();</span><br><span class="line">        <span class="comment">// 为对象设置name值</span></span><br><span class="line">        Method[] methods = userClazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method: methods)&#123;</span><br><span class="line">            <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;setName&quot;</span>)) &#123;</span><br><span class="line">                method.invoke(user,<span class="string">&quot;Jieker&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用对象sayHello方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method: methods)&#123;</span><br><span class="line">            <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;sayHello&quot;</span>)) &#123;</span><br><span class="line">                String result = (String) method.invoke(user);</span><br><span class="line">                System.out.println(result);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果演示：<br /><a name="73YMZ"></a></p><h2 id="imagepng"><a class="markdownIt-Anchor" href="#imagepng"></a> <img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603457293549-50c1b501-b3f3-4ec3-bb11-9dd6ed907e86.png#align=left&amp;display=inline&amp;height=35&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=70&amp;originWidth=366&amp;size=29920&amp;status=done&amp;style=none&amp;width=183" alt="image.png" /></h2><p><a name="jDQGN"></a></p><h2 id="序列化和反序列化"><a class="markdownIt-Anchor" href="#序列化和反序列化"></a> 序列化和反序列化</h2><p><a name="X7Lbm"></a></p><h3 id="writeexteral和readexternal"><a class="markdownIt-Anchor" href="#writeexteral和readexternal"></a> writeExteral和readExternal</h3><p>之前分析过如果声明一个类的对象是可序列化的，则必须继承Serializable接口或者Externalizable接口。<br />继承Serializable的话不需要任何其他其他操作就可以完成序列化和反序列化，该过程都由Java内部机制完成。<br />继承Externalizable接口实现序列化和反序列化则需要自定义序列化和反序列化，其内部有两个抽象方法如下：</p><ul><li>void writeExternal(ObjectOutput var1)：该方法在目标对象序列化时调用。方法中可以调用dataOutput方法来保存其基本值，或调用ObjectOutput的writeObject方法来保存对象、字符串和数组。</li><li>void readExternal(ObjectInput var1)：该方法在目标对象反序列化时调用，其为writeExternal的逆过程。<br /><a name="t2aSA"></a></li></ul><h4 id="使用演示-3"><a class="markdownIt-Anchor" href="#使用演示-3"></a> 使用演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserModel02</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVerisionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;writeExternal doing ...&quot;</span>);</span><br><span class="line">        out.write(id); <span class="comment">// DataOutput中的方法</span></span><br><span class="line">        out.writeObject(name + <span class="string">&quot;(from writeExternal)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;readExternal doing ...&quot;</span>);</span><br><span class="line">        id = in.read();</span><br><span class="line">        name = (String) in.readObject();</span><br><span class="line">        System.out.println(<span class="string">&quot;name in file is：&quot;</span> + name);</span><br><span class="line">        name = name + <span class="string">&quot;(from readExternal)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo02</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;run demo02:&quot;</span>);</span><br><span class="line">    UserModel02 userModel02 = <span class="keyword">new</span> UserModel02();</span><br><span class="line">    userModel02.setId(<span class="number">1</span>);</span><br><span class="line">    userModel02.setName(<span class="string">&quot;Jieker&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;m2.tempdata&quot;</span>));</span><br><span class="line">    oos.writeObject(userModel02);</span><br><span class="line">    oos.flush();</span><br><span class="line">    oos.close();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;↑write;↓read&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;m2.tempdata&quot;</span>));</span><br><span class="line">    UserModel02 newUser = (UserModel02) ois.readObject();</span><br><span class="line">    System.out.println(<span class="string">&quot;newUser:&quot;</span> + newUser.getId() + <span class="string">&quot;-&quot;</span> + newUser.getName());</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603457923688-1aaef015-04e1-470a-aaee-f3de55ae6964.png#align=left&amp;display=inline&amp;height=80&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=160&amp;originWidth=666&amp;size=94020&amp;status=done&amp;style=none&amp;width=333" alt="image.png" /><br />可见，对象序列化时会调用writeExternal，反序列化时会调用readExternal<br /><a name="iJswa"></a></p><h3 id="writereplace和readresolve"><a class="markdownIt-Anchor" href="#writereplace和readresolve"></a> writeReplace和readResolve</h3><p>进行序列化和反序列化的目标类还可以定义writeReplace和readResolve方法。</p><ul><li>writeReplace：对该类的对象序列化操作前会先调用这个方法。最终序列化的对象是该方法生成的对象、</li><li>readResolve：反序列化之前会先调用该方法。最终反序列化的对象是该方法生成的对象、<br /><a name="qJGp0"></a></li></ul><h4 id="使用演示-4"><a class="markdownIt-Anchor" href="#使用演示-4"></a> 使用演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserModel03</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVerisionUID = <span class="number">123L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">writeReplace</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;writeReplace doing ...&quot;</span>);</span><br><span class="line">        UserModel03 userModel = <span class="keyword">new</span> UserModel03();</span><br><span class="line">        userModel.setId(<span class="number">2</span>);</span><br><span class="line">        userModel.setName(<span class="string">&quot;jieker&quot;</span>);</span><br><span class="line">        userModel.setDescription(<span class="string">&quot;description from writeReplace&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> userModel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo03</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;run demo03:&quot;</span>);</span><br><span class="line">    UserModel03 userModel03 = <span class="keyword">new</span> UserModel03();</span><br><span class="line">    userModel03.setId(<span class="number">1</span>);</span><br><span class="line">    userModel03.setName(<span class="string">&quot;Jieker&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;m3.tempdata&quot;</span>));</span><br><span class="line">    oos.writeObject(userModel03);</span><br><span class="line">    oos.flush();</span><br><span class="line">    oos.close();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;↑write;↓read&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;m3.tempdata&quot;</span>));</span><br><span class="line">    UserModel03 newUser = (UserModel03) ois.readObject();</span><br><span class="line">    System.out.println(<span class="string">&quot;newUser:&quot;</span> + newUser.getId() + <span class="string">&quot;-&quot;</span> + newUser.getName());</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603458565376-536e6776-8c88-4b19-b10d-3293204b1eb5.png#align=left&amp;display=inline&amp;height=82&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=164&amp;originWidth=388&amp;size=70364&amp;status=done&amp;style=none&amp;width=194" alt="image.png" /><br /><a name="6jV1u"></a></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>上述四个方法的执行顺序是：writeReplace–&gt;writeExternal–&gt;readExternal–&gt;readResolve<br />Externalizable执行流程如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603458703846-3d252c64-2956-4ebe-8d9c-b23e56cf23e9.png#align=left&amp;display=inline&amp;height=165&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=330&amp;originWidth=479&amp;size=192105&amp;status=done&amp;style=none&amp;width=239.5" alt="image.png" /><br />Serializable执行流程如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603458717778-45d8472d-bb96-4c60-af72-8a4070d7c0ee.png#align=left&amp;display=inline&amp;height=148&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=296&amp;originWidth=453&amp;size=167697&amp;status=done&amp;style=none&amp;width=226.5" alt="image.png" /><br /><a name="oIXrG"></a></p><h2 id="treadlocal"><a class="markdownIt-Anchor" href="#treadlocal"></a> TreadLocal</h2><p>一个对象会被多个线程访问，因为多个共享了这个对象，就可能会出现一系列的并发问题。常用的方法只要把这个对象变为了线程独有就可以避免并发问题产生，这是一种典型的空间换时间的思路。<br />TreadLocal是典型的时间换空间的思路，每个线程都有一个独有的TreadLocal（通过ThreadLocalMap来分配ThreadLocal）。TreadLocal的方法主要有：</p><ul><li>T get()：从TreadLocal中读取数据。</li><li>void set(T value)：向TreadLocal中写入数据</li><li>void remove()：从TreadLocal中删除数据。</li></ul><p>每个线程操作的TreadLocal的变量都是线程内部的变量，不会对其他线程造成干扰。<br />在多线程中如果需要保存一些线程独有的数据时，可以借助TreadLocal实现。<br /><a name="jolOr"></a></p><h2 id="存储过程"><a class="markdownIt-Anchor" href="#存储过程"></a> 存储过程</h2><p>存储过程是数据库的一段可以被重用的代码片断，可以通过外部调用完成较为复杂的操作。在调用时，可以为存储过程传入输入参数，而存储过程执行结束后也可以给出输出参数。<br />创建语句格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名称</span><br><span class="line">([[IN|OUTINOUT]参数名 数据类型[,[IN|OUTINOUT]参数名 数据类型...]])</span><br></pre></td></tr></table></figure><p>其中存储过程的参数分为如下三类：</p><ul><li>IN：输入参数。该参数向存储过程输入值，但是不能从存储过程中返回值。</li><li>OUT：输出参数。该参数可以从存储过程中返回值，但是不能向存储过程输入值。</li><li>INOUT：双向参数。该参数既可以向存储过程输入值，又可以从存储过程中返回值。</li></ul><p>存储过程创建之后便可以进行存储过程的查询、调用、删除等工作。<br />存储过程支持变量定义、逻辑判断数据校验和多输出等。并且基于存储过程还可以将操作逻辑封装到数据库中，提高了逻辑的保密性。但是将操作逻辑封装到数据库中也会带来逻辑不清晰、与数据库耦合度高等问题。<br /><a name="ZVF8s"></a></p><h2 id="statement及其子接口"><a class="markdownIt-Anchor" href="#statement及其子接口"></a> Statement及其子接口</h2><p>Statement接口中定义了一些抽象方法能用来执行静态SQL语句并返回结果，通常返回的结果是一个结果集ResultSet。<br />Statement及其子类类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603460047503-481a1061-995f-4bae-9cd6-083eb0302c30.png#align=left&amp;display=inline&amp;height=314&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=379&amp;originWidth=293&amp;size=153607&amp;status=done&amp;style=none&amp;width=243" alt="image.png" /><br />这三个接口由上到下依次对应着设置SQL语句时的简单语句、预编译语句和存储过程语句。<br />Statement的方法主要是用来执行操作并获取操作结果的。<br />PreparedStatement在Statement基础上定义了一些setter方法，使得预编译的SQL语句具有了按参数位置为参数赋值的功能。<br />CallableStatement在PrepareStatement的基础上又增加了一些方法，其分为四类：</p><ul><li>按参数名称赋值方法：这一类方法能够为存储过程中指定名称的参数赋值。</li><li>注册输出参数方法：这一类方法能够向存储过程注册输出参数。</li><li>按照参数值位置获取值方法：这一类方法能够读取存储过程指定位置的参数值。</li><li>按照参数名称获取值方法：这一类方法能够获取存储过程指定名称的参数值。</li></ul><p>Mybatis和以上三种方法的关系如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603460459684-2a6fbb7b-fefe-4a8e-9635-924a67eeca98.png#align=left&amp;display=inline&amp;height=308&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=615&amp;originWidth=1247&amp;size=1285331&amp;status=done&amp;style=none&amp;width=623.5" alt="image.png" /><br /><a name="kRwE1"></a></p><h1 id="主键自增功能"><a class="markdownIt-Anchor" href="#主键自增功能"></a> 主键自增功能</h1><p>在进行数据插入操作时经常需要一个自增生成的主键编号，这样既可以保证主键的唯一性，又能保证主键的连续性。<br />很多数据库都支持主键的自增功能，比如Mysql。无论支不支持主键自增，executor包中的keygen子包都兼容。其内部类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603515886908-255c9483-4739-417f-b5b2-10bb007708b4.png#align=left&amp;display=inline&amp;height=146&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=292&amp;originWidth=1094&amp;size=467132&amp;status=done&amp;style=none&amp;width=547" alt="image.png" /><br />接口中定义了proccessBefore和processAfter方法，在其实现类中分别做出了相应的处理。<br /><a name="DsB7a"></a></p><h2 id="主键自增的配置"><a class="markdownIt-Anchor" href="#主键自增的配置"></a> 主键自增的配置</h2><p>类图中的三种实现类只能有一种生效。<br /><a name="7lpq3"></a></p><h3 id="jdbc3keygenerator"><a class="markdownIt-Anchor" href="#jdbc3keygenerator"></a> Jdbc3KeyGenerator</h3><p>如果要启用Jdbc3KeyGenerator则可以在配置文件中加入如下配置：<br /><code>&lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot;/&gt;</code><br />或者在相关语句上启用userGeneratedKeys即可，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=<span class="string">&quot;addUser_A&quot;</span> parameterType=<span class="string">&quot;User&quot;</span> useGeneratedKeys=<span class="string">&quot;true&quot;</span> keyProperty=<span class="string">&quot;id&quot;</span>&gt;</span><br><span class="line">    INSERT INTO `user`</span><br><span class="line">    (`name`,`email`,`age`,`sex`,`schoolName`)</span><br><span class="line">    VALUES</span><br><span class="line">    (#&#123;name&#125;,#&#123;email&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;schoolName&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><p><a name="qUALd"></a></p><h3 id="selectkeygenerator"><a class="markdownIt-Anchor" href="#selectkeygenerator"></a> SelectKeyGenerator</h3><p>如果要启用SelectKeyGenerator需要在SQL语句前加上一段selectKey，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=<span class="string">&quot;addUser_B&quot;</span> parameterType=<span class="string">&quot;User&quot;</span>&gt;</span><br><span class="line">    &lt;selectKey resultType=<span class="string">&quot;java.lang.Integer&quot;</span> keyProperty=<span class="string">&quot;id&quot;</span> order=<span class="string">&quot;AFTER&quot;</span>&gt;</span><br><span class="line">        <span class="function">SELECT <span class="title">LAST_INSERT_ID</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    &lt;/selectKey&gt;</span></span><br><span class="line"><span class="function">    INSERT INTO `user`</span></span><br><span class="line"><span class="function">    <span class="params">(`name`,`email`,`age`,`sex`,`schoolName`)</span></span></span><br><span class="line"><span class="function">    VALUES</span></span><br><span class="line"><span class="function">    <span class="params">(#&#123;name&#125;,#&#123;email&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;schoolName&#125;)</span></span></span><br><span class="line"><span class="function">&lt;/insert&gt;</span></span><br></pre></td></tr></table></figure><p><a name="uZk3t"></a></p><h3 id="解析优先级"><a class="markdownIt-Anchor" href="#解析优先级"></a> 解析优先级</h3><p>如果以下Jdbc3KeyGenerator和SelectKeyGenerator同时配置，则SelectKeyGenerator生效。在XMLStatementBuilder中可以找到对应的原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理SelectKey节点，这里会将KeyGenerator加到Configuration.KeyGenerators中</span></span><br><span class="line">processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line"><span class="comment">// 此时&lt;SelectKey&gt;和&lt;include&gt;已经被解析完毕并删除</span></span><br><span class="line">KeyGenerator keyGenerator;</span><br><span class="line">   String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">   keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 如果有解析好了的KeyGenerator</span></span><br><span class="line">   <span class="keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">     keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 全局或本语句只要有启动自动key的生成，则使用key生成</span></span><br><span class="line">     keyGenerator = context.getBooleanAttribute(<span class="string">&quot;useGeneratedKeys&quot;</span>,</span><br><span class="line">         configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">         ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>最终KeyGenerator会保存在整个Statement中，在Statement执行时会直接调用KeyGenerator中的proccessBefore和processAfter方法，必然会有以上三种Generator来执行实际的两个方法。<br /><a name="FGxAz"></a></p><h2 id="类解析"><a class="markdownIt-Anchor" href="#类解析"></a> 类解析</h2><p><a name="sHLzj"></a></p><h3 id="jdbc3keygenerator-2"><a class="markdownIt-Anchor" href="#jdbc3keygenerator-2"></a> Jdbc3KeyGenerator</h3><p><a name="nbnmx"></a></p><h4 id="功能"><a class="markdownIt-Anchor" href="#功能"></a> 功能</h4><p>Jdbc3KeyGenerator是为具有主键自增功能的数据库准备的，它存在的意义就是提供自增主键的回写功能。<br />代码演示：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603517275530-0da415de-c850-4fc3-9657-e88f04a2ec6a.png#align=left&amp;display=inline&amp;height=90&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=180&amp;originWidth=1267&amp;size=150925&amp;status=done&amp;style=none&amp;width=633.5" alt="image.png" /><br />该类所做的就是在Java对象插入完成后将数据库自增产生的id读取出来，然后写回Java对象本身。<br /><a name="c41bn"></a></p><h4 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h4><p>这些工作都是在processAfter方法进行的，而proccessBefore并需要做任何操作。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processBefore</span><span class="params">(Executor executor, MappedStatement ms, Statement stmt, Object parameter)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processAfter</span><span class="params">(Executor executor, MappedStatement ms, Statement stmt, Object parameter)</span> </span>&#123;</span><br><span class="line">  processBatch(ms, stmt, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Statement的getGeneratedKeys可以返回此语句操作自增生成的主键，如果此语句没有产生自增主键，则返回空的ResultSet对象。其内部的processBatch就是基于这个原理，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processBatch</span><span class="params">(MappedStatement ms, Statement stmt, Object parameter)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 拿到主键的属性名</span></span><br><span class="line">  <span class="keyword">final</span> String[] keyProperties = ms.getKeyProperties();</span><br><span class="line">  <span class="comment">// 如果没有主键则无需操作</span></span><br><span class="line">  <span class="keyword">if</span> (keyProperties == <span class="keyword">null</span> || keyProperties.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用Statement的getGeneratedKeys方法获取自动生成的主键值</span></span><br><span class="line">  <span class="keyword">try</span> (ResultSet rs = stmt.getGeneratedKeys()) &#123;</span><br><span class="line">    <span class="comment">// 获取输出结果的描述信息</span></span><br><span class="line">    <span class="keyword">final</span> ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">    <span class="keyword">final</span> Configuration configuration = ms.getConfiguration();</span><br><span class="line">    <span class="comment">// 主键数目比结果总字段数目还多，因此可能发生了错误，但因为该操作是附属操作不影响主要工作，忽略错误</span></span><br><span class="line">    <span class="keyword">if</span> (rsmd.getColumnCount() &lt; keyProperties.length) &#123;</span><br><span class="line">      <span class="comment">// Error?</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 调用字方法，将主键值赋值给实参</span></span><br><span class="line">      assignKeys(configuration, rs, rsmd, keyProperties, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Error getting generated key or setting result to parameter object. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="MDj5W"></a></p><h3 id="selectkeygenerator-2"><a class="markdownIt-Anchor" href="#selectkeygenerator-2"></a> SelectKeyGenerator</h3><p>面对不支持主键自增功能的数据库时SelectKeyGenerator可以真正的生成自增主键。<br />其processAfter和proccessBefore方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据插入前操作</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processBefore</span><span class="params">(Executor executor, MappedStatement ms, Statement stmt, Object parameter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (executeBefore) &#123;</span><br><span class="line">    processGeneratedKeys(executor, ms, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数据插入后操作</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processAfter</span><span class="params">(Executor executor, MappedStatement ms, Statement stmt, Object parameter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!executeBefore) &#123;</span><br><span class="line">    processGeneratedKeys(executor, ms, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实现原理是先执行一段特定的SQL语句获取一个值，然后将这个值赋值给Java对象的自增属性，其执行时机分为如下两种：</p><ul><li>数据插入之前执行。执行完特定SQL语句并将该值赋值给对象的自增属性后再将这个完整的对象插入数据库。这种情况又分为如下两种：<ul><li>如果数据库没有设置或者不支持主键自增，则完整的对象会被完整的插入数据库。这是SelectKeyGenerator常用的场景。</li><li>如果数据库设置了主键自增，这种操作则可能会造成Java对象的自增属性值和数据库中的属性值不一致，因此不建议使用SelectKeyGenerator，而应该使用Jdbc3KeyGenerator。</li></ul></li><li>在数据库插入之后执行。对象插入数据库结束后，Java对象的自增属性设置为特定的SQL语句执行的结果。这种操作也分由如下两种：<ul><li>如果数据库不支持自增则之前被插入的自增属性是没有赋值的，而Java对象中是被赋值的。这样造成了数据不一致的错误。</li><li>如果设置了主键自增买这时候的操作无疑是回显功能，建议使用Jdbc3KeyGenerator。</li></ul></li></ul><p>因此可以确认频繁调用的processGeneratedKeys方法的任务是执行一个SQL语句后获取一个值，然后将该值赋值给Java对象的自增属性。<br /><a name="pnNYp"></a></p><h4 id="processgeneratedkeys"><a class="markdownIt-Anchor" href="#processgeneratedkeys"></a> processGeneratedKeys</h4><p>分析processGeneratedKeys之前，首先要查看一下SelectKeyGenerator的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于生成主键的SQL语句的特有标志，该标志会追加在用于生成主键SQL语句的id的后方</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SELECT_KEY_SUFFIX = <span class="string">&quot;!selectKey&quot;</span>;</span><br><span class="line"><span class="comment">// 插入前执行还是插入后执行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> executeBefore;</span><br><span class="line"><span class="comment">// 用户生成主键的SQL语句</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MappedStatement keyStatement;</span><br></pre></td></tr></table></figure><p>processGeneratedKeys源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processGeneratedKeys</span><span class="params">(Executor executor, MappedStatement ms, Object parameter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// keyStatement为生成主键的SQL语句，keyStatement.getKeyProperties()拿到的是自增属性</span></span><br><span class="line">    <span class="keyword">if</span> (parameter != <span class="keyword">null</span> &amp;&amp; keyStatement != <span class="keyword">null</span> &amp;&amp; keyStatement.getKeyProperties() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 要自增的属性</span></span><br><span class="line">      String[] keyProperties = keyStatement.getKeyProperties();</span><br><span class="line">      <span class="keyword">final</span> Configuration configuration = ms.getConfiguration();</span><br><span class="line">      <span class="keyword">final</span> MetaObject metaParam = configuration.newMetaObject(parameter);</span><br><span class="line">      <span class="keyword">if</span> (keyProperties != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 为生成主键的SQL语句创建执行器keyExecutor</span></span><br><span class="line">        <span class="comment">// 不要关闭keyExecutor，因为它会被父类关闭</span></span><br><span class="line">        Executor keyExecutor = configuration.newExecutor(executor.getTransaction(), ExecutorType.SIMPLE);</span><br><span class="line">        <span class="comment">// 执行SQL语句，得到主键值  </span></span><br><span class="line">        List&lt;Object&gt; values = keyExecutor.query(keyStatement, parameter, RowBounds.DEFAULT, Executor.NO_RESULT_HANDLER);</span><br><span class="line">        <span class="comment">// 主键值必须唯一</span></span><br><span class="line">        <span class="keyword">if</span> (values.size() == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;SelectKey returned no data.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (values.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;SelectKey returned more than one value.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          MetaObject metaResult = configuration.newMetaObject(values.get(<span class="number">0</span>));</span><br><span class="line">          <span class="comment">// 要自增的主键只有一个，为其赋值</span></span><br><span class="line">          <span class="keyword">if</span> (keyProperties.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (metaResult.hasGetter(keyProperties[<span class="number">0</span>])) &#123;</span><br><span class="line">              <span class="comment">// 从metaResult的getter得到主键值</span></span><br><span class="line">              setValue(metaParam, keyProperties[<span class="number">0</span>], metaResult.getValue(keyProperties[<span class="number">0</span>]));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 可能返回的直接就是主键值本身</span></span><br><span class="line">              setValue(metaParam, keyProperties[<span class="number">0</span>], values.get(<span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 把要执行SQL语句得到的值赋值给多个属性</span></span><br><span class="line">            handleMultipleProperties(keyProperties, metaParam, metaResult);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ExecutorException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Error selecting key or setting result to parameter object. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="gixUT"></a></p><h1 id="懒加载功能"><a class="markdownIt-Anchor" href="#懒加载功能"></a> 懒加载功能</h1><p><a name="ZfZXo"></a></p><h2 id="懒加载的配置"><a class="markdownIt-Anchor" href="#懒加载的配置"></a> 懒加载的配置</h2><p>有些时候，从表A查询出来的数据只有部分是需要用来查询B的，这时候就要引入懒加载来减少损耗。想要启动懒加载，需要在配置文件中做出如下配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;!--<span class="keyword">true</span>即：全局启用惰性加载--&gt;</span><br><span class="line">    &lt;setting name=<span class="string">&quot;lazyLoadingEnabled&quot;</span> value=<span class="string">&quot;true&quot;</span> /&gt;</span><br><span class="line">    &lt;!--<span class="keyword">false</span>即：惰性加载时，每个属性都按需加载--&gt;</span><br><span class="line">    &lt;setting name=<span class="string">&quot;aggressiveLazyLoading&quot;</span> value=<span class="string">&quot;false&quot;</span>/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure><p>其中aggressiveLazyLoading为激进懒加载设置，即对对象任一属性的读或写操作都会触发该对象的所有懒加载属性的加载。如果关闭激进懒加载则代表对对象某一懒加载属性的读取操作才会触发该属性的加载。<br />此外，对于equals、hashCode、toString、clone中的任意一个方法的调用都会触发懒加载属性的加载。<br /><a name="mUeRG"></a></p><h2 id="懒加载的实现"><a class="markdownIt-Anchor" href="#懒加载的实现"></a> 懒加载的实现</h2><p>整个懒加载的过程可以简化如下：</p><ul><li>先查询user表，获得User对象</li><li>将返回的User对象替换为User对象的代理对象UserProxy对象，并返回上层应用。UserProxy有如下几个特点：<ul><li>当属性的写方法被调用时，直接将属性值写入被代理对象。</li><li>当属性读方法被调用时，判断是否为懒加载属性。如果不是懒加载属性则直接由被代理对象返回；如果是懒加载属性，则根据配置加载该属性再返回。</li></ul></li></ul><p>其代理类的实际类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603522075575-f0b54450-d1b1-482b-8501-e06d9fbeb01f.png#align=left&amp;display=inline&amp;height=431&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=618&amp;originWidth=623&amp;size=585319&amp;status=done&amp;style=none&amp;width=434" alt="image.png" /><br /><a name="x8Lsf"></a></p><h3 id="代理工厂"><a class="markdownIt-Anchor" href="#代理工厂"></a> 代理工厂</h3><p>ProxyFactory是创建代理类的工厂接口，其内部的createProxy方法是用来创建一个代理对象的方法。<br />ProxyFactory接口有两个实现类一个是CglibProxyFactory，一个是JavassistProxyFactory。这两个类的结构高度一致，只是原理不通。接下来以CglibProxyFactory为例进行源码分析。<br /><a name="ZzsfC"></a></p><h4 id="cglibproxyfactory"><a class="markdownIt-Anchor" href="#cglibproxyfactory"></a> CglibProxyFactory</h4><p>CglibProxyFactory内部提供了两个创建代理的方法：</p><ul><li>createProxy：是父接口定义的方法的实现，用来创建一个普通的代理对象。</li><li>createDeserializationProxy：创建一个反序列化的代理对象。在基础回顾中分析过具体的创建方法，这里不做赘述。</li></ul><p>createProxy方法创建的代理对象是内部类EnhancedResultObjectProxyImpl的实例，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被代理类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line"><span class="comment">// 要懒加载的属性Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ResultLoaderMap lazyLoader;</span><br><span class="line"><span class="comment">// 是否是激进懒加载</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> aggressive;</span><br><span class="line"><span class="comment">// equals、clone、hashCode、toString这四个方法名在Configuration中被初始化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; lazyLoadTriggerMethods;</span><br><span class="line"><span class="comment">// 对象工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ObjectFactory objectFactory;</span><br><span class="line"><span class="comment">// 被代理类构造函数的参数类型列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; constructorArgTypes;</span><br><span class="line"><span class="comment">// 被代理类构造函数的参数列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; constructorArgs;</span><br></pre></td></tr></table></figure><p>代理类中最核心的intercept方法会在被代理类方法调用时拦截进该方法，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object enhanced, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// 取出被代理类中此次被调用的方法的名称</span></span><br><span class="line">  <span class="keyword">final</span> String methodName = method.getName();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 防止属性的并发加载</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lazyLoader) &#123;</span><br><span class="line">      <span class="comment">// 被调用的是一个writeReplace方法</span></span><br><span class="line">      <span class="keyword">if</span> (WRITE_REPLACE_METHOD.equals(methodName)) &#123;</span><br><span class="line">        <span class="comment">// 创建一个原始对象</span></span><br><span class="line">        Object original;</span><br><span class="line">        <span class="keyword">if</span> (constructorArgTypes.isEmpty()) &#123;</span><br><span class="line">          original = objectFactory.create(type);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          original = objectFactory.create(type, constructorArgTypes, constructorArgs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将被代理类的属性拷贝到原始对象</span></span><br><span class="line">        PropertyCopier.copyBeanProperties(type, enhanced, original);</span><br><span class="line">        <span class="comment">// 存在懒加载属性</span></span><br><span class="line">        <span class="keyword">if</span> (lazyLoader.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 返回的不只是原对象，还有相关的懒加载的设置等信息，因此调用CglibSerialStateHolder进行封装</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> CglibSerialStateHolder(original, lazyLoader.getProperties(), objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> original;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 存在懒加载属性且调用的不是finalize方法</span></span><br><span class="line">        <span class="keyword">if</span> (lazyLoader.size() &gt; <span class="number">0</span> &amp;&amp; !FINALIZE_METHOD.equals(methodName)) &#123;</span><br><span class="line">          <span class="comment">// 设置了激进懒加载或者调用的方法能够触发全局加载的方法</span></span><br><span class="line">          <span class="keyword">if</span> (aggressive || lazyLoadTriggerMethods.contains(methodName)) &#123;</span><br><span class="line">            <span class="comment">// 完成所有属性的懒加载</span></span><br><span class="line">            lazyLoader.loadAll();</span><br><span class="line">           <span class="comment">// 调用了属性的写方法</span></span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PropertyNamer.isSetter(methodName)) &#123;</span><br><span class="line">            <span class="keyword">final</span> String property = PropertyNamer.methodToProperty(methodName);</span><br><span class="line">            <span class="comment">// 先清除该属性的懒加载设置</span></span><br><span class="line">            lazyLoader.remove(property);</span><br><span class="line">           <span class="comment">// 调用了属性的读方法</span></span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PropertyNamer.isGetter(methodName)) &#123;</span><br><span class="line">            <span class="keyword">final</span> String property = PropertyNamer.methodToProperty(methodName);</span><br><span class="line">            <span class="comment">// 如果属性是尚未加载的懒加载属性，则进行懒加载</span></span><br><span class="line">            <span class="keyword">if</span> (lazyLoader.hasLoader(property)) &#123;</span><br><span class="line">              lazyLoader.load(property);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 触发被代理类的相应方法</span></span><br><span class="line">    <span class="keyword">return</span> methodProxy.invokeSuper(enhanced, args);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结上述过程得出intercept的处理方式如下：</p><ul><li>如果设置了激进懒加载或者触发全局加载的方法，则直接加载所有未加载的属性。</li><li>如果被调用的是属性的写方法，则将该方法从懒加载列表移除，因为此时数据库中的数据已经不是最新的了，没有必要再去加载。</li><li>如果调用的是属性的读方法，且该属性尚未被加载的话，则加载该属性。如果已经被加载过了，则直接读取该属性。<br /><a name="vVLl9"></a></li></ul><h3 id="resultsetloadermap"><a class="markdownIt-Anchor" href="#resultsetloadermap"></a> ResultSetLoaderMap</h3><p>被代理的对象可能会有多个属性可以被懒加载，这些尚未完成加载的属性是在ResultSetLoaderMap中存储的。<br /><a name="IAHMZ"></a></p><h4 id="loadpair"><a class="markdownIt-Anchor" href="#loadpair"></a> LoadPair</h4><p>LoadPair是ResultSetLoaderMap的内部类，它能够实现对应属性的懒加载操作，该类的属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来根据反射得到的数据库连接的方法名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORY_METHOD = <span class="string">&quot;getConfiguration&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否经过了序列化的标志位，因为该属性被设置了transient，经过一次序列化和反序列化后会变null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> Object serializationCheck = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出结果对象的封装</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> MetaObject metaResultObject;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用以加载未加载属性的加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ResultLoader resultLoader;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 日志记录器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Log log;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来获取数据库连接工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; configurationFactory;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该未加载的属性的属性名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String property;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 能够加载未加载属性的SQL语句编号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String mappedStatement;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 能够加载未加载属性的SQL语句参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Serializable mappedParameter;</span><br></pre></td></tr></table></figure><p>指定属性的加载操作由load方法来完成，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(<span class="keyword">final</span> Object userObject)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 输出结果对象的封装不存在或输出结果的加载器不存在</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.metaResultObject == <span class="keyword">null</span> || <span class="keyword">this</span>.resultLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 判断用以加载属性的对应SQL语句存在</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.mappedParameter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Property [&quot;</span> + <span class="keyword">this</span>.property + <span class="string">&quot;] cannot be loaded because &quot;</span></span><br><span class="line">                + <span class="string">&quot;required parameter of mapped statement [&quot;</span></span><br><span class="line">                + <span class="keyword">this</span>.mappedStatement + <span class="string">&quot;] is not serializable.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> Configuration config = <span class="keyword">this</span>.getConfiguration();</span><br><span class="line">      <span class="comment">// 取出用来加载结果的SQL语句</span></span><br><span class="line">      <span class="keyword">final</span> MappedStatement ms = config.getMappedStatement(<span class="keyword">this</span>.mappedStatement);</span><br><span class="line">      <span class="keyword">if</span> (ms == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Cannot lazy load property [&quot;</span> + <span class="keyword">this</span>.property</span><br><span class="line">                + <span class="string">&quot;] of deserialized object [&quot;</span> + userObject.getClass()</span><br><span class="line">                + <span class="string">&quot;] because configuration does not contain statement [&quot;</span></span><br><span class="line">                + <span class="keyword">this</span>.mappedStatement + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 创建对象的包装</span></span><br><span class="line">      <span class="keyword">this</span>.metaResultObject = config.newMetaObject(userObject);</span><br><span class="line">      <span class="comment">// 创建结果加载器</span></span><br><span class="line">      <span class="keyword">this</span>.resultLoader = <span class="keyword">new</span> ResultLoader(config, <span class="keyword">new</span> ClosedExecutor(), ms, <span class="keyword">this</span>.mappedParameter,</span><br><span class="line">              metaResultObject.getSetterType(<span class="keyword">this</span>.property), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要经过持久化，就可能在别的线程中了，为此次懒加载创建新的线程ResultLoader</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.serializationCheck == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> ResultLoader old = <span class="keyword">this</span>.resultLoader;</span><br><span class="line">      <span class="keyword">this</span>.resultLoader = <span class="keyword">new</span> ResultLoader(old.configuration, <span class="keyword">new</span> ClosedExecutor(), old.mappedStatement,</span><br><span class="line">              old.parameterObject, old.targetType, old.cacheKey, old.boundSql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.metaResultObject.setValue(property, <span class="keyword">this</span>.resultLoader.loadResult());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先，懒加载的过程就是执行懒加载SQL语句后将查询结果使用输出结果加载器赋给输出结果元对象的过程。因此，load方法首先会判断输出结果元对象metaResultObject和输出结果加载器resultLoader是否存在。如果不存在的话则会使用输入参数userObject重新创建上述两者。<br />此外，关于transient关键字修饰的某个属性，如果继承了Serializable接口的类，那么序列化时就会忽略该属性，因此在序列化反序列化的过程metaResultObject等就会变为null。<br />这样，只要LoadPair只要检测出自身经历过持久化，就会依赖老的ResultLoader对象中的信息重新创建一个ResultLoader对象，ResultLoader也被transient修饰，因此真正的老ResultLoader也会在序列化反序列化中消失。因此这里所谓的老ResultLoader是在(this.metaResultObject == null || this.resultLoader == null)中重建的。<br />而新的ResultLoader和老的ResultLoader区别就是其缺失了cacheKey和boundSql两个参数。其中cacheKey是为了加速查询而存在的。boundSql会在后面的查询阶段补足。<br /><a name="NfkGo"></a></p><h4 id="closedexecutor"><a class="markdownIt-Anchor" href="#closedexecutor"></a> ClosedExecutor</h4><p>ClosedExecutor是ResultLoaderMap类的内部类，该类只有一个isClosed是正常工作的。这是因为ClodedExecutor存在的目的就是通过isClosed方法返回true；来证明自己是一个要关闭的类，以保证任何遇到ClosedExecutor对象的操作都会重新创建一个新的有实际功能的Executor。<br /><a name="bfQcX"></a></p><h3 id="resuleloader"><a class="markdownIt-Anchor" href="#resuleloader"></a> ResuleLoader</h3><p>因为懒加载只涉及查询，因此只有个selectList来进行数据查询。<br /><a name="7lInJ"></a></p><h2 id="懒加载对反序列化的支持"><a class="markdownIt-Anchor" href="#懒加载对反序列化的支持"></a> 懒加载对反序列化的支持</h2><p>如果要对查询结果对象进行序列化，实际上代理对象即EnhancedResultObjectProxyImpl对象进行序列化。在该类的属性中显然并不包含已加载完成的属性（未加载和加载完的属性）。因此，只要对查询结果对象进行一次序列化和反序列化的操作，则已加载完后才能的属性都会丢失。因此，首要目的是必须保证在序列化时将被代理对象和代理对象的所有信息全部保存。<br />其createProxy源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">crateProxy</span><span class="params">(Class&lt;?&gt; type, Callback callback, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">  Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">  enhancer.setCallback(callback);</span><br><span class="line">  <span class="comment">// 创建的代理对象是原对象的子类</span></span><br><span class="line">  enhancer.setSuperclass(type);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取类的writeReplace方法</span></span><br><span class="line">    type.getDeclaredMethod(WRITE_REPLACE_METHOD);</span><br><span class="line">    <span class="comment">// ObjectOutputStream will call writeReplace of objects returned by writeReplace</span></span><br><span class="line">    <span class="keyword">if</span> (LogHolder.log.isDebugEnabled()) &#123;</span><br><span class="line">      LogHolder.log.debug(WRITE_REPLACE_METHOD + <span class="string">&quot; method was found on bean &quot;</span> + type + <span class="string">&quot;, make sure it returns this&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    <span class="comment">// 如果没有找到writeReplace方法，则设置代理类继承WriteReplaceInterface接口，该接口有writeReplace方法</span></span><br><span class="line">    enhancer.setInterfaces(<span class="keyword">new</span> Class[]&#123;WriteReplaceInterface.class&#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">    <span class="comment">// nothing to do here</span></span><br><span class="line">  &#125;</span><br><span class="line">  Object enhanced;</span><br><span class="line">  <span class="keyword">if</span> (constructorArgTypes.isEmpty()) &#123;</span><br><span class="line">    enhanced = enhancer.create();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Class&lt;?&gt;[] typesArray = constructorArgTypes.toArray(<span class="keyword">new</span> Class[constructorArgTypes.size()]);</span><br><span class="line">    Object[] valuesArray = constructorArgs.toArray(<span class="keyword">new</span> Object[constructorArgs.size()]);</span><br><span class="line">    enhanced = enhancer.create(typesArray, valuesArray);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> enhanced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的最大的任务就是获取writeReplace方法，而再起intercept方法中对writeReplace作出了特殊处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (WRITE_REPLACE_METHOD.equals(methodName)) &#123;</span><br><span class="line">  Object original;</span><br><span class="line">  <span class="keyword">if</span> (constructorArgTypes.isEmpty()) &#123;</span><br><span class="line">    original = objectFactory.create(type);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    original = objectFactory.create(type, constructorArgTypes, constructorArgs);</span><br><span class="line">  &#125;</span><br><span class="line">  PropertyCopier.copyBeanProperties(type, enhanced, original);</span><br><span class="line">  <span class="keyword">if</span> (lazyLoader.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CglibSerialStateHolder(original, lazyLoader.getProperties(), objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> original;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，最终初始化的是CglibSerialStateHolder类，其是AbstractSerialStateHolder的子类，该父类的属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ObjectOutputStream&gt; stream = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"><span class="comment">// 序列化后的对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] userBeanBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 原对象</span></span><br><span class="line"><span class="keyword">private</span> Object userBean;</span><br><span class="line"><span class="comment">// 未加载的属性</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, ResultLoaderMap.LoadPair&gt; unloadedProperties;</span><br><span class="line"><span class="comment">// 对象工厂，创建对象时使用</span></span><br><span class="line"><span class="keyword">private</span> ObjectFactory objectFactory;</span><br><span class="line"><span class="comment">// 构造函数的属性类型列表</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt;[] constructorArgTypes;</span><br><span class="line"><span class="comment">// 构造函数的属性列表</span></span><br><span class="line"><span class="keyword">private</span> Object[] constructorArgs;</span><br></pre></td></tr></table></figure><p>writeExternal：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(<span class="keyword">final</span> ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> firstRound = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">final</span> ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">  ObjectOutputStream os = stream.get();</span><br><span class="line">  <span class="keyword">if</span> (os == <span class="keyword">null</span>) &#123;</span><br><span class="line">    os = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">    firstRound = <span class="keyword">true</span>;</span><br><span class="line">    stream.set(os);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  os.writeObject(<span class="keyword">this</span>.userBean);</span><br><span class="line">  os.writeObject(<span class="keyword">this</span>.unloadedProperties);</span><br><span class="line">  os.writeObject(<span class="keyword">this</span>.objectFactory);</span><br><span class="line">  os.writeObject(<span class="keyword">this</span>.constructorArgTypes);</span><br><span class="line">  os.writeObject(<span class="keyword">this</span>.constructorArgs);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line">  out.writeObject(bytes);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (firstRound) &#123;</span><br><span class="line">    stream.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>readResolve：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">  <span class="comment">/* Second run */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.userBean != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.userBeanBytes.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.userBean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First run */</span></span><br><span class="line">  <span class="keyword">try</span> (ObjectInputStream in = <span class="keyword">new</span> LookAheadObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(<span class="keyword">this</span>.userBeanBytes))) &#123;</span><br><span class="line">    <span class="keyword">this</span>.userBean = in.readObject();</span><br><span class="line">    <span class="keyword">this</span>.unloadedProperties = (Map&lt;String, ResultLoaderMap.LoadPair&gt;) in.readObject();</span><br><span class="line">    <span class="keyword">this</span>.objectFactory = (ObjectFactory) in.readObject();</span><br><span class="line">    <span class="keyword">this</span>.constructorArgTypes = (Class&lt;?&gt;[]) in.readObject();</span><br><span class="line">    <span class="keyword">this</span>.constructorArgs = (Object[]) in.readObject();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> (ObjectStreamException) <span class="keyword">new</span> StreamCorruptedException().initCause(ex);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> ClassNotFoundException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> (ObjectStreamException) <span class="keyword">new</span> InvalidClassException(ex.getLocalizedMessage()).initCause(ex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Map&lt;String, ResultLoaderMap.LoadPair&gt; arrayProps = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="keyword">this</span>.unloadedProperties);</span><br><span class="line">  <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; arrayTypes = Arrays.asList(<span class="keyword">this</span>.constructorArgTypes);</span><br><span class="line">  <span class="keyword">final</span> List&lt;Object&gt; arrayValues = Arrays.asList(<span class="keyword">this</span>.constructorArgs);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.createDeserializationProxy(userBean, arrayProps, objectFactory, arrayTypes, arrayValues);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化过程中还对结果进行了缓存。这样，对同一个对象多次反序列化除了第一次需要进行实际的反序列化操作以外，之后只需将属性中缓存的结果直接返回即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;executor包一&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#executor包一&quot;&gt;&lt;/a&gt; executor包（一）&lt;/h1&gt;
&lt;p&gt;executor包是执行器包，它作为Mybatis的核心将其他各个包聚集在了一起，每一个子包</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="核心操作包" scheme="https://jie-blog.icu/categories/mybatis/%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C%E5%8C%85/"/>
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>cursor包</title>
    <link href="https://jie-blog.icu/posts/mybatis-transaction/"/>
    <id>https://jie-blog.icu/posts/mybatis-transaction/</id>
    <published>2020-11-04T04:10:58.000Z</published>
    <updated>2020-11-04T04:15:44.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cursor包"><a class="markdownIt-Anchor" href="#cursor包"></a> cursor包</h1><p><a name="NGdE1"></a></p><h1 id="iterable与iterator"><a class="markdownIt-Anchor" href="#iterable与iterator"></a> Iterable与Iterator</h1><p>这两个接口都是代表着与迭代器操作相关的能力。<br />Iterable接口表征的一个类是可迭代的，Iterator是接口表征的一个类是迭代器。</p><ul><li>如果一个类能够给出一个迭代器（通过Iterator方法）用来对某个集合中的元素进行迭代，那么这个类可以继承Iterable接口。</li><li>如果一个类本身就是一个迭代器，能够对某个集合展开迭代操作，那么这个类可以继承Iterator接口。</li></ul><p>Iterable接口内部主要定义了一个Iterator<T> iterator抽象方法用于返回一个Iterator对象。Iterator接口表示一个针对集合的迭代器，Iterator接口定义了迭代器最重要的方法，如下所示：</p><ul><li>boolean hasNext：判断当前迭代中是否还有未迭代元素。</li><li>E next：返回迭代中的下一个元素。</li><li>default void remove：从迭代器指向的集合中移除迭代器中移除迭代器返回的最后一个元素。不建议使用。</li></ul><p>foreach就基于这个规则实现的语法糖原理例如如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Iterator itor = users.iterator();</span><br><span class="line"><span class="keyword">while</span> (itor.hasNext())&#123;</span><br><span class="line">    User user= (User) itor.next();</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语法糖是编程语言中一种简化的语法，它能使代码更加整洁。JVM并不识别语法糖，因此这些语法会在编译阶段被还原成基本语法。<br /><a name="vHdet"></a></p><h1 id="mybatis中游标的使用"><a class="markdownIt-Anchor" href="#mybatis中游标的使用"></a> Mybatis中游标的使用</h1><p>有些时候希望的是逐一录入和处理查询结果，而不是一次读取整个结果集。因为前者会减少对内存的占用，这在批量处理时是十分必要，游标就是负责实现这一目的。<br />Mybatis只需要在映射接口中注明返回值类型是Cursor即可，例如下述代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UserMapper userMapper = session.getMapper(UserMapper.class);</span><br><span class="line">User userParam = <span class="keyword">new</span> User();</span><br><span class="line">userParam.setSchoolName(<span class="string">&quot;Sunny School&quot;</span>);</span><br><span class="line">Cursor&lt;User&gt; userCursor = userMapper.queryUserBySchoolName(userParam);</span><br><span class="line"><span class="keyword">for</span> (User user : userCursor) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name : &quot;</span> + user.getName() + <span class="string">&quot; ;  email : &quot;</span> + user.getEmail());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cursor包中只有一个Cursor接口和默认的实现类DefaultCursor。<br /><a name="u0qov"></a></p><h2 id="cursor接口"><a class="markdownIt-Anchor" href="#cursor接口"></a> Cursor接口</h2><p>Cursor接口继承自Closeable和Iterable接口，Iterable表征了这个类是可迭代的。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cursor</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Closeable</span>, <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 游标是否开启</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> true if the cursor has started to fetch items from database.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否已经完成了所有遍历</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> true if the cursor is fully consumed and has returned all elements matching the query.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isConsumed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取当前元素的索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> -1 if the first cursor item has not been retrieved. The index of the current item retrieved.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getCurrentIndex</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="vyQEE"></a></p><h2 id="默认游标"><a class="markdownIt-Anchor" href="#默认游标"></a> 默认游标</h2><p>DefaultCursor是默认游标其内部含有三个内部类，以下将依次分析：<br /><a name="Dyw1l"></a></p><h3 id="cursorstatus"><a class="markdownIt-Anchor" href="#cursorstatus"></a> CursorStatus</h3><p>CursorStatus内部定义十分简单，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">enum</span> CursorStatus &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 表征新创建游标，结果集尚未消费</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  CREATED,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 表征游标正在被使用，结果集正在被消费</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  OPEN,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 表征游标已经被关闭，但其中的结果集未被完全消费</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  CLOSED,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 表征游标已经被关闭，其中的结果集已经被完全消费</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  CONSUMED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="Iar7t"></a></p><h3 id="objectwrapperresulthandler"><a class="markdownIt-Anchor" href="#objectwrapperresulthandler"></a> ObjectWrapperResultHandler</h3><p>ObjectWrapperResultHandler继承了ResultHandler接口，是一个简单结果处理器。ResultHandler接口在session包中，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleResult</span><span class="params">(ResultContext&lt;? extends T&gt; resultContext)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjectWrapperResultHandler源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectWrapperResultHandler</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">ResultHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> T result;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResult</span><span class="params">(ResultContext&lt;? extends T&gt; context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取出结果上下文中的一条结果</span></span><br><span class="line">    <span class="keyword">this</span>.result = context.getResultObject();</span><br><span class="line">    <span class="comment">// 关闭结果上下文</span></span><br><span class="line">    context.stop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="Av3Vq"></a></p><h3 id="cursoriterator"><a class="markdownIt-Anchor" href="#cursoriterator"></a> CursorIterator</h3><p>CursorIterator继承自Iterator接口，是一个迭代器类。DefaultCursor间接继承了Iterator接口，DefaultCursor返回的对象就是CursorIterator对象。CursorIterator迭代器源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CursorIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 缓存下一个要返回的对象，在next操作中写入</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   T object;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * next方法中返回的对象的索引</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">int</span> iteratorIndex = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 判断是否还有下一个元素，如果有则随便写入一个object</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 如果object！=null，则显然有下一个对象（Object）</span></span><br><span class="line">     <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 获取下一个对象，如果没有返回null</span></span><br><span class="line">       object = fetchNextUsingRowBound();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> object != <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 返回下一个对象</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     T next = object;</span><br><span class="line">     <span class="comment">// next中无对象</span></span><br><span class="line">     <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 尝试获取下一个对象</span></span><br><span class="line">       next = fetchNextUsingRowBound();</span><br><span class="line">     &#125;</span><br><span class="line">  <span class="comment">// next中有对象</span></span><br><span class="line">     <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 清空object，因为next已经拿到object的值了</span></span><br><span class="line">       object = <span class="keyword">null</span>;</span><br><span class="line">       iteratorIndex++;</span><br><span class="line">       <span class="keyword">return</span> next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 删除当前对象</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;Cannot remove element from Cursor&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>显然，这里的fetchNextUsingRowBound方法是十分重要的，该方法属于其外部类，接下来将于外部类一同分析。<br /><a name="EbWvG"></a></p><h3 id="defaultcursor"><a class="markdownIt-Anchor" href="#defaultcursor"></a> DefaultCursor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果集处理器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DefaultResultSetHandler resultSetHandler;</span><br><span class="line"><span class="comment">// 该结果集对应的ResultMap信息来源于Mapper中的&lt;ResultMap&gt;节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ResultMap resultMap;</span><br><span class="line"><span class="comment">// 返回结果的详细信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ResultSetWrapper rsw;</span><br><span class="line"><span class="comment">// 结果的起止信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RowBounds rowBounds;</span><br><span class="line"><span class="comment">// ResultHandler的子类，起到暂存结果的作用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ObjectWrapperResultHandler&lt;T&gt; objectWrapperResultHandler = <span class="keyword">new</span> ObjectWrapperResultHandler&lt;&gt;();</span><br><span class="line"><span class="comment">// 内部迭代器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CursorIterator cursorIterator = <span class="keyword">new</span> CursorIterator();</span><br><span class="line"><span class="comment">// 迭代器存在标志位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> iteratorRetrieved;</span><br><span class="line"><span class="comment">// 游标状态</span></span><br><span class="line"><span class="keyword">private</span> CursorStatus status = CursorStatus.CREATED;</span><br><span class="line"><span class="comment">// 记录已经映射的行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> indexWithRowBound = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>DefaultCursor中大多数方法使用来实现Cursor、Closeable、Iterable三个接口的方法。<br />Iterable接口中定义的iterator方法使用iteratorRetrieved变量保证了迭代器只能给出一次，防止多次给出造成访问混乱。iterator源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (iteratorRetrieved) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot open more than one iterator on a Cursor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isClosed()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;A Cursor is already closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  iteratorRetrieved = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">return</span> cursorIterator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fetchNextObjectFromDatabase方法在每次调用时都会从数据库查询返回的结果集中取出一条结果，fetchNextUsingRowBound方法则在此基础上考虑了查询时的边界限制条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 考虑边界限制，从数据库中获取下一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">fetchNextUsingRowBound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 从数据库查询结果中取出下一个对象</span></span><br><span class="line">  T result = fetchNextObjectFromDatabase();</span><br><span class="line">  <span class="comment">// 如果对象存在但不满足边界限制，则持续读取数据库结果中的下一个，直到边界起始位置</span></span><br><span class="line">  <span class="keyword">while</span> (result != <span class="keyword">null</span> &amp;&amp; indexWithRowBound &lt; rowBounds.getOffset()) &#123;</span><br><span class="line">    result = fetchNextObjectFromDatabase();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fetchNextObjectFromDatabase源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> T <span class="title">fetchNextObjectFromDatabase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (isClosed()) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     status = CursorStatus.OPEN;</span><br><span class="line">     <span class="comment">// 结果集尚未关闭</span></span><br><span class="line">     <span class="keyword">if</span> (!rsw.getResultSet().isClosed()) &#123;</span><br><span class="line">       <span class="comment">// 从结果集中取出一条记录，将其转化为对象存入到objectWrapperResultHandler</span></span><br><span class="line">       resultSetHandler.handleRowValues(rsw, resultMap, objectWrapperResultHandler, RowBounds.DEFAULT, <span class="keyword">null</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 获得存入objectWrapperResultHandler中的对象</span></span><br><span class="line">   T next = objectWrapperResultHandler.result;</span><br><span class="line">   <span class="comment">// 读取到新的对象</span></span><br><span class="line">   <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">// 更改索引，表明记录索引加1</span></span><br><span class="line">     indexWithRowBound++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 没有新对象或者已经到了rowBounds边界</span></span><br><span class="line">   <span class="keyword">if</span> (next == <span class="keyword">null</span> || getReadItemsCount() == rowBounds.getOffset() + rowBounds.getLimit()) &#123;</span><br><span class="line">     <span class="comment">// 游标内数据已经消费完毕</span></span><br><span class="line">     close();</span><br><span class="line">     status = CursorStatus.CONSUMED;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 清除objectWrapperResultHandler的对象，已准备迎接下一个对象</span></span><br><span class="line">   objectWrapperResultHandler.result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> next;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>fetchNextObjectFromDatabase方法并不会引发数据库查询操作。因为，在该方法被调用之前，数据库查询的结果集已经完整的保存在了rsw变量中。fetchNextObjectFromDatabase方法只是从结果集中取出下一条记录。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cursor包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cursor包&quot;&gt;&lt;/a&gt; cursor包&lt;/h1&gt;
&lt;p&gt;&lt;a name=&quot;NGdE1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;iterable与iterator&quot;&gt;&lt;a cl</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="核心操作包" scheme="https://jie-blog.icu/categories/mybatis/%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C%E5%8C%85/"/>
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>transaction包</title>
    <link href="https://jie-blog.icu/posts/mybatis-transaction/"/>
    <id>https://jie-blog.icu/posts/mybatis-transaction/</id>
    <published>2020-11-04T04:10:22.000Z</published>
    <updated>2020-11-04T04:17:56.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="transaction包"><a class="markdownIt-Anchor" href="#transaction包"></a> transaction包</h1><p>该包是负责事务管理的包，其内部有两个子包：jdbc子包中是基于JDBC进行事务管理的类，managed子包中包含基于容器进行事务管理的类。<br /><a name="G1rLw"></a></p><h1 id="事务概述"><a class="markdownIt-Anchor" href="#事务概述"></a> 事务概述</h1><p>事务拥有ACID（原子性、唯一性、隔离性、持久性）四个特性。mybatis中事务的功能是由数据库提供的，以MySql为例，其内部有两种引擎：MyISAM和InnoDB。其中MyISAM引擎是不支持事务也不支持外键的，其特点是访问速度快；InnoDB支持事务，但是它相对于MyISAM可能会比较慢，而且占用磁盘空间也比较多（MyISAM的data信息存储的是地址，而InnoDB存储的是数据）。<br />Mysql默认操作模式是自动提交的，实现Mysql数据库事务主要用以下三个语句：</p><ul><li>BEGIN：开启事务</li><li>ROLLBACK：回滚事务</li><li>COMMIT：提交事务<br /><a name="eXaUa"></a></li></ul><h1 id="事务接口及工厂"><a class="markdownIt-Anchor" href="#事务接口及工厂"></a> 事务接口及工厂</h1><p>该包内类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603276195123-4539f2ad-ba9f-4976-9536-a8658d3ba5e2.png#align=left&amp;display=inline&amp;height=180&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=305&amp;originWidth=1109&amp;size=508782&amp;status=done&amp;style=none&amp;width=653" alt="image.png" /><br />TransactionFactory是所有事务工厂的接口，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 配置工厂属性</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> props</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties props)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// NOP</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从给定的连接中获取一个事务</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> conn Existing database connection</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> Transaction</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 3.1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Transaction <span class="title">newTransaction</span><span class="params">(Connection conn)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从给定的数据源中获取食物，并对事务进行配置</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> dataSource DataSource to take the connection from</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> level Desired isolation level</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> autoCommit Desired autocommit</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> Transaction</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 3.1.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Transaction <span class="title">newTransaction</span><span class="params">(DataSource dataSource, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Transaction是所有的事务接口，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取该事物对应的数据库连接</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> DataBase connection</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 提交事务</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 回滚事务</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 关闭对应的数据连接</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取设置的事务超时时间</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Integer <span class="title">getTimeout</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个接口的两套实现分别在jdbc子包和managed子包中<br /><a name="afqUM"></a></p><h1 id="jdbc事务"><a class="markdownIt-Anchor" href="#jdbc事务"></a> JDBC事务</h1><p>jdbc子包中存放的是实现了JDBC事务的JdbcTransaction类以及对应的工厂类。<br />JdbcTransaction属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据库连接池</span></span><br><span class="line"><span class="keyword">protected</span> Connection connection;</span><br><span class="line"><span class="comment">// 数据源</span></span><br><span class="line"><span class="keyword">protected</span> DataSource dataSource;</span><br><span class="line"><span class="comment">// 事务隔离级别</span></span><br><span class="line"><span class="keyword">protected</span> TransactionIsolationLevel level;</span><br><span class="line"><span class="comment">// 是否自动提交事务</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> autoCommit;</span><br></pre></td></tr></table></figure><p>其相关源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; !connection.getAutoCommit()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;Committing JDBC Connection [&quot;</span> + connection + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    connection.commit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; !connection.getAutoCommit()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;Rolling back JDBC Connection [&quot;</span> + connection + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    connection.rollback();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，直接调用的Connection方法。<br /> 其工厂类实现简单，暂不分析。<br /><a name="vh3KU"></a></p><h1 id="容器事务"><a class="markdownIt-Anchor" href="#容器事务"></a> 容器事务</h1><p>managed子包存放的是实现事物的ManagedTransaction类及其对应的工厂类。然而源码发现其内部的定义都为空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// Does nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// Does nothing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为其将相关的事物都委托给了容器进行管理。<br />以Spring为例，当其与Mybatis集成时，Mybatis拿到的数据库连接对象是Spring给出的，Spring可以通过XML、注解等配置来管理事务，虽然都是通过Connection操作，但是这不归mybatis来管全权委托给Spring即可。<br /> 其工厂类实现简单，暂不分析。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;transaction包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#transaction包&quot;&gt;&lt;/a&gt; transaction包&lt;/h1&gt;
&lt;p&gt;该包是负责事务管理的包，其内部有两个子包：jdbc子包中是基于JDBC进行事务管理的</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="核心操作包" scheme="https://jie-blog.icu/categories/mybatis/%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C%E5%8C%85/"/>
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>jdbc包</title>
    <link href="https://jie-blog.icu/posts/mybatis-jdbc/"/>
    <id>https://jie-blog.icu/posts/mybatis-jdbc/</id>
    <published>2020-11-04T04:09:04.000Z</published>
    <updated>2020-11-04T04:15:26.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jdbc包"><a class="markdownIt-Anchor" href="#jdbc包"></a> jdbc包</h1><p>该包提供了数据库操作语句的执行能力和脚本运行能力。<br /><a name="FFzMt"></a></p><h1 id="数据库语句操作"><a class="markdownIt-Anchor" href="#数据库语句操作"></a> 数据库语句操作</h1><p>该部分的核心类是AbstractSQL，其有两个内部类分别是：SafeAppendable和SQLStatement<br /><a name="pTbba"></a></p><h2 id="safeappendable"><a class="markdownIt-Anchor" href="#safeappendable"></a> SafeAppendable</h2><p>该类是一个拼接器，其append是一个拼接方法，该类源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeAppendable</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 主串</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Appendable a;</span><br><span class="line">   <span class="comment">// 主串是否为空</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> empty = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SafeAppendable</span><span class="params">(Appendable a)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>();</span><br><span class="line">     <span class="keyword">this</span>.a = a;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 向主串中拼接字符串</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> SafeAppendable <span class="title">append</span><span class="params">(CharSequence s)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 要拼接的字符串长度不为零</span></span><br><span class="line">       <span class="keyword">if</span> (empty &amp;&amp; s.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 拼接完主串也不为空</span></span><br><span class="line">         empty = <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       a.append(s);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 判断主串是否为空</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> empty;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><a name="66jKn"></a></p><h2 id="sqlstatement"><a class="markdownIt-Anchor" href="#sqlstatement"></a> SQLStatement</h2><p>该类负责完整的表述出一条SQL语句，其主要属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语句类型    </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> StatementType &#123;</span><br><span class="line">      DELETE, INSERT, SELECT, UPDATE</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 当前语句的语句类型</span></span><br><span class="line">StatementType statementType;</span><br><span class="line"><span class="comment">// 语句片段信息</span></span><br><span class="line">List&lt;String&gt; sets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; select = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; tables = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; join = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; innerJoin = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; outerJoin = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; leftOuterJoin = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; rightOuterJoin = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; where = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; having = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; groupBy = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; orderBy = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; lastList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; columns = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;List&lt;String&gt;&gt; valuesList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 是否去重，仅对SELECT有效</span></span><br><span class="line"><span class="keyword">boolean</span> distinct;</span><br><span class="line"><span class="comment">// 结果偏移量</span></span><br><span class="line">String offset;</span><br><span class="line"><span class="comment">// 结果总数限制</span></span><br><span class="line">String limit;</span><br><span class="line"><span class="comment">// 结果约束策略</span></span><br><span class="line">LimitingRowsStrategy limitingRowsStrategy = LimitingRowsStrategy.NOP;</span><br></pre></td></tr></table></figure><p>该类的入口方法是sql方法，其实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sql</span><span class="params">(Appendable a)</span> </span>&#123;</span><br><span class="line">      SafeAppendable builder = <span class="keyword">new</span> SafeAppendable(a);</span><br><span class="line">      <span class="keyword">if</span> (statementType == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      String answer;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (statementType) &#123;</span><br><span class="line">        <span class="keyword">case</span> DELETE:</span><br><span class="line">          answer = deleteSQL(builder);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> INSERT:</span><br><span class="line">          answer = insertSQL(builder);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> SELECT:</span><br><span class="line">          answer = selectSQL(builder);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> UPDATE:</span><br><span class="line">          answer = updateSQL(builder);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          answer = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以select为例，selectSQL方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">selectSQL</span><span class="params">(SafeAppendable builder)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (distinct) &#123;</span><br><span class="line">    sqlClause(builder, <span class="string">&quot;SELECT DISTINCT&quot;</span>, select, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;, &quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sqlClause(builder, <span class="string">&quot;SELECT&quot;</span>, select, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;, &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sqlClause(builder, <span class="string">&quot;FROM&quot;</span>, tables, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;, &quot;</span>);</span><br><span class="line">  <span class="comment">// 该方法比较复杂，源码见下</span></span><br><span class="line">  joins(builder);</span><br><span class="line">  sqlClause(builder, <span class="string">&quot;WHERE&quot;</span>, where, <span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>, <span class="string">&quot; AND &quot;</span>);</span><br><span class="line">  sqlClause(builder, <span class="string">&quot;GROUP BY&quot;</span>, groupBy, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;, &quot;</span>);</span><br><span class="line">  sqlClause(builder, <span class="string">&quot;HAVING&quot;</span>, having, <span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>, <span class="string">&quot; AND &quot;</span>);</span><br><span class="line">  sqlClause(builder, <span class="string">&quot;ORDER BY&quot;</span>, orderBy, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;, &quot;</span>);</span><br><span class="line">  limitingRowsStrategy.appendClause(builder, offset, limit);</span><br><span class="line">  <span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>joins：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">joins</span><span class="params">(SafeAppendable builder)</span> </span>&#123;</span><br><span class="line">  sqlClause(builder, <span class="string">&quot;JOIN&quot;</span>, join, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;\nJOIN &quot;</span>);</span><br><span class="line">  sqlClause(builder, <span class="string">&quot;INNER JOIN&quot;</span>, innerJoin, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;\nINNER JOIN &quot;</span>);</span><br><span class="line">  sqlClause(builder, <span class="string">&quot;OUTER JOIN&quot;</span>, outerJoin, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;\nOUTER JOIN &quot;</span>);</span><br><span class="line">  sqlClause(builder, <span class="string">&quot;LEFT OUTER JOIN&quot;</span>, leftOuterJoin, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;\nLEFT OUTER JOIN &quot;</span>);</span><br><span class="line">  sqlClause(builder, <span class="string">&quot;RIGHT OUTER JOIN&quot;</span>, rightOuterJoin, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;\nRIGHT OUTER JOIN &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sqlClause源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sqlClause</span><span class="params">(SafeAppendable builder, String keyword, List&lt;String&gt; parts, String open, String close,</span></span></span><br><span class="line"><span class="function"><span class="params">                       String conjunction)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断数值是否为空</span></span><br><span class="line">  <span class="keyword">if</span> (!parts.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// 判断主串是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!builder.isEmpty()) &#123;</span><br><span class="line">      builder.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(keyword);</span><br><span class="line">    builder.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    builder.append(open);</span><br><span class="line">    String last = <span class="string">&quot;________&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = parts.size(); i &lt; n; i++) &#123;</span><br><span class="line">      String part = parts.get(i);</span><br><span class="line">      <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; !part.equals(AND) &amp;&amp; !part.equals(OR) &amp;&amp; !last.equals(AND) &amp;&amp; !last.equals(OR)) &#123;</span><br><span class="line">        builder.append(conjunction);</span><br><span class="line">      &#125;</span><br><span class="line">      builder.append(part);</span><br><span class="line">      last = part;</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(close);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="kGt8y"></a></p><h2 id="abstractsql"><a class="markdownIt-Anchor" href="#abstractsql"></a> AbstractSQL</h2><p>有了这两个内部类后，AbstractSQL就不需要依赖其他类的辅助实现SQL语句的拼装了，其可以按照下述方式执行SQL语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">queryUsersBySchoolName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SQL()</span><br><span class="line">                .SELECT(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .FROM(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                .WHERE(<span class="string">&quot;schoolName = #&#123;schoolName&#125;&quot;</span>)</span><br><span class="line">                .toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SelectProvider(type = UserProvider.class, method = &quot;queryUsersBySchoolName&quot;)</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">queryUsersBySchoolName</span><span class="params">(String schoolName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是因此，该类内部的方法都采用大写的方式定义：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602932055497-b4ace44e-e8de-4fb5-a9ce-f9185b3fa620.png#align=left&amp;display=inline&amp;height=408&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=815&amp;originWidth=452&amp;size=171251&amp;status=done&amp;style=none&amp;width=226" alt="image.png" /><br />这样就可以顺应用户的习惯了。<br /><a name="Zm7Jj"></a></p><h3 id="执行流程梳理"><a class="markdownIt-Anchor" href="#执行流程梳理"></a> 执行流程梳理</h3><ul><li>首先用户通过上述方法定义SQL语句。</li><li>这些片段被解析保存在AbstractSQL中的内部类SQLStatement的ArrayList中。</li><li>用户调用toString触发SQL拼接工作，其源码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">  sql().sql(sb);</span><br><span class="line">  <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="IAjMo"></a></p><h3 id="小彩蛋"><a class="markdownIt-Anchor" href="#小彩蛋"></a> 小彩蛋</h3><p>以instert为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">insertSQL</span><span class="params">(SafeAppendable builder)</span> </span>&#123;</span><br><span class="line">  sqlClause(builder, <span class="string">&quot;INSERT INTO&quot;</span>, tables, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  sqlClause(builder, <span class="string">&quot;&quot;</span>, columns, <span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>, <span class="string">&quot;, &quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valuesList.size(); i++) &#123;</span><br><span class="line">    sqlClause(builder, i &gt; <span class="number">0</span> ? <span class="string">&quot;,&quot;</span> : <span class="string">&quot;VALUES&quot;</span>, valuesList.get(i), <span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>, <span class="string">&quot;, &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其语句的顺序都是固定的，因此用户可以打乱语句顺序！<br /><a name="1jcL3"></a></p><h2 id="sql类"><a class="markdownIt-Anchor" href="#sql类"></a> SQL类</h2><p>该类是AbstractSQL的实现，其内部仅仅重写了一个getSelf方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SQL <span class="title">getSelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，没什么用。但是为什么要抽象AbstractSQL？<br />因为这样可以保留扩展性，比如可以在所有操作前都加上EXPLAIN前缀。<br /><a name="7xDqD"></a></p><h2 id="sqlrunner"><a class="markdownIt-Anchor" href="#sqlrunner"></a> SqlRunner</h2><p>SqlRunner类是Mybatis提供的可以直接执行SQL语句的工具类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">&quot;SELECT * FROM user WHERE age = ?;&quot;</span>;</span><br><span class="line">SqlRunner sqlRunner = <span class="keyword">new</span> SqlRunner(connection);</span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; result = sqlRunner.selectAll(sql,<span class="number">15</span>);</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// SqlRunner类的使用，email变量值为null</span></span><br><span class="line">sql = <span class="string">&quot;UPDATE user SET email = ?  WHERE id = 2;&quot;</span>;</span><br><span class="line">Integer out = sqlRunner.update(sql,Null.STRING);</span><br><span class="line">System.out.println(out);</span><br></pre></td></tr></table></figure><p>其中，如果参数为null，一定要调用枚举类类型的NUll，因为该类型包含了类型信息和类型处理器信息，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Null &#123;</span><br><span class="line">  BOOLEAN(<span class="keyword">new</span> BooleanTypeHandler(), JdbcType.BOOLEAN),</span><br><span class="line"></span><br><span class="line">  BYTE(<span class="keyword">new</span> ByteTypeHandler(), JdbcType.TINYINT),</span><br><span class="line">  <span class="comment">// 省略其他类型</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> TypeHandler&lt;?&gt; typeHandler;</span><br><span class="line">  <span class="keyword">private</span> JdbcType jdbcType;</span><br><span class="line"></span><br><span class="line">  Null(TypeHandler&lt;?&gt; typeHandler, JdbcType jdbcType) &#123;</span><br><span class="line">    <span class="keyword">this</span>.typeHandler = typeHandler;</span><br><span class="line">    <span class="keyword">this</span>.jdbcType = jdbcType;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略setter getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种定义确保了参数值虽然为null，但是参数类型是明确的。<br />以selectAll为例，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; selectAll(String sql, Object... args) <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  PreparedStatement ps = connection.prepareStatement(sql);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    setParameters(ps, args);</span><br><span class="line">    ResultSet rs = ps.executeQuery();</span><br><span class="line">    <span class="keyword">return</span> getResults(rs);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ps.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      <span class="comment">//ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中核心逻辑在getResults中，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Map&lt;String, Object&gt;&gt; getResults(ResultSet rs) <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 返回结果的字段名列表，按字段顺序排列</span></span><br><span class="line">    List&lt;String&gt; columns = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 返回结果的类型处理器列表，按字段顺序排列</span></span><br><span class="line">    List&lt;TypeHandler&lt;?&gt;&gt; typeHandlers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 获取返回结果的表信息、字段信息</span></span><br><span class="line">    ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = rsmd.getColumnCount(); i &lt; n; i++) &#123;</span><br><span class="line">      <span class="comment">// 记录字段名</span></span><br><span class="line">      columns.add(rsmd.getColumnLabel(i + <span class="number">1</span>));</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 记录字段对应的处理器</span></span><br><span class="line">        Class&lt;?&gt; type = Resources.classForName(rsmd.getColumnClassName(i + <span class="number">1</span>));</span><br><span class="line">        TypeHandler&lt;?&gt; typeHandler = typeHandlerRegistry.getTypeHandler(type);</span><br><span class="line">        <span class="keyword">if</span> (typeHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">          typeHandler = typeHandlerRegistry.getTypeHandler(Object.class);</span><br><span class="line">        &#125;</span><br><span class="line">        typeHandlers.add(typeHandler);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 默认的是Object类型的处理器</span></span><br><span class="line">        typeHandlers.add(typeHandlerRegistry.getTypeHandler(Object.class));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环结果集</span></span><br><span class="line">    <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">      Map&lt;String, Object&gt; row = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = columns.size(); i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 字段名</span></span><br><span class="line">        String name = columns.get(i);</span><br><span class="line">        <span class="comment">// 对应处理器</span></span><br><span class="line">        TypeHandler&lt;?&gt; handler = typeHandlers.get(i);</span><br><span class="line">        <span class="comment">// 放入结果中，key为字段名的大写，value为取出的结果集</span></span><br><span class="line">        row.put(name.toUpperCase(Locale.ENGLISH), handler.getResult(rs, name));</span><br><span class="line">      &#125;</span><br><span class="line">      list.add(row);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        rs.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="jIPsm"></a></p><h1 id="脚本运行操作"><a class="markdownIt-Anchor" href="#脚本运行操作"></a> 脚本运行操作</h1><p>ScriptRunner是负责执行SQL脚本的工具类，这个可以将整个脚本文件提交给Mybatis，操作语句如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ScriptRunner scriptRunner = <span class="keyword">new</span> ScriptRunner(connection);</span><br><span class="line">scriptRunner.runScript(Resources.getResourceAsReader(<span class="string">&quot;demoScript.sql&quot;</span>));</span><br></pre></td></tr></table></figure><p>其入口方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runScript</span><span class="params">(Reader reader)</span> </span>&#123;</span><br><span class="line">  setAutoCommit();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sendFullScript) &#123;</span><br><span class="line">      <span class="comment">// 全脚本执行</span></span><br><span class="line">      executeFullScript(reader);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 逐行执行</span></span><br><span class="line">      executeLineByLine(reader);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    rollbackConnection();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>executeFullScript源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeFullScript</span><span class="params">(Reader reader)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 脚本全文</span></span><br><span class="line">  StringBuilder script = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    BufferedReader lineReader = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = lineReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 逐行读入脚本</span></span><br><span class="line">      script.append(line);</span><br><span class="line">      script.append(LINE_SEPARATOR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拼接为一条命令</span></span><br><span class="line">    String command = script.toString();</span><br><span class="line">    println(command);</span><br><span class="line">    <span class="comment">// 执行命令</span></span><br><span class="line">    executeStatement(command);</span><br><span class="line">    <span class="comment">// 如果没有启动自动提交则进行提交</span></span><br><span class="line">    commitConnection();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    String message = <span class="string">&quot;Error executing: &quot;</span> + script + <span class="string">&quot;.  Cause: &quot;</span> + e;</span><br><span class="line">    printlnError(message);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeSqlException(message, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="wTny5"></a></p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>该jdbc包是mybatis提供的一个功能独立的工具包，留给用户自行使用而不是由mybatis调用，因为有些时候想对数据库进行操作，却不需要ORM的支持。<br /><a name="PLxYF"></a></p><h2 id="代码演示"><a class="markdownIt-Anchor" href="#代码演示"></a> 代码演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 首先获取Connection对象备用，也可以使用其他方式获取</span></span><br><span class="line">        String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        Connection connection = sqlSession.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SqlRunner类的使用</span></span><br><span class="line">        String sql = <span class="string">&quot;SELECT * FROM user WHERE age = ?;&quot;</span>;</span><br><span class="line">        SqlRunner sqlRunner = <span class="keyword">new</span> SqlRunner(connection);</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; result = sqlRunner.selectAll(sql,<span class="number">15</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SqlRunner类的使用，email变量值为null</span></span><br><span class="line">        sql = <span class="string">&quot;UPDATE user SET email = ?  WHERE id = 2;&quot;</span>;</span><br><span class="line">        Integer out = sqlRunner.update(sql,Null.STRING);</span><br><span class="line">        System.out.println(out);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ScriptRunner类的使用</span></span><br><span class="line">        ScriptRunner scriptRunner = <span class="keyword">new</span> ScriptRunner(connection);</span><br><span class="line">        scriptRunner.runScript(Resources.getResourceAsReader(<span class="string">&quot;demoScript.sql&quot;</span>));</span><br><span class="line"></span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jdbc包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jdbc包&quot;&gt;&lt;/a&gt; jdbc包&lt;/h1&gt;
&lt;p&gt;该包提供了数据库操作语句的执行能力和脚本运行能力。&lt;br /&gt;
&lt;a name=&quot;FFzMt&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="核心操作包" scheme="https://jie-blog.icu/categories/mybatis/%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C%E5%8C%85/"/>
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>cache包</title>
    <link href="https://jie-blog.icu/posts/mybatis-cache/"/>
    <id>https://jie-blog.icu/posts/mybatis-cache/</id>
    <published>2020-11-04T04:08:26.000Z</published>
    <updated>2020-11-04T04:15:30.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cache包"><a class="markdownIt-Anchor" href="#cache包"></a> cache包</h1><p>Mybatis缓存使得每次数据库查询请求都会先经过缓存系统的过滤，只有在没有命中缓存的情况下才会去查询物理数据库。其中cache包就是Mybatis缓存能力的提供者，但是它只提供缓存能力，不涉及具体缓存功能的使用。<br /><a name="vbW6J"></a></p><h1 id="java的引用"><a class="markdownIt-Anchor" href="#java的引用"></a> Java的引用</h1><p>Java的引用一共有四种情况（JVM有说过）：</p><ul><li>强引用是最传统的引用定义，是指在程序代码之中普遍存在的引用赋值，即类似：<code>Object obj=new Object()</code>这种引用关系。只要强引用还在，GC就不会回收掉被引用的对象。</li><li>软引用是用来描述一些还有用，但非必须的对象。只要被软引用关联的对象，在系统发生内存溢出异常之前，都会被列入回收范围之中二次回收，如果此次回收还没有足够的内存才会抛出异常。</li><li>弱引用是用来描述非必须的对象，被弱引用关联的对象只能生存到下一次收集发生位置。当垃圾回收工作时，无论内存是否够用，该引用都会被回收。</li><li>虚引用又被称为“幽灵引用”或者“幻影引用”。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来构建一个对象实例。该引用的存在就是为了再回收时收到一个系统通知。<br /><a name="aOpzw"></a></li></ul><h2 id="referencequeue"><a class="markdownIt-Anchor" href="#referencequeue"></a> ReferenceQueue</h2><p>ReferenceQueue本身是一个列表，可以在创建软引用或者弱引用的包装对象时传入该列表。当JVM回收被包装对象时会将其包装类加入ReferenceQueue中。<br /><a name="Hpsgn"></a></p><h3 id="代码演示"><a class="markdownIt-Anchor" href="#代码演示"></a> 代码演示：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        simpleRef();</span><br><span class="line">        refWithReferenceQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simpleRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过等号直接建立的引用都是强引用</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过SoftReference建立的引用是软引用</span></span><br><span class="line">        SoftReference&lt;User&gt; softRefUser =<span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> User());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过WeakReference建立的引用是弱引用</span></span><br><span class="line">        WeakReference&lt;User&gt; weakRefUser = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> User());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">refWithReferenceQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建ReferenceQueue</span></span><br><span class="line">        ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来存储弱引用的目标对象</span></span><br><span class="line">        List&lt;WeakReference&gt; weakRefUserList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 创建大量的弱引用对象，交给weakRefUserList引用</span></span><br><span class="line">        <span class="comment">// 创建这么多的目的是为了让内存空间紧张</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ; i&lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建弱引用对象，并在此过程中传入ReferenceQueue</span></span><br><span class="line">            WeakReference&lt;User&gt; weakReference = <span class="keyword">new</span> WeakReference(<span class="keyword">new</span> User(Math.round(Math.random() * <span class="number">1000</span>)),referenceQueue);</span><br><span class="line">            <span class="comment">// 引用弱引用对象</span></span><br><span class="line">            weakRefUserList.add(weakReference);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakReference weakReference;</span><br><span class="line">        Integer count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理被回收的弱引用</span></span><br><span class="line">        <span class="keyword">while</span> ((weakReference = (WeakReference) referenceQueue.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 虽然弱引用存在，但是引用的目标对象已经为空</span></span><br><span class="line">            System.out.println(<span class="string">&quot;JVM 清理了：&quot;</span> + weakReference + <span class="string">&quot;, 从WeakReference中取出对象值为：&quot;</span> + weakReference.get());</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 被回收的弱引用总数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;weakReference中的元素数目为：&quot;</span> + count);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在弱引用的目标对象不被清理时，可以引用到目标对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;在不被清理的情况下，可以从WeakReference中取出对象值为：&quot;</span> +</span><br><span class="line">                <span class="keyword">new</span> WeakReference(<span class="keyword">new</span> User(Math.round(Math.random() * <span class="number">1000</span>)),referenceQueue).get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603001666822-51129404-45d9-4486-88d5-ceb7b8f0c4d0.png#align=left&amp;display=inline&amp;height=148&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=295&amp;originWidth=1123&amp;size=371152&amp;status=done&amp;style=none&amp;width=561.5" alt="image.png" /><br /><a name="edHRI"></a></p><h3 id="结果分析"><a class="markdownIt-Anchor" href="#结果分析"></a> 结果分析</h3><p>由于User对象已经被清理了，而包装对象却被保留在了ReferenceQueue中，因此可以取出weakReference但是对象的值却为null<br /><a name="pIwaY"></a></p><h1 id="cache包结构"><a class="markdownIt-Anchor" href="#cache包结构"></a> cache包结构</h1><p>cache包是典型的装饰器模式的应用案例，在imple包中存放了实现类，在decorators包中存放了众多的修饰器类。而Cache接口是实现类和装饰器类的共同的接口。其内部类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603001990731-71819f7a-8ac0-404c-aa27-fad0988f9c1d.png#align=left&amp;display=inline&amp;height=342&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=684&amp;originWidth=993&amp;size=1165110&amp;status=done&amp;style=none&amp;width=496.5" alt="image.png" /><br /><a name="tN1Jm"></a></p><h2 id="cache接口"><a class="markdownIt-Anchor" href="#cache接口"></a> Cache接口</h2><p>该接口源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取缓存Id</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 向缓存写一条数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 向缓存中读取一条数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Object <span class="title">getObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 向缓存中删除一条数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Object <span class="title">removeObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 清空缓存</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取缓存数据数目</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取读写锁</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="bl2zh"></a></p><h1 id="缓存键"><a class="markdownIt-Anchor" href="#缓存键"></a> 缓存键</h1><p>Mybatis每秒过滤很多条数据库查询语句，这使Mybatis的缓存键要求就变得高，其要满足以下几点：</p><ul><li>无碰撞：必须保障两条不同的查询请求生成的键不同，这是最重要的也是必须要满足的要求，否则会导致命中错误的缓存，返回错误的结果。</li><li>高效比较：每次缓存查询操作都可能会引发键之间的多次比较，因此该操作必须是高效的。</li><li>高效生成：每次缓存查询和写入操作前都要生成缓存的键，因此该操作也是要高效的。<br /><a name="fS0Iv"></a></li></ul><h2 id="缓存键原理"><a class="markdownIt-Anchor" href="#缓存键原理"></a> 缓存键原理</h2><p>Mybatis设计了CacheKey来作为缓存键，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 乘数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> multiplier;</span><br><span class="line"><span class="comment">// 哈希值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hashcode;</span><br><span class="line"><span class="comment">// 求和校验值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> checksum;</span><br><span class="line"><span class="comment">// 更新次数  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;  </span><br><span class="line"><span class="comment">// 历史更新  </span></span><br><span class="line"><span class="keyword">private</span> List&lt;Object&gt; updateList;</span><br></pre></td></tr></table></figure><p>其更新操作源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> baseHashCode = object == <span class="keyword">null</span> ? <span class="number">1</span> : ArrayUtil.hashCode(object);</span><br><span class="line"></span><br><span class="line">  count++;</span><br><span class="line">  checksum += baseHashCode;</span><br><span class="line">  baseHashCode *= count;</span><br><span class="line"></span><br><span class="line">  hashcode = multiplier * hashcode + baseHashCode;</span><br><span class="line"></span><br><span class="line">  updateList.add(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，其比较方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 如果地址相等，那证明是同一个对象</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span> == object) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果不是CacheKey那一定不相等</span></span><br><span class="line">   <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> CacheKey)) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> CacheKey cacheKey = (CacheKey) object;</span><br><span class="line"><span class="comment">// 依次进行值比较</span></span><br><span class="line">   <span class="keyword">if</span> (hashcode != cacheKey.hashcode) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (checksum != cacheKey.checksum) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (count != cacheKey.count) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 查看历史是否有碰撞</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; updateList.size(); i++) &#123;</span><br><span class="line">     Object thisObject = updateList.get(i);</span><br><span class="line">     Object thatObject = cacheKey.updateList.get(i);</span><br><span class="line">     <span class="keyword">if</span> (!ArrayUtil.equals(thisObject, thatObject)) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>此外，该类还有一个属性如下：<br /><code>public static final CacheKey NULL_CACHE_KEY = new NullCacheKey();</code><br />其代表空键，其构造方法调用的是CacheKey的默认构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.hashcode = DEFAULT_HASHCODE;</span><br><span class="line">  <span class="keyword">this</span>.multiplier = DEFAULT_MULTIPLYER;</span><br><span class="line">  <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.updateList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样保证了不会引发空指针异常。<br /><a name="ByV8w"></a></p><h2 id="缓存键的生成"><a class="markdownIt-Anchor" href="#缓存键的生成"></a> 缓存键的生成</h2><p>查询时会根据当前查询条件生成一个对应的CacheKey，以BaseExecutor的query方法为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">  <span class="comment">// 生成缓存键</span></span><br><span class="line">  CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">  <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createCacheKey源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建CacheKey，将所有查询参数依次更新写入</span></span><br><span class="line">  CacheKey cacheKey = <span class="keyword">new</span> CacheKey();</span><br><span class="line">  cacheKey.update(ms.getId());</span><br><span class="line">  cacheKey.update(rowBounds.getOffset());</span><br><span class="line">  cacheKey.update(rowBounds.getLimit());</span><br><span class="line">  cacheKey.update(boundSql.getSql());</span><br><span class="line">  List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">  <span class="comment">// mimic DefaultParameterHandler logic</span></span><br><span class="line">  <span class="keyword">for</span> (ParameterMapping parameterMapping : parameterMappings) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">      Object value;</span><br><span class="line">      String propertyName = parameterMapping.getProperty();</span><br><span class="line">      <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">        value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">        value = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">        value = parameterObject;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">        value = metaObject.getValue(propertyName);</span><br><span class="line">      &#125;</span><br><span class="line">      cacheKey.update(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (configuration.getEnvironment() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// issue #176</span></span><br><span class="line">    cacheKey.update(configuration.getEnvironment().getId());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cacheKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的CacheKey对象中包含了查询的所有信息，包括查询语句的id、查询的翻页限制、数据总量、完整的SQL语句，这些信息保证了两次查询的一致性，可以同equals就可以判断是否一致。<br /><a name="YIpA6"></a></p><h1 id="缓存的实现类"><a class="markdownIt-Anchor" href="#缓存的实现类"></a> 缓存的实现类</h1><p>cache接口的唯一实现类PerpetualCache，其内部实现十分简单，只有两个属性而已：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存的ID </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line"><span class="comment">// 存储要缓存的数据</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;Object, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p><a name="dWumK"></a></p><h1 id="缓存装饰器"><a class="markdownIt-Anchor" href="#缓存装饰器"></a> 缓存装饰器</h1><p>虽然Cache的实现类很简单，但是其可以通过众多的包装类增加很多功能，decorators包中的包装类可以分为如下几大类：</p><ul><li>同步装饰器：为缓存增加同步功能，如SynchronizedCache类。</li><li>日志装饰器：为缓存增加日志功能，如LoggingCache类。</li><li>清理装饰类：为缓存中的数据增加清理功能，如FifoCache、LruCache、WeakCache、SoftCache类。</li><li>阻塞装饰类：为缓存增加阻塞功能，如BlockingCache类。</li><li>定时清理装饰类：为缓存增加定时刷新功能，如ScheduledCache类。</li><li>序列化修饰类：为缓存增加序列化功能，如SerializedCache类。</li><li>事务修饰类：用于支持事务操作的装饰器，如TransactionalCache类。<br /><a name="Q5RZM"></a></li></ul><h2 id="同步修饰器"><a class="markdownIt-Anchor" href="#同步修饰器"></a> 同步修饰器</h2><p>并发下可能会出现多个线程同时访问一个缓存的情况，Mybatis将保证缓存多线程安全这项工作交给了SynchronizedCache修饰器来完成，其内部实现十分简单，直接在方法外围加上了Synchronized关键词（实现简单，不做展示）。<br /><a name="lFl3W"></a></p><h2 id="日志修饰器"><a class="markdownIt-Anchor" href="#日志修饰器"></a> 日志修饰器</h2><p>日志修饰器可以为缓存增加日志统计的功能，而需要统计的数据主要是缓存命中率，开发者可以依据这些指标来设置合适的缓存大小。<br />日志修饰器的实现也非常简单，即在查询的时候记录查询总次数和命中次数即可，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  requests++;</span><br><span class="line">  <span class="keyword">final</span> Object value = delegate.getObject(key);</span><br><span class="line">  <span class="comment">// 命中缓存</span></span><br><span class="line">  <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 命中次数+1</span></span><br><span class="line">    hits++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;Cache Hit Ratio [&quot;</span> + getId() + <span class="string">&quot;]: &quot;</span> + getHitRatio());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="4VSpt"></a></p><h2 id="清理修饰器"><a class="markdownIt-Anchor" href="#清理修饰器"></a> 清理修饰器</h2><p>缓存是以消耗内存空间为代价的，缓存空间总是有限的，因此可以为缓存增加合适的清理策略来最大化的利用缓存空间。<br />清理修饰器共有四种，对应着四种不同的策略：<br /><a name="nQYM3"></a></p><h3 id="fifocache"><a class="markdownIt-Anchor" href="#fifocache"></a> FifoCache</h3><p>该类采用先进先出策略来清理缓存，其内部采用keyList属性存储了缓存数据的写入顺序，并且使用size属性存储了缓存数据的数量限制。当缓存中的数据达到限制时，FifoCache装饰器会将先放入缓存中的数据删除。其属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被修饰对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line"><span class="comment">// 按照写入顺序保存了缓存数据的键</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;Object&gt; keyList;</span><br><span class="line"><span class="comment">// 缓存空间大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>向缓存存入数据时会先判断数据数量是否已经超过了限制，如果超过了会对先写入的数据进行删除，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">  cycleKeyList(key);</span><br><span class="line">  delegate.putObject(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cycleKeyList</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  keyList.addLast(key);</span><br><span class="line">  <span class="keyword">if</span> (keyList.size() &gt; size) &#123;</span><br><span class="line">    Object oldestKey = keyList.removeFirst();</span><br><span class="line">    delegate.removeObject(oldestKey);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="bsBJ8"></a></p><h3 id="lrucache"><a class="markdownIt-Anchor" href="#lrucache"></a> LruCache</h3><p>近期最少使用算法，该算法会在缓存数据数量达到设置上限时将近期未使用的数据删除。其属性列表如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被装饰对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line"><span class="comment">// 使用LinkedHashMap来保存缓存数据的键</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;Object, Object&gt; keyMap;</span><br><span class="line"><span class="comment">// 最近最少使用的数据的键</span></span><br><span class="line"><span class="keyword">private</span> Object eldestKey;</span><br></pre></td></tr></table></figure><p>其构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(Cache delegate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">  setSize(<span class="number">1024</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了setSize方法来设置缓存空间的大小，setSize源码如下：.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">  keyMap = <span class="keyword">new</span> LinkedHashMap&lt;Object, Object&gt;(size, .<span class="number">75F</span>, <span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4267176411845948333L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Object, Object&gt; eldest)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> tooBig = size() &gt; size;</span><br><span class="line">      <span class="keyword">if</span> (tooBig) &#123;</span><br><span class="line">        eldestKey = eldest.getKey();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> tooBig;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里重写了LinkedHashMap的removeEldestEntry方法，该方法在插入数据后会自动触发，该方法实现了长度判断，如果溢出会将eldest的key放入到eldestKey。<br />此外，其还做了两件事：</p><ul><li>每次进行缓存查询时更新keyMap中键值的排序，将当前查询到的键值排序到最前面。</li><li>每次进行缓存写入操作时向keyMap写入新的键，并且在当前缓存中数据量超过设置的数据量时删除最久未访问的数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 查询操作</span></span><br><span class="line">  delegate.putObject(key, value);</span><br><span class="line">  <span class="comment">// 将key值放入keyMap，根据空间情况决定是否删除数据</span></span><br><span class="line">  cycleKeyList(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 触及一下当前被访问的键，说明其被访问了</span></span><br><span class="line">  keyMap.get(key);</span><br><span class="line">  <span class="comment">// 真正的查询操作</span></span><br><span class="line">  <span class="keyword">return</span> delegate.getObject(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cycleKeyList</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  keyMap.put(key, key);</span><br><span class="line">  <span class="keyword">if</span> (eldestKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">    delegate.removeObject(eldestKey);</span><br><span class="line">    eldestKey = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从cycleKeyList方法中可以看出LinkedHashMap中存储的键和值都是key，这是因为其目的仅仅是用来保存缓存数据被访问的情况而不是参与具体数据的保存。<br /><a name="0HEMg"></a></p><h3 id="weakcache"><a class="markdownIt-Anchor" href="#weakcache"></a> WeakCache</h3><p>WeakCache装饰器通过将缓存数据包装成弱引用的数据，从而使得JVM可以清理掉缓存数据。其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强引用对象列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;Object&gt; hardLinksToAvoidGarbageCollection;</span><br><span class="line"><span class="comment">// 弱引用对象列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queueOfGarbageCollectedEntries;</span><br><span class="line"><span class="comment">// 被装饰对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line"><span class="comment">// 强引用对象的数目限制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> numberOfHardLinks;</span><br></pre></td></tr></table></figure><p>放入数据源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 清除垃圾回收队列中的元素</span></span><br><span class="line">  removeGarbageCollectedItems();</span><br><span class="line">  <span class="comment">// 向被装饰对象中放入的值是弱引用的句柄</span></span><br><span class="line">  delegate.putObject(key, <span class="keyword">new</span> WeakEntry(key, value, queueOfGarbageCollectedEntries));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>removeGarbageCollectedItems：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeGarbageCollectedItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  WeakEntry sv;</span><br><span class="line">  <span class="comment">// 轮询该垃圾回收器队列</span></span><br><span class="line">  <span class="keyword">while</span> ((sv = (WeakEntry) queueOfGarbageCollectedEntries.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 将该队列中涉及的键删除</span></span><br><span class="line">    delegate.removeObject(sv.key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取出缓存也会是数据的弱引用包装类。数据本身可能已经被JVM清理掉了，因此还要对取出做出判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Object result = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 假定被修饰对象只被该修饰器完全控制</span></span><br><span class="line">  WeakReference&lt;Object&gt; weakReference = (WeakReference&lt;Object&gt;) delegate.getObject(key);</span><br><span class="line">  <span class="comment">// 读取到弱引用句柄</span></span><br><span class="line">  <span class="keyword">if</span> (weakReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取到弱引用对象</span></span><br><span class="line">    result = weakReference.get();</span><br><span class="line">    <span class="comment">// 如果为空</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 清理弱引用对象</span></span><br><span class="line">      delegate.removeObject(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 将缓存数据写入强引用列表</span></span><br><span class="line">      hardLinksToAvoidGarbageCollection.addFirst(result);</span><br><span class="line">      <span class="comment">// 如果超出列表</span></span><br><span class="line">      <span class="keyword">if</span> (hardLinksToAvoidGarbageCollection.size() &gt; numberOfHardLinks) &#123;</span><br><span class="line">        <span class="comment">// 删除最后一个元素</span></span><br><span class="line">        hardLinksToAvoidGarbageCollection.removeLast();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止键值回收后无法删除，因此定义了内部类WeakEntry来为每一个弱引用设置一个强引用属性，来作为唯一标识符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakEntry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object key;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">WeakEntry</span><span class="params">(Object key, Object value, ReferenceQueue&lt;Object&gt; garbageCollectionQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(value, garbageCollectionQueue);</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="fvjKz"></a></p><h2 id="阻塞修饰器"><a class="markdownIt-Anchor" href="#阻塞修饰器"></a> 阻塞修饰器</h2><p>如果在数据库查询尚未结束时，Mybatis又收到一条完全相同的数据库查询请求，可以按照下述方法处理：<br />虽然缓存中没有对应的缓存结果，但是已经向数据库发起过一次请求，因此缓存应该先阻塞第二次查询请求。等待数据库查询结束后，将数据库的查询结果返回给第二次查询请求即可。<br /><a name="zkmk7"></a></p><h3 id="blockingcache"><a class="markdownIt-Anchor" href="#blockingcache"></a> BlockingCache</h3><p>该类就是为缓存提供上述功能的，阻塞修饰器工作示意图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603108895033-555dc925-74d5-4b58-9005-1c9a0e3c82a4.png#align=left&amp;display=inline&amp;height=266&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=531&amp;originWidth=1122&amp;size=933136&amp;status=done&amp;style=none&amp;width=561" alt="image.png" /><br />在使用阻塞修饰器装饰缓存后，缓存在收到多条相同的查询请求时会暂时阻塞住后面的查询，等待数据库结果返回时将所有请求一并返回。<br />该类的内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁时的运行等待时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line"><span class="comment">// 被装饰对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line"><span class="comment">// 锁的映射表。键为缓存记录的键，值为对应的锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Object, ReentrantLock&gt; locks;</span><br></pre></td></tr></table></figure><p>观察其方法得出，其对每一个记录都有一个对应的锁，而不是锁住整个缓存。与加锁相关的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出指定键的锁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ReentrantLock <span class="title">getLockForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> locks.computeIfAbsent(key, k -&gt; <span class="keyword">new</span> ReentrantLock());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取某个键的锁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">acquireLock</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 找出指定键的锁</span></span><br><span class="line">  Lock lock = getLockForKey(key);</span><br><span class="line">  <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">boolean</span> acquired = lock.tryLock(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">      <span class="keyword">if</span> (!acquired) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;Couldn&#x27;t get a lock in &quot;</span> + timeout + <span class="string">&quot; for the key &quot;</span> +  key + <span class="string">&quot; at the cache &quot;</span> + delegate.getId());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;Got interrupted while trying to acquire lock for key &quot;</span> + key, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 锁住</span></span><br><span class="line">    lock.lock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放某个对象的锁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 找出指定键的锁</span></span><br><span class="line">  ReentrantLock lock = locks.get(key);</span><br><span class="line">  <span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在读取缓存中的数据前需要获取该数据对应的锁，如果从缓存中获取到了对应的数据，则立即释放该锁；如果没有获取到对应的数据，则意味着接下来会进行数据库查询，直到数据库查询结束向缓存中写入该数据才会释放锁。相关源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向缓存中写入一条消息</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 向缓存中放入数据</span></span><br><span class="line">    delegate.putObject(key, value);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    releaseLock(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从缓存读消息</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取锁</span></span><br><span class="line">  acquireLock(key);</span><br><span class="line">  <span class="comment">// 读取结果</span></span><br><span class="line">  Object value = delegate.getObject(key);</span><br><span class="line">  <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 读取到结果后释放锁</span></span><br><span class="line">    releaseLock(key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果没有读取到数据，则返回null，准备进行数据库操作，等到写入缓存再释放锁</span></span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="lE41J"></a></p><h2 id="定时清理修饰器"><a class="markdownIt-Anchor" href="#定时清理修饰器"></a> 定时清理修饰器</h2><p>当调用clear方法时会清理缓存中的数据，但是这个操作不是自动执行的。<br />SecheduledCache修饰过的Cache可以按照一定的间隔时间来清理缓存中的数据。其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被修饰的对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line"><span class="comment">// 清理的间隔时间</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> clearInterval;</span><br><span class="line"><span class="comment">// 上次清理的时刻</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> lastClear;</span><br></pre></td></tr></table></figure><p>核心方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">clearWhenStale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (System.currentTimeMillis() - lastClear &gt; clearInterval) &#123;</span><br><span class="line">    clear();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  lastClear = System.currentTimeMillis();</span><br><span class="line">  delegate.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clearWhenStale方法会在getSize、getObject、putObject、removeObject调用时调用，如果没有被调用，那么clearWhenStale也不会被触发，也不会清理缓存。<br />这种非实时的方法节约了资源，也不会造成太大的误差。<br /><a name="v1jsr"></a></p><h2 id="序列化修饰器"><a class="markdownIt-Anchor" href="#序列化修饰器"></a> 序列化修饰器</h2><p>对象放入缓存的是对象的引用，也就是说如果修改了一方，另一方也会发生变化。<br />为了保证外部读取缓存中的对象时每次读取的都是一个全新的拷贝而不是引用SerializedCache就诞生了。使用了该类后，每次向缓存写入数据实际上写入的就是对象的序列化串；每次读取数据时，实际上读取的就是序列化串反序列化后的值。<br />注意：被序列化的对象也要实现序列化。<br />核心原码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入一条数据</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object object)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存必须是可以序列化的</span></span><br><span class="line">  <span class="keyword">if</span> (object == <span class="keyword">null</span> || object <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">    delegate.putObject(key, serialize((Serializable) object));</span><br><span class="line">  <span class="comment">// 如果不可序列化</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;SharedCache failed to make a copy of a non-serializable object: &quot;</span> + object);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取一条数据</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Object object = delegate.getObject(key);</span><br><span class="line">  <span class="comment">// 反序列化后返回</span></span><br><span class="line">  <span class="keyword">return</span> object == <span class="keyword">null</span> ? <span class="keyword">null</span> : deserialize((<span class="keyword">byte</span>[]) object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="R2Pyk"></a></p><h1 id="缓存的创建"><a class="markdownIt-Anchor" href="#缓存的创建"></a> 缓存的创建</h1><p>组件缓存的过程就是根据需求为缓存的基本实现增加各种装饰的过程，该过程在CacheBuilder完成，其入口方法是build，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Cache <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设置缓存的默认实现、默认装饰器</span></span><br><span class="line">  setDefaultImplementations();</span><br><span class="line">  <span class="comment">// 创建默认缓存</span></span><br><span class="line">  Cache cache = newBaseCacheInstance(implementation, id);</span><br><span class="line">  <span class="comment">// 设置缓存属性</span></span><br><span class="line">  setCacheProperties(cache);</span><br><span class="line">  <span class="comment">// 缓存的实现类是PerpetualCache而非用户自定义的实现类</span></span><br><span class="line">  <span class="keyword">if</span> (PerpetualCache.class.equals(cache.getClass())) &#123;</span><br><span class="line">    <span class="comment">// 逐级嵌套自定义的装饰器</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;? extends Cache&gt; decorator : decorators) &#123;</span><br><span class="line">      <span class="comment">// 生成的装饰器实例并装配。</span></span><br><span class="line">      cache = newCacheDecoratorInstance(decorator, cache);</span><br><span class="line">      <span class="comment">// 为装饰器设置属性</span></span><br><span class="line">      setCacheProperties(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为缓存增加标准装饰器</span></span><br><span class="line">    cache = setStandardDecorators(cache);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!LoggingCache.class.isAssignableFrom(cache.getClass())) &#123;</span><br><span class="line">    <span class="comment">// 增加日志装饰器</span></span><br><span class="line">    cache = <span class="keyword">new</span> LoggingCache(cache);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果外部没有指定实现类的话，缓存默认的实现类是PerpetualCache类，默认的清理装饰器是LruCache，详见setDefaultImplementations源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setDefaultImplementations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (implementation == <span class="keyword">null</span>) &#123;</span><br><span class="line">    implementation = PerpetualCache.class;</span><br><span class="line">    <span class="keyword">if</span> (decorators.isEmpty()) &#123;</span><br><span class="line">      decorators.add(LruCache.class);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这里只是简单地放入，并没实际的装配。<br />接下来的newCacheDecoratorInstance生成缓存的实现，并主机包装用户自定义的装饰器。最后会通过setStandardDecorators方法增加标准的装饰器。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Cache <span class="title">setStandardDecorators</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    MetaObject metaCache = SystemMetaObject.forObject(cache);</span><br><span class="line">    <span class="comment">// 设置缓存大小</span></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="keyword">null</span> &amp;&amp; metaCache.hasSetter(<span class="string">&quot;size&quot;</span>)) &#123;</span><br><span class="line">      metaCache.setValue(<span class="string">&quot;size&quot;</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果定义了清理间隔，则使用清理装饰器装饰缓存</span></span><br><span class="line">    <span class="keyword">if</span> (clearInterval != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cache = <span class="keyword">new</span> ScheduledCache(cache);</span><br><span class="line">      ((ScheduledCache) cache).setClearInterval(clearInterval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果允许读写，则用序列化装饰器</span></span><br><span class="line">    <span class="keyword">if</span> (readWrite) &#123;</span><br><span class="line">      cache = <span class="keyword">new</span> SerializedCache(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用日志装饰器</span></span><br><span class="line">    cache = <span class="keyword">new</span> LoggingCache(cache);</span><br><span class="line">    <span class="comment">// 使用同步装饰器</span></span><br><span class="line">    cache = <span class="keyword">new</span> SynchronizedCache(cache);</span><br><span class="line">    <span class="comment">// 如果被阻塞了则使用阻塞装饰器</span></span><br><span class="line">    <span class="keyword">if</span> (blocking) &#123;</span><br><span class="line">      cache = <span class="keyword">new</span> BlockingCache(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回被装饰的结果</span></span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;Error building standard cache decorators.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="9sv6c"></a></p><h1 id="事务缓存"><a class="markdownIt-Anchor" href="#事务缓存"></a> 事务缓存</h1><p>事务不仅可以指代封装在一起的多条语句，还可以用来指代一条普通的语句。如果没有显式的声明事务，那么一条语句本身就是一个事务。<br />如果事务中的语句进行数据库查询操作后直接放入了缓存，如果该事务进行了回滚，那么缓存中的数据就可能和数据库产生不一致。因此TransactionalCache包装类使用entriesToAddOnCommit属性将事务中产生的数据暂时保存起来，事务操作中产生的数据需要在事务提交时写入缓存，而在事务回滚时直接销毁。<br />TransactionalCache类也支持将缓存范围限定在事务以内，只需要将clearOnCommit设定为true即可。只要事务结束就会直接将暂时保存的数据销毁掉，而不是写入缓存。<br /><a name="lT2iQ"></a></p><h2 id="transactionalcache"><a class="markdownIt-Anchor" href="#transactionalcache"></a> TransactionalCache</h2><p>该类的内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被装饰的对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line"><span class="comment">// 事务提交后是否直接缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> clearOnCommit;</span><br><span class="line"><span class="comment">// 事务提交时需要写入缓存的数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Object&gt; entriesToAddOnCommit;</span><br><span class="line"><span class="comment">// 缓存查询未命中的数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Object&gt; entriesMissedInCache;</span><br></pre></td></tr></table></figure><p><a name="Ji3ax"></a></p><h3 id="缓存读取和存入"><a class="markdownIt-Anchor" href="#缓存读取和存入"></a> 缓存读取和存入</h3><p>读取缓存时是真正从缓存中获取的，而写入数据却只是暂存在TransactionalCache内部。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从缓存中读取数据</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中读取数据</span></span><br><span class="line">    Object object = delegate.getObject(key);</span><br><span class="line">    <span class="comment">// 缓存未命中</span></span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 记录未命中数据</span></span><br><span class="line">      entriesMissedInCache.add(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果开启了缓存范围限定</span></span><br><span class="line">    <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 返回查询结果</span></span><br><span class="line">      <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 写入一条数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object object)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 放入到entriesToAddOnCommit中暂存</span></span><br><span class="line">    entriesToAddOnCommit.put(key, object);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><a name="eko5x"></a></p><h3 id="事务提交回滚"><a class="markdownIt-Anchor" href="#事务提交回滚"></a> 事务提交回滚</h3><p><a name="45xsj"></a></p><h4 id="事务提交"><a class="markdownIt-Anchor" href="#事务提交"></a> 事务提交</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事务提交</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果设置了缓存范围限定</span></span><br><span class="line">    <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">      <span class="comment">// 清理缓存</span></span><br><span class="line">      delegate.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将未写入缓存的数据写入缓存</span></span><br><span class="line">    flushPendingEntries();</span><br><span class="line">    <span class="comment">// 清理环境</span></span><br><span class="line">    reset();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>flushPendingEntries源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushPendingEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将entriesToAddOnCommit中的数据写入缓存</span></span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;</span><br><span class="line">    delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将entriesToAddOnCommit中的数据写入缓存</span></span><br><span class="line">  <span class="keyword">for</span> (Object entry : entriesMissedInCache) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!entriesToAddOnCommit.containsKey(entry)) &#123;</span><br><span class="line">      delegate.putObject(entry, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reset源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  clearOnCommit = <span class="keyword">false</span>;</span><br><span class="line">  entriesToAddOnCommit.clear();</span><br><span class="line">  entriesMissedInCache.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="86ILn"></a></p><h4 id="事务回滚"><a class="markdownIt-Anchor" href="#事务回滚"></a> 事务回滚</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 删除缓存未命中数据</span></span><br><span class="line">  unlockMissedEntries();</span><br><span class="line">  reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unlockMissedEntries源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlockMissedEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Object entry : entriesMissedInCache) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      delegate.removeObject(entry);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      log.warn(<span class="string">&quot;Unexpected exception while notifiying a rollback to the cache adapter.&quot;</span></span><br><span class="line">          + <span class="string">&quot;Consider upgrading your cache adapter to the latest version.  Cause: &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="m5ft2"></a></p><h4 id="entriesmissedincache作用分析"><a class="markdownIt-Anchor" href="#entriesmissedincache作用分析"></a> entriesMissedInCache作用分析</h4><p>源码易得entriesMissedInCache的作用是往缓存里添加null的数据，其作用可以结合BlockingCache来看，如果缓存查询得到的结果为null会导致该数据上锁，从而阻塞后续对该数据的操作。而事务回滚后，entriesMissedInCache通过保存的这些键值可以在事务结束时对数据解锁。源码原理如unlockMissedEntries，其调用BlockingCache的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">removeObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// despite of its name, this method is called only to release locks</span></span><br><span class="line">  releaseLock(key);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="QQy8D"></a></p><h2 id="transactionalcachemanager"><a class="markdownIt-Anchor" href="#transactionalcachemanager"></a> TransactionalCacheManager</h2><p>该类是用来管理一个事务中的多个缓存的，其中transactionalCaches保存了多个缓存和对应的经过缓存装饰器装饰后的缓存，如下所示：<br /><code>private final Map&lt;Cache, TransactionalCache&gt; transactionalCaches = new HashMap&lt;&gt;();</code><br />其提交回滚源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">    txCache.commit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">    txCache.rollback();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="ADLT0"></a></p><h1 id="mybatis缓存机制"><a class="markdownIt-Anchor" href="#mybatis缓存机制"></a> Mybatis缓存机制</h1><p>cache包中并没设计缓存的具体使用，在executor包中，Mybatis基于cache包中提供的缓存实现了二级缓存。<br />Executor是执行器接口，其负责进行数据查询等操作，其类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603269192495-27c116a6-a543-46e9-9e4b-36dd1db5546a.png#align=left&amp;display=inline&amp;height=207&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=413&amp;originWidth=998&amp;size=607326&amp;status=done&amp;style=none&amp;width=499" alt="image.png" /><br />之后会对其进行详解，这里只对其两个子类功能进行分析：</p><ul><li>CachingExecutor：是一个装饰器类，它能够为执行器实现类增加缓存功能。</li><li>BaseExecutor是一个基类，它有四个子类，而其中ClosedExecutor没有实际功能，因此这里就只有三个实际执行器。</li></ul><p>两级缓存执行流程如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603275800970-802ad58f-f927-4284-ba69-ef404b9b93ea.png#align=left&amp;display=inline&amp;height=324&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=647&amp;originWidth=747&amp;size=663804&amp;status=done&amp;style=none&amp;width=373.5" alt="image.png" /><br /><a name="P9Sbc"></a></p><h2 id="一级缓存"><a class="markdownIt-Anchor" href="#一级缓存"></a> 一级缓存</h2><p>Mybatis的一级缓存又叫本地缓存，其有两个配置项：</p><ul><li>配置在setting节点下，可选项有SESSION和STATEMENT分别对应一次会话和一条语句，其默认为SESSION。<ul><li>配置样式：<code>&lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt;</code></li></ul></li><li>在映射文件的数据库操作节点内增加flushCache属性项，为true时会在该数据库操作执行前清空一、二级缓存。默认为false。<ul><li>配置样式：<code>&lt;select id=&quot;selectUser_A&quot; resultMap=&quot;userMapByConstructor&quot; flushCache=&quot;false&quot;&gt;</code><br /><a name="O8KR3"></a></li></ul></li></ul><h3 id="baseexecutor"><a class="markdownIt-Anchor" href="#baseexecutor"></a> BaseExecutor</h3><p>一级缓存主要由该类实现，其内部相关属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询操作的结果缓存</span></span><br><span class="line"><span class="keyword">protected</span> PerpetualCache localCache;</span><br><span class="line"><span class="comment">// Callable查询的输出参数缓存</span></span><br><span class="line"><span class="keyword">protected</span> PerpetualCache localOutputParameterCache;</span><br></pre></td></tr></table></figure><p>这两个属性都是基础的PerpetualCache类型，因为其都是Executor的属性，因此不可能超出其作用范围，而Executor归属于SqlSession，因此第一级缓存最大的作用与就是SqlSession即一次会话。<br />其query包括了整个缓存原理，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="comment">// 执行器已经关闭</span></span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查询栈为空且要求清空缓存</span></span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    <span class="comment">// 清除一级缓存</span></span><br><span class="line">    clearLocalCache();</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    queryStack++;</span><br><span class="line">    <span class="comment">// 尝试从本地获取缓存</span></span><br><span class="line">    list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 本地缓存中有结果，对于Callable语句还需要绑定到IN/OUTPUT参数上</span></span><br><span class="line">      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 本地缓存没有结果，需要查询数据库</span></span><br><span class="line">      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    queryStack--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 懒加载处理</span></span><br><span class="line">    <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">      deferredLoad.load();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// issue #601</span></span><br><span class="line">    deferredLoads.clear();</span><br><span class="line">    <span class="comment">// 如果作用域是STATEMENT则清空本地缓存</span></span><br><span class="line">    <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">      <span class="comment">// issue #482</span></span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据库操作用的INSERT、UPDATE、DALETE都对应了该类中的update方法，在该方法里会引发一级缓存的更新，该方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing an update&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="comment">// 执行器已关闭</span></span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清空本地缓存</span></span><br><span class="line">  clearLocalCache();</span><br><span class="line">  <span class="comment">// 返回调用子类操作</span></span><br><span class="line">  <span class="keyword">return</span> doUpdate(ms, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="pmc7X"></a></p><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p>可见BaseExecutor的作用范围有限，其内部的两个参数也不支持装饰器修饰，因此不支持容量配置等操作。<br /><a name="nRiWV"></a></p><h2 id="二级缓存"><a class="markdownIt-Anchor" href="#二级缓存"></a> 二级缓存</h2><p>二级缓存作用范围是一个命名空间（配置文件），并且可以实现多命名空间共享。其配置项共有四个：</p><ul><li>第一个配置项在settings下，默认值为true，即支持二级缓存。<ul><li>配置演示：<code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</code></li></ul></li><li>第二个配置在映射文件内，即通过缓存的创建映射创建，同时也可以通过ref引入。</li><li>第三个配置在数据库操作节点内的useCache属性，通过它可以设置是否启用二级缓存。对于SELECT而言，useCache默认为true，对于其他节点来说没有意义。</li><li>第四个配置为flushCache属性项，和一级节点一致。<br /><a name="v029Z"></a></li></ul><h3 id="cachingexecutor"><a class="markdownIt-Anchor" href="#cachingexecutor"></a> CachingExecutor</h3><p>二级缓存主要由该类实现，他只是一个装饰器类，其能通过装饰实际执行器来增加二级缓存的功能。Configuration类中的newExecutor方法Mybatis会根据配置文件中的二级缓存开关配置用CachingExecutor类修饰实际的执行器。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">  Executor executor;</span><br><span class="line">  <span class="comment">// 根据数据库类型创建实际执行器</span></span><br><span class="line">  <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据setting判断是否开启缓存</span></span><br><span class="line">  <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">    <span class="comment">// 使用CachingExecutor装饰执行器</span></span><br><span class="line">    executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 未执行器增加拦截器</span></span><br><span class="line">  executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">  <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然一条语句也是一个事务，那么事务缓存管理器可以应用在有事务的场景，也可以应用在没有事务的场景。<br />其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被装饰得执行器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor delegate;</span><br><span class="line"><span class="comment">// 事务缓存管理器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TransactionalCacheManager tcm = <span class="keyword">new</span> TransactionalCacheManager();</span><br></pre></td></tr></table></figure><p>其核心query源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 获取MappedStatement对应的缓存，可能的结果有：该命名空间的缓存、共享的其他命名空间的缓存、无缓存</span></span><br><span class="line">  Cache cache = ms.getCache();</span><br><span class="line">  <span class="comment">// 如果映射文件未设置&lt;cache&gt;或&lt;cache-ref&gt;，则此处cache变量为null</span></span><br><span class="line">  <span class="comment">// 存在映射</span></span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据要求判断语句执行前是否要清除二级缓存</span></span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 二级缓存不支持含有输出参数的Callable的语句</span></span><br><span class="line">      ensureNoOutParams(ms, boundSql);</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      <span class="comment">// 读取缓存结果</span></span><br><span class="line">      List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">      <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 交给执行器</span></span><br><span class="line">        list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        <span class="comment">// 缓存被包装执行器返回的结果</span></span><br><span class="line">        tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flushCacheIfRequired源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取缓存</span></span><br><span class="line">  Cache cache = ms.getCache();</span><br><span class="line">  <span class="comment">// 存在缓存且该操作语句要求执行前清除</span></span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    <span class="comment">// 清除事务中的缓存</span></span><br><span class="line">    tcm.clear(cache);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其update方法会调用flushCacheIfRequired方法，而对于这些语句isFlushCacheRequired恒为true，因此总会导致二级缓存清除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cache包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cache包&quot;&gt;&lt;/a&gt; cache包&lt;/h1&gt;
&lt;p&gt;Mybatis缓存使得每次数据库查询请求都会先经过缓存系统的过滤，只有在没有命中缓存的情况下才会去查询物理数据库。其中c</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="核心操作包" scheme="https://jie-blog.icu/categories/mybatis/%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C%E5%8C%85/"/>
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>datasource包</title>
    <link href="https://jie-blog.icu/posts/mybatis-datasource/"/>
    <id>https://jie-blog.icu/posts/mybatis-datasource/</id>
    <published>2020-11-04T04:06:04.000Z</published>
    <updated>2020-11-04T04:15:24.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="datasource包"><a class="markdownIt-Anchor" href="#datasource包"></a> datasource包</h1><p>通过dataSource包Mybatis将完成数据源的获取、数据连接的建立等工作为操作语句打好基础。<br /><a name="tJzvq"></a></p><h1 id="基础知识铺垫"><a class="markdownIt-Anchor" href="#基础知识铺垫"></a> 基础知识铺垫</h1><p>在分析datasource包周期还需要有一些基础知识要铺垫一下。<br /><a name="ygYRa"></a></p><h2 id="javasql和javaxsql"><a class="markdownIt-Anchor" href="#javasql和javaxsql"></a> java.sql和javax.sql</h2><p>这两个包共同为Java提供了强大的JDBC能力。<br /><a name="HuBTY"></a></p><h3 id="javasql"><a class="markdownIt-Anchor" href="#javasql"></a> java.sql</h3><p>基于该包实现了SQL语句传递给数据库、从数据库以表格形式读写数据等功能。<br />java.sql提供了一个Driver接口作为数据库驱动的接口。不同的数据库厂商只需根据自身的数据库特点开发相应的Driver实现并通过DriverManager进行注册就可以使用了。<br />除此之外，java.sql还为数据库连接、SQL语句、结果集等提供了众多的类。通常完成一次数据库操作的流程如下所示：</p><ol><li>建立DriverManger对象</li><li>从DriverManger对象中获取Connection对象。</li><li>从Connection对象中获取Statement对象。</li><li>将SQL语句交给Statement对象执行，并返回结果，通常放到ResultSet中。<br /><a name="cDzN1"></a></li></ol><h3 id="javaxsql"><a class="markdownIt-Anchor" href="#javaxsql"></a> javax.sql</h3><p>该类包扩展了JDBC核心API的功能，提供了服务端的支持。<br />使用javax.sql扩展后建议使用DataSource来获取Connection对象，而不是直接获取DriverManger。<br /><a name="Rq2ur"></a></p><h2 id="drivermanger"><a class="markdownIt-Anchor" href="#drivermanger"></a> DriverManger</h2><p>它是JDBC驱动程序管理器，可以管理一组JDBC驱动程序。<br />当调用getConnection方法时，DriverManger会尝试在已加载的驱动程序中找出合适的一个，并用找出的驱动程序建立一个面向指定数据库的连接，最后将建立的连接返回。<br />其内部主要有如下几个方法：</p><ul><li>void registerDriver：向DriverManger中注册给定的驱动程序。</li><li>void deregisterDriver：从DriverManger中删除给定的驱动程序。</li><li>Driver getDriver：查找能匹配给定URL路径的驱动程序。</li><li>Enumeration getDrivers：获取当前调用者可以访问的所有已加载的JDBC驱动程序。</li><li>Connection getConnection：建立给定数据库的连接。<br /><a name="2x8wz"></a></li></ul><h2 id="datasource"><a class="markdownIt-Anchor" href="#datasource"></a> DataSource</h2><p>DataSource代表了一个实际的数据源，其功能是作为工厂提供数据源连接。<br />DataSource仅仅是一个接口，不同的数据库可以对其提供多种实现，常见实现有如下几种：</p><ul><li>基本实现：生成基本的到数据库的连接对象Connection。</li><li>连接池实现：生成的Connection对象能够自动加到连接池。</li><li>分布式事务实现：生成的Connection对象可以参与分布式事务。</li></ul><p>DataSource的具体实现中最终也是基于DriverManager获得的Connection，因此可以认为DataSource只是DriverManger的进一步封装。<br /><a name="huAiY"></a></p><h2 id="connection"><a class="markdownIt-Anchor" href="#connection"></a> Connection</h2><p>该类中的方法主要是用来完成Statement对象的获取、Connection属性的设置等功能。<br />同时，Connection中存在事务管理的方法。通过调用这些事务管理方法可以控制数据库完成相应的事务操作。<br /><a name="1OeJx"></a></p><h2 id="statement"><a class="markdownIt-Anchor" href="#statement"></a> Statement</h2><p>通常Statement对象会返回一个结果集对象ResultSet。其内部方法主要完成执行SQL语句、获取SQL语句执行结果等功能。<br /><a name="ckpCp"></a></p><h1 id="数据源工厂接口"><a class="markdownIt-Anchor" href="#数据源工厂接口"></a> 数据源工厂接口</h1><p>datasource包中DataSourceFactory作为工厂的接口，javax.sql包中DataSource作为所有工厂的接口。其类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602484058259-a51506a0-4247-4d20-89f4-ed8adbc01a0f.png#align=left&amp;display=inline&amp;height=308&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=615&amp;originWidth=1374&amp;size=1342308&amp;status=done&amp;style=none&amp;width=687" alt="image.png" /><br />既然是工厂方法模式就要有具体工厂实现，在XMLConfigBuilder的dataSourceElement方法中找到了生成具体工厂的过程，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DataSourceFactory <span class="title">dataSourceElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过Type判断数据源类型，例如ROOLED、UNPOOLED</span></span><br><span class="line">    String type = context.getStringAttribute(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取datasource下的property属性</span></span><br><span class="line">    Properties props = context.getChildrenAsProperties();</span><br><span class="line">    <span class="comment">// 根据type值找到对应的DataSourceFactory实现</span></span><br><span class="line">    DataSourceFactory factory = (DataSourceFactory) resolveClass(type).newInstance();</span><br><span class="line">    <span class="comment">// 设置相应的属性</span></span><br><span class="line">    factory.setProperties(props);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Environment declaration requires a DataSourceFactory.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="yM1Wq"></a></p><h1 id="jndi数据源工厂"><a class="markdownIt-Anchor" href="#jndi数据源工厂"></a> JNDI数据源工厂</h1><p>datasource的jndi子包提供了一个JNDI数据源工厂JndiDataSourceFactory，首先先要了解一下JNDI的概念。<br /><a name="0ZiRf"></a></p><h2 id="jndi数据源"><a class="markdownIt-Anchor" href="#jndi数据源"></a> JNDI数据源</h2><p>JNDI是Java命名和目录接口，它能够为Java应用程序提供命名和目录访问的接口，也可以将其理解为一种命名规范。在使用该规范为资源命名并将资源放入环境中后，可以通过命名从环境中查找对应的资源。<br />数据源作为一种资源就可以使用JNDI命名后放入到环境中，这就是JNDI数据源。之后只需要通过名称信息就可以查找出来。<br /><a name="1xHzT"></a></p><h2 id="工厂实现"><a class="markdownIt-Anchor" href="#工厂实现"></a> 工厂实现</h2><p>该数据源工厂的getDataSource方法只负责将成员变量中的DataSource对象返回，从环境中找到指定的DataSource操作是在setProperties中实现的，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 初始上下文环境</span></span><br><span class="line">    InitialContext initCtx;</span><br><span class="line">    <span class="comment">// 获取配置信息，根据配置信息初始化环境</span></span><br><span class="line">    Properties env = getEnvProperties(properties);</span><br><span class="line">    <span class="keyword">if</span> (env == <span class="keyword">null</span>) &#123;</span><br><span class="line">      initCtx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      initCtx = <span class="keyword">new</span> InitialContext(env);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// 从配置信息中获取数据源信息</span></span><br><span class="line">    <span class="keyword">if</span> (properties.containsKey(INITIAL_CONTEXT)</span><br><span class="line">        &amp;&amp; properties.containsKey(DATA_SOURCE)) &#123;</span><br><span class="line">      <span class="comment">// 定位到initial_context给出的起始环境</span></span><br><span class="line">      Context ctx = (Context) initCtx.lookup(properties.getProperty(INITIAL_CONTEXT));</span><br><span class="line">      <span class="comment">// 从起始环境找到指定的数据源</span></span><br><span class="line">      dataSource = (DataSource) ctx.lookup(properties.getProperty(DATA_SOURCE));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (properties.containsKey(DATA_SOURCE)) &#123;</span><br><span class="line">      <span class="comment">// 从整个环境中找到指定数据源</span></span><br><span class="line">      dataSource = (DataSource) initCtx.lookup(properties.getProperty(DATA_SOURCE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> DataSourceException(<span class="string">&quot;There was an error configuring JndiDataSourceTransactionPool. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，从本质上讲，JndiDataSourceFactory不是在生产数据源，而是负责查找数据源。<br /><a name="SLRty"></a></p><h1 id="非池化数据源及工厂"><a class="markdownIt-Anchor" href="#非池化数据源及工厂"></a> 非池化数据源及工厂</h1><p>datasource的unpooled子包提供了非池化的数据源工厂即非池化的数据源。<br /><a name="lyN2U"></a></p><h2 id="非池化数据源工厂"><a class="markdownIt-Anchor" href="#非池化数据源工厂"></a> 非池化数据源工厂</h2><p>该类直接在自身的构造方法中创建了数据源对象并保存在了自身的成员变量中。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSourceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.dataSource = <span class="keyword">new</span> UnpooledDataSource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该工厂的setProperties方法负责为工厂的数据源设置属性，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 驱动的属性</span></span><br><span class="line">  Properties driverProperties = <span class="keyword">new</span> Properties();</span><br><span class="line">  <span class="comment">// 生成一个包含DataSource的元对象</span></span><br><span class="line">  MetaObject metaDataSource = SystemMetaObject.forObject(dataSource);</span><br><span class="line">  <span class="comment">// 设置属性</span></span><br><span class="line">  <span class="keyword">for</span> (Object key : properties.keySet()) &#123;</span><br><span class="line">    String propertyName = (String) key;</span><br><span class="line">    <span class="comment">// 如果是以driver.开头的匹配信息</span></span><br><span class="line">    <span class="keyword">if</span> (propertyName.startsWith(DRIVER_PROPERTY_PREFIX)) &#123;</span><br><span class="line">      <span class="comment">// 记录配置信息</span></span><br><span class="line">      String value = properties.getProperty(propertyName);</span><br><span class="line">      driverProperties.setProperty(propertyName.substring(DRIVER_PROPERTY_PREFIX_LENGTH), value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (metaDataSource.hasSetter(propertyName)) &#123;</span><br><span class="line">      <span class="comment">// 通过反射为DataSource设置其他属性</span></span><br><span class="line">      String value = (String) properties.get(propertyName);</span><br><span class="line">      Object convertedValue = convertValue(metaDataSource, propertyName, value);</span><br><span class="line">      metaDataSource.setValue(propertyName, convertedValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> DataSourceException(<span class="string">&quot;Unknown DataSource property: &quot;</span> + propertyName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (driverProperties.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 将以driver.开头的配置信息放入到DataSource的driverProperies属性中</span></span><br><span class="line">    metaDataSource.setValue(<span class="string">&quot;driverProperties&quot;</span>, driverProperties);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="0oRO1"></a></p><h2 id="非池化数据源"><a class="markdownIt-Anchor" href="#非池化数据源"></a> 非池化数据源</h2><p>非池化数据源是最简单的数据源，其只需要在每次请求链接时打开连接，在每次连接结束时关闭连接即可。<br />其内部属性和配置信息一一对应，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 驱动加载器</span></span><br><span class="line"><span class="keyword">private</span> ClassLoader driverClassLoader;</span><br><span class="line"><span class="comment">// 启动配置信息</span></span><br><span class="line"><span class="keyword">private</span> Properties driverProperties;</span><br><span class="line"><span class="comment">// 已经注册的所有驱动</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Driver&gt; registeredDrivers = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 数据库驱动</span></span><br><span class="line"><span class="keyword">private</span> String driver;</span><br><span class="line"><span class="comment">// 数据源地址</span></span><br><span class="line"><span class="keyword">private</span> String url;</span><br><span class="line"><span class="comment">// 数据源用户名</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="comment">// 数据源密码</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="comment">// 是否自动提交</span></span><br><span class="line"><span class="keyword">private</span> Boolean autoCommit;</span><br><span class="line"><span class="comment">// 默认事务隔离级别</span></span><br><span class="line"><span class="keyword">private</span> Integer defaultTransactionIsolationLevel;</span><br><span class="line"><span class="comment">// 最长等待时间，发出请求后最长等待该时间后如果数据库还没有回应则认为失败</span></span><br><span class="line"><span class="keyword">private</span> Integer defaultNetworkTimeout;</span><br></pre></td></tr></table></figure><p>数据源的最重要的功能就是给出数据库连接对象Connection，该功能由doGetConnection提供，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Connection <span class="title">doGetConnection</span><span class="params">(Properties properties)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化驱动</span></span><br><span class="line">  initializeDriver();</span><br><span class="line">  <span class="comment">// 通过DriverManger获取连接</span></span><br><span class="line">  Connection connection = DriverManager.getConnection(url, properties);</span><br><span class="line">  <span class="comment">// 配置连接</span></span><br><span class="line">  configureConnection(connection);</span><br><span class="line">  <span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，Connection对象是由DriverManager提供的。此前，还调用了initializeDriver来初始化驱动，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initializeDriver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 如果所需的驱动尚未注册到registeredDrivers</span></span><br><span class="line">  <span class="keyword">if</span> (!registeredDrivers.containsKey(driver)) &#123;</span><br><span class="line">    Class&lt;?&gt; driverType;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 如果存在驱动类加载器</span></span><br><span class="line">      <span class="keyword">if</span> (driverClassLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 优先使用驱动类加载器加载驱动类</span></span><br><span class="line">        driverType = Class.forName(driver, <span class="keyword">true</span>, driverClassLoader);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用Resources中的加载器加载驱动</span></span><br><span class="line">        driverType = Resources.classForName(driver);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 实例化驱动</span></span><br><span class="line">      Driver driverInstance = (Driver)driverType.newInstance();</span><br><span class="line">      <span class="comment">// 向DriverManager中注册驱动代理</span></span><br><span class="line">      DriverManager.registerDriver(<span class="keyword">new</span> DriverProxy(driverInstance));</span><br><span class="line">      <span class="comment">// 注册到registeredDrivers表示驱动已经被加载</span></span><br><span class="line">      registeredDrivers.put(driver, driverInstance);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">&quot;Error setting driver on UnpooledDataSource. Cause: &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="A0cty"></a></p><h1 id="池化数据源"><a class="markdownIt-Anchor" href="#池化数据源"></a> 池化数据源</h1><p>在连接池中总保留一定数量的数据库连接以备使用，可以在需要的时候取出，不需要的时候放回，这样就减少了连接的创建和销毁工作，从而提高了整体的效率。<br />之前分析得出非池化的数据源UnpooledDataSource获取DataSource时，实际上就是在UnPooledDataSource中的DriverManger对象给出的。因此，这些连接Connection对象不属于任何一个连接池。<br />关于PooledDataSourceFactory，其内部仅仅重写了UnpooledDataSource构造方法而已，比较简单，这里就不做分析直接开始分析数据源了。<br /><a name="9n1Ig"></a></p><h2 id="池化数据源属性"><a class="markdownIt-Anchor" href="#池化数据源属性"></a> 池化数据源属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolState state = <span class="keyword">new</span> PoolState(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 持有一个UnpooledDataSource对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> UnpooledDataSource dataSource;</span><br><span class="line"><span class="comment">// 和连接池设置有关的配置项</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumActiveConnections = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumIdleConnections = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumCheckoutTime = <span class="number">20000</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolTimeToWait = <span class="number">20000</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumLocalBadConnectionTolerance = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">protected</span> String poolPingQuery = <span class="string">&quot;NO PING QUERY SET&quot;</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> poolPingEnabled;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolPingConnectionsNotUsedFor;</span><br><span class="line"><span class="comment">// 存储池子中的连接编码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> expectedConnectionTypeCode;</span><br></pre></td></tr></table></figure><p>以下将对其中重要的属性进行一一分析。<br /><a name="EmQ82"></a></p><h3 id="state"><a class="markdownIt-Anchor" href="#state"></a> State</h3><p>state是一个PoolState对象，其内部存储了所有数据库连接及状态信息。数据库连接池大小的设置需要根据业务场景判断。因此，对连接池的运行数据进行统计是很有必要的。<br />PooledDataSource没有直接使用列表而是使用PoolState对象来存储所有的数据库连接，就是为了统计连接池运行数据的需要。<br /><a name="vR0I5"></a></p><h4 id="poolstate"><a class="markdownIt-Anchor" href="#poolstate"></a> PoolState</h4><p>该类的属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 池化数据源</span></span><br><span class="line"><span class="keyword">protected</span> PooledDataSource dataSource;</span><br><span class="line"><span class="comment">// 空闲的连接</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> List&lt;PooledConnection&gt; idleConnections = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 活动的连接</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> List&lt;PooledConnection&gt; activeConnections = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 连接被取出的次数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> requestCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 取出请求花费时间的累计值。从准备取出请求到结束的时间为取出请求花费的时间</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> accumulatedRequestTime = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 累计被检出的时间</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> accumulatedCheckoutTime = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 声明过期的连接数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> claimedOverdueConnectionCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 过期的连接数的总检出时长</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> accumulatedCheckoutTimeOfOverdueConnections = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 总等待时长</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> accumulatedWaitTime = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 等待的轮次</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> hadToWaitCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 坏连接的数目</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> badConnectionCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><a name="wWnKG"></a></p><h3 id="datasource-2"><a class="markdownIt-Anchor" href="#datasource-2"></a> dataSource</h3><p>当池化的数据源在连接池中的连接不够时也需要创建新的连接，而属性dataSource是一个UnpooledDataSource对象，在需要创建新的连接时由该属性给出。<br /><a name="a2j9f"></a></p><h3 id="expectedconnectiontypecode"><a class="markdownIt-Anchor" href="#expectedconnectiontypecode"></a> expectedConnectionTypeCode</h3><p>一个数据源连接池必须确保池中的每个连接都是等价的，这样才能保证每次从连接池取出链接不会存在差异性。expectedConnectionTypeCode存储的就是该数据源的类型编码。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">assembleConnectionTypeCode</span><span class="params">(String url, String username, String password)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="string">&quot;&quot;</span> + url + username + password).hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该值在创建新的PooledDataSource时生成，然后会赋值给每一个从该对象的连接池取出的PooledConnection。当connection归还给连接池时会校验该值从而保证换回来的对象属于该池。<br /><a name="uLYoC"></a></p><h2 id="池化链接的给出与收回"><a class="markdownIt-Anchor" href="#池化链接的给出与收回"></a> 池化链接的给出与收回</h2><p><a name="pCnZI"></a></p><h3 id="给出池化连接"><a class="markdownIt-Anchor" href="#给出池化连接"></a> 给出池化连接</h3><p>该部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PooledConnection <span class="title">popConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span> countedWait = <span class="keyword">false</span>;</span><br><span class="line">   PooledConnection conn = <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">// 用于统计取出链接花费的时间点</span></span><br><span class="line">   <span class="keyword">long</span> t = System.currentTimeMillis();</span><br><span class="line">   <span class="keyword">int</span> localBadConnectionCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">// 给state加同步锁</span></span><br><span class="line">     <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">       <span class="comment">// 池中存在空闲连接</span></span><br><span class="line">       <span class="keyword">if</span> (!state.idleConnections.isEmpty()) &#123;</span><br><span class="line">         <span class="comment">// 左移操作，取出第一个连接</span></span><br><span class="line">         conn = state.idleConnections.remove(<span class="number">0</span>);</span><br><span class="line">         <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">           log.debug(<span class="string">&quot;Checked out connection &quot;</span> + conn.getRealHashCode() + <span class="string">&quot; from pool.&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">// 池中没有空余连接</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 池中还有空余位置</span></span><br><span class="line">         <span class="keyword">if</span> (state.activeConnections.size() &lt; poolMaximumActiveConnections) &#123;</span><br><span class="line">           <span class="comment">// 创建新连接</span></span><br><span class="line">           conn = <span class="keyword">new</span> PooledConnection(dataSource.getConnection(), <span class="keyword">this</span>);</span><br><span class="line">           <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">             log.debug(<span class="string">&quot;Created connection &quot;</span> + conn.getRealHashCode() + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="comment">// 连接池已满，不能创建新的连接</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 找到借出去最久的连接</span></span><br><span class="line">           PooledConnection oldestActiveConnection = state.activeConnections.get(<span class="number">0</span>);</span><br><span class="line">           <span class="comment">// 查看已经借出了多久</span></span><br><span class="line">           <span class="keyword">long</span> longestCheckoutTime = oldestActiveConnection.getCheckoutTime();</span><br><span class="line">           <span class="comment">// 如果已经超市</span></span><br><span class="line">           <span class="keyword">if</span> (longestCheckoutTime &gt; poolMaximumCheckoutTime) &#123;</span><br><span class="line">             <span class="comment">// 声明该链接超时未还</span></span><br><span class="line">             state.claimedOverdueConnectionCount++;</span><br><span class="line">             state.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;</span><br><span class="line">             state.accumulatedCheckoutTime += longestCheckoutTime;</span><br><span class="line">             <span class="comment">// 因超时而除名</span></span><br><span class="line">             state.activeConnections.remove(oldestActiveConnection);</span><br><span class="line">             <span class="comment">// 如果超时不还的连接没有设置自动提交事务</span></span><br><span class="line">             <span class="keyword">if</span> (!oldestActiveConnection.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">// 尝试替它回滚</span></span><br><span class="line">                 oldestActiveConnection.getRealConnection().rollback();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                 <span class="comment">// 如果回滚时报仅仅记录不抛出异常</span></span><br><span class="line">                 log.debug(<span class="string">&quot;Bad connection. Could not roll back&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 创建一个连接替代超时不还连接的位置</span></span><br><span class="line">             conn = <span class="keyword">new</span> PooledConnection(oldestActiveConnection.getRealConnection(), <span class="keyword">this</span>);</span><br><span class="line">             conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp());</span><br><span class="line">             conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp());</span><br><span class="line">             oldestActiveConnection.invalidate();</span><br><span class="line">             <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">               log.debug(<span class="string">&quot;Claimed overdue connection &quot;</span> + conn.getRealHashCode() + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">          <span class="comment">// 借出最久单位逾期</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 继续等待</span></span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (!countedWait) &#123;</span><br><span class="line">                 <span class="comment">// 记录发生等待的次数，某次请求等待多伦也算作只发生了一次等待</span></span><br><span class="line">                 state.hadToWaitCount++;</span><br><span class="line">                 countedWait = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                 log.debug(<span class="string">&quot;Waiting as long as &quot;</span> + poolTimeToWait + <span class="string">&quot; milliseconds for connection.&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">long</span> wt = System.currentTimeMillis();</span><br><span class="line">               <span class="comment">// 沉睡一段时间再试，防止一直占有计算资源</span></span><br><span class="line">               state.wait(poolTimeToWait);</span><br><span class="line">               state.accumulatedWaitTime += System.currentTimeMillis() - wt;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 取得了连接</span></span><br><span class="line">       <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 判断连接是否可用，如果可用</span></span><br><span class="line">         <span class="keyword">if</span> (conn.isValid()) &#123;</span><br><span class="line">           <span class="comment">// 该链接没有设置自动回滚</span></span><br><span class="line">           <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">             <span class="comment">// 回滚未提交操作</span></span><br><span class="line">             conn.getRealConnection().rollback();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 每个借出去的连接都打上数据源的连接类型编码，以便在归还时确保正确</span></span><br><span class="line">           conn.setConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password));</span><br><span class="line">           <span class="comment">// 数据记录操作  </span></span><br><span class="line">           conn.setCheckoutTimestamp(System.currentTimeMillis());</span><br><span class="line">           conn.setLastUsedTimestamp(System.currentTimeMillis());</span><br><span class="line">           state.activeConnections.add(conn);</span><br><span class="line">           state.requestCount++;</span><br><span class="line">           state.accumulatedRequestTime += System.currentTimeMillis() - t;</span><br><span class="line">           <span class="comment">// 连接不可用</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">             log.debug(<span class="string">&quot;A bad connection (&quot;</span> + conn.getRealHashCode() + <span class="string">&quot;) was returned from the pool, getting another connection.&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           state.badConnectionCount++;</span><br><span class="line">           localBadConnectionCount++;</span><br><span class="line">           <span class="comment">// 直接删除</span></span><br><span class="line">           conn = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">// 如果没有一个连接可用，说明连不上数据库</span></span><br><span class="line">           <span class="keyword">if</span> (localBadConnectionCount &gt; (poolMaximumIdleConnections + poolMaximumLocalBadConnectionTolerance)) &#123;</span><br><span class="line">             <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">               log.debug(<span class="string">&quot;PooledDataSource: Could not get a good connection to the database.&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">&quot;PooledDataSource: Could not get a good connection to the database.&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果到这里还没找到连接，则会循环此操作，继续尝试取出连接</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">       log.debug(<span class="string">&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> conn;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><a name="cfJ6I"></a></p><h3 id="取出池化连接"><a class="markdownIt-Anchor" href="#取出池化连接"></a> 取出池化连接</h3><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pushConnection</span><span class="params">(PooledConnection conn)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">    <span class="comment">// 将该链接从活跃连接中删除</span></span><br><span class="line">    state.activeConnections.remove(conn);</span><br><span class="line">    <span class="comment">// 当前连接可用</span></span><br><span class="line">    <span class="keyword">if</span> (conn.isValid()) &#123;</span><br><span class="line">      <span class="comment">// 判断连接池未满且该链接确实属于该连接池  </span></span><br><span class="line">      <span class="keyword">if</span> (state.idleConnections.size() &lt; poolMaximumIdleConnections &amp;&amp; conn.getConnectionTypeCode() == expectedConnectionTypeCode) &#123;</span><br><span class="line">        state.accumulatedCheckoutTime += conn.getCheckoutTime();</span><br><span class="line">        <span class="comment">// 如果链接没有设置自动提交</span></span><br><span class="line">        <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">          <span class="comment">// 将未完成的操作回滚  </span></span><br><span class="line">          conn.getRealConnection().rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新整理连接</span></span><br><span class="line">        PooledConnection newConn = <span class="keyword">new</span> PooledConnection(conn.getRealConnection(), <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 将连接放入空闲池</span></span><br><span class="line">        state.idleConnections.add(newConn);</span><br><span class="line">        newConn.setCreatedTimestamp(conn.getCreatedTimestamp());</span><br><span class="line">        newConn.setLastUsedTimestamp(conn.getLastUsedTimestamp());</span><br><span class="line">        <span class="comment">// 连接未校验，以便取出时重新校验</span></span><br><span class="line">        conn.invalidate();</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">          log.debug(<span class="string">&quot;Returned connection &quot;</span> + newConn.getRealHashCode() + <span class="string">&quot; to pool.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        state.notifyAll();</span><br><span class="line">      <span class="comment">// 连接池已满或者该链接不属于该连接池</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        state.accumulatedCheckoutTime += conn.getCheckoutTime();</span><br><span class="line">        <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">          conn.getRealConnection().rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接关闭连接，而不是将其放入到连接池中</span></span><br><span class="line">        conn.getRealConnection().close();</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">          log.debug(<span class="string">&quot;Closed connection &quot;</span> + conn.getRealHashCode() + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        conn.invalidate();</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 当前连接不可用</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;A bad connection (&quot;</span> + conn.getRealHashCode() + <span class="string">&quot;) attempted to return to the pool, discarding connection.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      state.badConnectionCount++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="FKd7T"></a></p><h3 id="池化数据源中链接的等价性"><a class="markdownIt-Anchor" href="#池化数据源中链接的等价性"></a> 池化数据源中链接的等价性</h3><p>一个数据源的连接池必须保证池中的每个链接都是等价的，PooledDataSource通过存储在expectedConnectionTypeCode中的数据源连接类型编码保证这一点。PooledDataSource在每次给出链接时会给链接写入编码，在收回连接时会校验编码。这就避免了非本池连接放入该池。   <br />如果在使用连接时更改了dirver、url等属性也不会造成非本池连接放入该池的结果。因为修改这些属性的时候必定会调用其setter方法，以setDriver为例，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDriver</span><span class="params">(String driver)</span> </span>&#123;</span><br><span class="line">  dataSource.setDriver(driver);</span><br><span class="line">  forceCloseAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在set以后都调用了forceCloseAll方法来将所有的活动和空闲连接全部关闭，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forceCloseAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 增加同步锁</span></span><br><span class="line">  <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">    <span class="comment">// 重新计算和更新连接类型代码</span></span><br><span class="line">    expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword());</span><br><span class="line">    <span class="comment">// 依次循环所有的活动链接</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = state.activeConnections.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        PooledConnection conn = state.activeConnections.remove(i - <span class="number">1</span>);</span><br><span class="line">        conn.invalidate();</span><br><span class="line"></span><br><span class="line">        Connection realConn = conn.getRealConnection();</span><br><span class="line">        <span class="keyword">if</span> (!realConn.getAutoCommit()) &#123;</span><br><span class="line">          realConn.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        realConn.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依次关闭所有的空闲连接  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = state.idleConnections.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        PooledConnection conn = state.idleConnections.remove(i - <span class="number">1</span>);</span><br><span class="line">        conn.invalidate();</span><br><span class="line"></span><br><span class="line">        Connection realConn = conn.getRealConnection();</span><br><span class="line">        <span class="keyword">if</span> (!realConn.getAutoCommit()) &#123;</span><br><span class="line">          realConn.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        realConn.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;PooledDataSource forcefully closed/removed all connections.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种机制保证了池化数据源的链接始终等价的。<br /><a name="XJgus"></a></p><h2 id="池化连接"><a class="markdownIt-Anchor" href="#池化连接"></a> 池化连接</h2><p>关闭一个池化连接时，不应该真正的关闭掉，而是应该将自己放回连接池。正因为如此，PooledDataSource获得的数据库连接不能是普通的Connection类而是PooledConnection类。这类事普通Connection类的代理类。其最终的一个重要工作就是修改Connection的close方法行为。<br />PooledConnection类继承了InvocationHandler接口实现了动态代理类，其invoke源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// 获取方法名</span></span><br><span class="line">  String methodName = method.getName();</span><br><span class="line">  <span class="keyword">if</span> (CLOSE.hashCode() == methodName.hashCode() &amp;&amp; CLOSE.equals(methodName)) &#123;</span><br><span class="line">    <span class="comment">// 把Connection返回给连接池</span></span><br><span class="line">    dataSource.pushConnection(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 检查连接是否可用</span></span><br><span class="line">    <span class="keyword">if</span> (!Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="comment">// issue #579 toString() should never fail</span></span><br><span class="line">      <span class="comment">// throw an SQLException instead of a Runtime</span></span><br><span class="line">      checkConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用真正的连接去执行</span></span><br><span class="line">    <span class="keyword">return</span> method.invoke(realConnection, args);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;datasource包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#datasource包&quot;&gt;&lt;/a&gt; datasource包&lt;/h1&gt;
&lt;p&gt;通过dataSource包Mybatis将完成数据源的获取、数据连接的建立等工作为操作语句</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="配置解析包" scheme="https://jie-blog.icu/categories/mybatis/%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8C%85/"/>
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>scripting包</title>
    <link href="https://jie-blog.icu/posts/mybatis-scripting/"/>
    <id>https://jie-blog.icu/posts/mybatis-scripting/</id>
    <published>2020-11-04T04:04:21.000Z</published>
    <updated>2020-11-04T04:15:28.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="scripting包"><a class="markdownIt-Anchor" href="#scripting包"></a> scripting包</h1><p>mapper中的SQL语句支持使用非常灵活的SQL语句组建方式，比如可以在组建语句时使用foreach、where、if等标签。但是，无论使用哪种方式，最终还是会被解析成为最基本的SQL语句才能被数据库接受，这个解析过程主要由scripting包完成。<br /><a name="Wf20I"></a></p><h1 id="语言驱动接口及语言驱动注册表"><a class="markdownIt-Anchor" href="#语言驱动接口及语言驱动注册表"></a> 语言驱动接口及语言驱动注册表</h1><p><a name="MjFF3"></a></p><h2 id="languagedriver"><a class="markdownIt-Anchor" href="#languagedriver"></a> LanguageDriver</h2><p>LanguageDriver为语言驱动类的接口。该接口内部一共定义了三个方法，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LanguageDriver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建参数处理器，参数处理器能够将实参传给JDBC statement</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> mappedStatement 完整的数据库操作节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> parameterObject 参数对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> boundSql 数据库操作语句转化的BoundSql对象.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 参数处理器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">ParameterHandler <span class="title">createParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建SqlSource对象（基于映射文件方式）。该方法在Mybatis启动阶段读取映射接口或映射文件时被调用</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> configuration 配置信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> script 映射文件中的数据库操作节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> parameterType 参数类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> SqlSource 对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, XNode script, Class&lt;?&gt; parameterType)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建SqlSource对象（基于注解的方式）。该方式在Mybatis启动阶段读取映射接口或映射文件时被调用</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> configuration 配置信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> script 注解中的SQL字符串</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> parameterType 参数类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> SqlSource 对象 准确地说是DynamicSqlSource和RowSqlSource中的一中</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, String script, Class&lt;?&gt; parameterType)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LanguageDriver接口默认有两个实现，分别是RawLanguageDriver和XMLLanguageDriver，其中RawLanguageDriver是XMLLanguageDriver的子类。<br />RawLanguageDriver的所有方法其实都是XMLLanguageDriver完成的。并且在XMLLanguageDriver类完成操作后通过checkIsNotDynamic方法校验SqlSource必须为RowSqlSource类型。因此说RawLanguageDriver实际上是通过checkIsNotDynamic方法对XMLLanguageDriver类的裁剪，使得自身仅仅支持RowSqlSource类型的SqlSource。这种自身功能是父类功能子集的模型是一种先繁再简的方法。<br />此外，Mybatis还允许用户自己给出LanguageDriver的实现类，通过配置文件中的defaultScriptingLanguage实行将其指定为默认的脚本驱动。<br /><a name="ILV7A"></a></p><h2 id="languagedriverregistry"><a class="markdownIt-Anchor" href="#languagedriverregistry"></a> LanguageDriverRegistry</h2><p>LanguageDriverRegistry作为语言驱动的注册表管理所有的语言驱动，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有的语言驱动类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;? extends LanguageDriver&gt;, LanguageDriver&gt; LANGUAGE_DRIVER_MAP = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 默认的语言驱动类</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;? extends LanguageDriver&gt; defaultDriverClass;</span><br></pre></td></tr></table></figure><p>该类内部主要包括注册驱动、选取驱动。<br /><a name="dVsCk"></a></p><h1 id="sql节点树组建"><a class="markdownIt-Anchor" href="#sql节点树组建"></a> SQL节点树组建</h1><p>众多SQL节点组成的就是一棵树，首先要做的就是将XML中的信息读取出来，然后在内存中将XML树组建为一个SQL节点树。SQL节点树的组建就是由XMLScriptBuilder类负责的。<br />该类内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前要处理的XML节点  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> XNode context;</span><br><span class="line"><span class="comment">// 当前节点是否为动态节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isDynamic;</span><br><span class="line"><span class="comment">// 输入参数的类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; parameterType;</span><br><span class="line"><span class="comment">// 节点类型和对应的处理器组成的Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, NodeHandler&gt; nodeHandlerMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>在该类的内部定义了一个内部接口NodeHandler，该接口主要负责将节点拼装到节点数中。其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">NodeHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 该方法将当前节点拼装到节点数中</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleNode</span><span class="params">(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个SQL节点都对应了一个NodeHandler实现类，NodeHandler接口与其实现类的类图如下图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602289550226-bbe5ed50-bdda-4587-8460-16be900103dd.png#align=left&amp;display=inline&amp;height=244&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=488&amp;originWidth=1123&amp;size=925441&amp;status=done&amp;style=none&amp;width=561.5" alt="image.png" /><br />SQL节点与NodeHandler的对应关系由nodeHandlerMap所存储。<br />以IfHandler为例来分析XML信息如何组建成SQL节点树，IfHandler源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">IfHandler</span> <span class="keyword">implements</span> <span class="title">NodeHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">IfHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Prevent Synthetic Access</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNode</span><span class="params">(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解析该节点的下级节点</span></span><br><span class="line">    MixedSqlNode mixedSqlNode = parseDynamicTags(nodeToHandle);</span><br><span class="line">    <span class="comment">// 获取该节点的test节点</span></span><br><span class="line">    String test = nodeToHandle.getStringAttribute(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建一个IfSqlNode</span></span><br><span class="line">    IfSqlNode ifSqlNode = <span class="keyword">new</span> IfSqlNode(mixedSqlNode, test);</span><br><span class="line">    <span class="comment">// 将创建的IfSqlNode存放到SQL树中</span></span><br><span class="line">    targetContents.add(ifSqlNode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，组件SQL节点树的过程是一个深度优先遍历的过程。在下级节点处理完毕后，提取了XML中的信息组建成IfSqlNode对象，然后将IfSqlNode对象放入到了SQL节点数中。<br />从根节点组建方法的入口方法是parseScriptNode，目的是为了解析节点生成SqlSource对象，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parseScriptNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 解析节点得到MixedSqlNode</span></span><br><span class="line">  MixedSqlNode rootSqlNode = parseDynamicTags(context);</span><br><span class="line">  SqlSource sqlSource;</span><br><span class="line">  <span class="comment">// 根据是否有动态，创建对应的SqlSource</span></span><br><span class="line">  <span class="keyword">if</span> (isDynamic) &#123;</span><br><span class="line">    sqlSource = <span class="keyword">new</span> DynamicSqlSource(configuration, rootSqlNode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sqlSource = <span class="keyword">new</span> RawSqlSource(configuration, rootSqlNode, parameterType);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sqlSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其主要操作在parseDynamicTags完成，即把对象解析为节点树，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> MixedSqlNode <span class="title">parseDynamicTags</span><span class="params">(XNode node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// XNode拆分出的SqlNode列表</span></span><br><span class="line">  List&lt;SqlNode&gt; contents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 输入XNode的子XNode</span></span><br><span class="line">  NodeList children = node.getNode().getChildNodes();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">    <span class="comment">// 循环遍历每一个XNode</span></span><br><span class="line">    XNode child = node.newXNode(children.item(i));</span><br><span class="line">    <span class="comment">// CDTATASection类型或者是Test类型的XNode节点</span></span><br><span class="line">    <span class="keyword">if</span> (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) &#123;</span><br><span class="line">      <span class="comment">// 获取XNode的信息</span></span><br><span class="line">      String data = child.getStringBody(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      TextSqlNode textSqlNode = <span class="keyword">new</span> TextSqlNode(data);</span><br><span class="line">      <span class="comment">// 只要有一个TestSqlNode对象是动态的，那么整个MixedSqlNode就是动态的</span></span><br><span class="line">      <span class="keyword">if</span> (textSqlNode.isDynamic()) &#123;</span><br><span class="line">        contents.add(textSqlNode);</span><br><span class="line">        isDynamic = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        contents.add(<span class="keyword">new</span> StaticTextSqlNode(data));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 子XNode也是Node类型</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getNode().getNodeType() == Node.ELEMENT_NODE) &#123; <span class="comment">// issue #628</span></span><br><span class="line">      String nodeName = child.getNode().getNodeName();</span><br><span class="line">      <span class="comment">// 找到对应的处理器</span></span><br><span class="line">      NodeHandler handler = nodeHandlerMap.get(nodeName);</span><br><span class="line">      <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Unknown element &lt;&quot;</span> + nodeName + <span class="string">&quot;&gt; in SQL statement.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 用处理器节点处理</span></span><br><span class="line">      handler.handleNode(child, contents);</span><br><span class="line">      isDynamic = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个混合节点，其实就是一个SQL节点树</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MixedSqlNode(contents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parseDynamicTags会逐步分析XML文件中的节点并使用对应的NodeHandler实现来处理该节点，最终将所有的节点整合到一个MixedSqlNode对象中。MixedSqlNode对象就是SQL节点树。<br />在整合节点树的过程中，只要存在一个动态节点，那么该SQL树就会被认作动态的，动态的SQL节点树将用来创建DynamicSqlSource对象，否则就创建RawSqlSource。<br /><a name="mQHfY"></a></p><h1 id="sql节点树的解析"><a class="markdownIt-Anchor" href="#sql节点树的解析"></a> SQL节点树的解析</h1><p>对创建好的SQL节点数的解析主要是在scripting包的xmltags子包中进行展开。<br /><a name="uMgGN"></a></p><h2 id="ognl"><a class="markdownIt-Anchor" href="#ognl"></a> OGNL</h2><p>在分析源码之前，首先要了解一下OGNL。<br />OGNL（对象导航语言）是一种强大的表达式语言（EL）。通过它能够完成从集合中选取对象、读写对象的属性、调用对象和类的方法、表达式求值与判断等工作。<br />OGNL有Java工具包，只要引用它就可以在Java中使用OGNL的功能，OGNL主要有三个概念：</p><ul><li>表达式（expression）：是一个带有语法含义的字符串，是整个OGNL的核心内容，通过表达式来确定需要进行的OGNL操作。</li><li>根对象（root）：可以理解为OGNL的被操作对象。表达式中表示的操作就是针对根对象展开的。</li><li>上下文（context）：整个OGNL处理的上下文环境，该环境是Map对象。在进行OGNL处理之前，可以传入一个初始化过得上下文环境。<br /><a name="MFVMQ"></a></li></ul><h2 id="xmltags中的ognl"><a class="markdownIt-Anchor" href="#xmltags中的ognl"></a> xmltags中的OGNL</h2><p>为了更好地完成OGNL的解析工作，xmltags中还设置了三个相关的类，分别是：OgnlCache、OgnlClassResolver、OgnlMemberAccess。<br /><a name="JayZh"></a></p><h3 id="ognlclassresolver"><a class="markdownIt-Anchor" href="#ognlclassresolver"></a> OgnlClassResolver</h3><p>该类是OGNL定义的一个类，OGNL可以通过该类进行类的读取，即将类名转化为一个类。<br />OgnlClassResolver继承自DefaultClassResolver，并覆盖了其toClassForName方法，这样就可以通过Resources来读取类了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OgnlClassResolver</span> <span class="keyword">extends</span> <span class="title">DefaultClassResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Class <span class="title">toClassForName</span><span class="params">(String className)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Resources.classForName(className);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="UQ8Qq"></a></p><h3 id="ognlmemberaccess"><a class="markdownIt-Anchor" href="#ognlmemberaccess"></a> OgnlMemberAccess</h3><p>MemberAccess是OGNL提供的一个钩子接口，OGNL借助这个接口为访问对象的属性做好准备。<br />OgnlMemberAccess实现了MemberAccess接口，并基于反射修改了对象的访问性功能，这样OGNL便可以基于这些功能为访问对象的属性做好准备。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OgnlMemberAccess</span> <span class="keyword">implements</span> <span class="title">MemberAccess</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当前环境下，通过反射是否能够修改对象属性的可访问性</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> canControlMemberAccessible;</span><br><span class="line"></span><br><span class="line">  OgnlMemberAccess() &#123;</span><br><span class="line">    <span class="keyword">this</span>.canControlMemberAccessible = Reflector.canControlMemberAccessible();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置属性的可访问性</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">setup</span><span class="params">(Map context, Object target, Member member, String propertyName)</span> </span>&#123;</span><br><span class="line">    Object result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果允许修改属性的可访问性</span></span><br><span class="line">    <span class="keyword">if</span> (isAccessible(context, target, member, propertyName)) &#123;</span><br><span class="line">      AccessibleObject accessible = (AccessibleObject) member;</span><br><span class="line">      <span class="comment">// 如果属性原本不可访问</span></span><br><span class="line">      <span class="keyword">if</span> (!accessible.isAccessible()) &#123;</span><br><span class="line">        result = Boolean.FALSE;</span><br><span class="line">        <span class="comment">// 将属性修改为可访问</span></span><br><span class="line">        accessible.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将属性的可访问性恢复到指定状态</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restore</span><span class="params">(Map context, Object target, Member member, String propertyName,</span></span></span><br><span class="line"><span class="function"><span class="params">      Object state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ((AccessibleObject) member).setAccessible((Boolean) state);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断对象属性是否可访问</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccessible</span><span class="params">(Map context, Object target, Member member, String propertyName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> canControlMemberAccessible;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="Cwk3y"></a></p><h3 id="ognlcache"><a class="markdownIt-Anchor" href="#ognlcache"></a> OgnlCache</h3><p>为了提升OGNL的运行效率，Mybatis还提供了该缓存类，其内部源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OgnlCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> OgnlMemberAccess MEMBER_ACCESS = <span class="keyword">new</span> OgnlMemberAccess();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> OgnlClassResolver CLASS_RESOLVER = <span class="keyword">new</span> OgnlClassResolver();</span><br><span class="line">  <span class="comment">// 缓存解析后的OGNL表达式，提高效率</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; expressionCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">OgnlCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Prevent Instantiation of Static Class</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 读取表达式结果</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getValue</span><span class="params">(String expression, Object root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建默认的上下文</span></span><br><span class="line">      Map context = Ognl.createDefaultContext(root, MEMBER_ACCESS, CLASS_RESOLVER, <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">// 依次传入表达式树、上下文、根，从而获得表达式的结果</span></span><br><span class="line">      <span class="keyword">return</span> Ognl.getValue(parseExpression(expression), context, root);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OgnlException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error evaluating expression &#x27;&quot;</span> + expression + <span class="string">&quot;&#x27;. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 解析表达式，得到解析后的表达式树</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">parseExpression</span><span class="params">(String expression)</span> <span class="keyword">throws</span> OgnlException </span>&#123;</span><br><span class="line">    <span class="comment">// 先从缓存中获取</span></span><br><span class="line">    Object node = expressionCache.get(expression);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 直接解析，放入缓存</span></span><br><span class="line">      node = Ognl.parseExpression(expression);</span><br><span class="line">      expressionCache.put(expression, node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="bLd3f"></a></p><h2 id="表达式求值"><a class="markdownIt-Anchor" href="#表达式求值"></a> 表达式求值</h2><p>Mybatis没有将OGNL暴露给各个SQL节点使用，而是进一步的易用封装，得到了ExpressionEvaluator类，即表达式求值器，该类内部一共有两个方法，一个是evaluateBoolean一个是evaluateIterable。<br /><a name="B2R01"></a></p><h3 id="evaluateboolean"><a class="markdownIt-Anchor" href="#evaluateboolean"></a> evaluateBoolean</h3><p>该方法能够根据结果为判断语句求值（<if test="name!=xx">），其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">evaluateBoolean</span><span class="params">(String expression, Object parameterObject)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取表达式</span></span><br><span class="line">  Object value = OgnlCache.getValue(expression, parameterObject);</span><br><span class="line">  <span class="comment">// 如果是Boolean类型</span></span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">    <span class="keyword">return</span> (Boolean) value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是数字形式</span></span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Number) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(String.valueOf(value)).compareTo(BigDecimal.ZERO) != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="pMRpz"></a></p><h3 id="evaluateiterable"><a class="markdownIt-Anchor" href="#evaluateiterable"></a> evaluateIterable</h3><p>该方法能够为迭代形式的表达式求值，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterable&lt;?&gt; evaluateIterable(String expression, Object parameterObject) &#123;</span><br><span class="line">  <span class="comment">// 获取表达式结果</span></span><br><span class="line">  Object value = OgnlCache.getValue(expression, parameterObject);</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;The expression &#x27;&quot;</span> + expression + <span class="string">&quot;&#x27; evaluated to a null value.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 结果是Iterable类型</span></span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Iterable) &#123;</span><br><span class="line">    <span class="keyword">return</span> (Iterable&lt;?&gt;) value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 结果是Array</span></span><br><span class="line">  <span class="keyword">if</span> (value.getClass().isArray()) &#123;</span><br><span class="line">    <span class="comment">// 如果Array是原始的调用asList会抛出异常，因此要手动转为ArrayList</span></span><br><span class="line">    <span class="keyword">int</span> size = Array.getLength(value);</span><br><span class="line">    List&lt;Object&gt; answer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      Object o = Array.get(value, i);</span><br><span class="line">      answer.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果结果为Map</span></span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">    <span class="keyword">return</span> ((Map) value).entrySet();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error evaluating expression &#x27;&quot;</span> + expression + <span class="string">&quot;&#x27;.  Return value (&quot;</span> + value + <span class="string">&quot;) was not iterable.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="WM3QQ"></a></p><h2 id="动态上下文"><a class="markdownIt-Anchor" href="#动态上下文"></a> 动态上下文</h2><p>在SQL节点树解析时，需要不断保存已完成的SQL片段。在进行SQL节点树的解析时也需要一些参数和环境信息为解析的依据。以上两个功能都由DynamicContext提供。其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上下文环境</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ContextMap bindings;</span><br><span class="line"><span class="comment">// 用于拼装SQL语句片段的SpringJoiner</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StringJoiner sqlBuilder = <span class="keyword">new</span> StringJoiner(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">// 解析时的唯一编号，防止解析混乱</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> uniqueNumber = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>ContextMap是DynamicContext的内部类，是HashMap的子类。在进行数据查询的时候会先从ContextMap中查询，如果查询失败会从参数对象属性中查询，因此在编写SQL语句时可以直接引用参数对象的的属性。<br />DynamicContext类的构造方法中有上下文环境初始化的主要逻辑，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DynamicContext</span><span class="params">(Configuration configuration, Object parameterObject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parameterObject != <span class="keyword">null</span> &amp;&amp; !(parameterObject <span class="keyword">instanceof</span> Map)) &#123;</span><br><span class="line">    <span class="comment">// 获得参数对象的元对象</span></span><br><span class="line">    MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">    <span class="comment">// 判断参数对象本身是否有对应的类型处理器</span></span><br><span class="line">    <span class="keyword">boolean</span> existsTypeHandler = configuration.getTypeHandlerRegistry().hasTypeHandler(parameterObject.getClass());</span><br><span class="line">    <span class="comment">// 放入上下文信息</span></span><br><span class="line">    bindings = <span class="keyword">new</span> ContextMap(metaObject, existsTypeHandler);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 上下文信息为空</span></span><br><span class="line">    bindings = <span class="keyword">new</span> ContextMap(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把参数对象放入上下文信息</span></span><br><span class="line">  bindings.put(PARAMETER_OBJECT_KEY, parameterObject);</span><br><span class="line">  <span class="comment">// 把数据库id放入上下文信息</span></span><br><span class="line">  bindings.put(DATABASE_ID_KEY, configuration.getDatabaseId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，bingdings属性中存储了以下信息：</p><ul><li>数据库id。因此在编写SQL语句时可以直接使用DATABASE_ID_KEY变量引用数据库id的值。</li><li>参数对象。在编写SQL语句时可以直接使用PARAMETER_OBJECT_KEY变量来引用整个参数对象。</li><li>参数对象的元数据。基于参数对象元数据可以方便的引用参数对象的属性值，因此，编写SQL语句时可以直接引用参数对象的属性。<br /><a name="BLXZm"></a></li></ul><h2 id="sql节点及其解析"><a class="markdownIt-Anchor" href="#sql节点及其解析"></a> SQL节点及其解析</h2><p>Mybatis会将动态节点解析后才交给数据库执行，这些节点在Mybatis中都会被认为SqlNode。<br />SqlNode是一个接口，其内部只定义了一个apply方法，该方法负责完成节点自身的解析，并将解析结果合并到输入参数提供的上下文环境中。该接口的类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602295821126-63be2991-78e6-46c0-8e34-f5d10fb7cd42.png#align=left&amp;display=inline&amp;height=304&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=608&amp;originWidth=1115&amp;size=743466&amp;status=done&amp;style=none&amp;width=557.5" alt="image.png" /><br />接下来以典型的IfSqlSource、ForEachSqlSource、TextSqlNode为例对SqlNode接口的实现类进行介绍。<br /><a name="rvTby"></a></p><h3 id="ifsqlsource"><a class="markdownIt-Anchor" href="#ifsqlsource"></a> IfSqlSource</h3><p>该类的目标是if标签，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表达式求值器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExpressionEvaluator evaluator;</span><br><span class="line"><span class="comment">// if判断时的测试条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String test;</span><br><span class="line"><span class="comment">// 如果if成立，要被拼接的SQL片段信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlNode contents;</span><br></pre></td></tr></table></figure><p>apply方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断if条件是否成立</span></span><br><span class="line">  <span class="keyword">if</span> (evaluator.evaluateBoolean(test, context.getBindings())) &#123;</span><br><span class="line">    <span class="comment">// contents拼接到context</span></span><br><span class="line">    contents.apply(context);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="95RzH"></a></p><h3 id="foreachsqlnode"><a class="markdownIt-Anchor" href="#foreachsqlnode"></a> ForEachSqlNode</h3><p>ForEachSqlNode节点对应了foreach标签，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表达式求值器 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExpressionEvaluator evaluator;</span><br><span class="line"><span class="comment">// conllection属性的值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String collectionExpression;</span><br><span class="line"><span class="comment">// 节点内的内容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlNode contents;</span><br><span class="line"><span class="comment">// 左侧插入的字符串</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String open;</span><br><span class="line"><span class="comment">// 右侧插入的字符串</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String close;</span><br><span class="line"><span class="comment">// 元素分隔符</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String separator;</span><br><span class="line"><span class="comment">// 元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String item;</span><br><span class="line"><span class="comment">// 元素编号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String index;</span><br><span class="line"><span class="comment">// 配置信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br></pre></td></tr></table></figure><p>apply实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取上下文信息</span></span><br><span class="line">  Map&lt;String, Object&gt; bindings = context.getBindings();</span><br><span class="line">  <span class="comment">// 交给表达式求值器解析表达式从而获取迭代器</span></span><br><span class="line">  <span class="keyword">final</span> Iterable&lt;?&gt; iterable = evaluator.evaluateIterable(collectionExpression, bindings);</span><br><span class="line">  <span class="comment">// 没有可迭代的元素</span></span><br><span class="line">  <span class="keyword">if</span> (!iterable.iterator().hasNext()) &#123;</span><br><span class="line">    <span class="comment">// 不需要拼接信息直接返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">boolean</span> first = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">// 添加open字符串</span></span><br><span class="line">  applyOpen(context);</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (Object o : iterable) &#123;</span><br><span class="line">    DynamicContext oldContext = context;</span><br><span class="line">    <span class="comment">// 第一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (first || separator == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 添加元素</span></span><br><span class="line">      context = <span class="keyword">new</span> PrefixedContext(context, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 添加间隔符</span></span><br><span class="line">      context = <span class="keyword">new</span> PrefixedContext(context, separator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> uniqueNumber = context.getUniqueNumber();</span><br><span class="line">    <span class="comment">// Issue #709</span></span><br><span class="line">    <span class="comment">// 迭代的对象是map</span></span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      <span class="comment">// 迭代对象放入上下文环境</span></span><br><span class="line">      Map.Entry&lt;Object, Object&gt; mapEntry = (Map.Entry&lt;Object, Object&gt;) o;</span><br><span class="line">      applyIndex(context, mapEntry.getKey(), uniqueNumber);</span><br><span class="line">      applyItem(context, mapEntry.getValue(), uniqueNumber);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 将被迭代对象放入上下文环境</span></span><br><span class="line">      applyIndex(context, i, uniqueNumber);</span><br><span class="line">      applyItem(context, o, uniqueNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据上下文环境等信息构建内容</span></span><br><span class="line">    contents.apply(<span class="keyword">new</span> FilteredDynamicContext(configuration, context, index, item, uniqueNumber));</span><br><span class="line">    <span class="keyword">if</span> (first) &#123;</span><br><span class="line">      first = !((PrefixedContext) context).isPrefixApplied();</span><br><span class="line">    &#125;</span><br><span class="line">    context = oldContext;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加close字符串</span></span><br><span class="line">  applyClose(context);</span><br><span class="line">  <span class="comment">// 清理此次操作对环境的影响</span></span><br><span class="line">  context.getBindings().remove(item);</span><br><span class="line">  context.getBindings().remove(index);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，其主要流程是解析被迭代元素获得的迭代对象，然后迭代对象的信息添加到上下文中，根据上下文信息拼接字符串。字符串拼接完成后，对此次操作产生的临时变量清除。<br /><a name="vJJl8"></a></p><h3 id="textsqlnode"><a class="markdownIt-Anchor" href="#textsqlnode"></a> TextSqlNode</h3><p>该标签对应了SQL语句的字符串节点。字符串节点应用广泛，TextSqlNode能替换掉其中的“<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 142: …c0a46e47b54.png#̲align=left&amp;disp…'>{}”占位符。&lt;br /&gt;该类内部类图如下：&lt;br /&gt;![image.png](https://cdn.nlark.com/yuque/0/2020/png/485026/1602297072525-c1dd57e6-87ab-4b64-ada5-6c0a46e47b54.png#align=left&amp;display=inline&amp;height=246&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=492&amp;originWidth=1092&amp;size=771788&amp;status=done&amp;style=none&amp;width=546)&lt;br /&gt;TokenHandler接口会和通用占位符解析器GenericTokenParser配合使用，GenericTokenParser解析到匹配的占位符时会将占位符中的内容交给TokenHandler对象的handleToken方法处理。在TextSqlNode对象中占位符就是“</span>{}”符号，该对象会将SQL语句交给其两个内部类分别处理：</p><ul><li>BindingTokenParser：该对象的handleToken方法会取出占位符中的变量，然后使用该变量作为键去上下文环境中寻找对应的值然后替换占位符。</li><li>DynamicCheckerTokenParser：该对象的handleToken方法会置位成员属性isDynamic，因此该对象可以记录是否自身读到过占位符。</li></ul><p>TextSqlNode的apply方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建通用占位符解析器</span></span><br><span class="line">  GenericTokenParser parser = createParser(<span class="keyword">new</span> BindingTokenParser(context, injectionFilter));</span><br><span class="line">  <span class="comment">// 替换掉$&#123;&#125;</span></span><br><span class="line">  context.appendSql(parser.parse(text));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> GenericTokenParser <span class="title">createParser</span><span class="params">(TokenHandler handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> GenericTokenParser(<span class="string">&quot;$&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于TextSqlNode而言，如果内部含有${}那就是动态的，否则就不是动态的。<br /><a name="7j58t"></a></p><h1 id="sqlsource总结"><a class="markdownIt-Anchor" href="#sqlsource总结"></a> SqlSource总结</h1><p>语言驱动类的主要工作就是生成SqlSource，在语言驱动接口LanguageDriver的三个方法中，有两个方法是用来生成SqlSource的。而SqlSource子类的转化工作也是主要在scripting包中完成的。<br />SqlSource的子类的区别：</p><ul><li>DynamicSqlSource：动态Sql语句。所谓动态SQL语句是指含有动态SQL节点或者含有“${}”占位符。</li><li>RawSqlSource：原生SQL语句。指非动态语句，语句中可能含有“#{}”占位符，但不含有动态的SQL节点与“${}”占位符。</li><li>StaticSqlSource：静态语句。语句中可能含有“?”，可以直接交给数据库执行。</li><li>ProviderSqlSource：上面几种都是通过XML文件获取SQL语句，而P它是通过注解映射的形式获取的SQL语句。<br /><a name="lE8Jv"></a></li></ul><h2 id="sqlsource的生成"><a class="markdownIt-Anchor" href="#sqlsource的生成"></a> SqlSource的生成</h2><p><a name="Xap9B"></a></p><h3 id="解析映射文件生成sqlsource"><a class="markdownIt-Anchor" href="#解析映射文件生成sqlsource"></a> 解析映射文件生成SqlSource</h3><p>LanguageDiriver的下述方法用来解析配置文件中的节点信息，从而获取SqlSource对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, XNode script, Class&lt;?&gt; parameterType)</span></span>;</span><br></pre></td></tr></table></figure><p>其实现在XMLLanguageDriver中，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, XNode script, Class&lt;?&gt; parameterType)</span> </span>&#123;</span><br><span class="line">  XMLScriptBuilder builder = <span class="keyword">new</span> XMLScriptBuilder(configuration, script, parameterType);</span><br><span class="line">  <span class="keyword">return</span> builder.parseScriptNode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parseScriptNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MixedSqlNode rootSqlNode = parseDynamicTags(context);</span><br><span class="line">  SqlSource sqlSource;</span><br><span class="line">  <span class="keyword">if</span> (isDynamic) &#123;</span><br><span class="line">    sqlSource = <span class="keyword">new</span> DynamicSqlSource(configuration, rootSqlNode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sqlSource = <span class="keyword">new</span> RawSqlSource(configuration, rootSqlNode, parameterType);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sqlSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，解析映射文件生成的SqlSource不是DynamicSqlSource就是RawSqlSource。<br /><a name="VYEmq"></a></p><h3 id="解析注解信息生成sqlsource"><a class="markdownIt-Anchor" href="#解析注解信息生成sqlsource"></a> 解析注解信息生成SqlSource</h3><p>ProviderSqlSource通过调用LanguageDriver中的下述接口方法来生成SqlSource接口子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, String script, Class&lt;?&gt; parameterType)</span></span>;</span><br></pre></td></tr></table></figure><p>其是现在XMLLanguageDriver中，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, String script, Class&lt;?&gt; parameterType)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果注解是以&lt;script&gt;开头</span></span><br><span class="line">  <span class="keyword">if</span> (script.startsWith(<span class="string">&quot;&lt;script&gt;&quot;</span>)) &#123;</span><br><span class="line">    XPathParser parser = <span class="keyword">new</span> XPathParser(script, <span class="keyword">false</span>, configuration.getVariables(), <span class="keyword">new</span> XMLMapperEntityResolver());</span><br><span class="line">    <span class="keyword">return</span> createSqlSource(configuration, parser.evalNode(<span class="string">&quot;/script&quot;</span>), parameterType);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果注解中的内容不以&lt;script&gt;开头</span></span><br><span class="line">    script = PropertyParser.parse(script, configuration.getVariables());</span><br><span class="line">    TextSqlNode textSqlNode = <span class="keyword">new</span> TextSqlNode(script);</span><br><span class="line">    <span class="keyword">if</span> (textSqlNode.isDynamic()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DynamicSqlSource(configuration, textSqlNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RawSqlSource(configuration, script, parameterType);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果以<script>开头的SQL语句将使用和映射文件相同的解析方式，从而生成DynamicSqlSource或者RawSqlSource。<br />如果不以<script>开头则直接生成DynamicSqlSource或者RawSqlSource。<br />对象转化图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602386804982-42427fa6-cd4e-4a24-b1cc-588c075e0b78.png#align=left&amp;display=inline&amp;height=455&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=455&amp;originWidth=824&amp;size=601302&amp;status=done&amp;style=none&amp;width=824" alt="image.png" /><br /><a name="rrzvq"></a></p><h2 id="dynamicsqlsource的转化"><a class="markdownIt-Anchor" href="#dynamicsqlsource的转化"></a> DynamicSqlSource的转化</h2><p>DynamicSqlSource类在scripting的xmltags子包中，无论是DynamicSqlSource还是RawSqlSource最终都会转化为StaticSqlSource，然后才能给出一个BoundSql对象。<br />DynamicSqlSource的getBoundSql源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;.</span><br><span class="line">  <span class="comment">// 创建DynamicSqlSource的辅助类，用来记录DynamicSqlSource解析出来的SQL片段信息</span></span><br><span class="line">  DynamicContext context = <span class="keyword">new</span> DynamicContext(configuration, parameterObject);</span><br><span class="line">  <span class="comment">// 这里会从根节点开始，对节点逐层调用apply方法，此后所有的动态节点和“$&#123;&#125;”都会被替换</span></span><br><span class="line">  rootSqlNode.apply(context);</span><br><span class="line">  <span class="comment">// 处理占位符、汇总参数信息</span></span><br><span class="line">  SqlSourceBuilder sqlSourceParser = <span class="keyword">new</span> SqlSourceBuilder(configuration);</span><br><span class="line">  Class&lt;?&gt; parameterType = parameterObject == <span class="keyword">null</span> ? Object.class : parameterObject.getClass();</span><br><span class="line">  <span class="comment">// 处理“#&#123;&#125;”为?，最终圣城StaticSqlSource对象                                                   </span></span><br><span class="line">  SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());</span><br><span class="line">  BoundSql boundSql = sqlSource.getBoundSql(parameterObject);</span><br><span class="line">  <span class="comment">// getBindings的信息放入到boundSql的metaParameters中保存                                                 </span></span><br><span class="line">  context.getBindings().forEach(boundSql::setAdditionalParameter);</span><br><span class="line">  <span class="keyword">return</span> boundSql;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中parse方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parse</span><span class="params">(String originalSql, Class&lt;?&gt; parameterType, Map&lt;String, Object&gt; additionalParameters)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 完成#&#123;&#125;处理的处理器  </span></span><br><span class="line">  ParameterMappingTokenHandler handler = <span class="keyword">new</span> ParameterMappingTokenHandler(configuration, parameterType, additionalParameters);</span><br><span class="line">  <span class="comment">// 通用占位符解析器，用来进行占位符替换  </span></span><br><span class="line">  GenericTokenParser parser = <span class="keyword">new</span> GenericTokenParser(<span class="string">&quot;#&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>, handler);</span><br><span class="line">  <span class="comment">// 将#&#123;&#125;替换为?</span></span><br><span class="line">  String sql = parser.parse(originalSql);</span><br><span class="line">  <span class="comment">// 生成StaticSqlSource并返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> StaticSqlSource(configuration, sql, handler.getParameterMappings());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="A1TQ1"></a></p><h2 id="rawsqlsource的转化"><a class="markdownIt-Anchor" href="#rawsqlsource的转化"></a> RawSqlSource的转化</h2><p>RawSqlSource比DynamicSqlSource简单，它不包含动态节点和${}，因此其在构造方法中就完成了到StaticSqlSource的转化，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RawSqlSource</span><span class="params">(Configuration configuration, String sql, Class&lt;?&gt; parameterType)</span> </span>&#123;</span><br><span class="line">  SqlSourceBuilder sqlSourceParser = <span class="keyword">new</span> SqlSourceBuilder(configuration);</span><br><span class="line">  Class&lt;?&gt; clazz = parameterType == <span class="keyword">null</span> ? Object.class : parameterType;</span><br><span class="line">  <span class="comment">// 处理RawSqlSOurce中的#&#123;&#125;占位符</span></span><br><span class="line">  sqlSource = sqlSourceParser.parse(sql, clazz, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getBoundSql方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 由StaticSqlSource对象返回</span></span><br><span class="line">  <span class="keyword">return</span> sqlSource.getBoundSql(parameterObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="SS2ll"></a></p><h2 id="sqlsource接口实现类总结"><a class="markdownIt-Anchor" href="#sqlsource接口实现类总结"></a> SqlSource接口实现类总结</h2><p>SqlSource实现了的转化图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602387869042-782cd122-28ec-4e15-8d02-3f908636f2e0.png#align=left&amp;display=inline&amp;height=364&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=364&amp;originWidth=1186&amp;size=854514&amp;status=done&amp;style=none&amp;width=1186" alt="image.png" /><br />不管经历了怎样的过程，最终SqlSource接口定义的getBoundSql都是由StaticSqlSource对象来完成的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;scripting包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#scripting包&quot;&gt;&lt;/a&gt; scripting包&lt;/h1&gt;
&lt;p&gt;mapper中的SQL语句支持使用非常灵活的SQL语句组建方式，比如可以在组建语句时使用fore</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="配置解析包" scheme="https://jie-blog.icu/categories/mybatis/%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8C%85/"/>
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mapping包</title>
    <link href="https://jie-blog.icu/posts/mybatis-mapping/"/>
    <id>https://jie-blog.icu/posts/mybatis-mapping/</id>
    <published>2020-11-04T04:04:07.000Z</published>
    <updated>2020-11-04T04:15:27.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mapping包"><a class="markdownIt-Anchor" href="#mapping包"></a> mapping包</h1><p>mapping中定义了众多的解析实体类。mapping包主要有以下功能：</p><ul><li>SQL语句处理功能。</li><li>输出结果处理功能。</li><li>输入参数处理功能。</li><li>多数据库种类处理功能。</li><li>其他功能。<br /><a name="e7nfx"></a></li></ul><h1 id="sql语句处理功能"><a class="markdownIt-Anchor" href="#sql语句处理功能"></a> SQL语句处理功能</h1><p>与SQL处理语句功能相关的类有三个，分别是MappedStatement、SqlSource和BoundSql。<br />其中，MappedStatement表示的是数据库操作节点（select、update、delete和insert）内的所有内容。SqlSource是数据库操作标签中包含的SQL语句。BoundSql是SqlSource的进一步处理产物。三者关系图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602126804963-c1fe5389-2d84-4cdb-a5c0-706f5e788b35.png#align=left&amp;display=inline&amp;height=124&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=249&amp;originWidth=1402&amp;size=498735&amp;status=done&amp;style=none&amp;width=701" alt="image.png" /><br /><a name="lk7FI"></a></p><h2 id="mappedstatement"><a class="markdownIt-Anchor" href="#mappedstatement"></a> MappedStatement</h2><p>这是一个典型的解析实体类，该类的属性和数据库操作标签十分相似。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602126921123-0983655e-b19b-4cd9-8cb6-dc236bca90af.png#align=left&amp;display=inline&amp;height=375&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=749&amp;originWidth=449&amp;size=156937&amp;status=done&amp;style=none&amp;width=224.5" alt="image.png" /><br />这里就不做过多的扩展了。<br /><a name="U1Hpb"></a></p><h2 id="sqlsource"><a class="markdownIt-Anchor" href="#sqlsource"></a> SqlSource</h2><p>SqlSource本身是一个接口，该接口只定义了一个返回BoundSql对象的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlSource</span> </span>&#123;</span><br><span class="line">  <span class="function">BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602127086507-90185b29-a121-4a20-8e7c-7847070a53df.png#align=left&amp;display=inline&amp;height=155&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=309&amp;originWidth=1258&amp;size=577094&amp;status=done&amp;style=none&amp;width=629" alt="image.png" /><br />四种实现类的区别如下：</p><ul><li>DynamicSqlSource：动态SQL语句。即SQL中含有动态SQL节点（如“if”）或者含有占位符（${}）。</li><li>RawSqlSource：原生的SQL语句。指非动态语句，语句中可能含有“#{}”占位符，但是不含动态SQL节点或者“${}”。</li><li>StaticSqlSource：静态语句。语句中可能含有“？”，直接可以交给数据库执行。</li><li>ProviderSqlSource：上面几种都是XML获取的SQL语句，而ProviderSqlSource是通过注解映射形式取得的SQL语句。</li></ul><p>DynamicSqlSource和RawSqlSource都会被处理成StaticSqlSource，然后通过StaticSqlSource的getBoundSql得到BoundSql对象。<br /><a name="WauoH"></a></p><h2 id="boundsql"><a class="markdownIt-Anchor" href="#boundsql"></a> BoundSql</h2><p>BoundSql是参数绑定完成后的SQL语句，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能含有&quot;?&quot;占位符的SQL语句</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String sql;</span><br><span class="line"><span class="comment">// 参数映射列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;ParameterMapping&gt; parameterMappings;</span><br><span class="line"><span class="comment">// 实参对象本身</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object parameterObject;</span><br><span class="line"><span class="comment">// 实参</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; additionalParameters;</span><br><span class="line"><span class="comment">// additionalParameters的包装对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MetaObject metaParameters;</span><br></pre></td></tr></table></figure><p>BoundSql是SQL语句的一个重要的中间产物，它既存储了转化结束的SQL信息，又包含了实参信息和一些附加的环境信息。<br /><a name="nrIcM"></a></p><h1 id="输出结果处理功能"><a class="markdownIt-Anchor" href="#输出结果处理功能"></a> 输出结果处理功能</h1><p>resultMap是一个十分强大的功能，它支持输出结果的组装、判断、懒加载等。<br />其在解析的时候设计的类包括：ResultMap、ResultMapping、Duscriminator，他们都是解析实体类，对应关系如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602127934737-76278523-dfff-4257-a21f-4acd9b343bb1.png#align=left&amp;display=inline&amp;height=148&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=295&amp;originWidth=1118&amp;size=522140&amp;status=done&amp;style=none&amp;width=559" alt="image.png" /><br /><a name="QOspf"></a></p><h2 id="resultmap"><a class="markdownIt-Anchor" href="#resultmap"></a> ResultMap</h2><p>该类和resultMap节点对应的信息高度一致，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局配置信息</span></span><br><span class="line"><span class="keyword">private</span> Configuration configuration;</span><br><span class="line"><span class="comment">// resultMap的编号</span></span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"><span class="comment">// 最终输出结果对应的Java类</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; type;</span><br><span class="line"><span class="comment">// XML中的&lt;result&gt;列表，即ResultMapping列表</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ResultMapping&gt; resultMappings;</span><br><span class="line"><span class="comment">// XML中的&lt;id&gt;和&lt;idArg&gt;</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ResultMapping&gt; idResultMappings;</span><br><span class="line"><span class="comment">// XML中的&lt;constructor&gt;</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ResultMapping&gt; constructorResultMappings;</span><br><span class="line"><span class="comment">// XML中的非&lt;constructor&gt;相关的属性列表</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ResultMapping&gt; propertyResultMappings;</span><br><span class="line"><span class="comment">// 所有参与映射的数据库中字段的集合</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; mappedColumns;</span><br><span class="line"><span class="comment">// 所有参与映射的Java对象属性集合</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; mappedProperties;</span><br><span class="line"><span class="comment">// 鉴别器</span></span><br><span class="line"><span class="keyword">private</span> Discriminator discriminator;</span><br><span class="line"><span class="comment">// 是否存在嵌套映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasNestedResultMaps;</span><br><span class="line"><span class="comment">// 是否存在嵌套查询</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasNestedQueries;</span><br><span class="line"><span class="comment">// 是否启动自动映射</span></span><br><span class="line"><span class="keyword">private</span> Boolean autoMapping;</span><br></pre></td></tr></table></figure><p>在resultMap中，属性被分为了两类：构造方法和非构造方法中的属性。非构造方法中的属性又被分为了两类：id属性和非id属性。根据这两个分类方式就产生了如下四个属性：</p><ul><li>resultMappings：所有的属性</li><li>idResultMappings：所有的id属性</li><li>constructorResultMappings：所有构造方法中的属性</li><li>propertyResultMappings：所有非构造方法中的属性<br /><a name="fOffb"></a></li></ul><h2 id="resultmapping"><a class="markdownIt-Anchor" href="#resultmapping"></a> ResultMapping</h2><p>上述涉及到的idArg、id、result等标签都对应着一个ResultMapping对象，该类内部结构如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602128431586-baf0e1c0-b9cf-4c3b-b788-564d0d79b560.png#align=left&amp;display=inline&amp;height=274&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=548&amp;originWidth=445&amp;size=111856&amp;status=done&amp;style=none&amp;width=222.5" alt="image.png" /><br />该类由于属性较多，因此创建ResultMapping对象会非常复杂，为了改善这个过程，ResultMapping使用了建造者模式。并且它的建造者模式直接放在了类的内部作为内部静态类出现。内部静态类中的方法调用不需要创建类的对象，而它却可以生成类的对象。<br />这种实现方法提升了类的内聚性，可以借鉴这种实现。<br /><a name="bngoH"></a></p><h2 id="discriminator"><a class="markdownIt-Anchor" href="#discriminator"></a> Discriminator</h2><p>Discriminator是resultMap内部的鉴别器，就像程序中的选择语句一样，它使得数据库查询结果能够根据某些条件的不同而进行不同的映射。<br />该类内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储条件判断行信息</span></span><br><span class="line"><span class="keyword">private</span> ResultMapping resultMapping;</span><br><span class="line"><span class="comment">// 存储选择项的信息，键为value的值，值为resultMap的值</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, String&gt; discriminatorMap;</span><br></pre></td></tr></table></figure><p>在DefaultResultSetHandler的resolveDiscriminatedResultMap方法中有该类属性生效的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultMap <span class="title">resolveDiscriminatedResultMap</span><span class="params">(ResultSet rs, ResultMap resultMap, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 已经处理过得鉴别器  </span></span><br><span class="line">  Set&lt;String&gt; pastDiscriminators = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  Discriminator discriminator = resultMap.getDiscriminator();</span><br><span class="line">  <span class="keyword">while</span> (discriminator != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 求解条件判断的结果，这个结果值就是鉴别器鉴别的依据</span></span><br><span class="line">    <span class="keyword">final</span> Object value = getDiscriminatorValue(rs, discriminator, columnPrefix);</span><br><span class="line">    <span class="comment">// 根据真实值判断属于哪个分支</span></span><br><span class="line">    <span class="keyword">final</span> String discriminatedMapId = discriminator.getMapIdFor(String.valueOf(value));</span><br><span class="line">    <span class="comment">// 从接下来的case里找到这个分支</span></span><br><span class="line">    <span class="keyword">if</span> (configuration.hasResultMap(discriminatedMapId)) &#123;</span><br><span class="line">      <span class="comment">// 找出指定的resultMap</span></span><br><span class="line">      resultMap = configuration.getResultMap(discriminatedMapId);</span><br><span class="line">      <span class="comment">// 继续分析下一层</span></span><br><span class="line">      Discriminator lastDiscriminator = discriminator;</span><br><span class="line">      <span class="comment">// 查看本resultMap内是否还有鉴别器</span></span><br><span class="line">      discriminator = resultMap.getDiscriminator();</span><br><span class="line">      <span class="comment">// 判别器出现了环</span></span><br><span class="line">      <span class="keyword">if</span> (discriminator == lastDiscriminator || !pastDiscriminators.add(discriminatedMapId)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resultMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求解鉴别器的条件判断结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getDiscriminatorValue</span><span class="params">(ResultSet rs, Discriminator discriminator, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ResultMapping resultMapping = discriminator.getResultMapping();</span><br><span class="line">  <span class="keyword">final</span> TypeHandler&lt;?&gt; typeHandler = resultMapping.getTypeHandler();</span><br><span class="line">  <span class="keyword">return</span> typeHandler.getResult(rs, prependPrefix(resultMapping.getColumn(), columnPrefix));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="15bMa"></a></p><h1 id="输入参数处理功能"><a class="markdownIt-Anchor" href="#输入参数处理功能"></a> 输入参数处理功能</h1><p>输入参数处理功能设计的两个类关系图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602129369295-91fd796c-bf99-4ae4-bc57-d34e4763768e.png#align=left&amp;display=inline&amp;height=81&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=161&amp;originWidth=1173&amp;size=264140&amp;status=done&amp;style=none&amp;width=586.5" alt="image.png" /><br />这两个类与RestMap和ResultMapping十分类似，并且在现在编译中已经弱化了parameterMap标签（建议使用内联参数），因此在这里就不做过多的分析了。<br /><a name="hcUdR"></a></p><h1 id="多数据库种类处理功能"><a class="markdownIt-Anchor" href="#多数据库种类处理功能"></a> 多数据库种类处理功能</h1><p>Mybatis支持多种数据库。在使用多种数据库前，需要先在配置文件中列举出要使用的数据库类型，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;databaseIdProvider type=<span class="string">&quot;DB_VENDOR&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;MySQL&quot;</span> value=<span class="string">&quot;mysql&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;SQL Server&quot;</span> value=<span class="string">&quot;sqlserver&quot;</span> /&gt;</span><br><span class="line">&lt;/databaseIdProvider&gt;</span><br></pre></td></tr></table></figure><p>然后在SQL语句上书写databaseId，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectByAge&quot;</span> resultMap=<span class="string">&quot;userMap&quot;</span> databaseId=<span class="string">&quot;sqlserver&quot;</span>&gt;</span><br><span class="line">    SELECT * FROM `user` WHERE `age` = #&#123;age&#125; TOP 5</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">&quot;selectByAge&quot;</span> resultMap=<span class="string">&quot;userMap&quot;</span> databaseId=<span class="string">&quot;mysql&quot;</span>&gt;</span><br><span class="line">    SELECT * FROM `user` WHERE `age` = #&#123;age&#125; LIMIT 5</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>多种数据库支持的实现由DatabaseIdProvider接口负责，它有一个VendorDatabaseIdProvider实现类和一个即将废除的DefaultDatabaseIdProvider的子类。<br /><a name="RniON"></a></p><h2 id="vendordatabaseidprovider"><a class="markdownIt-Anchor" href="#vendordatabaseidprovider"></a> VendorDatabaseIdProvider</h2><p>VendorDatabaseIdProvider中的两个重要方法均继承自DatabaseIdProvider接口，分别是setProperties和getDatabaseId。<br /><a name="eoCcQ"></a></p><h3 id="setproperties"><a class="markdownIt-Anchor" href="#setproperties"></a> setProperties</h3><p>setProperties方法是用来将Mybatis配置文件中设置在databaseIdProvider节点中的信息写入到VendorDatabaseIdProvider对象中。<br /><a name="3hOCF"></a></p><h3 id="getdatabaseid"><a class="markdownIt-Anchor" href="#getdatabaseid"></a> getDatabaseId</h3><p>getDatabaseId方法是用来给出当前传入的DataSource对应的databaseId。主要逻辑位于getDatabaseName中，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getDatabaseName</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 获取当前连接的数据库名</span></span><br><span class="line">  String productName = getDatabaseProductName(dataSource);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.properties != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果设置了properties的值，则将获取的数据库名称作为模糊的key，映射为对应的value</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; property : properties.entrySet()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (productName.contains((String) property.getKey())) &#123;</span><br><span class="line">        <span class="keyword">return</span> (String) property.getValue();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// no match, return null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> productName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，他一共做了两个工作：</p><ul><li>获取当前数据源的类型。</li><li>将数据源类型映射为databaseIdProvider中设置的别名。<br /><a name="ETqAY"></a></li></ul><h1 id="其他功能"><a class="markdownIt-Anchor" href="#其他功能"></a> 其他功能</h1><p>mapping包中还有两个重要的类：Envirment和CacheBuiler。<br /><a name="QCzrd"></a></p><h2 id="environment"><a class="markdownIt-Anchor" href="#environment"></a> Environment</h2><p>Environment也是一个解析实体类，它对应着environments节点，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line"><span class="comment">// 事务工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TransactionFactory transactionFactory;</span><br><span class="line"><span class="comment">// 数据源信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DataSource dataSource;</span><br></pre></td></tr></table></figure><p><a name="StyrD"></a></p><h2 id="cachebuilder"><a class="markdownIt-Anchor" href="#cachebuilder"></a> CacheBuilder</h2><p>CacheBuilder是缓存建造者，他负责完成缓存对象的创建，具体的实现将在后续分析。<br /><a name="iTE1p"></a></p><h2 id="其他枚举类"><a class="markdownIt-Anchor" href="#其他枚举类"></a> 其他枚举类</h2><p>mapping中还存在着其他的一些枚举类，作用分别如下：</p><ul><li>FetchType：延迟加载设置</li><li>ParameterType：参数类型，指输入参数、输出参数等。</li><li>ResultFlag：返回结果中属性的特殊标志，表示是否为id属性、是否为构造器属性。</li><li>ResultSetType：结果集支持的访问方式。</li><li>SqlCommandType：SQL类型，指增删改查等。</li><li>StatementType：SQL语句类型，指是否为预编译语句，是否为存储过程等。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mapping包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#mapping包&quot;&gt;&lt;/a&gt; mapping包&lt;/h1&gt;
&lt;p&gt;mapping中定义了众多的解析实体类。mapping包主要有以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SQL语</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="配置解析包" scheme="https://jie-blog.icu/categories/mybatis/%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8C%85/"/>
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>builder包</title>
    <link href="https://jie-blog.icu/posts/mybatis-builder/"/>
    <id>https://jie-blog.icu/posts/mybatis-builder/</id>
    <published>2020-11-04T04:03:15.000Z</published>
    <updated>2020-11-04T04:15:29.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="builder包"><a class="markdownIt-Anchor" href="#builder包"></a> builder包</h1><p>build包是一个按照类型划分出来的包，包中含有很多建造者类。虽然这个包是一个按照类型方式划分的包，但是该包也完成了如下两个比较完整的功能：</p><ul><li>解析XML配置文件和映射文件，这部分在功能xml子包中。</li><li>解析注解形式的Mapper声明，这部分功能在annotation子包中。<br /><a name="2JNa8"></a></li></ul><h1 id="建造者模式"><a class="markdownIt-Anchor" href="#建造者模式"></a> 建造者模式</h1><p>在仔细分析该包前首先要回忆一下建造者模式。<br />使用建造者模式对象建造的细节均交给了建造者来完成，调用者只需掌控总体流程即可，而不需要过多的关注建造对象的细节。<br />基于建造者创建的对象有以下几个优点：</p><ul><li>可以一次也可以分次设置被建造对象的属性。</li><li>调用者只需调用建造者的主要流程而不需要关心建造者的细节。</li><li>可以方便的修改建造者的行为来建造出不同的对象。</li></ul><p>建造者的实现有两种方法：</p><ul><li>属性设置方法。这类方法一般有多个，可以接受不同类型的参数来设置建造者的属性。</li><li>目标对象生成方法。这类方法一般只有一个，根据目前建造者的属性创建出一个目标对象。<br /><a name="IQfCQ"></a></li></ul><h2 id="建造者基类与工具类"><a class="markdownIt-Anchor" href="#建造者基类与工具类"></a> 建造者基类与工具类</h2><p>builder包中BaseBuilder是所有建造者的子类，其类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602034919258-c4700aa1-ab51-4647-ad59-84f70ebd37b5.png#align=left&amp;display=inline&amp;height=299&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=598&amp;originWidth=1157&amp;size=1077520&amp;status=done&amp;style=none&amp;width=578.5" alt="image.png" /><br />BaseBuilder更像一个工具类，为继承他的制造者提供了很多实用的方法：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602034997465-a81d025b-3fb2-4430-9336-92f2ce61e3c7.png#align=left&amp;display=inline&amp;height=229&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=458&amp;originWidth=511&amp;size=114178&amp;status=done&amp;style=none&amp;width=255.5" alt="image.png" /><br />BaseBuilder提供的工具方法大致分为如下几个类型：</p><ul><li>*ValueOf：类型转化函数，负责将输入参数转化为指定的类型，并支持默认值设置。</li><li>resolve*：字符串转枚举类型函数，根据字符串找出指定的枚举类型并返回。</li><li>createInstance：根据类型别名创建类型实例。</li><li>resolveTypeHandler：根据类型处理器别名返回类型处理器实例。</li></ul><p>也有一些类不需要BaseBuilder提供的方法，因此没有继承自它。<br />还有一些不是建造者模式也继承自该类，以MapperBuilderAssistant为例，它本身不是建造者类而是一个建造者辅助类，但是也继承自BaseBuilder。<br /><a name="WH1lA"></a></p><h3 id="mapperbuilderassistant"><a class="markdownIt-Anchor" href="#mapperbuilderassistant"></a> MapperBuilderAssistant</h3><p>Mybatis内部有很多设置项，比如命名空间、缓存共享、结果映射等等。最终这些设置将解析成不同的类，而MapperBuilderAssistant就是这些解析类的辅助类。其内部有很多辅助方法，如Mapper命名空间的设置、缓存的创建、鉴别器的创建等等。<br /><a name="laWXi"></a></p><h1 id="sqlsourcebuilder与staticsqlsource"><a class="markdownIt-Anchor" href="#sqlsourcebuilder与staticsqlsource"></a> SqlSourceBuilder与StaticSqlSource</h1><p>SqlSourceBuillder是一个建造者类，与它的名字不同，它并不能用来创建所有的SqlSource对象，而是只能通过parse方法生产出一个StaticSqlSource方法。<br />换句话说，SqlSourceBuillder类能够将DynamicSqlSource中的“#{}”替换掉，从而将其转化为StaticSqlSource。因此，把SqlSourceBuillder称作一个解析器或者转化器更为合适。在许多引用SqlSourceBuillder对象的地方都将对象的变量名定为“sqlSourceParser”。<br />其parse源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parse</span><span class="params">(String originalSql, Class&lt;?&gt; parameterType, Map&lt;String, Object&gt; additionalParameters)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 用来完成#&#123;&#125;处理的处理器  </span></span><br><span class="line">  ParameterMappingTokenHandler handler = <span class="keyword">new</span> ParameterMappingTokenHandler(configuration, parameterType, additionalParameters);</span><br><span class="line">  <span class="comment">// 通用的占位符解析器，用来进行占位符替换  </span></span><br><span class="line">  GenericTokenParser parser = <span class="keyword">new</span> GenericTokenParser(<span class="string">&quot;#&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>, handler);</span><br><span class="line">  <span class="comment">// 将#&#123;&#125;替换为?的SQL语句</span></span><br><span class="line">  String sql = parser.parse(originalSql);</span><br><span class="line">  <span class="comment">// 生成一个StaticSqlSource对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> StaticSqlSource(configuration, sql, handler.getParameterMappings());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="6PNJ5"></a></p><h2 id="staticsqlsource"><a class="markdownIt-Anchor" href="#staticsqlsource"></a> StaticSqlSource</h2><p>StaticSqlSource是SqlSource的一个子类，期内部的SQL语句已经不存在‘${}’或‘#{}’，而只存在？。其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只剩?的SQL语句  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String sql;</span><br><span class="line"><span class="comment">// SQL语句对应的参数列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;ParameterMapping&gt; parameterMappings;</span><br><span class="line"><span class="comment">// 配置信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br></pre></td></tr></table></figure><p>StaticSqlSource最重要的功能就是返回一个BoundSql对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> BoundSql(configuration, sql, parameterMappings, parameterObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BoundSql将在未来进行详细分析。<br /><a name="tmZ5S"></a></p><h1 id="caserefresolver和resultmapresolver"><a class="markdownIt-Anchor" href="#caserefresolver和resultmapresolver"></a> CaseRefResolver和ResultMapResolver</h1><p>这两个类都是某些类的解析器类，属性中包含被解析类相关的属性，同时还包含一个解析器（Mybatis把被解析对象命名为A，整合后的自解析类命名为AResolver）。<br /><a name="HIgT8"></a></p><h2 id="caserefresovler"><a class="markdownIt-Anchor" href="#caserefresovler"></a> CaseRefResovler</h2><p>Mybatis支持多个namespace之间共享缓存。CaseRefResolver就是用来处理多个命名空间共享缓存问题的，他自身有两个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mapper建造者辅助类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MapperBuilderAssistant assistant;</span><br><span class="line"><span class="comment">// 被应用的namespace，即使用cacheRef的Namespace缓存空间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String cacheRefNamespace;</span><br></pre></td></tr></table></figure><p>借助于MapperBuilderAssiant的useCacheRef方法，CaseRefResolver可以解析缓存共享问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Cache <span class="title">useCacheRef</span><span class="params">(String namespace)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (namespace == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;cache-ref element requires a namespace attribute.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    unresolvedCacheRef = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 获取namespace的缓存</span></span><br><span class="line">    Cache cache = configuration.getCache(namespace);</span><br><span class="line">    <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteElementException(<span class="string">&quot;No cache for namespace &#x27;&quot;</span> + namespace + <span class="string">&quot;&#x27; could be found.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 替换本地缓存，从而实现缓存共享</span></span><br><span class="line">    currentCache = cache;</span><br><span class="line">    unresolvedCacheRef = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteElementException(<span class="string">&quot;No cache for namespace &#x27;&quot;</span> + namespace + <span class="string">&quot;&#x27; could be found.&quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="PLejX"></a></p><h2 id="resultmapresovler"><a class="markdownIt-Anchor" href="#resultmapresovler"></a> ResultMapResovler</h2><p>Mybatis的resultMap标签支持继承，如下列代码所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id=<span class="string">&quot;girlUserMap&quot;</span> type=<span class="string">&quot;Girl&quot;</span> extends=<span class="string">&quot;userMap&quot;</span>&gt;</span><br><span class="line">    &lt;result property=<span class="string">&quot;email&quot;</span> column=<span class="string">&quot;email&quot;</span>/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;resultMap id=<span class="string">&quot;userMap&quot;</span> type=<span class="string">&quot;User&quot;</span> autoMapping=<span class="string">&quot;false&quot;</span>&gt;</span><br><span class="line">    &lt;id property=<span class="string">&quot;id&quot;</span> column=<span class="string">&quot;id&quot;</span> javaType=<span class="string">&quot;Integer&quot;</span> jdbcType=<span class="string">&quot;INTEGER&quot;</span></span><br><span class="line">        typeHandler=<span class="string">&quot;org.apache.ibatis.type.IntegerTypeHandler&quot;</span>/&gt;</span><br><span class="line">    &lt;result property=<span class="string">&quot;name&quot;</span> column=<span class="string">&quot;name&quot;</span>/&gt;</span><br><span class="line">    &lt;discriminator javaType=<span class="string">&quot;int&quot;</span> column=<span class="string">&quot;sex&quot;</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">case</span> value=<span class="string">&quot;0&quot;</span> resultMap=<span class="string">&quot;boyUserMap&quot;</span>/&gt;</span><br><span class="line">        &lt;<span class="keyword">case</span> value=<span class="string">&quot;1&quot;</span> resultMap=<span class="string">&quot;girlUserMap&quot;</span>/&gt;</span><br><span class="line">    &lt;/discriminator&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><p>其继承关系可以由ResultMapResovler所处理，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mapper建造者辅助类  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MapperBuilderAssistant assistant;</span><br><span class="line"><span class="comment">// ResultMap的id</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line"><span class="comment">// ResultMap的type属性，即目标对象类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line"><span class="comment">// ResultMap的extends属性，即继承属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String extend;</span><br><span class="line"><span class="comment">// ResultMap的Discriminator节点，即鉴别器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Discriminator discriminator;</span><br><span class="line"><span class="comment">// ResultMap中的属性映射列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;ResultMapping&gt; resultMappings;</span><br><span class="line"><span class="comment">// ResultMap的autoMapping属性，即是否开启自动映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Boolean autoMapping;</span><br></pre></td></tr></table></figure><p>借助MapperBuilderAssiant的addResultMap方法，ResultMapResovler完成了继承关系解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> ResultMap <span class="title">addResultMap</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     String id,</span></span></span><br><span class="line"><span class="function"><span class="params">     Class&lt;?&gt; type,</span></span></span><br><span class="line"><span class="function"><span class="params">     String extend,</span></span></span><br><span class="line"><span class="function"><span class="params">     Discriminator discriminator,</span></span></span><br><span class="line"><span class="function"><span class="params">     List&lt;ResultMapping&gt; resultMappings,</span></span></span><br><span class="line"><span class="function"><span class="params">     Boolean autoMapping)</span> </span>&#123;</span><br><span class="line">   id = applyCurrentNamespace(id, <span class="keyword">false</span>);</span><br><span class="line">   extend = applyCurrentNamespace(extend, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 解析ResultMap继承关系</span></span><br><span class="line">   <span class="comment">// 如果存在ResultMap的继承</span></span><br><span class="line">   <span class="keyword">if</span> (extend != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (!configuration.hasResultMap(extend)) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteElementException(<span class="string">&quot;Could not find a parent resultmap with id &#x27;&quot;</span> + extend + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 获取父级的ResultMap</span></span><br><span class="line">     ResultMap resultMap = configuration.getResultMap(extend);</span><br><span class="line">     <span class="comment">// 获取父级的属性映射</span></span><br><span class="line">     List&lt;ResultMapping&gt; extendedResultMappings = <span class="keyword">new</span> ArrayList&lt;&gt;(resultMap.getResultMappings());</span><br><span class="line">     <span class="comment">// 删除当前ResultMap已有的父级属性映射</span></span><br><span class="line">     extendedResultMappings.removeAll(resultMappings);</span><br><span class="line">     <span class="comment">// 如果ResultMap设有构造器，则移除父级构造器</span></span><br><span class="line">     <span class="keyword">boolean</span> declaresConstructor = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">for</span> (ResultMapping resultMapping : resultMappings) &#123;</span><br><span class="line">       <span class="keyword">if</span> (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">         declaresConstructor = <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (declaresConstructor) &#123;</span><br><span class="line">       extendedResultMappings.removeIf(resultMapping -&gt; resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 最终从父级继承而来的所有属性映射</span></span><br><span class="line">     resultMappings.addAll(extendedResultMappings);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 创建当前的ResultMap</span></span><br><span class="line">   ResultMap resultMap = <span class="keyword">new</span> ResultMap.Builder(configuration, id, type, resultMappings, autoMapping)</span><br><span class="line">       .discriminator(discriminator)</span><br><span class="line">       .build();</span><br><span class="line">   <span class="comment">// 将当前的ResultMap加入到configuration</span></span><br><span class="line">   configuration.addResultMap(resultMap);</span><br><span class="line">   <span class="keyword">return</span> resultMap;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><a name="mEf1o"></a></p><h1 id="parameterexpression类"><a class="markdownIt-Anchor" href="#parameterexpression类"></a> ParameterExpression类</h1><p>该类是一个属性解析器，用来将描述的字符串解析为键值对的形式。ParameterExpression继承自HashMap，内部能以键值对的形式保存最后的解析结果。<br />注意：对于没有属性声明的属性会以默认名称expression的形式出现。<br /><a name="Daltb"></a></p><h1 id="xml文件解析"><a class="markdownIt-Anchor" href="#xml文件解析"></a> XML文件解析</h1><p>Mybatis的XML文件都会被解析成对应的类，builder的xml包就负责完成这种工作。<br />Mybatis的配置文件和映射文件的节点很多，这些节点的解析是由xml子包中的五个解析器来配合完成的。范围如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602038458012-d9e972f9-c984-4d30-877d-fae496622b57.png#align=left&amp;display=inline&amp;height=481&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=627&amp;originWidth=808&amp;size=736922&amp;status=done&amp;style=none&amp;width=620" alt="image.png" /><br /><a name="mzE6P"></a></p><h2 id="xml文件声明解析"><a class="markdownIt-Anchor" href="#xml文件声明解析"></a> XML文件声明解析</h2><p>在DOCTYE声明中可以表明当前XML文件引用的地址，在EntityResolver接口中存在一个resolveEntity方法，可以通过实现这个方法自定义给出DTD文件流的方式，而不是只能从互联网下载。<br />XMLMapperEntityResolver就继承自该接口，其内部实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InputSource <span class="title">resolveEntity</span><span class="params">(String publicId, String systemId)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (systemId != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">// 将systemId转换为小写</span></span><br><span class="line">      String lowerCaseSystemId = systemId.toLowerCase(Locale.ENGLISH);</span><br><span class="line">      <span class="comment">// 通过判断说明是配置文档</span></span><br><span class="line">      <span class="keyword">if</span> (lowerCaseSystemId.contains(MYBATIS_CONFIG_SYSTEM) || lowerCaseSystemId.contains(IBATIS_CONFIG_SYSTEM)) &#123;</span><br><span class="line">        <span class="comment">// 把本地配置文档的DTD文件返回  </span></span><br><span class="line">        <span class="keyword">return</span> getInputSource(MYBATIS_CONFIG_DTD, publicId, systemId);</span><br><span class="line">      <span class="comment">// 通过判断说明是映射文档</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lowerCaseSystemId.contains(MYBATIS_MAPPER_SYSTEM) || lowerCaseSystemId.contains(IBATIS_MAPPER_SYSTEM)) &#123;</span><br><span class="line">        <span class="keyword">return</span> getInputSource(MYBATIS_MAPPER_DTD, publicId, systemId);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SAXException(e.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="priUa"></a></p><h2 id="配置文件解析"><a class="markdownIt-Anchor" href="#配置文件解析"></a> 配置文件解析</h2><p>配置文件解析是由XMLConfigBuilder完成的，同时该类还会建造出一个Configuration对象，其入口方法就是parse方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 不允许重复解析</span></span><br><span class="line">  <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Each XMLConfigBuilder can only be used once.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  parsed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">// 从根节点开始解析</span></span><br><span class="line">  parseConfiguration(parser.evalNode(<span class="string">&quot;/configuration&quot;</span>));</span><br><span class="line">  <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parseConfiguration：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 解析信息放入Configuration</span></span><br><span class="line">    <span class="comment">// 首先解析properties，以保证在解析其他节点时就可以生效</span></span><br><span class="line">    propertiesElement(root.evalNode(<span class="string">&quot;properties&quot;</span>));</span><br><span class="line">    Properties settings = settingsAsProperties(root.evalNode(<span class="string">&quot;settings&quot;</span>));</span><br><span class="line">    loadCustomVfs(settings);</span><br><span class="line">    loadCustomLogImpl(settings);</span><br><span class="line">    typeAliasesElement(root.evalNode(<span class="string">&quot;typeAliases&quot;</span>));</span><br><span class="line">    pluginElement(root.evalNode(<span class="string">&quot;plugins&quot;</span>));</span><br><span class="line">    objectFactoryElement(root.evalNode(<span class="string">&quot;objectFactory&quot;</span>));</span><br><span class="line">    objectWrapperFactoryElement(root.evalNode(<span class="string">&quot;objectWrapperFactory&quot;</span>));</span><br><span class="line">    reflectorFactoryElement(root.evalNode(<span class="string">&quot;reflectorFactory&quot;</span>));</span><br><span class="line">    settingsElement(settings);</span><br><span class="line">    <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">    environmentsElement(root.evalNode(<span class="string">&quot;environments&quot;</span>));</span><br><span class="line">    databaseIdProviderElement(root.evalNode(<span class="string">&quot;databaseIdProvider&quot;</span>));</span><br><span class="line">    typeHandlerElement(root.evalNode(<span class="string">&quot;typeHandlers&quot;</span>));</span><br><span class="line">    mapperElement(root.evalNode(<span class="string">&quot;mappers&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的调用一样是嵌套调用，这里以mapper为例继续解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理子节点，即mapper节点或package节点</span></span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="comment">// 是否为package</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">        <span class="comment">// 取出包路径</span></span><br><span class="line">        String mapperPackage = child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">// 全部存入mappers</span></span><br><span class="line">        configuration.addMappers(mapperPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// resource url mapperClass只有一个生效</span></span><br><span class="line">        String v = child.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">        String url = child.getStringAttribute(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        String mapperClass = child.getStringAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(resource);</span><br><span class="line">          <span class="comment">// 获取文件输入流</span></span><br><span class="line">          InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">          <span class="comment">// 使用XMLMapperBuilder解析映射文件</span></span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(url);</span><br><span class="line">          <span class="comment">// 获得网络输入流</span></span><br><span class="line">          InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">          <span class="comment">// 使用XMLMapperBuilder解析映射文件</span></span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 获取映射接口</span></span><br><span class="line">          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">          configuration.addMapper(mapperInterface);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XMLConfigBuilder在Mybatis中起到了引导的作用，正是从其parse方法开始引发了配置的解析。<br /><a name="ojvIG"></a></p><h2 id="数据库语句解析"><a class="markdownIt-Anchor" href="#数据库语句解析"></a> 数据库语句解析</h2><p>映射文件的解析由XMLMapperBuilder来负责，其parse方法为入口方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 判断是否重复解析</span></span><br><span class="line">   <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">     <span class="comment">// 处理mapper节点</span></span><br><span class="line">     configurationElement(parser.evalNode(<span class="string">&quot;/mapper&quot;</span>));</span><br><span class="line">     <span class="comment">// 加入已解析的列表，防止重复解析</span></span><br><span class="line">     configuration.addLoadedResource(resource);</span><br><span class="line">     <span class="comment">// 将mapper注册给Configuration</span></span><br><span class="line">     bindMapperForNamespace();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 分别处理失败的resultMap、cache-ref、SQL</span></span><br><span class="line">   parsePendingResultMaps();</span><br><span class="line">   parsePendingCacheRefs();</span><br><span class="line">   parsePendingStatements();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>处理mapper结点的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 读取当前配置文件的命名空间</span></span><br><span class="line">    String namespace = context.getStringAttribute(<span class="string">&quot;namespace&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (namespace == <span class="keyword">null</span> || namespace.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Mapper&#x27;s namespace cannot be empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">    <span class="comment">// 映射文件中其他配置节点的解析</span></span><br><span class="line">    cacheRefElement(context.evalNode(<span class="string">&quot;cache-ref&quot;</span>));</span><br><span class="line">    cacheElement(context.evalNode(<span class="string">&quot;cache&quot;</span>));</span><br><span class="line">    parameterMapElement(context.evalNodes(<span class="string">&quot;/mapper/parameterMap&quot;</span>));</span><br><span class="line">    resultMapElements(context.evalNodes(<span class="string">&quot;/mapper/resultMap&quot;</span>));</span><br><span class="line">    sqlElement(context.evalNodes(<span class="string">&quot;/mapper/sql&quot;</span>));</span><br><span class="line">    <span class="comment">// 处理各种数据库操作语句</span></span><br><span class="line">    buildStatementFromContext(context.evalNodes(<span class="string">&quot;select|insert|update|delete&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error parsing Mapper XML. The XML location is &#x27;&quot;</span> + resource + <span class="string">&quot;&#x27;. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类的parse方法在结尾有三个parsePending方法来处理解析过程中的暂时错误。<br />解析上下文读取文件时，可能会读取到一个节点是其还没有被定义，这种时候有两种解决方法：</p><ul><li>第一轮只读入所有结点但不处理依赖，在第二轮再处理依赖关系。Spring初始化时就用的这种方案。</li><li>如果为被定义就设为暂时性的错误，显然Mybatis默认采用这种方案。<br /><a name="O6ETX"></a></li></ul><h2 id="statement解析"><a class="markdownIt-Anchor" href="#statement解析"></a> Statement解析</h2><p>数据库的操作节点解析由XMLStatementBuilder的parseStatementNode方法完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseStatementNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取当前节点的id与databaseId</span></span><br><span class="line">   String id = context.getStringAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">   String databaseId = context.getStringAttribute(<span class="string">&quot;databaseId&quot;</span>);</span><br><span class="line"><span class="comment">// 验证id与databaseId是否匹配。Mybatis允许多种数据库配置，有些语句只能针对特定数据库生效</span></span><br><span class="line">   <span class="keyword">if</span> (!databaseIdMatchesCurrent(id, databaseId, <span class="keyword">this</span>.requiredDatabaseId)) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 获取节点名</span></span><br><span class="line">   String nodeName = context.getNode().getNodeName();</span><br><span class="line">   <span class="comment">// 读取和判断语句类型</span></span><br><span class="line">   SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">   <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">   <span class="keyword">boolean</span> flushCache = context.getBooleanAttribute(<span class="string">&quot;flushCache&quot;</span>, !isSelect);</span><br><span class="line">   <span class="keyword">boolean</span> useCache = context.getBooleanAttribute(<span class="string">&quot;useCache&quot;</span>, isSelect);</span><br><span class="line">   <span class="keyword">boolean</span> resultOrdered = context.getBooleanAttribute(<span class="string">&quot;resultOrdered&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理语句的include节点</span></span><br><span class="line">   XMLIncludeTransformer includeParser = <span class="keyword">new</span> XMLIncludeTransformer(configuration, builderAssistant);</span><br><span class="line">   includeParser.applyIncludes(context.getNode());</span><br><span class="line"><span class="comment">// 获取参数类型</span></span><br><span class="line">   String parameterType = context.getStringAttribute(<span class="string">&quot;parameterType&quot;</span>);</span><br><span class="line">   Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);</span><br><span class="line"><span class="comment">// 获取语句类型</span></span><br><span class="line">   String lang = context.getStringAttribute(<span class="string">&quot;lang&quot;</span>);</span><br><span class="line">   LanguageDriver langDriver = getLanguageDriver(lang);</span><br><span class="line"><span class="comment">// 处理SelectKey节点，这里会将KeyGenerator加入到Configuration.keyGenerators中</span></span><br><span class="line">   processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 所有的selectKey和include已经被解析并删除完毕，开始SQL解析</span></span><br><span class="line">   KeyGenerator keyGenerator;</span><br><span class="line">   String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">   keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="keyword">true</span>);</span><br><span class="line">   <span class="comment">// 判断是否已经有解析好的KeyGenerator</span></span><br><span class="line">   <span class="keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">     keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 全局或者本语句只要一启动自动key生成就会使用key生成</span></span><br><span class="line">     keyGenerator = context.getBooleanAttribute(<span class="string">&quot;useGeneratedKeys&quot;</span>,</span><br><span class="line">         configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">         ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 读取各个配置属性</span></span><br><span class="line">   SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line">   StatementType statementType = StatementType.valueOf(context.getStringAttribute(<span class="string">&quot;statementType&quot;</span>, StatementType.PREPARED.toString()));</span><br><span class="line">   Integer fetchSize = context.getIntAttribute(<span class="string">&quot;fetchSize&quot;</span>);</span><br><span class="line">   Integer timeout = context.getIntAttribute(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">   String parameterMap = context.getStringAttribute(<span class="string">&quot;parameterMap&quot;</span>);</span><br><span class="line">   String resultType = context.getStringAttribute(<span class="string">&quot;resultType&quot;</span>);</span><br><span class="line">   Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">   String resultMap = context.getStringAttribute(<span class="string">&quot;resultMap&quot;</span>);</span><br><span class="line">   String resultSetType = context.getStringAttribute(<span class="string">&quot;resultSetType&quot;</span>);</span><br><span class="line">   ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);</span><br><span class="line">   <span class="keyword">if</span> (resultSetTypeEnum == <span class="keyword">null</span>) &#123;</span><br><span class="line">     resultSetTypeEnum = configuration.getDefaultResultSetType();</span><br><span class="line">   &#125;</span><br><span class="line">   String keyProperty = context.getStringAttribute(<span class="string">&quot;keyProperty&quot;</span>);</span><br><span class="line">   String keyColumn = context.getStringAttribute(<span class="string">&quot;keyColumn&quot;</span>);</span><br><span class="line">   String resultSets = context.getStringAttribute(<span class="string">&quot;resultSets&quot;</span>);</span><br><span class="line"><span class="comment">// 在MapperBuilderAssistant帮助下创建MappedStatement对象并写入Configuration</span></span><br><span class="line">   builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">       fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">       resultSetTypeEnum, flushCache, useCache, resultOrdered,</span><br><span class="line">       keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="ZUVk0"></a></p><h2 id="引用解析"><a class="markdownIt-Anchor" href="#引用解析"></a> 引用解析</h2><p>Mybatis支持在数据库操作语句中编写引用语句片段。<br />在之前statement解析中也可以看到include节点是由XMLIncludeTransformer来负责的，他可以将include中的include节点替换为被引用的SQL片段。其applyInclude（Node）方法时解析include结点的入口方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyIncludes</span><span class="params">(Node source, <span class="keyword">final</span> Properties variablesContext, <span class="keyword">boolean</span> included)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (source.getNodeName().equals(<span class="string">&quot;include&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 找出被应用的节点</span></span><br><span class="line">    Node toInclude = findSqlFragment(getStringAttribute(source, <span class="string">&quot;refid&quot;</span>), variablesContext);</span><br><span class="line">    Properties toIncludeContext = getVariablesContext(source, variablesContext);</span><br><span class="line">    <span class="comment">// 递归处理被引用节点中的include节点</span></span><br><span class="line">    applyIncludes(toInclude, toIncludeContext, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (toInclude.getOwnerDocument() != source.getOwnerDocument()) &#123;</span><br><span class="line">      toInclude = source.getOwnerDocument().importNode(toInclude, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完成include节点的替换</span></span><br><span class="line">    source.getParentNode().replaceChild(toInclude, source);</span><br><span class="line">    <span class="keyword">while</span> (toInclude.hasChildNodes()) &#123;</span><br><span class="line">      toInclude.getParentNode().insertBefore(toInclude.getFirstChild(), toInclude);</span><br><span class="line">    &#125;</span><br><span class="line">    toInclude.getParentNode().removeChild(toInclude);</span><br><span class="line">   <span class="comment">// 元素节点</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">    <span class="keyword">if</span> (included &amp;&amp; !variablesContext.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// 用属性替换变量</span></span><br><span class="line">      NamedNodeMap attributes = source.getAttributes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; attributes.getLength(); i++) &#123;</span><br><span class="line">        Node attr = attributes.item(i);</span><br><span class="line">        attr.setNodeValue(PropertyParser.parse(attr.getNodeValue(), variablesContext));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环到下层节点递归处理的下层的include节点</span></span><br><span class="line">    NodeList children = source.getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">      applyIncludes(children.item(i), variablesContext, included);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (included &amp;&amp; source.getNodeType() == Node.TEXT_NODE</span><br><span class="line">      <span class="comment">// 文本节点</span></span><br><span class="line">      &amp;&amp; !variablesContext.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// 用属性值来替代变量</span></span><br><span class="line">    source.setNodeValue(PropertyParser.parse(source.getNodeValue(), variablesContext));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="e3QAH"></a></p><h3 id="解析过程示意图"><a class="markdownIt-Anchor" href="#解析过程示意图"></a> 解析过程示意图：</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602041595938-b2808eab-bcf7-4d37-bb5f-294e45545484.png#align=left&amp;display=inline&amp;height=211&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=275&amp;originWidth=692&amp;size=234735&amp;status=done&amp;style=none&amp;width=530" alt="image.png" /><br /><a name="MWkYB"></a></p><h1 id="注解映射解析"><a class="markdownIt-Anchor" href="#注解映射解析"></a> 注解映射解析</h1><p>Mybatis也支持使用注解来配置映射，builder包中的annocation子包就可以用来完成这种形式的映射解析。<br /><a name="unVX5"></a></p><h2 id="解析触发"><a class="markdownIt-Anchor" href="#解析触发"></a> 解析触发</h2><p>注解解析是从MapperAnnotationBuilder中的parse方法开始的。<br />该类在触发方法之前就已经在静态代码块中完成了一些初始化工作了，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  SQL_ANNOTATION_TYPES.add(Select.class);</span><br><span class="line">  SQL_ANNOTATION_TYPES.add(Insert.class);</span><br><span class="line">  SQL_ANNOTATION_TYPES.add(Update.class);</span><br><span class="line">  SQL_ANNOTATION_TYPES.add(Delete.class);</span><br><span class="line"></span><br><span class="line">  SQL_PROVIDER_ANNOTATION_TYPES.add(SelectProvider.class);</span><br><span class="line">  SQL_PROVIDER_ANNOTATION_TYPES.add(InsertProvider.class);</span><br><span class="line">  SQL_PROVIDER_ANNOTATION_TYPES.add(UpdateProvider.class);</span><br><span class="line">  SQL_PROVIDER_ANNOTATION_TYPES.add(DeleteProvider.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SQL_ANNOTATION_TYPES中放入了四种直接注解，SQL_PROVIDER_ANNOTATION_TYPES中放入了四种间接注解。<br />在mappers中标注出dao层接口以后就会触发MapperAnnotationBuilder的parse方法开始解析工作。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String resource = type.toString();</span><br><span class="line">  <span class="comment">// 防止重复分析</span></span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    <span class="comment">// 寻找类名对应的resources路径下是否有xml配置，如果有则解析。这样就可以两种模式双管齐下。</span></span><br><span class="line">    loadXmlResource();</span><br><span class="line">    <span class="comment">// 记录资源路径</span></span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    <span class="comment">// 设置命名空间</span></span><br><span class="line">    assistant.setCurrentNamespace(type.getName());</span><br><span class="line">    <span class="comment">// 处理缓存</span></span><br><span class="line">    parseCache();</span><br><span class="line">    parseCacheRef();</span><br><span class="line">    Method[] methods = type.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 排除桥接方法</span></span><br><span class="line">        <span class="keyword">if</span> (!method.isBridge()) &#123;</span><br><span class="line">          <span class="comment">// 解析方法</span></span><br><span class="line">          parseStatement(method);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">        <span class="comment">// 暂存解析异常</span></span><br><span class="line">        configuration.addIncompleteMethod(<span class="keyword">new</span> MethodResolver(<span class="keyword">this</span>, method));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  parsePendingMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>桥接方法是为了匹配泛型类型擦除而由编译器自动引入的，并非用户编写的，所以需要排除。<br />注意：在解析接口方法时可能会遇到一些尚未读取的其他信息，如尚未解析的ResultMap、命名空间信息等。这时会将该方法放入到Configuration类中的incompleteMethods属性中，在最后再次处理。在再次处理时，用到了MethodResolver对象，该对象通过调用parseStatement方法对解析失败的接口方法进行再一次解析。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parseStatement</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 通过子方法获取参数类型</span></span><br><span class="line">  Class&lt;?&gt; parameterTypeClass = getParameterType(method);</span><br><span class="line">  <span class="comment">// 获取方法的脚本语言驱动</span></span><br><span class="line">  LanguageDriver languageDriver = getLanguageDriver(method);</span><br><span class="line">  <span class="comment">// 通过注解获取SqlSource</span></span><br><span class="line">  SqlSource sqlSource = getSqlSourceFromAnnotations(method, parameterTypeClass, languageDriver);</span><br><span class="line">  <span class="keyword">if</span> (sqlSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取方法上可能存在的配置信息，配置信息由@Options注解指定</span></span><br><span class="line">    Options options = method.getAnnotation(Options.class);</span><br><span class="line">    <span class="keyword">final</span> String mappedStatementId = type.getName() + <span class="string">&quot;.&quot;</span> + method.getName();</span><br><span class="line"> <span class="comment">// 用默认值初始化各项设置，省略具体代码。</span></span><br><span class="line">    <span class="comment">// 处理主键自动生成的问题，省略具体代码</span></span><br><span class="line">    <span class="comment">// 如果存在@Options注解，则根据其中的配置信息重新配置，省略具体代码</span></span><br><span class="line">    <span class="comment">// 返回结果ResultMap处理，省略具体代码</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 将获取的映射信息存入configuration</span></span><br><span class="line">    assistant.addMappedStatement(</span><br><span class="line">        <span class="comment">// 省略代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最关键的方法就是getSqlSourceFromAnnotations，通过该方法获取了SqlSource对象，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSource <span class="title">getSqlSourceFromAnnotations</span><span class="params">(Method method, Class&lt;?&gt; parameterType, LanguageDriver languageDriver)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历寻找是否有直接注解</span></span><br><span class="line">    Class&lt;? extends Annotation&gt; sqlAnnotationType = getSqlAnnotationType(method);</span><br><span class="line">    <span class="comment">// 遍历寻找是否有间接注解</span></span><br><span class="line">    Class&lt;? extends Annotation&gt; sqlProviderAnnotationType = getSqlProviderAnnotationType(method);</span><br><span class="line">    <span class="keyword">if</span> (sqlAnnotationType != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sqlProviderAnnotationType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 两类注解不可同时使用</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;You cannot supply both a static SQL and SqlProvider to method named &quot;</span> + method.getName());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 含有直接注解的</span></span><br><span class="line">      Annotation sqlAnnotation = method.getAnnotation(sqlAnnotationType);</span><br><span class="line">      <span class="comment">// 取出value值</span></span><br><span class="line">      <span class="keyword">final</span> String[] strings = (String[]) sqlAnnotation.getClass().getMethod(<span class="string">&quot;value&quot;</span>).invoke(sqlAnnotation);</span><br><span class="line">      <span class="comment">// 基于字符串构建SqlSource</span></span><br><span class="line">      <span class="keyword">return</span> buildSqlSourceFromStrings(strings, parameterType, languageDriver);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sqlProviderAnnotationType != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 含有间接注解的</span></span><br><span class="line">      Annotation sqlProviderAnnotation = method.getAnnotation(sqlProviderAnnotationType);</span><br><span class="line">      <span class="comment">// 根据对应的方法获取SqlSource</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ProviderSqlSource(assistant.getConfiguration(), sqlProviderAnnotation, type, method);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Could not find value method on SQL annotation.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="77H4A"></a></p><h3 id="直接注解"><a class="markdownIt-Anchor" href="#直接注解"></a> 直接注解</h3><p>上述方法中直接注解映射由buildSqlSourceFromStrings负责生成，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSource <span class="title">buildSqlSourceFromStrings</span><span class="params">(String[] strings, Class&lt;?&gt; parameterTypeClass, LanguageDriver languageDriver)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> StringBuilder sql = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">  <span class="keyword">for</span> (String fragment : strings) &#123;</span><br><span class="line">    sql.append(fragment);</span><br><span class="line">    sql.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> languageDriver.createSqlSource(configuration, sql.toString().trim(), parameterTypeClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作很简单，就是直接将SQL语句的字符串拼接交给languageDriver进行处理并返回。<br /><a name="uwopA"></a></p><h2 id="间接注解"><a class="markdownIt-Anchor" href="#间接注解"></a> 间接注解</h2><p>在分析间接注解前首先要分析ProviderContext和ProviderMethodDriver两个类。<br /><a name="dmxZq"></a></p><h3 id="providercontext"><a class="markdownIt-Anchor" href="#providercontext"></a> ProviderContext</h3><p>该类的功能就是将以下三个属性整合为一个整体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供映射信息类 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; mapperType;</span><br><span class="line"><span class="comment">// 提供映射信息的方法，该方法属于mapperType类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Method mapperMethod;</span><br><span class="line"><span class="comment">// 数据库编号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String databaseId;</span><br></pre></td></tr></table></figure><p><a name="grMCT"></a></p><h3 id="providermethodresolver"><a class="markdownIt-Anchor" href="#providermethodresolver"></a> ProviderMethodResolver</h3><p>该接口默认方法是resoveMethod，其作用是从@*Provider注解的type属性所指向的类中挑出method属性中所指定的方法。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Method <span class="title">resolveMethod</span><span class="params">(ProviderContext context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 找出同名方法</span></span><br><span class="line">  List&lt;Method&gt; sameNameMethods = Arrays.stream(getClass().getMethods())</span><br><span class="line">      .filter(m -&gt; m.getName().equals(context.getMapperMethod().getName()))</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">  <span class="comment">// 如果没有找到，则抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (sameNameMethods.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Cannot resolve the provider method because &#x27;&quot;</span></span><br><span class="line">        + context.getMapperMethod().getName() + <span class="string">&quot;&#x27; not found in SqlProvider &#x27;&quot;</span> + getClass().getName() + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据返回类型再次判断，返回类型必须是CharSequence及其子类</span></span><br><span class="line">  List&lt;Method&gt; targetMethods = sameNameMethods.stream()</span><br><span class="line">      .filter(m -&gt; CharSequence.class.isAssignableFrom(m.getReturnType()))</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">  <span class="keyword">if</span> (targetMethods.size() == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 若唯一则返回该方法</span></span><br><span class="line">    <span class="keyword">return</span> targetMethods.get(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (targetMethods.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Cannot resolve the provider method because &#x27;&quot;</span></span><br><span class="line">        + context.getMapperMethod().getName() + <span class="string">&quot;&#x27; does not return the CharSequence or its subclass in SqlProvider &#x27;&quot;</span></span><br><span class="line">        + getClass().getName() + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Cannot resolve the provider method because &#x27;&quot;</span></span><br><span class="line">        + context.getMapperMethod().getName() + <span class="string">&quot;&#x27; is found multiple in SqlProvider &#x27;&quot;</span> + getClass().getName() + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要分为两个步骤：</p><ol><li>找到符合方法名的所有方法。</li><li>根据方法返回值进一步校验。<br /><a name="ymVAL"></a></li></ol><h3 id="providersqlsource"><a class="markdownIt-Anchor" href="#providersqlsource"></a> ProviderSqlSource</h3><p>该类内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Configuration对象  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line"><span class="comment">// *Provider注解上type属性所指的类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; providerType;</span><br><span class="line"><span class="comment">// 语言驱动</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LanguageDriver languageDriver;</span><br><span class="line"><span class="comment">// 含有注解的接口方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Method mapperMethod;</span><br><span class="line"><span class="comment">// *Provider注解上，method属性所指的方法</span></span><br><span class="line"><span class="keyword">private</span> Method providerMethod;</span><br><span class="line"><span class="comment">// 给定SQL语句的方法对应的参数</span></span><br><span class="line"><span class="keyword">private</span> String[] providerMethodArgumentNames;</span><br><span class="line"><span class="comment">// 给定SQL语句的方法对应的参数类型</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt;[] providerMethodParameterTypes;</span><br><span class="line"><span class="comment">// ProviderContext对象</span></span><br><span class="line"><span class="keyword">private</span> ProviderContext providerContext;</span><br><span class="line"><span class="comment">// ProviderContext对象</span></span><br><span class="line"><span class="keyword">private</span> Integer providerContextIndex;</span><br></pre></td></tr></table></figure><p>该类作为SqlSource接口的子类，实现了getBoundSql方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取sqlSource对象</span></span><br><span class="line">  SqlSource sqlSource = createSqlSource(parameterObject);</span><br><span class="line">  <span class="comment">// 从SqlSource中获取BoundSql对象</span></span><br><span class="line">  <span class="keyword">return</span> sqlSource.getBoundSql(parameterObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createSqlSource方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSource <span class="title">createSqlSource</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// SQL字符串信息存储</span></span><br><span class="line">    String sql;</span><br><span class="line">    <span class="comment">// 如果是map类型</span></span><br><span class="line">    <span class="keyword">if</span> (parameterObject <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">      <span class="keyword">int</span> bindParameterCount = providerMethodParameterTypes.length - (providerContext == <span class="keyword">null</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (bindParameterCount == <span class="number">1</span> &amp;&amp;</span><br><span class="line">        (providerMethodParameterTypes[Integer.valueOf(<span class="number">0</span>).equals(providerContextIndex) ? <span class="number">1</span> : <span class="number">0</span>].isAssignableFrom(parameterObject.getClass()))) &#123;</span><br><span class="line">        <span class="comment">// 调用*Provider注解的type类中的method方法，从而获取SQL字符串</span></span><br><span class="line">        sql = invokeProviderMethod(extractProviderMethodArguments(parameterObject));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Map&lt;String, Object&gt; params = (Map&lt;String, Object&gt;) parameterObject;</span><br><span class="line">        <span class="comment">// 调用*Provider注解的type类中的method方法，从而获得SQL字符串  </span></span><br><span class="line">        sql = invokeProviderMethod(extractProviderMethodArguments(params, providerMethodArgumentNames));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (providerMethodParameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 无需参数</span></span><br><span class="line">      sql = invokeProviderMethod();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (providerMethodParameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (providerContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 只有一个参数</span></span><br><span class="line">        sql = invokeProviderMethod(parameterObject);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 参数为providerContext</span></span><br><span class="line">        sql = invokeProviderMethod(providerContext);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (providerMethodParameterTypes.length == <span class="number">2</span>) &#123;</span><br><span class="line">      sql = invokeProviderMethod(extractProviderMethodArguments(parameterObject));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Cannot invoke SqlProvider method &#x27;&quot;</span> + providerMethod</span><br><span class="line">        + <span class="string">&quot;&#x27; with specify parameter &#x27;&quot;</span> + (parameterObject == <span class="keyword">null</span> ? <span class="keyword">null</span> : parameterObject.getClass())</span><br><span class="line">        + <span class="string">&quot;&#x27; because SqlProvider method arguments for &#x27;&quot;</span> + mapperMethod + <span class="string">&quot;&#x27; is an invalid combination.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt; parameterType = parameterObject == <span class="keyword">null</span> ? Object.class : parameterObject.getClass();</span><br><span class="line">    <span class="keyword">return</span> languageDriver.createSqlSource(configuration, sql, parameterType);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (BuilderException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error invoking SqlProvider method &#x27;&quot;</span> + providerMethod</span><br><span class="line">        + <span class="string">&quot;&#x27; with specify parameter &#x27;&quot;</span> + (parameterObject == <span class="keyword">null</span> ? <span class="keyword">null</span> : parameterObject.getClass()) + <span class="string">&quot;&#x27;.  Cause: &quot;</span> + extractRootCause(e), e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法可以概括为三步：</p><ul><li>调用*Provider注解的type类中的method方法，从而获得SQL字符串。</li><li>向languageDriver的createSqlSource方法传入SQL字符串等参数生成一个SqlSource对象。</li><li>调用SqlSource的getBoundSql方法，获得BoundSql对象。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;builder包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#builder包&quot;&gt;&lt;/a&gt; builder包&lt;/h1&gt;
&lt;p&gt;build包是一个按照类型划分出来的包，包中含有很多建造者类。虽然这个包是一个按照类型方式划分的包，但是该包</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="配置解析包" scheme="https://jie-blog.icu/categories/mybatis/%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8C%85/"/>
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>binding包</title>
    <link href="https://jie-blog.icu/posts/mybatis-binding/"/>
    <id>https://jie-blog.icu/posts/mybatis-binding/</id>
    <published>2020-11-04T04:01:32.000Z</published>
    <updated>2020-11-04T04:15:29.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="binding包"><a class="markdownIt-Anchor" href="#binding包"></a> binding包</h1><p>binding包主要负责处理Java方法与SQL语句之间绑定关系。<br />binding包主要有以下两个功能：</p><ul><li>维护映射接口中抽象方法与数据库操作节点之间的映射关系。</li><li>为映射接口中的抽象方法接入相应的数据库操作。<br /><a name="4DnUf"></a></li></ul><h1 id="数据库接入操作"><a class="markdownIt-Anchor" href="#数据库接入操作"></a> 数据库接入操作</h1><p>binding包是基于映射的动态代理实现的，该包内与接入数据库相关的类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601946515109-39ebd2b0-853d-4912-b054-e96cc74268fe.png#align=left&amp;display=inline&amp;height=358&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=715&amp;originWidth=1129&amp;size=1152659&amp;status=done&amp;style=none&amp;width=564.5" alt="image.png" /><br /><a name="w0LHb"></a></p><h2 id="mappermethod"><a class="markdownIt-Anchor" href="#mappermethod"></a> MapperMethod</h2><p>首先要做的就是要把数据库操作节点转换为一个方法。MapperMethod对象就表示数据库操作转化后的方法。每个MapperMethod对象都对应一个数据库操作节点，调用MapperMethod的execute方法就可以触发节点中的SQL语句操作数据库。<br /><a name="G2IIP"></a></p><h3 id="内部类"><a class="markdownIt-Anchor" href="#内部类"></a> 内部类</h3><p>MapperMethod类中有两个重要的属性，分别对应着两个内部类，即SqlCommand和MethodSignature。<br />还有一个重要的ParamMap属性来作为取值使用。<br /><a name="t2kzl"></a></p><h4 id="methodsignature"><a class="markdownIt-Anchor" href="#methodsignature"></a> MethodSignature</h4><p>该类指代一个具体方法的签名（细节），其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值是否是集合    </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsMany;</span><br><span class="line"><span class="comment">// 返回值是否是map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsMap;</span><br><span class="line"><span class="comment">// 返回值是否为空</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsVoid;</span><br><span class="line"><span class="comment">// 返回值类型是否是Cursor</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsCursor;</span><br><span class="line"><span class="comment">// 返回值类型是否是Optional</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsOptional;</span><br><span class="line"><span class="comment">// 该方法的返回值类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; returnType;</span><br><span class="line"><span class="comment">// 如果返回值类型是map 则在这里记录key</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String mapKey;</span><br><span class="line"><span class="comment">// resultHandle参数的位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Integer resultHandlerIndex;</span><br><span class="line"><span class="comment">// rowBounds参数的位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Integer rowBoundsIndex;</span><br><span class="line"><span class="comment">// 参数名称解析器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ParamNameResolver paramNameResolver;</span><br></pre></td></tr></table></figure><p><a name="z2YEm"></a></p><h4 id="sqlcommand"><a class="markdownIt-Anchor" href="#sqlcommand"></a> SqlCommand</h4><p>该类是指代一个SQL语句，内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SQL语句的名称   </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"><span class="comment">// SQL语句的种类，包含增、删、改、查、清缓存和未知</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlCommandType type;</span><br></pre></td></tr></table></figure><p>SqlCommand会根据传入参数完成对name和type的赋值。resolveMappedStatement字方法会根据接口找到对应的MappedStatement，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> MappedStatement <span class="title">resolveMappedStatement</span><span class="params">(Class&lt;?&gt; mapperInterface, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;?&gt; declaringClass, Configuration configuration)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数据库操作语句编号是：接口名.方法名</span></span><br><span class="line">    String statementId = mapperInterface.getName() + <span class="string">&quot;.&quot;</span> + methodName;</span><br><span class="line">    <span class="comment">// configuration保存了解析后的所有操作语句，所以在这里判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (configuration.hasStatement(statementId)) &#123;</span><br><span class="line">      <span class="comment">// 找到语句并返回</span></span><br><span class="line">      <span class="keyword">return</span> configuration.getMappedStatement(statementId);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mapperInterface.equals(declaringClass)) &#123;</span><br><span class="line">      <span class="comment">// 递归到头了都没找到，返回空值</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向上寻找直到找到接口（递归调用）</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; superInterface : mapperInterface.getInterfaces()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (declaringClass.isAssignableFrom(superInterface)) &#123;</span><br><span class="line">        MappedStatement ms = resolveMappedStatement(superInterface, methodName,</span><br><span class="line">            declaringClass, configuration);</span><br><span class="line">        <span class="keyword">if</span> (ms != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> ms;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="YzfJ8"></a></p><h3 id="总结分析"><a class="markdownIt-Anchor" href="#总结分析"></a> 总结分析</h3><p>显然MapperMethod类将一个数据库操作语句和Java语句绑定在了一起，其MethodSignature属性保存了这个方法的详细信息，SqlCommand对象持有这个方法对应的SQL语句，如下图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601948351931-e618b729-205e-42fc-89a2-f6ea1fda9ad0.png#align=left&amp;display=inline&amp;height=137&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=274&amp;originWidth=1121&amp;size=456941&amp;status=done&amp;style=none&amp;width=560.5" alt="image.png" /><br /><a name="lUEmO"></a></p><h3 id="parammap"><a class="markdownIt-Anchor" href="#parammap"></a> ParamMap</h3><p>该类是HashMap的子类，但是它比HashMap要严格：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">super</span>.containsKey(key)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Parameter &#x27;&quot;</span> + key + <span class="string">&quot;&#x27; not found. Available parameters are &quot;</span> + keySet());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获取值时，如果不存在直接抛出异常。<br /><a name="X2drJ"></a></p><h3 id="execute"><a class="markdownIt-Anchor" href="#execute"></a> execute</h3><p>只要触发了MapperMethod的execute方法就可以触发具体的数据库操作，于是数据库就被转化成了具体的方法。exectue源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">   Object result;</span><br><span class="line"><span class="comment">// 根据SQL语句不同执行不同的操作</span></span><br><span class="line">   <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">     <span class="comment">// 如果是插入语句</span></span><br><span class="line">     <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">       <span class="comment">// 调整参数和实参顺序</span></span><br><span class="line">       Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">       <span class="comment">// 执行并返回</span></span><br><span class="line">       result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果是更新语句</span></span><br><span class="line">     <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">       Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">       result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果是删除语句</span></span><br><span class="line">     <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">       Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">       result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果是查询语句</span></span><br><span class="line">     <span class="keyword">case</span> SELECT:</span><br><span class="line">       <span class="comment">// 方法返回值是void，但是方法有结果</span></span><br><span class="line">       <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">         <span class="comment">// 使用结果处理器执行查询</span></span><br><span class="line">         executeWithResultHandler(sqlSession, args);</span><br><span class="line">         result = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 方法返回值是集合</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">         result = executeForMany(sqlSession, args);</span><br><span class="line">       <span class="comment">// 方法返回值是map</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">         result = executeForMap(sqlSession, args);</span><br><span class="line">       <span class="comment">// 方法返回值是Cursor</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">         result = executeForCursor(sqlSession, args);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 单条结果查询</span></span><br><span class="line">         Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">         result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">         <span class="comment">// 查询结果为null或者返回值类型不匹配，返回值是Optional</span></span><br><span class="line">         <span class="keyword">if</span> (method.returnsOptional()</span><br><span class="line">             &amp;&amp; (result == <span class="keyword">null</span> || !method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">           result = Optional.ofNullable(result);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     <span class="comment">// 如果是刷新语句</span></span><br><span class="line">     <span class="keyword">case</span> FLUSH:</span><br><span class="line">       result = sqlSession.flushStatements();</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Unknown execution method for: &quot;</span> + command.getName());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 查询结果为空，但返回值为基本类型且不为空</span></span><br><span class="line">   <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Mapper method &#x27;&quot;</span> + command.getName()</span><br><span class="line">         + <span class="string">&quot; attempted to return null from a method with a primitive return type (&quot;</span> + method.getReturnType() + <span class="string">&quot;).&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><a name="qPA1A"></a></p><h2 id="mapperproxy"><a class="markdownIt-Anchor" href="#mapperproxy"></a> MapperProxy</h2><p>在MapperMethod方法把数据库操作转换成了一个方法，这里又要通过MapperProxy来将数据库操作方法接入映射接口的抽象方法中，即可以使用动态代理来调用MapperMethod的方法实现mapper文件中定义的方法的功能。<br />MapperProxy是基于动态代理针对接口映射方法调用转接成了对MapperMethod对象execute方法的调用从而实现了接口调用数据库操作的功能。<br />MapperProxy继承自InvocationHandler，是个标准的动态代理的类。当实例替代被代理对象后，对被代理对象的方法调用会被转接到MapperProxy的invoke方法上，invoke方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否继承自object</span></span><br><span class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="comment">// 直接执行原有方法</span></span><br><span class="line">      <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">    <span class="comment">// 判断是否是默认方法</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.isDefault()) &#123;</span><br><span class="line">     <span class="comment">// 执行默认方法</span></span><br><span class="line">      <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 找到对应的MapperMethod对象</span></span><br><span class="line">  <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">  <span class="comment">// 调用excute方法</span></span><br><span class="line">  <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="XocJR"></a></p><h2 id="mapperproxyfactory"><a class="markdownIt-Anchor" href="#mapperproxyfactory"></a> MapperProxyFactory</h2><p>该类的实现比较简单，就是MapperProxy的生产工厂，newInstance方法会生成一个MapperProxy对象。<br /><a name="JS5IX"></a></p><h1 id="抽象方法与数据库操作节点的关联"><a class="markdownIt-Anchor" href="#抽象方法与数据库操作节点的关联"></a> 抽象方法与数据库操作节点的关联</h1><p>前面的操作已经将与各数据库操作转换成了一个方法，甚至是一个动态代理乃至一个生产工厂，并将这个方法接入一个映射接口的抽象方法中。<br />Mapper文件如此之多，因此要在确定关联关系是个很重要的事情，Mybatis分两步完成了该任务：<br /><a name="ltuUv"></a></p><h2 id="绑定接口和映射文件"><a class="markdownIt-Anchor" href="#绑定接口和映射文件"></a> 绑定接口和映射文件</h2><p>将映射接口与MapperProxyFactory关联起来，这种关联关系是在MapperRegistry中的knowMappers属性中维护的，其属性定义：<code>private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap&lt;&gt;();</code><br />因为MapperProxyFactory的构造方法只接受一个接口类型，且不允许修改，因此MapperProxyFactory和映射接口的对应是唯一的，同样MapperProxyFactory和MapperProxy也是一一对应的，因此knowMappers间接对应了唯一的MapperProxy。<br />MapperRegistry的getMapper方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 找出指定映射接口的映射工厂</span></span><br><span class="line">  <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">  <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is not known to the MapperRegistry.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 通过mapperProxyFactory返回对应的处理器实例</span></span><br><span class="line">    <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样映射文件就和接口就通过返回的代理对象绑定了起来。<br /><a name="adtHd"></a></p><h2 id="绑定抽象方法"><a class="markdownIt-Anchor" href="#绑定抽象方法"></a> 绑定抽象方法</h2><p>现在范围已经缩减到了映射接口和MapperProxy的关系映射，接下来由MapperProxy中的MethodCache属性维护接口抽象方法和MapperMethod的映射。其属性定义如下：<code>private final Map&lt;Method, MapperMethod&gt; methodCache;</code><br />在cachedMapperMethod方法中完成了赋值操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> methodCache.computeIfAbsent(method, k -&gt; <span class="keyword">new</span> MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="aaoJk"></a></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>经过了上述两个步骤形成了下图的结构：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601951581210-b79f8609-55ae-43f2-bef5-a4fd24141d6f.png#align=left&amp;display=inline&amp;height=304&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=608&amp;originWidth=1214&amp;size=1164326&amp;status=done&amp;style=none&amp;width=607" alt="image.png" /><br />代理关系建立完成后，只要调用映射接口中的方法都会被MapperProxy截获，而MapperProxy会创建或选取合适的MapperMethod对象，并触发execute方法完成数据库操作。因而，抽象方法的调用变成了数据库操作。<br /><a name="eMsVp"></a></p><h1 id="数据库操作的总结"><a class="markdownIt-Anchor" href="#数据库操作的总结"></a> 数据库操作的总结</h1><p><a name="OCqE5"></a></p><h2 id="初始化阶段"><a class="markdownIt-Anchor" href="#初始化阶段"></a> 初始化阶段</h2><p>对各个映射文件解析时，各个数据库操作的节点信息会被记录到Configuration对象的mappedStatements属性中。该属性结构是一种StrictMap，键值为SQL语句的namespace.语句id，值为数据库操作节点信息。<br />Mybatis还会根据扫描的所有映射接口，根据映射接口创建与之关联的MapperProxyFactory，两者关联关系由MapperRegistry维护。当调用getMapper方法时，MapperProxyFactory会生产出一个MapperProxy对象作为映射接口代理。<br /><a name="DNIQ1"></a></p><h2 id="读写阶段"><a class="markdownIt-Anchor" href="#读写阶段"></a> 读写阶段</h2><p>当接口方法被调用时会被MapperProxy所劫持，触发内部的invoke方法，从而创建MapperMethod对象。<br />在创建MapperMethod的过程中，MapperMethod中的sqlCommond子类的构造方法会去Configuration对象的mappedStatements属性中获取当前映射接口名、其他的SQL语句信息。<br />之后execute方法会被触发来执行数据库操作。<br /><a name="X35TD"></a></p><h1 id="spring整合"><a class="markdownIt-Anchor" href="#spring整合"></a> Spring整合</h1><p>在Spring的application.xml中配置mapper文件所在的位置后，Spring在启动阶段会对指定路径进行扫描。对于扫描到的映射接口，mybatis-spring会将其当做MapperFactoryBean对象注册到Spring的Bean列表中。而MapperFactoryBean可以给出映射接口的代理类。这样就可以实现自动注入的功能。<br />springboot同理，知识增加了负责完成自动配置工作的mybatis-spring-boot-autoconfigure项目而已。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;binding包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#binding包&quot;&gt;&lt;/a&gt; binding包&lt;/h1&gt;
&lt;p&gt;binding包主要负责处理Java方法与SQL语句之间绑定关系。&lt;br /&gt;binding包主要有以下两个</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="配置解析包" scheme="https://jie-blog.icu/categories/mybatis/%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8C%85/"/>
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>配置解析概述</title>
    <link href="https://jie-blog.icu/posts/mybatis-title/"/>
    <id>https://jie-blog.icu/posts/mybatis-title/</id>
    <published>2020-11-04T04:00:08.000Z</published>
    <updated>2020-11-04T04:15:28.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置解析概述"><a class="markdownIt-Anchor" href="#配置解析概述"></a> 配置解析概述</h1><p>Mybatis的配置解析依赖两个文件进行：</p><ul><li>配置文件，里面包含了Mybatis的基本信息，该文件只有一个。</li><li>映射文件，这里面设置了Java对象和数据库属性之间的映射关系、数据库操作语句等。该文件可以有多个。</li></ul><p>Mybatis首先要完成以上两类文件的解析，并根据解析的信息设置好Mybatis的运行环境以备使用。<br />所谓的解析过程就是将配置信息提取、转化，最终在Java对象中保存的过程。</p><hr /><p>按照上述思路，从类的角度分析，可以将配置解析相关的类分为以下两种：</p><ul><li>解析类（含接口）：提供配置的解析功能，完成配置信息的提取、转化。</li><li>解析实体类（含接口）：提供配置保存功能。该类在结构上与配置信息有对应的关系。配置信息最终会保存到解析实体类的属性中。</li></ul><p>注意：这种划分不是绝对的，因为存在一个二者皆是的。<br /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;配置解析概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#配置解析概述&quot;&gt;&lt;/a&gt; 配置解析概述&lt;/h1&gt;
&lt;p&gt;Mybatis的配置解析依赖两个文件进行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置文件，里面包含了Mybatis的基本信息，该文</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="配置解析包" scheme="https://jie-blog.icu/categories/mybatis/%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8C%85/"/>
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>parsing包</title>
    <link href="https://jie-blog.icu/posts/mybatis-parsing/"/>
    <id>https://jie-blog.icu/posts/mybatis-parsing/</id>
    <published>2020-11-04T03:59:14.000Z</published>
    <updated>2020-11-04T04:15:27.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="parsing包"><a class="markdownIt-Anchor" href="#parsing包"></a> parsing包</h1><p>Mybatis的parsing包就是用来解析XML文件的包，要了解该包前，要先回顾一下以下基础知识。<br /><a name="VawTP"></a></p><h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1><p><a name="CLYI0"></a></p><h2 id="xml文件"><a class="markdownIt-Anchor" href="#xml文件"></a> XML文件</h2><p>扩展标记语言（XML）是一种标记语言。标记语言即指计算机所能理解的信息符号，通过标记可以实现软件开发者与计算机之间的信息沟通。<br />XML可扩展的一个重要表现就是XML文档的结构是可以自由定义的。XML的节点包括元素节点、属性节点、文本节点、文档节点等。定义的XML文档可以用DTD，也可以用XML Schema。<br /><a name="c8zEb"></a></p><h2 id="xpath"><a class="markdownIt-Anchor" href="#xpath"></a> XPath</h2><p>XML表述的是一种树状结构，而XPath（XML路径语言）作为一种小型的查询语言能够根据XML结构树在树上寻找节点。<br />解析样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String resource = <span class="string">&quot;info.xml&quot;</span>;</span><br><span class="line">            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">            DocumentBuilder db = dbf.newDocumentBuilder();</span><br><span class="line">            Document doc = db.parse(Thread.currentThread().getContextClassLoader().getResourceAsStream(resource));</span><br><span class="line">            XPathFactory factory = XPathFactory.newInstance();</span><br><span class="line">            XPath xpath = factory.newXPath();</span><br><span class="line">            XPathExpression compile = xpath.compile(<span class="string">&quot;/members/user[id=1]&quot;</span>);</span><br><span class="line">            System.out.println(compile.evaluate(doc));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="s8sls"></a></p><h1 id="xml解析"><a class="markdownIt-Anchor" href="#xml解析"></a> XML解析</h1><p>Mybatis的配置文件与映射文件均是XML文件，因此解析并读取XML文档的内容是Mybatis展开后续工作的基础。<br />XPathParser和XNode类是两个最为关键的类，其主要关系如下图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601866214309-2172d457-bd4b-4692-a083-85a164bb8b5d.png#align=left&amp;display=inline&amp;height=188&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=375&amp;originWidth=1055&amp;size=491882&amp;status=done&amp;style=none&amp;width=527.5" alt="image.png" /><br /><a name="CUkwH"></a></p><h2 id="xpathparser"><a class="markdownIt-Anchor" href="#xpathparser"></a> XpathParser</h2><p>XpathParser内部封装了XPath类的对象，因此XpathParser具有解析XML的能力，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要解析的XML文档  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Document document;</span><br><span class="line"><span class="comment">// 是否开启验证</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> validation;</span><br><span class="line"><span class="comment">// 声明寻找DTD文件的方法，本地寻找还是网络下载</span></span><br><span class="line"><span class="keyword">private</span> EntityResolver entityResolver;</span><br><span class="line"><span class="comment">// Mybatis配置文件的Properties节点</span></span><br><span class="line"><span class="keyword">private</span> Properties variables;</span><br><span class="line"><span class="comment">// XPath工具</span></span><br><span class="line"><span class="keyword">private</span> XPath xpath;</span><br></pre></td></tr></table></figure><p>该类内部有很多重载的构造，他们均是传入参数并且初始化document属性的此外。此外，其还提供大量的eval*方法，这些方法最后都调用了evaluate方法，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">evaluate</span><span class="params">(String expression, Object root, QName returnType)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> xpath.evaluate(expression, root, returnType);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error evaluating XPath.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，这里调用的是xpath的方法，因此，整个XPathParser类的本质是对XPath的封装和调用。<br /><a name="807Iu"></a></p><h2 id="xnode"><a class="markdownIt-Anchor" href="#xnode"></a> XNode</h2><p>同理，可以把XNode看作是Node类的包装类。其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XML的一个节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node node;</span><br><span class="line"><span class="comment">// 节点名</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"><span class="comment">// 节点体</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String body;</span><br><span class="line"><span class="comment">// 节点属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Properties attributes;</span><br><span class="line"><span class="comment">// Mybatis Properties信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Properties variables;</span><br><span class="line"><span class="comment">// XML解析器XPathParser</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> XPathParser xpathParser;</span><br></pre></td></tr></table></figure><p>XNode里封装了XPathParser对象。显然，XNode封装了自身的解析器，在一个类中封装自身的解析器是一种常见的做法，如此一来他便获得了解析自身的能力，从而减少了对外部的依赖，具有内聚性。<br /><a name="8tsij"></a></p><h2 id="变量替换"><a class="markdownIt-Anchor" href="#变量替换"></a> 变量替换</h2><p>XPathParser类中还有一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">evalString</span><span class="params">(Object root, String expression)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 解析出来的字符结果</span></span><br><span class="line">  String result = (String) evaluate(expression, root, XPathConstants.STRING);</span><br><span class="line">  <span class="comment">// 对字符中的属性进行处理</span></span><br><span class="line">  result = PropertyParser.parse(result, variables);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PropertyParser.parse方法对解析出来的结果进行了进一步的处理。<br />PropertyParser是属性解析器，其类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601868758405-fa3a10f2-5e25-4ded-8476-f4920fc1e362.png#align=left&amp;display=inline&amp;height=292&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=584&amp;originWidth=868&amp;size=663796&amp;status=done&amp;style=none&amp;width=434" alt="image.png" /><br /><a name="yFB0h"></a></p><h3 id="generictokenparser"><a class="markdownIt-Anchor" href="#generictokenparser"></a> GenericTokenParser</h3><p>GenericTokenParser是通用的占位符解析器，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 占位符起始标志</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String openToken;</span><br><span class="line"><span class="comment">// 占位符结束标志</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String closeToken;</span><br><span class="line"><span class="comment">// 占位符处理器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TokenHandler handler;</span><br></pre></td></tr></table></figure><p>其内部仅有的方法时parse方法，其主要完成的是占位符的定位工作，然后替换工作交给TokenHandler来处理。<br />此外，GenericTokenParser提供的占位符定位功能应用十分广泛，不仅仅局限在XML解析中，SQL语句中的“#{}”或“${}”也离不开该类的解析。<br /><a name="sqcfP"></a></p><h3 id="tokenhandler"><a class="markdownIt-Anchor" href="#tokenhandler"></a> TokenHandler</h3><p>PropertyParser内部类VariableTokenHandler就实现了该接口，其属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入的属性变量，是HashTable的子类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Properties variables;</span><br><span class="line"><span class="comment">// 是否启用默认值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> enableDefaultValue;</span><br><span class="line"><span class="comment">// 如果启用默认值则表示键和默认值之间的分隔符</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String defaultValueSeparator;</span><br></pre></td></tr></table></figure><p>向handleToken方法中传入参数后，该方法会以输入参数为键尝试从variables中获取值并返回，这个键值寻找的过程中还支持默认值，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">handleToken</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (variables != <span class="keyword">null</span>) &#123;</span><br><span class="line">      String key = content;</span><br><span class="line">      <span class="comment">// 如果启动默认值，则设置默认值</span></span><br><span class="line">      <span class="keyword">if</span> (enableDefaultValue) &#123;</span><br><span class="line">        <span class="comment">// 找出键与默认值分隔符的位置</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> separatorIndex = content.indexOf(defaultValueSeparator);</span><br><span class="line">        String defaultValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (separatorIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 分隔符以前是键</span></span><br><span class="line">          key = content.substring(<span class="number">0</span>, separatorIndex);</span><br><span class="line">          <span class="comment">// 分隔符以后是默认值</span></span><br><span class="line">          defaultValue = content.substring(separatorIndex + defaultValueSeparator.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (defaultValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 非默认值方式寻值</span></span><br><span class="line">          <span class="keyword">return</span> variables.getProperty(key, defaultValue);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (variables.containsKey(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> variables.getProperty(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果variables为空，原样返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;$&#123;&quot;</span> + content + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到parse方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parse</span><span class="params">(String string, Properties variables)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 负责替换字符串的类</span></span><br><span class="line">  VariableTokenHandler handler = <span class="keyword">new</span> VariableTokenHandler(variables);</span><br><span class="line">  <span class="comment">// 创建通用占位符的类</span></span><br><span class="line">  GenericTokenParser parser = <span class="keyword">new</span> GenericTokenParser(<span class="string">&quot;$&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>, handler);</span><br><span class="line">  <span class="comment">// 开展解析，即替换占位符中的值</span></span><br><span class="line">  <span class="keyword">return</span> parser.parse(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样只要XML中使用“${}”包围一个变量名，该变量名就会被解析替换成properties节点中对应的值。<br />s</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;parsing包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#parsing包&quot;&gt;&lt;/a&gt; parsing包&lt;/h1&gt;
&lt;p&gt;Mybatis的parsing包就是用来解析XML文件的包，要了解该包前，要先回顾一下以下基础知识。&lt;br </summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="基础功能包" scheme="https://jie-blog.icu/categories/mybatis/%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%8C%85/"/>
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>logging包</title>
    <link href="https://jie-blog.icu/posts/mybatis-logging/"/>
    <id>https://jie-blog.icu/posts/mybatis-logging/</id>
    <published>2020-11-04T03:58:08.000Z</published>
    <updated>2020-11-04T04:15:26.676Z</updated>
    
    <content type="html"><![CDATA[<h1 id="logging包"><a class="markdownIt-Anchor" href="#logging包"></a> logging包</h1><p>logging包负责完成Mybatis操作中的日志记录工作。<br /><a name="CCKd0"></a></p><h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1><p><a name="FjPog"></a></p><h2 id="适配器模式"><a class="markdownIt-Anchor" href="#适配器模式"></a> 适配器模式</h2><p>适配器模式是一种结构性模式，基于该模式设计的类能够在两个或者多个不兼容的类之间起到沟通桥梁的作用。<br />适配器模式能够使得原本不兼容的类可以一起工作。通常情况下，如果目标类是可以修改的，则不需要使用适配器模式进行干预了，直接修改目标类即可。但如果目标类是不可修改的（例如目标类由外部提供，或者目标类被众多其他类依赖必须保持不变），那么就可以使用适配器模式。<br /><a name="C4OCm"></a></p><h2 id="日志框架与日志级别"><a class="markdownIt-Anchor" href="#日志框架与日志级别"></a> 日志框架与日志级别</h2><p>日志框架是一种在目标对象发生变化时将相关信息记录进日志文件框架。这样，当目标对象出现问题或需要检查目标对象变动历史时，日志框架记录的日志文件便可以提供翔实的资料。<br />常见日志等级划分如下：</p><ul><li>Fatal：致命等级的日志，指发生了严重的会导致应用程序退出的事件。</li><li>Error：错误等级的日志，指发生了错误，但是不影响系统运行。</li><li>Warn：警告等级的日志，指发生了异常没可能是潜在的错误。</li><li>Info：信息登记的日志，指一些在颗粒度级别上需要强调的应用程序运行信息。</li><li>Debug：调试等级日志，指一些颗粒对于程序调试有帮助的信息。</li><li>Trace：跟踪等级的日志，指一些包含程序运行调试过程的信息。</li></ul><p>很多日志框架都可以定义日志的级别，也可以根据日志等级进行输出，防止大量的日志信息混杂在一起。<br /><a name="wOB2d"></a></p><h2 id="基于反射的动态代理"><a class="markdownIt-Anchor" href="#基于反射的动态代理"></a> 基于反射的动态代理</h2><p>之前回顾过静态代理，这里回顾一下基于反射的动态代理。<br />动态代理灵活性很多，它在代码运行时动态的为一个对象增加代理，并且能为代理对象动态的增加方法。<br />具体实现方法详见后续的源码分析。<br /><a name="FJEpx"></a></p><h1 id="log接口"><a class="markdownIt-Anchor" href="#log接口"></a> Log接口</h1><p>logger包中最核心的就是Log接口，其有11个实现类分布在logging包的不同子包中。<br />Log接口中定义了如下几个抽象方法：<br /><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601807799081-eea08218-79c5-4357-8c0b-f2df6d38409d.png#align=left&amp;display=inline&amp;height=114&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=228&amp;originWidth=370&amp;size=38052&amp;status=done&amp;style=none&amp;width=185" alt="image.png" /></strong><br />其含义分别是：</p><ul><li>error：打印Error级别的日志。</li><li>warn：打印Warn级别日志。</li><li>debug：打印Debug级别日志。</li><li>trace：打印Trace级别的日志。</li><li>isDebugEnable：判断打印Debug级别日志的功能是否开启。</li><li>isTraceEnable：判断打印Trace级别日志的功能是否开启。<br /><a name="nz0kq"></a></li></ul><h1 id="log接口的实现类"><a class="markdownIt-Anchor" href="#log接口的实现类"></a> Log接口的实现类</h1><p>Log接口的实现类一共有11个，这里就不进行逐一详细的分析。<br />NoLoggingImpl：望文生义，其内部没有什么具体的实现，只是一种Log接口的实现罢了。<br />StdOutImpl：其方法也没什么特别，只是对error级别的日志进行err级别的打印罢了。<br />Slf4jLocationAwareLoggerImpl和Sl4jLoggerImpl类只是Slf4jImpl的装饰器。<br />Log4jAbstractLoggerImpl和Log4j2LoggerImpl类是Log4j2Impl的装饰器。<br />这样 就剩下了五个实现类。接下来以JakartaCommonsLoggingImpl类的为例来分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JakartaCommonsLoggingImpl</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">ibatis</span>.<span class="title">logging</span>.<span class="title">Log</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Log log;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JakartaCommonsLoggingImpl</span><span class="params">(String clazz)</span> </span>&#123;</span><br><span class="line">    log = LogFactory.getLog(clazz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isDebugEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isTraceEnabled();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略其他源码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JakartaCommonsLoggingImpl是一个典型的对象适配器，其内部持有一个org.apache.ibatis.logging.Log对象，然后所有方法都将操作委托给了该对象。<br /><a name="3ni1T"></a></p><h1 id="logfactory"><a class="markdownIt-Anchor" href="#logfactory"></a> LogFactory</h1><p>该类就是一个制造实现类的工厂，最终，该工厂会给出一个可用的Log实现类，有它来完成日志打印的工作。<br />Log接口的实现类都是对象适配器，最终的实际工作都要委托给被适配的目标对象来完成。LogFactory的主要工作就是尝试生成各个目标对象。该功能是通过如下静态代码块实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  tryImplementation(LogFactory::useSlf4jLogging);</span><br><span class="line">  tryImplementation(LogFactory::useCommonsLogging);</span><br><span class="line">  tryImplementation(LogFactory::useLog4J2Logging);</span><br><span class="line">  tryImplementation(LogFactory::useLog4JLogging);</span><br><span class="line">  tryImplementation(LogFactory::useJdkLogging);</span><br><span class="line">  tryImplementation(LogFactory::useNoLogging);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tryImplementation</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (logConstructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      runnable.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="comment">// ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用runnable.run方法不会触发不会触发多线程，因此这里的多个tryImplementation是依次执行的，而这里的useNoLogging就是他的保底实现类，即不输出任何日志。<br />跟随断点来到了setImplementation方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setImplementation</span><span class="params">(Class&lt;? extends Log&gt; implClass)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 当前日志实现类的构造方法</span></span><br><span class="line">    Constructor&lt;? extends Log&gt; candidate = implClass.getConstructor(String.class);</span><br><span class="line">    <span class="comment">// 尝试生成日志实现类的实例</span></span><br><span class="line">    Log log = candidate.newInstance(LogFactory.class.getName());</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;Logging initialized using &#x27;&quot;</span> + implClass + <span class="string">&quot;&#x27; adapter.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果运行到这里，说明没有异常发生，则实例化日志实现类成功</span></span><br><span class="line">    logConstructor = candidate;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> LogException(<span class="string">&quot;Error setting Log implementation.  Cause: &quot;</span> + t, t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当外部调用getLog方法时，便可以由logConstructor创建一个Log类的实例。.<br /><a name="p9hgu"></a></p><h1 id="jdbc日志打印"><a class="markdownIt-Anchor" href="#jdbc日志打印"></a> JDBC日志打印</h1><p>jdbc子包基于代理模式，让Mybatis能够将JDBC的操作日志打印出来。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601811138309-d5a08dd6-effe-4ce2-938b-1784c8a9bcbe.png#align=left&amp;display=inline&amp;height=169&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=337&amp;originWidth=1195&amp;size=600702&amp;status=done&amp;style=none&amp;width=597.5" alt="image.png" /><br />BaseJdbcLogger各个子类使用动态代理（继承InvactionHandler接口）来实现日志的打印。<br />以下以ConnectionLogger为例进行的invoke方法进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获得方法来源，如果方法继承来自Object类，则直接交给目标对象执行</span></span><br><span class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, params);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;prepareStatement&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDebugEnabled()) &#123;</span><br><span class="line">        <span class="comment">// 输出方法中的参数信息</span></span><br><span class="line">        debug(<span class="string">&quot; Preparing: &quot;</span> + removeBreakingWhitespace((String) params[<span class="number">0</span>]), <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 交由目标对象执行</span></span><br><span class="line">      PreparedStatement stmt = (PreparedStatement) method.invoke(connection, params);</span><br><span class="line">      <span class="comment">// 返回一个PreparedStatementLogger对象，代理PreparedStatement完成日志打印</span></span><br><span class="line">      stmt = PreparedStatementLogger.newInstance(stmt, statementLog, queryStack);</span><br><span class="line">      <span class="keyword">return</span> stmt;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;prepareCall&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDebugEnabled()) &#123;</span><br><span class="line">        debug(<span class="string">&quot; Preparing: &quot;</span> + removeBreakingWhitespace((String) params[<span class="number">0</span>]), <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 交由目标对象执行</span></span><br><span class="line">      PreparedStatement stmt = (PreparedStatement) method.invoke(connection, params);</span><br><span class="line">      <span class="comment">// 返回一个PreparedStatementLogger对象，代理PreparedStatement完成日志打印</span></span><br><span class="line">      stmt = PreparedStatementLogger.newInstance(stmt, statementLog, queryStack);</span><br><span class="line">      <span class="keyword">return</span> stmt;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;createStatement&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">      <span class="comment">// 交由目标对象执行</span></span><br><span class="line">      Statement stmt = (Statement) method.invoke(connection, params);</span><br><span class="line">      <span class="comment">// 返回一个StatementLogger对象，代理Statement完成日志打印</span></span><br><span class="line">      stmt = StatementLogger.newInstance(stmt, statementLog, queryStack);</span><br><span class="line">      <span class="keyword">return</span> stmt;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 其他方法</span></span><br><span class="line">      <span class="keyword">return</span> method.invoke(connection, params);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;logging包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#logging包&quot;&gt;&lt;/a&gt; logging包&lt;/h1&gt;
&lt;p&gt;logging包负责完成Mybatis操作中的日志记录工作。&lt;br /&gt;
&lt;a name=&quot;CCKd0&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="基础功能包" scheme="https://jie-blog.icu/categories/mybatis/%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%8C%85/"/>
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>I/O包</title>
    <link href="https://jie-blog.icu/posts/mybatis-i_o/"/>
    <id>https://jie-blog.icu/posts/mybatis-i_o/</id>
    <published>2020-11-04T03:57:01.000Z</published>
    <updated>2020-11-04T04:15:25.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="io包"><a class="markdownIt-Anchor" href="#io包"></a> I/O包</h1><p>顾名思义，I/O包即输入输出包，负责完成对Mybatis的输入输出相关的操作。<br />在Mybatis中，与磁盘文件的交互主要是对xml配置文件的读写。因此，I/O包中主要提供对磁盘文件读操作的支持。此外，I/O包还提供对内存中类文件（class文件）的操作。<br /><a name="Zlflf"></a></p><h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1><p>要想细致分析I/O包，要对以下知识点留有概念。<br /><a name="YdFbS"></a></p><h2 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h2><p>使用单例模式的类提供的一个方法得到该类的对象就可以保证该类的对象是唯一的。<br /><a name="aBTVC"></a></p><h2 id="代理模式"><a class="markdownIt-Anchor" href="#代理模式"></a> 代理模式</h2><p>代理模式是指建立某一个对象的代理对象，并且由代理对象控制对原对象的引用。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601706025779-12f34328-cbee-460b-af68-af3e764f17a2.png#align=left&amp;display=inline&amp;height=352&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=352&amp;originWidth=839&amp;size=400691&amp;status=done&amp;style=none&amp;width=839" alt="image.png" /><br />代理类能够实现很多功能：</p><ul><li>隔离功能：能够建立一个目标对象的代理对象。从而防止外部对目标对象的访问。可以在代理对象中增加身份验证等功能，从而实现对目标对象的安全防护。</li><li>扩展功能：对一个目标对象建立代理对象后，可以在代理对象中增加更多的扩展功能。</li><li>直接替换：对一个目标对象建立代理对象后，可以直接使用代理对象完全替换目标对象，由代理对象实现全部的功能。<br /><a name="Y5NxH"></a></li></ul><h3 id="静态代理"><a class="markdownIt-Anchor" href="#静态代理"></a> 静态代理</h3><p>所谓静态，是指代理对象和被代理对象在程序中是确定的，不会在程序运行过程中发生变化。<br /><a name="GzGiG"></a></p><h3 id="动态代理"><a class="markdownIt-Anchor" href="#动态代理"></a> 动态代理</h3><p>静态代理的特点就是其局限性，这样的代理方法十分不灵活，动态代理就可以完美的解决这一问题。<br /><a name="MRCtQ"></a></p><h2 id="vfs"><a class="markdownIt-Anchor" href="#vfs"></a> VFS</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601706043407-f2b5b78a-e0fe-4982-a0ac-097c2edfa1b9.png#align=left&amp;display=inline&amp;height=546&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=546&amp;originWidth=938&amp;size=769135&amp;status=done&amp;style=none&amp;width=938" alt="image.png" /><br />磁盘文件系统可以分为很多种，如：FAT、VFAT、NFS、NTFS等。不同的文件系统操作不同，VFS作为一个虚拟的文件系统，将各个磁盘文件系统的差异屏蔽起来，提供了统一的操作。在操作磁盘文件时，软件程序只需要和VFS沟通即可。<br /><a name="0aK5T"></a></p><h1 id="vfs的实现类"><a class="markdownIt-Anchor" href="#vfs的实现类"></a> VFS的实现类</h1><p>Mybatis的io包中的VFS的作用是从应用服务器中寻找和读取资源文件。IO包中VFS相关类主要有三个：VFS、DefaultVFS、JBoss6VFS。<br />DefaultVFS和JBoss6VFS是VFS的两个实现类，在确定了具体实现类之后，外部只需调用VFS中的方法就可以完成外部文件读取的操作。<br /><a name="pStL4"></a></p><h2 id="vfs分析"><a class="markdownIt-Anchor" href="#vfs分析"></a> VFS分析</h2><p>VFS的内部核心属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储内置的VFS实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] IMPLEMENTATIONS = &#123; JBoss6VFS.class, DefaultVFS.class &#125;;</span><br><span class="line"><span class="comment">// 存储用户自定的VFS实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Class&lt;? extends VFS&gt;&gt; USER_IMPLEMENTATIONS = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>观察其内部接口可知，VFS有一个VFSHolder内部类，其使用了单例模式的方法定义了VFS的实现类。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最终生成的VFS对象    </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> VFS INSTANCE = createVFS();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> VFS <span class="title">createVFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// VFS实现类列表</span></span><br><span class="line">      List&lt;Class&lt;? extends VFS&gt;&gt; impls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="comment">// 先添加用户自定义的实现类，因此用户自定义实现类的优先级最高</span></span><br><span class="line">      impls.addAll(USER_IMPLEMENTATIONS);</span><br><span class="line">      impls.addAll(Arrays.asList((Class&lt;? extends VFS&gt;[]) IMPLEMENTATIONS));</span><br><span class="line"></span><br><span class="line">      VFS vfs = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 依次生成实现类实例，找出第一个可用实例并返回</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; vfs == <span class="keyword">null</span> || !vfs.isValid(); i++) &#123;</span><br><span class="line">        Class&lt;? extends VFS&gt; impl = impls.get(i);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 生成一个实现类对象</span></span><br><span class="line">          vfs = impl.newInstance();</span><br><span class="line">          <span class="comment">// 判断对象是否可用</span></span><br><span class="line">          <span class="keyword">if</span> (vfs == <span class="keyword">null</span> || !vfs.isValid()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">              log.debug(<span class="string">&quot;VFS implementation &quot;</span> + impl.getName() +</span><br><span class="line">                  <span class="string">&quot; is not valid in this environment.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">          log.error(<span class="string">&quot;Failed to instantiate &quot;</span> + impl, e);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Using VFS adapter &quot;</span> + vfs.getClass().getName());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> vfs;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><a name="l9axx"></a></p><h2 id="defaultvfs"><a class="markdownIt-Anchor" href="#defaultvfs"></a> DefaultVFS</h2><p>该类是VFS的默认实现类之一，其isVaild返回的值恒为true，因此，VFS最终生成的对象至少会为DefaultVFS实例。除此之外，其内部还有如下几个方法：</p><ul><li>list：列出指定url下符合条件的资源名称。</li><li>listResources：列出给定Jar包中符合条件的资源名称。</li><li>findJarForResource：找出指定路径上的jar包中符合条件的资源名称。</li><li>getPackagePath：将jar包名称转换为路径。</li><li>isJar：判断指定路径上是否为jar包。<br /><a name="jXfL0"></a></li></ul><h2 id="jboss6vfs"><a class="markdownIt-Anchor" href="#jboss6vfs"></a> JBoss6VFS</h2><p>JBoss6VFS是借鉴JBoss6设计的一套VFS实现类。其主要存在两个内部类：</p><ul><li>Virsual6VFS：仿照JBoss中VirsualFile设计的一个功能子集。</li><li>VFS：仿照JBoss中VFS类设计的一个功能子集。</li></ul><p>经过源码分析发现，这两个类的方法都没实现具体的操作，而是通过invoke调用JBoss的相关方法。因此可以认为其内部类都是代理类，只负责完成将相关操作传给被代理类工作。至于确定被代理类是否存在的工作，在initialize方法中完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  initialize();</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (valid == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 假设可用</span></span><br><span class="line">    valid = Boolean.TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L校验所需的类是否存在，不存在变为不可用</span></span><br><span class="line">    VFS.VFS = checkNotNull(getClass(<span class="string">&quot;org.jboss.vfs.VFS&quot;</span>));</span><br><span class="line">    VirtualFile.VirtualFile = checkNotNull(getClass(<span class="string">&quot;org.jboss.vfs.VirtualFile&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检验所需的方法是否存在，不存在便不可用</span></span><br><span class="line">    VFS.getChild = checkNotNull(getMethod(VFS.VFS, <span class="string">&quot;getChild&quot;</span>, URL.class));</span><br><span class="line">    VirtualFile.getChildrenRecursively = checkNotNull(getMethod(VirtualFile.VirtualFile,</span><br><span class="line">        <span class="string">&quot;getChildrenRecursively&quot;</span>));</span><br><span class="line">    VirtualFile.getPathNameRelativeTo = checkNotNull(getMethod(VirtualFile.VirtualFile,</span><br><span class="line">        <span class="string">&quot;getPathNameRelativeTo&quot;</span>, VirtualFile.VirtualFile));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断上述方法的返回值是否达到预期，否则不可用</span></span><br><span class="line">    checkReturnType(VFS.getChild, VirtualFile.VirtualFile);</span><br><span class="line">    checkReturnType(VirtualFile.getChildrenRecursively, List.class);</span><br><span class="line">    checkReturnType(VirtualFile.getPathNameRelativeTo, String.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="xE7I5"></a></p><h1 id="类文件的加载"><a class="markdownIt-Anchor" href="#类文件的加载"></a> 类文件的加载</h1><p>除了读取普通文件外，有时还需要读取类文件，并加载成一个类。<br />把类文件加载成类需要类加载器的支持，ClassLoaderWrapper类中封装了五种加载器，而Resources类又对ClassLoaderWrapper进行了简单的封装，下列将会详细分析ClassLoaderWrapper。<br />五种加载器在getClassLoaders方法中进行了定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader[] getClassLoaders(ClassLoader classLoader) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ClassLoader[]&#123;</span><br><span class="line">      <span class="comment">// 作为参数传入的类加载器，可能为null</span></span><br><span class="line">      classLoader,</span><br><span class="line">      <span class="comment">// 系统默认的类加载器，如果没设置可以为null</span></span><br><span class="line">      defaultClassLoader,</span><br><span class="line">      <span class="comment">// 当前线程的线程上下文中的类加载器</span></span><br><span class="line">      Thread.currentThread().getContextClassLoader(),</span><br><span class="line">      <span class="comment">// 当前对象的类加载器</span></span><br><span class="line">      getClass().getClassLoader(),</span><br><span class="line">      <span class="comment">// 系统类加载器，在ClassLoaderWrapper构造函数中设置</span></span><br><span class="line">      systemClassLoader&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述五种类加载器优先级由高到低进行排序，在方法classForName根据类名找出指定类的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> Class&lt;?&gt; classForName(String name, ClassLoader[] classLoader) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"><span class="comment">// 对上述五种加载器进行尝试</span></span><br><span class="line">   <span class="keyword">for</span> (ClassLoader cl : classLoader) &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">null</span> != cl) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 使用当前类加载器尝试是否能够成功</span></span><br><span class="line">         Class&lt;?&gt; c = Class.forName(name, <span class="keyword">true</span>, cl);</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">null</span> != c) &#123;</span><br><span class="line">           <span class="comment">// 只要能找到目标则返回结果</span></span><br><span class="line">           <span class="keyword">return</span> c;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">         <span class="comment">// 忽略这个异常，在下面所有加载器未找到时统一抛出</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;Cannot find class: &quot;</span> + name);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><a name="05Nhw"></a></p><h1 id="resolverutil类"><a class="markdownIt-Anchor" href="#resolverutil类"></a> ResolverUtil类</h1><p>该类是一个工具类，其主要完成的是对类的筛选，这些条件可以是：</p><ul><li>是否是某个接口或类的子类</li><li>是否具有某个注解</li></ul><p>ResolverUtil设置了一个内部接口Test，该接口是一个筛选器，内部类中有一个抽象方法matches来判断指定类是否满足筛选条件。该工具类内部类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601708320241-dde058a0-da42-46f5-a990-07b18cc30b16.png#align=left&amp;display=inline&amp;height=401&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=401&amp;originWidth=1094&amp;size=624104&amp;status=done&amp;style=none&amp;width=1094" alt="image.png" /><br />如上图所示，其内部的两个实现类都重写了matches方法：</p><ul><li>IsA类中的matches方法可以判断目标类是否实现了某个接口或者继承了某个类。</li><li>AnnotatedWith的matches方法可以判断目标类是否具有某个注解。</li></ul><p>上述校验的类会放入到工具类的matches属性里。这样一来，读取某个路径上的类文件是，可以借助该工具类进行筛选，其内部的find方法支持筛选出指定路径下符合条件的类文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResolverUtil&lt;T&gt; <span class="title">find</span><span class="params">(Test test, String packageName)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获得起始包路径</span></span><br><span class="line">  String path = getPackagePath(packageName);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 找出包内的各个文件</span></span><br><span class="line">    List&lt;String&gt; children = VFS.getInstance().list(path);</span><br><span class="line">    <span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">      <span class="comment">// 判断后缀</span></span><br><span class="line">      <span class="keyword">if</span> (child.endsWith(<span class="string">&quot;.class&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 判断是否符合条件（Test可以是IsA或者AnnotatedWith）</span></span><br><span class="line">        addIfMatching(test, child);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;Could not read package: &quot;</span> + packageName, ioe);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addIfMatching方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addIfMatching</span><span class="params">(Test test, String fqn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 转化为外部名称</span></span><br><span class="line">    String externalName = fqn.substring(<span class="number">0</span>, fqn.indexOf(<span class="string">&#x27;.&#x27;</span>)).replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="comment">// 获取类加载器</span></span><br><span class="line">    ClassLoader loader = getClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;Checking to see if class &quot;</span> + externalName + <span class="string">&quot; matches criteria [&quot;</span> + test + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// 加载类文件</span></span><br><span class="line">    Class&lt;?&gt; type = loader.loadClass(externalName);</span><br><span class="line">    <span class="keyword">if</span> (test.matches(type)) &#123;</span><br><span class="line">      <span class="comment">// 添加到matches属性中</span></span><br><span class="line">      matches.add((Class&lt;T&gt;) type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;Could not examine class &#x27;&quot;</span> + fqn + <span class="string">&quot;&#x27;&quot;</span> + <span class="string">&quot; due to a &quot;</span> +</span><br><span class="line">        t.getClass().getName() + <span class="string">&quot; with message: &quot;</span> + t.getMessage());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;io包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#io包&quot;&gt;&lt;/a&gt; I/O包&lt;/h1&gt;
&lt;p&gt;顾名思义，I/O包即输入输出包，负责完成对Mybatis的输入输出相关的操作。&lt;br /&gt;在Mybatis中，与磁盘文件的交互主要是对x</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="基础功能包" scheme="https://jie-blog.icu/categories/mybatis/%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%8C%85/"/>
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>type包</title>
    <link href="https://jie-blog.icu/posts/mybatis-type/"/>
    <id>https://jie-blog.icu/posts/mybatis-type/</id>
    <published>2020-11-04T03:56:18.000Z</published>
    <updated>2020-11-04T04:15:23.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="type包"><a class="markdownIt-Anchor" href="#type包"></a> type包</h1><p>type包里有55个类，为了不头大，这里先进行简单的分类，方便进一步的分析。</p><ul><li>类型处理器<ul><li>TypeHandler：类型处理器接口。</li><li>BaseTypeHandler：类型处理器的基础实现。</li><li>TypeReference：类型参考器。</li><li>*TypeHandler：43个类型处理器。</li></ul></li><li>类型注册表：<ul><li>SimpleTypeRegistry：基本类型注册表，内部使用Set维护了所有Java基本数据类型的集合。</li><li>TypeAliasRegistry：类型别名注册表，内部使用HashMap维护了所有的类型的别名和类型关系映射。</li><li>TypeHandlerRegistry：类型处理器注册表，内部维护了所有类型与对应类型处理器的映射关系。</li></ul></li><li>注解类：<ul><li>Alias：使用该注解可以给类设置别名，设置后，别名和类型的映射关系便存入TypeAliasTypes中。</li><li>MappedJdbcTypes：想要使用自己的处理器来处理某些JDBC类型时，只需创建BaseTypeHandler的子类然后加上该注解声明其要处理的JDBC类型即可。</li><li>MappedTypes：想要使用自己的处理器处理某些Java类型时，只需创建BaseTypeHandler的子类然后加上该注解，然后声明要处理的Java类型即可。</li></ul></li><li>异常类：<ul><li>TypeException：表示类型处理相关的异常。</li></ul></li><li>枚举类：<ul><li>JdbcType：在Enum中定义了所有的JDBC类型。<br /><a name="DdBtH"></a></li></ul></li></ul><h1 id="模板模式"><a class="markdownIt-Anchor" href="#模板模式"></a> 模板模式</h1><p>分析处理器前要先了解一下模板模式。<br />在模板模式中，需要使用一个抽象类定义一套整体的步骤（即模板），而抽象类的子类则完成每个步骤的具体实现。<br /><a name="G2CfO"></a></p><h1 id="类型处理器"><a class="markdownIt-Anchor" href="#类型处理器"></a> 类型处理器</h1><p><a name="J9SFk"></a></p><h2 id="basetypehandler"><a class="markdownIt-Anchor" href="#basetypehandler"></a> BaseTypeHandler</h2><p>作为一个ORM框架，对象关系映射中的数据类型映射也就十分重要，不同字段所需的读写方法各不相同，因此需要对不同类型的字段采取相应的处理方法。<br />在type包中，将每种类型对应的处理方法封装在了对应的类型处理器中。TypeHandler和BaseTypeHandler分别是类型处理器的接口和基类，其类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601634542762-145aaf65-3411-4031-a224-12051e27a51c.png#align=left&amp;display=inline&amp;height=500&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=500&amp;originWidth=1049&amp;size=614400&amp;status=done&amp;style=none&amp;width=1049" alt="image.png" /><br />这里的BaseTypeHandler就引用了模板模式的思想，以getResult方法为例，该方法完成了异常处理等统一的工作，而与具体类型相关的getNullableResult则通过抽象方法交给具体类型处理器实现。该方法的四种定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向 PreparedStatement对象中的指定变量位置写入一个不为null的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, T parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">// 从  ResultSet中按照字段名读出一个可能为null的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">// 从  ResultSet中按照字段编号读出一个可能为null的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">getNullableResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">// 从  CallableStatement中按照字段编号读出一个可能为null的数据  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">getNullableResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><p>因为抽象方法跟具体类型相关，因此存在泛型参数T。在每种类型处理器的实现中，都给出了泛型参数的值。<br /><a name="Dg6PO"></a></p><h2 id="typereference"><a class="markdownIt-Anchor" href="#typereference"></a> TypeReference</h2><p>所有类型处理器都是TypeHandler接口的实现，因此都可以通过TypeHandler来调用。但是TypeHandler的实现如此多，就需要一种参照书来查看当前的调用使用的是哪种目标类型。<br />Mybatis定义了一个TypeReference类，它能够判断出一个TypeHandler用来处理的目标类型。其判断方法很简单，就是取出TypeHandler实现类中的泛型参数T的类型而已，这个值的类型就是要处理的目标类型。其子类BaseTypeHandler通过传入泛型的值，从而递交给TypeReference来获取目标类型。<br />该功能由getSuperclassTypeParameter实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">Type <span class="title">getSuperclassTypeParameter</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 获取clazz类带有泛型的直接父类</span></span><br><span class="line">   Type genericSuperclass = clazz.getGenericSuperclass();</span><br><span class="line">   <span class="keyword">if</span> (genericSuperclass <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">     <span class="comment">// try to climb up the hierarchy until meet something useful</span></span><br><span class="line">     <span class="keyword">if</span> (TypeReference.class != genericSuperclass) &#123;</span><br><span class="line">       <span class="comment">// 说明没有解析到足够上层，将clazz类的父类作为输入参数递归调用</span></span><br><span class="line">       <span class="keyword">return</span> getSuperclassTypeParameter(clazz.getSuperclass());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">&quot;&#x27;&quot;</span> + getClass() + <span class="string">&quot;&#x27; extends TypeReference but misses the type parameter. &quot;</span></span><br><span class="line">       + <span class="string">&quot;Remove the extension or add a type parameter to it.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 说明genericSuperclass是泛型，获取泛型的第一个参数</span></span><br><span class="line">   Type rawType = ((ParameterizedType) genericSuperclass).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">   <span class="comment">// TODO remove this when Reflector is fixed to return Types</span></span><br><span class="line">   <span class="comment">// 判断是否是参数化类型</span></span><br><span class="line">   <span class="keyword">if</span> (rawType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">     <span class="comment">// 获取参数化类型的实际类型</span></span><br><span class="line">     rawType = ((ParameterizedType) rawType).getRawType();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> rawType;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>该方法通过TypeReference的构造器中调用。<br /><a name="oNnJJ"></a></p><h1 id="类型注册表"><a class="markdownIt-Anchor" href="#类型注册表"></a> 类型注册表</h1><p>推断出目标类型以后，Mybatis还需要根据目标类型来找到相应的类型处理器，这个过程就需要各种类型注册表的帮助。<br />SimpleTypeRegistry是一个非常简单的注册表，其内部通过SIMPLE_TYPE_SET定义了很多基本类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Class&lt;?&gt;&gt; SIMPLE_TYPE_SET = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  SIMPLE_TYPE_SET.add(String.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Byte.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Short.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Character.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Integer.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Long.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Float.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Double.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Boolean.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Date.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Class.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(BigInteger.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(BigDecimal.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TypeAliasRegistry是一个别名注册表，其内部使用typeAliases属性维护了类型和别名的对应关系。<br />TypeHandlerRegistry是这三个注册表中最核心也是最关键的一个，数据类型和相关处理器都是它来维护的。接下来要详细的分析一下这个类。<br /><a name="LjNW2"></a></p><h2 id="typehandlerregistry"><a class="markdownIt-Anchor" href="#typehandlerregistry"></a> TypeHandlerRegistry</h2><p>在分析之前，要明确Java类型参数和JDBC中的类型参数是一对多的关系，比如一个String会对应数据库的varchar、char。<br />其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDBC类型与对应类型处理器的映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;  jdbcTypeHandlerMap = <span class="keyword">new</span> EnumMap&lt;&gt;(JdbcType.class);</span><br><span class="line"><span class="comment">// Java类型与Map&lt;JdbcType,TypeHandler&lt;?&gt;&gt;的映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; typeHandlerMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 未知类型的处理器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TypeHandler&lt;Object&gt; unknownTypeHandler = <span class="keyword">new</span> UnknownTypeHandler(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 键与typeHandler.getClass()，值为typeHandler。里面存储了所有的类型处理器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt; allTypeHandlersMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 空的Map&lt;jdbcType,TypeHandler&lt;?&gt;&gt;，表示该Java类型没有对应的Map&lt;jdbcType,TypeHandler&lt;?&gt;&gt;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; NULL_TYPE_HANDLER_MAP = Collections.emptyMap();</span><br><span class="line"><span class="comment">// 默认的枚举类型处理器</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;? extends TypeHandler&gt; defaultEnumTypeHandler = EnumTypeHandler.class;</span><br></pre></td></tr></table></figure><p>其实际的获取处理器的方式就是两次映射的过程：</p><ul><li>根据传入的Java类型，调用getJdbcHandlerMap字方法寻找对应的jdbcTypeHandler后返回。</li><li>基于jdbcTypeHandlerMap，根据JDBC类型找到对应的TypeHandler。</li></ul><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">TypeHandler&lt;T&gt; <span class="title">getTypeHandler</span><span class="params">(Type type, JdbcType jdbcType)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否是单一的Java类型</span></span><br><span class="line">  <span class="keyword">if</span> (ParamMap.class.equals(type)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据Java类型找到对应的jdbcHandlerMap</span></span><br><span class="line">  Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; jdbcHandlerMap = getJdbcHandlerMap(type);</span><br><span class="line">  TypeHandler&lt;?&gt; handler = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (jdbcHandlerMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据JDBC类型找寻对应的处理器</span></span><br><span class="line">    handler = jdbcHandlerMap.get(jdbcType);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      handler = jdbcHandlerMap.get(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// #591</span></span><br><span class="line">      handler = pickSoleHandler(jdbcHandlerMap);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// type drives generics here</span></span><br><span class="line">  <span class="keyword">return</span> (TypeHandler&lt;T&gt;) handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;type包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#type包&quot;&gt;&lt;/a&gt; type包&lt;/h1&gt;
&lt;p&gt;type包里有55个类，为了不头大，这里先进行简单的分类，方便进一步的分析。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型处理器
&lt;ul&gt;
</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="基础功能包" scheme="https://jie-blog.icu/categories/mybatis/%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%8C%85/"/>
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>annocations包与lang包</title>
    <link href="https://jie-blog.icu/posts/mybatis-annocations&amp;lang/"/>
    <id>https://jie-blog.icu/posts/mybatis-annocations&amp;lang/</id>
    <published>2020-11-04T03:54:39.000Z</published>
    <updated>2020-11-04T04:15:29.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="annocations包与lang包"><a class="markdownIt-Anchor" href="#annocations包与lang包"></a> annocations包与lang包</h1><p>这两个包中存放的都是自定义的注解类，这里只分析其共性，就不一一进行分析了。<br /><a name="pwrG6"></a></p><h1 id="java的注解详解"><a class="markdownIt-Anchor" href="#java的注解详解"></a> Java的注解详解</h1><p>以随机一个注解为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.PARAMETER)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Param &#123;</span><br><span class="line">  <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，这个自定义的注解类还会包含很多其他的注解，这些注解其他注解的注解称为元注解。<br />元注解共有五个：@Target、@Retention、@Documented、@Interited、@Repeatable。其分别含义：<br /><a name="FlT6B"></a></p><h2 id="target"><a class="markdownIt-Anchor" href="#target"></a> @Target</h2><p>该注解是用来声明注解可以用在什么地方的，他的值需要从枚举类ElementType中选取，ElementType的枚举值如下：</p><ul><li>TYPE：类、接口、注释、枚举。</li><li>FIELD：字段。</li><li>METHOD：方法。</li><li>PARMETER：参数。</li><li>CONSTRUCTOR：构造方法。</li><li>LOCAL_VARIABLE：本地变量。</li><li>ANNOTATION_TYPE：注解。</li><li>PACKAGE：包。</li><li>TYPE_PARAMETER：参数类型。</li><li>TYPE_USER：类型使用。</li></ul><p>注：元属性也有Target、枚举值可以选择多个。<br /><a name="8fLTd"></a></p><h1 id="retention"><a class="markdownIt-Anchor" href="#retention"></a> @Retention</h1><p>该注解是用来声明注解的生命周期的，即表明注解会被保存到哪一个阶段。他的值需要从枚举类RetentionType中选取，其枚举值如下：</p><ul><li>SOURCE：保留到源码阶段。这一类注解一把留给编译器使用，在编译时会被擦除。</li><li>CLASS：保留到类文件阶段。这是默认的生命周期，JVM运行时不包含这类信息。</li><li>RUNTIME：保留到JVM运行阶段。<br /><a name="uAKak"></a></li></ul><h2 id="document"><a class="markdownIt-Anchor" href="#document"></a> @Document</h2><p>不需要设置具体的值，被注解的注解会在javadoc中生成。<br /><a name="kl0zk"></a></p><h2 id="inherited"><a class="markdownIt-Anchor" href="#inherited"></a> @Inherited</h2><p>不需要设置具体的值，被该注解的注解的注解可以被继承（不能从接口继承）。<br /><a name="VLWw3"></a></p><h2 id="repeatable"><a class="markdownIt-Anchor" href="#repeatable"></a> @Repeatable</h2><p>表示该注解可以重复在一个地方使用多次。<br /><a name="80JyB"></a></p><h1 id="param注解分析"><a class="markdownIt-Anchor" href="#param注解分析"></a> Param注解分析</h1><p>这里以Param注解为例来分析自定义注解类。<br />在调用dao层方法时加上@Param注解，便可以在Mapper中引用id所指代的变量。接下来将分析该功能是如何实现的。<br />随着调试来到ParamNameResolver的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ParamNameResolver</span><span class="params">(Configuration config, Method method)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取参数参数类型列表</span></span><br><span class="line">  <span class="keyword">final</span> Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line">  <span class="comment">// 准备用二维数组存取所有参数的注解</span></span><br><span class="line">  <span class="keyword">final</span> Annotation[][] paramAnnotations = method.getParameterAnnotations();</span><br><span class="line">  <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">int</span> paramCount = paramAnnotations.length;</span><br><span class="line">  <span class="comment">// 循环处理各个参数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> paramIndex = <span class="number">0</span>; paramIndex &lt; paramCount; paramIndex++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isSpecialParameter(paramTypes[paramIndex])) &#123;</span><br><span class="line">      <span class="comment">// 跳过特别的参数</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数名字</span></span><br><span class="line">    String name = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : paramAnnotations[paramIndex]) &#123;</span><br><span class="line">      <span class="comment">// 找到param注解</span></span><br><span class="line">      <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Param) &#123;</span><br><span class="line">        hasParamAnnotation = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 以param的值作为参数名</span></span><br><span class="line">        name = ((Param) annotation).value();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 否则保留参数</span></span><br><span class="line">      <span class="keyword">if</span> (config.isUseActualParamName()) &#123;</span><br><span class="line">        name = getActualParamName(method, paramIndex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// use the parameter index as the name (&quot;0&quot;, &quot;1&quot;, ...)</span></span><br><span class="line">        <span class="comment">// gcode issue #71</span></span><br><span class="line">        name = String.valueOf(map.size());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存入位置序号+名字</span></span><br><span class="line">    map.put(paramIndex, name);</span><br><span class="line">  &#125;</span><br><span class="line">  names = Collections.unmodifiableSortedMap(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;annocations包与lang包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#annocations包与lang包&quot;&gt;&lt;/a&gt; annocations包与lang包&lt;/h1&gt;
&lt;p&gt;这两个包中存放的都是自定义的注解类，这里只分析其</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="基础功能包" scheme="https://jie-blog.icu/categories/mybatis/%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%8C%85/"/>
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>reflection包</title>
    <link href="https://jie-blog.icu/posts/mybatis-annocations&amp;lang/"/>
    <id>https://jie-blog.icu/posts/mybatis-annocations&amp;lang/</id>
    <published>2020-11-04T03:54:22.000Z</published>
    <updated>2020-11-04T04:15:27.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="reflection包"><a class="markdownIt-Anchor" href="#reflection包"></a> reflection包</h1><p><a name="vA04i"></a></p><h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1><p><a name="Pw5mh"></a></p><h2 id="装饰器模式"><a class="markdownIt-Anchor" href="#装饰器模式"></a> 装饰器模式</h2><p>装饰器模式又称包装模式，是一种结构型模式。在使用装饰器模式对包装类进行扩展后不会影响原有类。通常使用的场景是在一个核心基本类的基础上提供大量的装饰类，从而使核心基本类经过不同的装饰类修饰后获得不同的功能。此外，装饰器类还可以叠加使用，从而使一个基本类同时具有多个装饰类的功能。<br />装饰器模式归在本人的理解就是在一杯奶茶里加上波霸、芋圆、椰果后，这杯奶茶变成了一杯加料的“奶茶”。好比FileInputStream和InputStream的关系。<br /><a name="7LE5V"></a></p><h2 id="反射"><a class="markdownIt-Anchor" href="#反射"></a> 反射</h2><p>通过Java的反射能够在类的运行过程中知道这个类有哪些属性和方法。此外，还可以修改属性、调用方法、建立类的实例。例如平常进行的复制操作就可以利用反射书写一个适用于任何类的对象的赋值工作。<br />反射主要提供了以下几个功能：</p><ul><li>在运行时判断任意一个对象所属的类。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时修改任意一个对象的成员变量。</li><li>在运行时调用任意一个对象的方法。<br /><a name="lqoZy"></a></li></ul><h2 id="type接口及其子类"><a class="markdownIt-Anchor" href="#type接口及其子类"></a> Type接口及其子类</h2><p>在反射中经常会遇到一个位于java.lang.reflect包下的Type接口，该接口子类类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601365504161-8d341197-8b6a-42c1-ab12-762df6a6052a.png#align=left&amp;display=inline&amp;height=147&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=294&amp;originWidth=1262&amp;size=581414&amp;status=done&amp;style=none&amp;width=631" alt="image.png" /></p><ul><li>Class类：它代表运行的Java程序中的类和接口。</li><li>WildcardType接口：它代表通配符表达式。例如：“？”，“？ extends Number”。</li><li>TypeVariable接口：它代表参数化的类型，例如：“Map&lt;K，V&gt;”中的K，V。</li><li>ParameterizedType接口：它代表参数化的类型。例如：“Collection<String>”就是参数化类型。</li><li>GenericArrayType接口：它代表包含ParameterizedType或者TypeVariable元素的列表。<br /><a name="YSlQP"></a></li></ul><h1 id="对象工厂子包"><a class="markdownIt-Anchor" href="#对象工厂子包"></a> 对象工厂子包</h1><p>reflection包下的factory子包就是一个对象工厂子包，该对象常用来基于反射生产出各种对象，子包结构：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601365848909-95047bfd-6944-44cc-8aa4-b02c99110907.png#align=left&amp;display=inline&amp;height=68&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=109&amp;originWidth=316&amp;size=14545&amp;status=done&amp;style=none&amp;width=197" alt="image.png" /><br />观察ObjectFacory接口，有如下三个方法：</p><ul><li><code>void setProperties(Properties properties)</code>：设置工厂属性</li><li><code>&lt;T&gt; T create(Class&lt;T&gt; type)</code>：传入到下一个create</li><li><code>&lt;T&gt; T create(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</code>：传入目标类型、参数类型列表、参数值列表，根据相应的含参构造方法生成这个类型的实例。</li><li><code>&lt;T&gt; boolean isCollection(Class&lt;T&gt; type)</code>：判断传入的类型是否是一个集合类。</li></ul><p>DefaultObjectFactory类实现了该接口，其create最终返回的是instantiateClass方法生成的对象，其方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>  &lt;T&gt; <span class="function">T <span class="title">instantiateClass</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 构造方法对象</span></span><br><span class="line">    Constructor&lt;T&gt; constructor;</span><br><span class="line">    <span class="comment">// 判断是否不含参或者参数列表为null</span></span><br><span class="line">    <span class="keyword">if</span> (constructorArgTypes == <span class="keyword">null</span> || constructorArgs == <span class="keyword">null</span>) &#123;</span><br><span class="line">      constructor = type.getDeclaredConstructor();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 返回空构造函数生成对象</span></span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="comment">// 如果访问异常，判断构造函数访问属性可否修改</span></span><br><span class="line">        <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) &#123;</span><br><span class="line">          <span class="comment">// 修改构造函数访问属性</span></span><br><span class="line">          constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">          <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据输入参数类型找到对应的构造器</span></span><br><span class="line">    constructor = type.getDeclaredConstructor(constructorArgTypes.toArray(<span class="keyword">new</span> Class[constructorArgTypes.size()]));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 采用有参构造函数创建实例并返回</span></span><br><span class="line">      <span class="keyword">return</span> constructor.newInstance(constructorArgs.toArray(<span class="keyword">new</span> Object[constructorArgs.size()]));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) &#123;</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance(constructorArgs.toArray(<span class="keyword">new</span> Object[constructorArgs.size()]));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 收集所有参数类型</span></span><br><span class="line">    String argTypes = Optional.ofNullable(constructorArgTypes).orElseGet(Collections::emptyList)</span><br><span class="line">        .stream().map(Class::getSimpleName).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">    <span class="comment">// 收集所有参数</span></span><br><span class="line">    String argValues = Optional.ofNullable(constructorArgs).orElseGet(Collections::emptyList)</span><br><span class="line">        .stream().map(String::valueOf).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">&quot;Error instantiating &quot;</span> + type + <span class="string">&quot; with invalid types (&quot;</span> + argTypes + <span class="string">&quot;) or values (&quot;</span> + argValues + <span class="string">&quot;). Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外该实现类里还有一个resolveInterface方法，其作用是判断如果传入的类型是容器接口的话，返回相应的容器对象，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveInterface(Class&lt;?&gt; type) &#123;</span><br><span class="line">  Class&lt;?&gt; classToCreate;</span><br><span class="line">  <span class="keyword">if</span> (type == List.class || type == Collection.class || type == Iterable.class) &#123;</span><br><span class="line">    classToCreate = ArrayList.class;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Map.class) &#123;</span><br><span class="line">    classToCreate = HashMap.class;</span><br><span class="line">  &#125; else if (type == SortedSet.class) &#123; // issue #510 Collections Support</span><br><span class="line">    classToCreate = TreeSet.class;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Set.class) &#123;</span><br><span class="line">    classToCreate = HashSet.class;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    classToCreate = type;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> classToCreate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="duvQU"></a></p><h1 id="执行器子包"><a class="markdownIt-Anchor" href="#执行器子包"></a> 执行器子包</h1><p>reflection包下的invoker子包是执行器的子包，该子包中的类能够基于反射实现对象方法的调用和对象属性的读写，该包下的类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601366988466-8ad4d0f5-6c8d-4f7a-b5c6-7dcff3ef3098.png#align=left&amp;display=inline&amp;height=182&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=364&amp;originWidth=1126&amp;size=630938&amp;status=done&amp;style=none&amp;width=563" alt="image.png" /><br />Invoker的三种实现分别用于处理环境如下：</p><ul><li>GetFieldInvoker：负责对象属性的读操作。</li><li>SetFiledInvoker：负责对象属性的写操作。</li><li>MethodInvoker：负责对象其他方法的操作。</li></ul><p>此外，Invoker接口中定义的两个抽象方法的功能分别是：</p><ul><li>invoker：执行方法，该方法负责完成对象方法的调用和对象属性的读写。在三个实现类中，分别是属性读写操作、属性赋值操作、方法触发操作。</li><li>getType：用来获取方法。它对于GetFieldInvoker、SetFiledInvoker的含义是获取目标属性类型，而MethodInvoker取略有不同，详见下文。<br /><a name="GCbzN"></a></li></ul><h2 id="methodinvoker的gettype"><a class="markdownIt-Anchor" href="#methodinvoker的gettype"></a> MethodInvoker的getType</h2><p>该类的getType源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getType() &#123;</span><br><span class="line">  <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅仅是返回一个type对象，其对象又是在其构造方法中定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MethodInvoker</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.method = method;</span><br><span class="line"><span class="comment">// 有且仅有一个参数时</span></span><br><span class="line">   <span class="keyword">if</span> (method.getParameterTypes().length == <span class="number">1</span>) &#123;</span><br><span class="line">     type = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     type = method.getReturnType();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当有且仅有一个参数时，type为输入参数的类型，否则type将为返回值类型。<br /><a name="ef7BF"></a></p><h2 id="invoke的实现"><a class="markdownIt-Anchor" href="#invoke的实现"></a> invoke的实现</h2><p>这里以GetFieldInvoker为示例，其实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object target, Object[] args)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 直接获取反射目标对象的值</span></span><br><span class="line">    <span class="keyword">return</span> field.get(target);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    <span class="comment">// 如果属性的访问性可以修改</span></span><br><span class="line">    <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) &#123;</span><br><span class="line">      <span class="comment">// 修改访问属性</span></span><br><span class="line">      field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">return</span> field.get(target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><a name="RkJTo"></a></p><h1 id="属性子包"><a class="markdownIt-Anchor" href="#属性子包"></a> 属性子包</h1><p>reflection包下的properties子包是属性的子包，该子包中的类用来完成与对象属性相关的操作，其包结构如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601367880256-db406b71-8690-4b05-8f40-46765dfc1c2d.png#align=left&amp;display=inline&amp;height=81&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=106&amp;originWidth=272&amp;size=14096&amp;status=done&amp;style=none&amp;width=208" alt="image.png" /><br /><a name="i1U8m"></a></p><h2 id="propertiescopier"><a class="markdownIt-Anchor" href="#propertiescopier"></a> PropertiesCopier</h2><p>其中，PropertiesCopier负责复制属性的值，该类中的唯一方法就是实现拷贝功能的方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyBeanProperties</span><span class="params">(Class&lt;?&gt; type, Object sourceBean, Object destinationBean)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 两个对象同属的类</span></span><br><span class="line">  Class&lt;?&gt; parent = type;</span><br><span class="line">  <span class="keyword">while</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取该类的全部属性</span></span><br><span class="line">    <span class="keyword">final</span> Field[] fields = parent.getDeclaredFields();</span><br><span class="line">    <span class="comment">// 遍历属性</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 调用set方法进行赋值</span></span><br><span class="line">          field.set(destinationBean, field.get(sourceBean));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">          <span class="comment">// 判断是否有属性访问权限</span></span><br><span class="line">          <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) &#123;</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            field.set(destinationBean, field.get(sourceBean));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// Nothing useful to do, will only fail on final fields, which will be ignored.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parent = parent.getSuperclass();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：该方法无法完成继承得来的属性的赋值，因为copyBeanProperties方法在赋值的时候不包含继承属性。<br /><a name="MY2un"></a></p><h2 id="propertynamer"><a class="markdownIt-Anchor" href="#propertynamer"></a> PropertyNamer</h2><p>该类用于提供属性名称相关的操作功能，其正常运行的前提下是对象的属性符合JavaBean命名规范。<br /><a name="x1caz"></a></p><h2 id="propertytokenizer"><a class="markdownIt-Anchor" href="#propertytokenizer"></a> PropertyTokenizer</h2><p>该类是一个属性标记器，当传入一个形如“student[sId].name”的字符串时，标记器会将其拆开放入到各个属性中。<br /><a name="81yad"></a></p><h1 id="对象包装器子包"><a class="markdownIt-Anchor" href="#对象包装器子包"></a> 对象包装器子包</h1><p>reflection包下的wrapper子包是对象包装器的子包，该子包中的类使用装饰器模式对各种类型的对象进行进一步封装，使其增加新的功能。包内类图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601448001468-5b168440-ce42-4f74-9f73-4a0eaea7ef81.png#align=left&amp;display=inline&amp;height=305&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=610&amp;originWidth=1107&amp;size=855226&amp;status=done&amp;style=none&amp;width=553.5" alt="image.png" /><br />其中DefaultObjectWrapperFactory是对象包装器工厂接口的实现，但是这个类中并没有任何功能。因此用户可以通过这个接口定义自己的工厂实现类。<br /><a name="pNTCp"></a></p><h2 id="beanwrapper"><a class="markdownIt-Anchor" href="#beanwrapper"></a> BeanWrapper</h2><p>ObjectWrapper接口是所有对象包装器的总接口，下面将以BeanWrapper为例介绍一下包装器的实现，但是此前要先了解一下MetaObject和MetaClass类：</p><ul><li>MetaObject：涵盖对象中更多细节信息和功能的一个类，又称元对象。</li><li>MetaClass：涵盖了类型中更多细节信息和功能的类，称为元类。</li></ul><p>BeanWrapper有三个重要的属性，其中metaObject属性是由父类BaseWrappper继承而来的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被包装对象的元对象（继承自父类BaseWrapper）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> MetaObject metaObject;</span><br><span class="line"><span class="comment">// 被包装的对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object object;</span><br><span class="line"><span class="comment">// 被包装对象所属类的元类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MetaClass metaClass;</span><br></pre></td></tr></table></figure><p>类中方法的解释：</p><ul><li>get：获得被包装对象某个属性的值。</li><li>set：设置被包装对象某个属性的值。</li><li>findProperty：找到对应属性的名称。</li><li>getGetterNames：获得所有的属性get方法的名字。</li><li>getSetterNames：获得所有的属性set方法的名字。</li><li>getSetterType：获得指定属性的set方法的类型。</li><li>getGetterType：获得指定属性的get方法的类型。</li><li>hasSetter：判断某个属性是否有对应的set方法。</li><li>hasGetter：判断某个属性是否有对应的get方法。</li><li>instantiatePropertyValue：实例化某个属性的值。</li></ul><p>因此，一个Bean经过BeanWrapper包装后就可以暴露出很多易用的方法，从而实现对属性、方法的一系列操作。<br /><a name="z8pZE"></a></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>类似于BeanWrapper，CollectionWrapper、MapWrapper也可以通过这样的包装使Collection和Map暴露出很多易用的方法。<br />BaseWrapper作为MapWrapper和BeanWrapper的父类，提供了两个有用的基础方法为set和get使用。<br /><a name="4u9Mv"></a></p><h1 id="父包类"><a class="markdownIt-Anchor" href="#父包类"></a> 父包类</h1><p><a name="BXLDN"></a></p><h2 id="反射核心类"><a class="markdownIt-Anchor" href="#反射核心类"></a> 反射核心类</h2><p>reflection包中最核心的类就是Reflector类。<br />Refection的相关类类图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601450359300-46397827-be8f-4554-96a2-58fed10099ae.png#align=left&amp;display=inline&amp;height=150&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=299&amp;originWidth=866&amp;size=390074&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br /><a name="jsJNi"></a></p><h3 id="reflection"><a class="markdownIt-Anchor" href="#reflection"></a> Reflection</h3><p>该类将一个类反射解析后会将该类的属性、方法等一一归类放到下述各个属性中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要被反射解析的类  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line"><span class="comment">// 能够读的属性列表，即有get方法的属性列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] readablePropertyNames;</span><br><span class="line"><span class="comment">// 能够写的属性列表，即有set方法的属性列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] writablePropertyNames;</span><br><span class="line"><span class="comment">// set方法映射表。键为属性名，值为set方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Invoker&gt; setMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// get方法映射表。键为属性名，值为get方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Invoker&gt; getMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// set方法输入类型。键为属性名，值为对应的该属性的set方法的类型（set方法第一个参数的类型）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; setTypes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// get方法输出类型。键为属性名，值为对应的该属性的get方法的类型（get方法返回值的类型）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; getTypes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="keyword">private</span> Constructor&lt;?&gt; defaultConstructor;</span><br><span class="line"><span class="comment">// 大小无关的属性映射表。键为属性全大写值，值为属性名。</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, String&gt; caseInsensitivePropertyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>Reflection类反射解析一个类的过程是由构造函数触发的，构造函数源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Reflector</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 要被反射解析的类</span></span><br><span class="line">  type = clazz;</span><br><span class="line">  <span class="comment">// 设置无参构造函数属性</span></span><br><span class="line">  addDefaultConstructor(clazz);</span><br><span class="line">  <span class="comment">// 解析所有的getter</span></span><br><span class="line">  addGetMethods(clazz);</span><br><span class="line">  <span class="comment">// 解析所有的setter</span></span><br><span class="line">  addSetMethods(clazz);</span><br><span class="line">  <span class="comment">// 解析所有的属性</span></span><br><span class="line">  addFields(clazz);</span><br><span class="line">  <span class="comment">// 设置可读参数</span></span><br><span class="line">  readablePropertyNames = getMethods.keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// 设置可写参数</span></span><br><span class="line">  writablePropertyNames = setMethods.keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// 将可读可写参数放入大小写无关的属性映射表</span></span><br><span class="line">  <span class="keyword">for</span> (String propName : readablePropertyNames) &#123;</span><br><span class="line">    caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (String propName : writablePropertyNames) &#123;</span><br><span class="line">    caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的几个方法实现较为基础，暂不做分析。<br /><a name="ReqH3"></a></p><h3 id="defaultreflectorfactory"><a class="markdownIt-Anchor" href="#defaultreflectorfactory"></a> DefaultReflectorFactory</h3><p>ReflectorFactory是Reflector的接口工厂，DefaultReflectorFactory是该接口的实现，于是将分析DefaultReflectorFactory类。<br />该类中只有一个业务相关的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Reflector <span class="title">findForClass</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否允许缓存</span></span><br><span class="line">  <span class="keyword">if</span> (classCacheEnabled) &#123;</span><br><span class="line">    <span class="comment">// synchronized (type) removed see issue #461</span></span><br><span class="line">    <span class="comment">// 生产输入参数Type的反射器对象并放入缓存</span></span><br><span class="line">    <span class="keyword">return</span> reflectorMap.computeIfAbsent(type, Reflector::<span class="keyword">new</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Reflector(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="2bgpx"></a></p><h2 id="反射包装类"><a class="markdownIt-Anchor" href="#反射包装类"></a> 反射包装类</h2><p>之前在wrapper涉及到的两个基础类：MetaClass和MetaObject这里将详细分析。<br /><a name="HoWcP"></a></p><h3 id="metaobject"><a class="markdownIt-Anchor" href="#metaobject"></a> MetaObject</h3><p>MetaObject被称为元对象，是一个针对普通Object对象的包装类，其属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object originalObject;</span><br><span class="line"><span class="comment">// 对象包装器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ObjectWrapper objectWrapper;</span><br><span class="line"><span class="comment">// 对象工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ObjectFactory objectFactory;</span><br><span class="line"><span class="comment">// 对象包装器工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ObjectWrapperFactory objectWrapperFactory;</span><br><span class="line"><span class="comment">// 反射工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReflectorFactory reflectorFactory;</span><br></pre></td></tr></table></figure><p>该类提供很多和objectWrapper一样的方法：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601452010427-e85d7658-a737-4b16-a09c-f1a3e3e49c2d.png#align=left&amp;display=inline&amp;height=164&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=327&amp;originWidth=495&amp;size=76636&amp;status=done&amp;style=none&amp;width=247.5" alt="image.png" /><br />并且在实现的时候调用了objectWrapper的响应方法。<br />然而在objectWrapper的实现中却调用了MetaClass对象的相应方法。<br /><a name="YUEZC"></a></p><h3 id="metaclass"><a class="markdownIt-Anchor" href="#metaclass"></a> MetaClass</h3><p>MetaClass被称为元类，它是针对类的进一步封装，内部集成了类可能使用的反射器和反射工厂。<br /><a name="0BB5j"></a></p><h3 id="systemmetaobject"><a class="markdownIt-Anchor" href="#systemmetaobject"></a> SystemMetaObject</h3><p>该类中限定了一些默认值，源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemMetaObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectFactory DEFAULT_OBJECT_FACTORY = <span class="keyword">new</span> DefaultObjectFactory();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectWrapperFactory DEFAULT_OBJECT_WRAPPER_FACTORY = <span class="keyword">new</span> DefaultObjectWrapperFactory();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MetaObject NULL_META_OBJECT = MetaObject.forObject(NullObject.class, DEFAULT_OBJECT_FACTORY, DEFAULT_OBJECT_WRAPPER_FACTORY, <span class="keyword">new</span> DefaultReflectorFactory());</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SystemMetaObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Prevent Instantiation of Static Class</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NullObject</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MetaObject <span class="title">forObject</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MetaObject.forObject(object, DEFAULT_OBJECT_FACTORY, DEFAULT_OBJECT_WRAPPER_FACTORY, <span class="keyword">new</span> DefaultReflectorFactory());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中forObject方法只能使用默认MetaObject工厂。<br /><a name="dqzQN"></a></p><h2 id="异常拆包类"><a class="markdownIt-Anchor" href="#异常拆包类"></a> 异常拆包类</h2><p>该类的设计比较有趣，ExcepetionUtil是一个异常工具类，他提供了一个拆包异常的工具方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Throwable <span class="title">unwrapThrowable</span><span class="params">(Throwable wrapped)</span> </span>&#123;</span><br><span class="line">  Throwable unwrapped = wrapped;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (unwrapped <span class="keyword">instanceof</span> InvocationTargetException) &#123;</span><br><span class="line">      <span class="comment">// 拆包获得内部异常</span></span><br><span class="line">      unwrapped = ((InvocationTargetException) unwrapped).getTargetException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unwrapped <span class="keyword">instanceof</span> UndeclaredThrowableException) &#123;</span><br><span class="line">      <span class="comment">// 拆包获得内部异常</span></span><br><span class="line">      unwrapped = ((UndeclaredThrowableException) unwrapped).getUndeclaredThrowable();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> unwrapped;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类将InvocationTargetException和UndeclaredThrowableException两个异常进行拆包来得到真正的异常类。<br />这里InvocationTargetException属于必检异常，UndeclaredThrowableException属于免检异常，他们都不属于Mybatis，来自java.lang.reflect包。<br />反射过程中抛出的异常是无法确定是哪种异常，因此通常都会以Throwable抛出。Throwable又可以分为必检型和免检型，因此就要交给这两个异常分别处理：<br /><a name="jlTRv"></a></p><h3 id="invocationtargetexception"><a class="markdownIt-Anchor" href="#invocationtargetexception"></a> InvocationTargetException</h3><p>反射操作的目标方法中出现异常时都会统一的包装成一个必检异常InvocationTargetException，在InvocationTargetException内部的target保存了原始的异常。<br />内部核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationTargetException</span> <span class="keyword">extends</span> <span class="title">ReflectiveOperationException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4085088731926701167L</span>;</span><br><span class="line">    <span class="keyword">private</span> Throwable target;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvocationTargetException</span><span class="params">(Throwable target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((Throwable)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Throwable <span class="title">getTargetException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="1fPcs"></a></p><h3 id="undeclaredthrowableexception"><a class="markdownIt-Anchor" href="#undeclaredthrowableexception"></a> UndeclaredThrowableException</h3><p>在代码实现的时候，如果子类想要抛出必检异常，那么父类必定要声明过这个必检异常。同样的，如果代理类和被代理类实现了共同的接口，则代理类方法中抛出的必检异常必须是在共同接口声明过的。<br />可是当代理类想抛出异常时，其共同的接口或父类并没有声明该必检异常，那又该如何处理。<br />答案就是将这个必检异常包装成免检异常UndeclaredThrowableException，所以说UndeclaredThrowableException并不代表着真实的免检异常，其内部也可能包裹着必检异常InvocationTargetException。<br /><a name="IU6N3"></a></p><h3 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3><p>经过分析UndeclaredThrowableException和InvocationTargetException后可以了解为什么要在ExceptionUtil中会有一个while(true)，因为只有这样才能把这两个包装类拆包拆出真正的异常。<br /><a name="aBJJp"></a></p><h2 id="参数名解析器"><a class="markdownIt-Anchor" href="#参数名解析器"></a> 参数名解析器</h2><p>ParamNameResolver是一个参数名解析器，用来按顺序列出方法中的虚参，并对实参进行命名标注。<br />其内部参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法输入参数的参数次序表，键为参数次序，值为参数名称或者参数@Param注解的值  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; names;</span><br><span class="line"><span class="comment">// 该方法输入参数中是否含有@Param</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasParamAnnotation;</span><br></pre></td></tr></table></figure><p>其主要方法有ParamNameResolver构造函数和getNamedParams方法，暂不做解析。<br /><a name="Y7kWy"></a></p><h2 id="泛型解析器"><a class="markdownIt-Anchor" href="#泛型解析器"></a> 泛型解析器</h2><p><a name="0O0EW"></a></p><h3 id="解析器作用"><a class="markdownIt-Anchor" href="#解析器作用"></a> 解析器作用</h3><p>TypeParameterResolver是一个泛型参数解析器，下面用一段简单的代码演示其功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用TypeParameterResolver分析User类中getInfo方法输出结果的具体类型</span></span><br><span class="line">            Type type1 = TypeParameterResolver.resolveReturnType(User.class.getMethod(&quot;getInfo&quot;), User.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;User类中getInfo方法的输出结果类型 :\n&quot;</span> + type1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用TypeParameterResolver分析Student类中getInfo方法输出结果的具体类型</span></span><br><span class="line">            Type type2 = TypeParameterResolver.resolveReturnType(User.class.getMethod(&quot;getInfo&quot;), Student.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;Student类中getInfo方法的输出结果类型 :\n&quot;</span> + type2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601454537014-490989df-40ce-40e3-bbc8-0e9ba5ed4f9a.png#align=left&amp;display=inline&amp;height=92&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=183&amp;originWidth=1027&amp;size=193417&amp;status=done&amp;style=none&amp;width=513.5" alt="image.png" /><br />显然，其作用就是帮助Mybatis解析出属性返回值、输入参数的泛型的具体类型。<br /><a name="autgF"></a></p><h3 id="解析器原理分析"><a class="markdownIt-Anchor" href="#解析器原理分析"></a> 解析器原理分析</h3><p>其对外提供了三个方法：</p><ul><li>resolveFieldType：解析属性的泛型</li><li>resolveReturnType：解析方法的返回值泛型</li><li>resolveParamTypes：解析方法输入参数的泛型</li></ul><p>这三个方法实现方法大致相同，先选择一个最难的resolveParamTypes进行解析。<br />其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Type[] resolveParamTypes(Method method, Type srcType) &#123;</span><br><span class="line">  <span class="comment">// 取出方法所有的参数</span></span><br><span class="line">  Type[] paramTypes = method.getGenericParameterTypes();</span><br><span class="line">  <span class="comment">// 定义目标方法的类或接口</span></span><br><span class="line">  Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line">  <span class="comment">// 创建解析结果的集合</span></span><br><span class="line">  Type[] result = <span class="keyword">new</span> Type[paramTypes.length];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paramTypes.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 对输入的每个参数调用resolveType方法解析结果</span></span><br><span class="line">    result[i] = resolveType(paramTypes[i], srcType, declaringClass);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resolveType需要传入三个参数：</p><ul><li>Type type：指要分析的字段或者参数的类型。这里要分析的是getInfo的输出参数，即List<T>。</li><li>Type srcType：指要分析的字段或者参数所属的类。这里要分析的是Student类中的getInfo方法，故所属的类是Student</li><li>Class_&lt;<em>?</em>&gt; _declaringClass：指要分析的字段或者参数的类。getInfo方法在User类中被定义，故这里是User类。</li></ul><p>其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Type <span class="title">resolveType</span><span class="params">(Type type, Type srcType, Class&lt;?&gt; declaringClass)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是类型变量，如Map&lt;K,V&gt;的 K，V</span></span><br><span class="line">  <span class="keyword">if</span> (type <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">    <span class="keyword">return</span> resolveTypeVar((TypeVariable&lt;?&gt;) type, srcType, declaringClass);</span><br><span class="line">  <span class="comment">// 如果是参数化类型，如Collection&lt;String&gt;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">    <span class="keyword">return</span> resolveParameterizedType((ParameterizedType) type, srcType, declaringClass);</span><br><span class="line">  <span class="comment">// 如果是包含ParameterizedType或者TypeVariable元素的列表</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type <span class="keyword">instanceof</span> GenericArrayType) &#123;</span><br><span class="line">    <span class="keyword">return</span> resolveGenericArrayType((GenericArrayType) type, srcType, declaringClass);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，resolveType会根据不同的参数类型调用不同的子方法处理。<br />追随端点来到相应的resolveParameterizedType方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ParameterizedType <span class="title">resolveParameterizedType</span><span class="params">(ParameterizedType parameterizedType, Type srcType, Class&lt;?&gt; declaringClass)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取变量的原始类型，本次为List</span></span><br><span class="line">  Class&lt;?&gt; rawType = (Class&lt;?&gt;) parameterizedType.getRawType();</span><br><span class="line">  <span class="comment">// 获取类型参数，本例只有一个T</span></span><br><span class="line">  Type[] typeArgs = parameterizedType.getActualTypeArguments();</span><br><span class="line">  <span class="comment">// 类型参数的实际类型</span></span><br><span class="line">  Type[] args = <span class="keyword">new</span> Type[typeArgs.length];</span><br><span class="line">  <span class="comment">// 依次处理每一个类型参数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; typeArgs.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 类型参数是类型变量，本次符合</span></span><br><span class="line">    <span class="keyword">if</span> (typeArgs[i] <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">      args[i] = resolveTypeVar((TypeVariable&lt;?&gt;) typeArgs[i], srcType, declaringClass);</span><br><span class="line">    <span class="comment">// 类型参数是参数化类型，例如List&lt;List&lt;T&gt;&gt;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeArgs[i] <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">      args[i] = resolveParameterizedType((ParameterizedType) typeArgs[i], srcType, declaringClass);</span><br><span class="line">    <span class="comment">// 类型参数是通配符泛型，例如&lt;? extends XXX&gt;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeArgs[i] <span class="keyword">instanceof</span> WildcardType) &#123;</span><br><span class="line">      args[i] = resolveWildcardType((WildcardType) typeArgs[i], srcType, declaringClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 类型参数时确定类型，例如 Conllection&lt;String&gt;</span></span><br><span class="line">      args[i] = typeArgs[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ParameterizedTypeImpl(rawType, <span class="keyword">null</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟踪resolveTypeVar：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Type <span class="title">resolveTypeVar</span><span class="params">(TypeVariable&lt;?&gt; typeVar, Type srcType, Class&lt;?&gt; declaringClass)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 解析出来的类型参数结果</span></span><br><span class="line">   Type result;</span><br><span class="line">   Class&lt;?&gt; clazz;</span><br><span class="line">   <span class="comment">// 该类型参数是一个Class，本例符合</span></span><br><span class="line">   <span class="keyword">if</span> (srcType <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">     clazz = (Class&lt;?&gt;) srcType;</span><br><span class="line">   <span class="comment">// 该类型属于参数化类型</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (srcType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">     ParameterizedType parameterizedType = (ParameterizedType) srcType;</span><br><span class="line">     <span class="comment">// 获取参数化类型的原始类型</span></span><br><span class="line">     clazz = (Class&lt;?&gt;) parameterizedType.getRawType();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;The 2nd arg must be Class or ParameterizedType, but was: &quot;</span> + srcType.getClass());</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 变量所属的类和定义变量的类一致。本例中T属于Student定义属于User</span></span><br><span class="line">   <span class="keyword">if</span> (clazz == declaringClass) &#123;</span><br><span class="line">     <span class="comment">// 确定边界上限（边界类型，本次Number）</span></span><br><span class="line">     Type[] bounds = typeVar.getBounds();</span><br><span class="line">     <span class="keyword">if</span> (bounds.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> bounds[<span class="number">0</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> Object.class;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 获取所属类的父类</span></span><br><span class="line">   Type superclass = clazz.getGenericSuperclass();</span><br><span class="line">   <span class="comment">// 扫描父类，确定边界（边界类型，本次Number）</span></span><br><span class="line">   result = scanSuperTypes(typeVar, srcType, declaringClass, clazz, superclass);</span><br><span class="line">   <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 获取变量所属类的接口</span></span><br><span class="line">   Type[] superInterfaces = clazz.getGenericInterfaces();</span><br><span class="line">   <span class="comment">// 遍历父接口确定边界</span></span><br><span class="line">   <span class="keyword">for</span> (Type superInterface : superInterfaces) &#123;</span><br><span class="line">     result = scanSuperTypes(typeVar, srcType, declaringClass, clazz, superInterface);</span><br><span class="line">     <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> Object.class;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>此外还有resolveTypeVar和resolveGenericArrayType方法。<br />方法就是resolveParameterizedType的简化版。<br />resolveGenericArrayType源码解析如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Type <span class="title">resolveGenericArrayType</span><span class="params">(GenericArrayType genericArrayType, Type srcType, Class&lt;?&gt; declaringClass)</span> </span>&#123;</span><br><span class="line">  Type componentType = genericArrayType.getGenericComponentType();</span><br><span class="line">  Type resolvedComponentType = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 元素类型是类的变量，例如T[]</span></span><br><span class="line">  <span class="keyword">if</span> (componentType <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">    resolvedComponentType = resolveTypeVar((TypeVariable&lt;?&gt;) componentType, srcType, declaringClass);</span><br><span class="line">  <span class="comment">// 元素类型是泛型列表，例如T[][]</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (componentType <span class="keyword">instanceof</span> GenericArrayType) &#123;</span><br><span class="line">    resolvedComponentType = resolveGenericArrayType((GenericArrayType) componentType, srcType, declaringClass);</span><br><span class="line">  <span class="comment">// 元素类型是参数化类型，例如Collection&lt;T&gt;[]</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (componentType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">    resolvedComponentType = resolveParameterizedType((ParameterizedType) componentType, srcType, declaringClass);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是Class类</span></span><br><span class="line">  <span class="keyword">if</span> (resolvedComponentType <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">    <span class="keyword">return</span> Array.newInstance((Class&lt;?&gt;) resolvedComponentType, <span class="number">0</span>).getClass();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GenericArrayTypeImpl(resolvedComponentType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;reflection包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#reflection包&quot;&gt;&lt;/a&gt; reflection包&lt;/h1&gt;
&lt;p&gt;&lt;a name=&quot;vA04i&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a cla</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="基础功能包" scheme="https://jie-blog.icu/categories/mybatis/%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%8C%85/"/>
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/tags/mybatis/"/>
    
  </entry>
  
</feed>
