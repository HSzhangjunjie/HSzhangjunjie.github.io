<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jieker&#39;s Blog</title>
  
  <subtitle>Jiker</subtitle>
  <link href="https://jie-blog.icu/atom.xml" rel="self"/>
  
  <link href="https://jie-blog.icu/"/>
  <updated>2020-11-04T04:06:54.103Z</updated>
  <id>https://jie-blog.icu/</id>
  
  <author>
    <name>Zhang Junjie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>datasource包</title>
    <link href="https://jie-blog.icu/posts/mybatis-datasource/"/>
    <id>https://jie-blog.icu/posts/mybatis-datasource/</id>
    <published>2020-11-04T04:06:04.000Z</published>
    <updated>2020-11-04T04:06:54.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="datasource包"><a class="markdownIt-Anchor" href="#datasource包"></a> datasource包</h1><p>通过dataSource包Mybatis将完成数据源的获取、数据连接的建立等工作为操作语句打好基础。<br /><a name="tJzvq"></a></p><h1 id="基础知识铺垫"><a class="markdownIt-Anchor" href="#基础知识铺垫"></a> 基础知识铺垫</h1><p>在分析datasource包周期还需要有一些基础知识要铺垫一下。<br /><a name="ygYRa"></a></p><h2 id="javasql和javaxsql"><a class="markdownIt-Anchor" href="#javasql和javaxsql"></a> java.sql和javax.sql</h2><p>这两个包共同为Java提供了强大的JDBC能力。<br /><a name="HuBTY"></a></p><h3 id="javasql"><a class="markdownIt-Anchor" href="#javasql"></a> java.sql</h3><p>基于该包实现了SQL语句传递给数据库、从数据库以表格形式读写数据等功能。<br />java.sql提供了一个Driver接口作为数据库驱动的接口。不同的数据库厂商只需根据自身的数据库特点开发相应的Driver实现并通过DriverManager进行注册就可以使用了。<br />除此之外，java.sql还为数据库连接、SQL语句、结果集等提供了众多的类。通常完成一次数据库操作的流程如下所示：</p><ol><li>建立DriverManger对象</li><li>从DriverManger对象中获取Connection对象。</li><li>从Connection对象中获取Statement对象。</li><li>将SQL语句交给Statement对象执行，并返回结果，通常放到ResultSet中。<br /><a name="cDzN1"></a></li></ol><h3 id="javaxsql"><a class="markdownIt-Anchor" href="#javaxsql"></a> javax.sql</h3><p>该类包扩展了JDBC核心API的功能，提供了服务端的支持。<br />使用javax.sql扩展后建议使用DataSource来获取Connection对象，而不是直接获取DriverManger。<br /><a name="Rq2ur"></a></p><h2 id="drivermanger"><a class="markdownIt-Anchor" href="#drivermanger"></a> DriverManger</h2><p>它是JDBC驱动程序管理器，可以管理一组JDBC驱动程序。<br />当调用getConnection方法时，DriverManger会尝试在已加载的驱动程序中找出合适的一个，并用找出的驱动程序建立一个面向指定数据库的连接，最后将建立的连接返回。<br />其内部主要有如下几个方法：</p><ul><li>void registerDriver：向DriverManger中注册给定的驱动程序。</li><li>void deregisterDriver：从DriverManger中删除给定的驱动程序。</li><li>Driver getDriver：查找能匹配给定URL路径的驱动程序。</li><li>Enumeration getDrivers：获取当前调用者可以访问的所有已加载的JDBC驱动程序。</li><li>Connection getConnection：建立给定数据库的连接。<br /><a name="2x8wz"></a></li></ul><h2 id="datasource"><a class="markdownIt-Anchor" href="#datasource"></a> DataSource</h2><p>DataSource代表了一个实际的数据源，其功能是作为工厂提供数据源连接。<br />DataSource仅仅是一个接口，不同的数据库可以对其提供多种实现，常见实现有如下几种：</p><ul><li>基本实现：生成基本的到数据库的连接对象Connection。</li><li>连接池实现：生成的Connection对象能够自动加到连接池。</li><li>分布式事务实现：生成的Connection对象可以参与分布式事务。</li></ul><p>DataSource的具体实现中最终也是基于DriverManager获得的Connection，因此可以认为DataSource只是DriverManger的进一步封装。<br /><a name="huAiY"></a></p><h2 id="connection"><a class="markdownIt-Anchor" href="#connection"></a> Connection</h2><p>该类中的方法主要是用来完成Statement对象的获取、Connection属性的设置等功能。<br />同时，Connection中存在事务管理的方法。通过调用这些事务管理方法可以控制数据库完成相应的事务操作。<br /><a name="1OeJx"></a></p><h2 id="statement"><a class="markdownIt-Anchor" href="#statement"></a> Statement</h2><p>通常Statement对象会返回一个结果集对象ResultSet。其内部方法主要完成执行SQL语句、获取SQL语句执行结果等功能。<br /><a name="ckpCp"></a></p><h1 id="数据源工厂接口"><a class="markdownIt-Anchor" href="#数据源工厂接口"></a> 数据源工厂接口</h1><p>datasource包中DataSourceFactory作为工厂的接口，javax.sql包中DataSource作为所有工厂的接口。其类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602484058259-a51506a0-4247-4d20-89f4-ed8adbc01a0f.png#align=left&amp;display=inline&amp;height=308&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=615&amp;originWidth=1374&amp;size=1342308&amp;status=done&amp;style=none&amp;width=687" alt="image.png" /><br />既然是工厂方法模式就要有具体工厂实现，在XMLConfigBuilder的dataSourceElement方法中找到了生成具体工厂的过程，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DataSourceFactory <span class="title">dataSourceElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过Type判断数据源类型，例如ROOLED、UNPOOLED</span></span><br><span class="line">    String type = context.getStringAttribute(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取datasource下的property属性</span></span><br><span class="line">    Properties props = context.getChildrenAsProperties();</span><br><span class="line">    <span class="comment">// 根据type值找到对应的DataSourceFactory实现</span></span><br><span class="line">    DataSourceFactory factory = (DataSourceFactory) resolveClass(type).newInstance();</span><br><span class="line">    <span class="comment">// 设置相应的属性</span></span><br><span class="line">    factory.setProperties(props);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Environment declaration requires a DataSourceFactory.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="yM1Wq"></a></p><h1 id="jndi数据源工厂"><a class="markdownIt-Anchor" href="#jndi数据源工厂"></a> JNDI数据源工厂</h1><p>datasource的jndi子包提供了一个JNDI数据源工厂JndiDataSourceFactory，首先先要了解一下JNDI的概念。<br /><a name="0ZiRf"></a></p><h2 id="jndi数据源"><a class="markdownIt-Anchor" href="#jndi数据源"></a> JNDI数据源</h2><p>JNDI是Java命名和目录接口，它能够为Java应用程序提供命名和目录访问的接口，也可以将其理解为一种命名规范。在使用该规范为资源命名并将资源放入环境中后，可以通过命名从环境中查找对应的资源。<br />数据源作为一种资源就可以使用JNDI命名后放入到环境中，这就是JNDI数据源。之后只需要通过名称信息就可以查找出来。<br /><a name="1xHzT"></a></p><h2 id="工厂实现"><a class="markdownIt-Anchor" href="#工厂实现"></a> 工厂实现</h2><p>该数据源工厂的getDataSource方法只负责将成员变量中的DataSource对象返回，从环境中找到指定的DataSource操作是在setProperties中实现的，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 初始上下文环境</span></span><br><span class="line">    InitialContext initCtx;</span><br><span class="line">    <span class="comment">// 获取配置信息，根据配置信息初始化环境</span></span><br><span class="line">    Properties env = getEnvProperties(properties);</span><br><span class="line">    <span class="keyword">if</span> (env == <span class="keyword">null</span>) &#123;</span><br><span class="line">      initCtx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      initCtx = <span class="keyword">new</span> InitialContext(env);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// 从配置信息中获取数据源信息</span></span><br><span class="line">    <span class="keyword">if</span> (properties.containsKey(INITIAL_CONTEXT)</span><br><span class="line">        &amp;&amp; properties.containsKey(DATA_SOURCE)) &#123;</span><br><span class="line">      <span class="comment">// 定位到initial_context给出的起始环境</span></span><br><span class="line">      Context ctx = (Context) initCtx.lookup(properties.getProperty(INITIAL_CONTEXT));</span><br><span class="line">      <span class="comment">// 从起始环境找到指定的数据源</span></span><br><span class="line">      dataSource = (DataSource) ctx.lookup(properties.getProperty(DATA_SOURCE));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (properties.containsKey(DATA_SOURCE)) &#123;</span><br><span class="line">      <span class="comment">// 从整个环境中找到指定数据源</span></span><br><span class="line">      dataSource = (DataSource) initCtx.lookup(properties.getProperty(DATA_SOURCE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> DataSourceException(<span class="string">&quot;There was an error configuring JndiDataSourceTransactionPool. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，从本质上讲，JndiDataSourceFactory不是在生产数据源，而是负责查找数据源。<br /><a name="SLRty"></a></p><h1 id="非池化数据源及工厂"><a class="markdownIt-Anchor" href="#非池化数据源及工厂"></a> 非池化数据源及工厂</h1><p>datasource的unpooled子包提供了非池化的数据源工厂即非池化的数据源。<br /><a name="lyN2U"></a></p><h2 id="非池化数据源工厂"><a class="markdownIt-Anchor" href="#非池化数据源工厂"></a> 非池化数据源工厂</h2><p>该类直接在自身的构造方法中创建了数据源对象并保存在了自身的成员变量中。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSourceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.dataSource = <span class="keyword">new</span> UnpooledDataSource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该工厂的setProperties方法负责为工厂的数据源设置属性，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 驱动的属性</span></span><br><span class="line">  Properties driverProperties = <span class="keyword">new</span> Properties();</span><br><span class="line">  <span class="comment">// 生成一个包含DataSource的元对象</span></span><br><span class="line">  MetaObject metaDataSource = SystemMetaObject.forObject(dataSource);</span><br><span class="line">  <span class="comment">// 设置属性</span></span><br><span class="line">  <span class="keyword">for</span> (Object key : properties.keySet()) &#123;</span><br><span class="line">    String propertyName = (String) key;</span><br><span class="line">    <span class="comment">// 如果是以driver.开头的匹配信息</span></span><br><span class="line">    <span class="keyword">if</span> (propertyName.startsWith(DRIVER_PROPERTY_PREFIX)) &#123;</span><br><span class="line">      <span class="comment">// 记录配置信息</span></span><br><span class="line">      String value = properties.getProperty(propertyName);</span><br><span class="line">      driverProperties.setProperty(propertyName.substring(DRIVER_PROPERTY_PREFIX_LENGTH), value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (metaDataSource.hasSetter(propertyName)) &#123;</span><br><span class="line">      <span class="comment">// 通过反射为DataSource设置其他属性</span></span><br><span class="line">      String value = (String) properties.get(propertyName);</span><br><span class="line">      Object convertedValue = convertValue(metaDataSource, propertyName, value);</span><br><span class="line">      metaDataSource.setValue(propertyName, convertedValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> DataSourceException(<span class="string">&quot;Unknown DataSource property: &quot;</span> + propertyName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (driverProperties.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 将以driver.开头的配置信息放入到DataSource的driverProperies属性中</span></span><br><span class="line">    metaDataSource.setValue(<span class="string">&quot;driverProperties&quot;</span>, driverProperties);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="0oRO1"></a></p><h2 id="非池化数据源"><a class="markdownIt-Anchor" href="#非池化数据源"></a> 非池化数据源</h2><p>非池化数据源是最简单的数据源，其只需要在每次请求链接时打开连接，在每次连接结束时关闭连接即可。<br />其内部属性和配置信息一一对应，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 驱动加载器</span></span><br><span class="line"><span class="keyword">private</span> ClassLoader driverClassLoader;</span><br><span class="line"><span class="comment">// 启动配置信息</span></span><br><span class="line"><span class="keyword">private</span> Properties driverProperties;</span><br><span class="line"><span class="comment">// 已经注册的所有驱动</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Driver&gt; registeredDrivers = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 数据库驱动</span></span><br><span class="line"><span class="keyword">private</span> String driver;</span><br><span class="line"><span class="comment">// 数据源地址</span></span><br><span class="line"><span class="keyword">private</span> String url;</span><br><span class="line"><span class="comment">// 数据源用户名</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="comment">// 数据源密码</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="comment">// 是否自动提交</span></span><br><span class="line"><span class="keyword">private</span> Boolean autoCommit;</span><br><span class="line"><span class="comment">// 默认事务隔离级别</span></span><br><span class="line"><span class="keyword">private</span> Integer defaultTransactionIsolationLevel;</span><br><span class="line"><span class="comment">// 最长等待时间，发出请求后最长等待该时间后如果数据库还没有回应则认为失败</span></span><br><span class="line"><span class="keyword">private</span> Integer defaultNetworkTimeout;</span><br></pre></td></tr></table></figure><p>数据源的最重要的功能就是给出数据库连接对象Connection，该功能由doGetConnection提供，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Connection <span class="title">doGetConnection</span><span class="params">(Properties properties)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化驱动</span></span><br><span class="line">  initializeDriver();</span><br><span class="line">  <span class="comment">// 通过DriverManger获取连接</span></span><br><span class="line">  Connection connection = DriverManager.getConnection(url, properties);</span><br><span class="line">  <span class="comment">// 配置连接</span></span><br><span class="line">  configureConnection(connection);</span><br><span class="line">  <span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，Connection对象是由DriverManager提供的。此前，还调用了initializeDriver来初始化驱动，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initializeDriver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 如果所需的驱动尚未注册到registeredDrivers</span></span><br><span class="line">  <span class="keyword">if</span> (!registeredDrivers.containsKey(driver)) &#123;</span><br><span class="line">    Class&lt;?&gt; driverType;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 如果存在驱动类加载器</span></span><br><span class="line">      <span class="keyword">if</span> (driverClassLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 优先使用驱动类加载器加载驱动类</span></span><br><span class="line">        driverType = Class.forName(driver, <span class="keyword">true</span>, driverClassLoader);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用Resources中的加载器加载驱动</span></span><br><span class="line">        driverType = Resources.classForName(driver);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 实例化驱动</span></span><br><span class="line">      Driver driverInstance = (Driver)driverType.newInstance();</span><br><span class="line">      <span class="comment">// 向DriverManager中注册驱动代理</span></span><br><span class="line">      DriverManager.registerDriver(<span class="keyword">new</span> DriverProxy(driverInstance));</span><br><span class="line">      <span class="comment">// 注册到registeredDrivers表示驱动已经被加载</span></span><br><span class="line">      registeredDrivers.put(driver, driverInstance);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">&quot;Error setting driver on UnpooledDataSource. Cause: &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="A0cty"></a></p><h1 id="池化数据源"><a class="markdownIt-Anchor" href="#池化数据源"></a> 池化数据源</h1><p>在连接池中总保留一定数量的数据库连接以备使用，可以在需要的时候取出，不需要的时候放回，这样就减少了连接的创建和销毁工作，从而提高了整体的效率。<br />之前分析得出非池化的数据源UnpooledDataSource获取DataSource时，实际上就是在UnPooledDataSource中的DriverManger对象给出的。因此，这些连接Connection对象不属于任何一个连接池。<br />关于PooledDataSourceFactory，其内部仅仅重写了UnpooledDataSource构造方法而已，比较简单，这里就不做分析直接开始分析数据源了。<br /><a name="9n1Ig"></a></p><h2 id="池化数据源属性"><a class="markdownIt-Anchor" href="#池化数据源属性"></a> 池化数据源属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolState state = <span class="keyword">new</span> PoolState(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 持有一个UnpooledDataSource对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> UnpooledDataSource dataSource;</span><br><span class="line"><span class="comment">// 和连接池设置有关的配置项</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumActiveConnections = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumIdleConnections = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumCheckoutTime = <span class="number">20000</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolTimeToWait = <span class="number">20000</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumLocalBadConnectionTolerance = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">protected</span> String poolPingQuery = <span class="string">&quot;NO PING QUERY SET&quot;</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> poolPingEnabled;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolPingConnectionsNotUsedFor;</span><br><span class="line"><span class="comment">// 存储池子中的连接编码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> expectedConnectionTypeCode;</span><br></pre></td></tr></table></figure><p>以下将对其中重要的属性进行一一分析。<br /><a name="EmQ82"></a></p><h3 id="state"><a class="markdownIt-Anchor" href="#state"></a> State</h3><p>state是一个PoolState对象，其内部存储了所有数据库连接及状态信息。数据库连接池大小的设置需要根据业务场景判断。因此，对连接池的运行数据进行统计是很有必要的。<br />PooledDataSource没有直接使用列表而是使用PoolState对象来存储所有的数据库连接，就是为了统计连接池运行数据的需要。<br /><a name="vR0I5"></a></p><h4 id="poolstate"><a class="markdownIt-Anchor" href="#poolstate"></a> PoolState</h4><p>该类的属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 池化数据源</span></span><br><span class="line"><span class="keyword">protected</span> PooledDataSource dataSource;</span><br><span class="line"><span class="comment">// 空闲的连接</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> List&lt;PooledConnection&gt; idleConnections = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 活动的连接</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> List&lt;PooledConnection&gt; activeConnections = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 连接被取出的次数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> requestCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 取出请求花费时间的累计值。从准备取出请求到结束的时间为取出请求花费的时间</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> accumulatedRequestTime = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 累计被检出的时间</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> accumulatedCheckoutTime = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 声明过期的连接数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> claimedOverdueConnectionCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 过期的连接数的总检出时长</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> accumulatedCheckoutTimeOfOverdueConnections = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 总等待时长</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> accumulatedWaitTime = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 等待的轮次</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> hadToWaitCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 坏连接的数目</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> badConnectionCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><a name="wWnKG"></a></p><h3 id="datasource-2"><a class="markdownIt-Anchor" href="#datasource-2"></a> dataSource</h3><p>当池化的数据源在连接池中的连接不够时也需要创建新的连接，而属性dataSource是一个UnpooledDataSource对象，在需要创建新的连接时由该属性给出。<br /><a name="a2j9f"></a></p><h3 id="expectedconnectiontypecode"><a class="markdownIt-Anchor" href="#expectedconnectiontypecode"></a> expectedConnectionTypeCode</h3><p>一个数据源连接池必须确保池中的每个连接都是等价的，这样才能保证每次从连接池取出链接不会存在差异性。expectedConnectionTypeCode存储的就是该数据源的类型编码。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">assembleConnectionTypeCode</span><span class="params">(String url, String username, String password)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="string">&quot;&quot;</span> + url + username + password).hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该值在创建新的PooledDataSource时生成，然后会赋值给每一个从该对象的连接池取出的PooledConnection。当connection归还给连接池时会校验该值从而保证换回来的对象属于该池。<br /><a name="uLYoC"></a></p><h2 id="池化链接的给出与收回"><a class="markdownIt-Anchor" href="#池化链接的给出与收回"></a> 池化链接的给出与收回</h2><p><a name="pCnZI"></a></p><h3 id="给出池化连接"><a class="markdownIt-Anchor" href="#给出池化连接"></a> 给出池化连接</h3><p>该部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PooledConnection <span class="title">popConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span> countedWait = <span class="keyword">false</span>;</span><br><span class="line">   PooledConnection conn = <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">// 用于统计取出链接花费的时间点</span></span><br><span class="line">   <span class="keyword">long</span> t = System.currentTimeMillis();</span><br><span class="line">   <span class="keyword">int</span> localBadConnectionCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">// 给state加同步锁</span></span><br><span class="line">     <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">       <span class="comment">// 池中存在空闲连接</span></span><br><span class="line">       <span class="keyword">if</span> (!state.idleConnections.isEmpty()) &#123;</span><br><span class="line">         <span class="comment">// 左移操作，取出第一个连接</span></span><br><span class="line">         conn = state.idleConnections.remove(<span class="number">0</span>);</span><br><span class="line">         <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">           log.debug(<span class="string">&quot;Checked out connection &quot;</span> + conn.getRealHashCode() + <span class="string">&quot; from pool.&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">// 池中没有空余连接</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 池中还有空余位置</span></span><br><span class="line">         <span class="keyword">if</span> (state.activeConnections.size() &lt; poolMaximumActiveConnections) &#123;</span><br><span class="line">           <span class="comment">// 创建新连接</span></span><br><span class="line">           conn = <span class="keyword">new</span> PooledConnection(dataSource.getConnection(), <span class="keyword">this</span>);</span><br><span class="line">           <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">             log.debug(<span class="string">&quot;Created connection &quot;</span> + conn.getRealHashCode() + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="comment">// 连接池已满，不能创建新的连接</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 找到借出去最久的连接</span></span><br><span class="line">           PooledConnection oldestActiveConnection = state.activeConnections.get(<span class="number">0</span>);</span><br><span class="line">           <span class="comment">// 查看已经借出了多久</span></span><br><span class="line">           <span class="keyword">long</span> longestCheckoutTime = oldestActiveConnection.getCheckoutTime();</span><br><span class="line">           <span class="comment">// 如果已经超市</span></span><br><span class="line">           <span class="keyword">if</span> (longestCheckoutTime &gt; poolMaximumCheckoutTime) &#123;</span><br><span class="line">             <span class="comment">// 声明该链接超时未还</span></span><br><span class="line">             state.claimedOverdueConnectionCount++;</span><br><span class="line">             state.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;</span><br><span class="line">             state.accumulatedCheckoutTime += longestCheckoutTime;</span><br><span class="line">             <span class="comment">// 因超时而除名</span></span><br><span class="line">             state.activeConnections.remove(oldestActiveConnection);</span><br><span class="line">             <span class="comment">// 如果超时不还的连接没有设置自动提交事务</span></span><br><span class="line">             <span class="keyword">if</span> (!oldestActiveConnection.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">// 尝试替它回滚</span></span><br><span class="line">                 oldestActiveConnection.getRealConnection().rollback();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                 <span class="comment">// 如果回滚时报仅仅记录不抛出异常</span></span><br><span class="line">                 log.debug(<span class="string">&quot;Bad connection. Could not roll back&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 创建一个连接替代超时不还连接的位置</span></span><br><span class="line">             conn = <span class="keyword">new</span> PooledConnection(oldestActiveConnection.getRealConnection(), <span class="keyword">this</span>);</span><br><span class="line">             conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp());</span><br><span class="line">             conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp());</span><br><span class="line">             oldestActiveConnection.invalidate();</span><br><span class="line">             <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">               log.debug(<span class="string">&quot;Claimed overdue connection &quot;</span> + conn.getRealHashCode() + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">          <span class="comment">// 借出最久单位逾期</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 继续等待</span></span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (!countedWait) &#123;</span><br><span class="line">                 <span class="comment">// 记录发生等待的次数，某次请求等待多伦也算作只发生了一次等待</span></span><br><span class="line">                 state.hadToWaitCount++;</span><br><span class="line">                 countedWait = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                 log.debug(<span class="string">&quot;Waiting as long as &quot;</span> + poolTimeToWait + <span class="string">&quot; milliseconds for connection.&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">long</span> wt = System.currentTimeMillis();</span><br><span class="line">               <span class="comment">// 沉睡一段时间再试，防止一直占有计算资源</span></span><br><span class="line">               state.wait(poolTimeToWait);</span><br><span class="line">               state.accumulatedWaitTime += System.currentTimeMillis() - wt;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 取得了连接</span></span><br><span class="line">       <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 判断连接是否可用，如果可用</span></span><br><span class="line">         <span class="keyword">if</span> (conn.isValid()) &#123;</span><br><span class="line">           <span class="comment">// 该链接没有设置自动回滚</span></span><br><span class="line">           <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">             <span class="comment">// 回滚未提交操作</span></span><br><span class="line">             conn.getRealConnection().rollback();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 每个借出去的连接都打上数据源的连接类型编码，以便在归还时确保正确</span></span><br><span class="line">           conn.setConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password));</span><br><span class="line">           <span class="comment">// 数据记录操作  </span></span><br><span class="line">           conn.setCheckoutTimestamp(System.currentTimeMillis());</span><br><span class="line">           conn.setLastUsedTimestamp(System.currentTimeMillis());</span><br><span class="line">           state.activeConnections.add(conn);</span><br><span class="line">           state.requestCount++;</span><br><span class="line">           state.accumulatedRequestTime += System.currentTimeMillis() - t;</span><br><span class="line">           <span class="comment">// 连接不可用</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">             log.debug(<span class="string">&quot;A bad connection (&quot;</span> + conn.getRealHashCode() + <span class="string">&quot;) was returned from the pool, getting another connection.&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           state.badConnectionCount++;</span><br><span class="line">           localBadConnectionCount++;</span><br><span class="line">           <span class="comment">// 直接删除</span></span><br><span class="line">           conn = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">// 如果没有一个连接可用，说明连不上数据库</span></span><br><span class="line">           <span class="keyword">if</span> (localBadConnectionCount &gt; (poolMaximumIdleConnections + poolMaximumLocalBadConnectionTolerance)) &#123;</span><br><span class="line">             <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">               log.debug(<span class="string">&quot;PooledDataSource: Could not get a good connection to the database.&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">&quot;PooledDataSource: Could not get a good connection to the database.&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果到这里还没找到连接，则会循环此操作，继续尝试取出连接</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">       log.debug(<span class="string">&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> conn;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><a name="cfJ6I"></a></p><h3 id="取出池化连接"><a class="markdownIt-Anchor" href="#取出池化连接"></a> 取出池化连接</h3><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pushConnection</span><span class="params">(PooledConnection conn)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">    <span class="comment">// 将该链接从活跃连接中删除</span></span><br><span class="line">    state.activeConnections.remove(conn);</span><br><span class="line">    <span class="comment">// 当前连接可用</span></span><br><span class="line">    <span class="keyword">if</span> (conn.isValid()) &#123;</span><br><span class="line">      <span class="comment">// 判断连接池未满且该链接确实属于该连接池  </span></span><br><span class="line">      <span class="keyword">if</span> (state.idleConnections.size() &lt; poolMaximumIdleConnections &amp;&amp; conn.getConnectionTypeCode() == expectedConnectionTypeCode) &#123;</span><br><span class="line">        state.accumulatedCheckoutTime += conn.getCheckoutTime();</span><br><span class="line">        <span class="comment">// 如果链接没有设置自动提交</span></span><br><span class="line">        <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">          <span class="comment">// 将未完成的操作回滚  </span></span><br><span class="line">          conn.getRealConnection().rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新整理连接</span></span><br><span class="line">        PooledConnection newConn = <span class="keyword">new</span> PooledConnection(conn.getRealConnection(), <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 将连接放入空闲池</span></span><br><span class="line">        state.idleConnections.add(newConn);</span><br><span class="line">        newConn.setCreatedTimestamp(conn.getCreatedTimestamp());</span><br><span class="line">        newConn.setLastUsedTimestamp(conn.getLastUsedTimestamp());</span><br><span class="line">        <span class="comment">// 连接未校验，以便取出时重新校验</span></span><br><span class="line">        conn.invalidate();</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">          log.debug(<span class="string">&quot;Returned connection &quot;</span> + newConn.getRealHashCode() + <span class="string">&quot; to pool.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        state.notifyAll();</span><br><span class="line">      <span class="comment">// 连接池已满或者该链接不属于该连接池</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        state.accumulatedCheckoutTime += conn.getCheckoutTime();</span><br><span class="line">        <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">          conn.getRealConnection().rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接关闭连接，而不是将其放入到连接池中</span></span><br><span class="line">        conn.getRealConnection().close();</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">          log.debug(<span class="string">&quot;Closed connection &quot;</span> + conn.getRealHashCode() + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        conn.invalidate();</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 当前连接不可用</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;A bad connection (&quot;</span> + conn.getRealHashCode() + <span class="string">&quot;) attempted to return to the pool, discarding connection.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      state.badConnectionCount++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="FKd7T"></a></p><h3 id="池化数据源中链接的等价性"><a class="markdownIt-Anchor" href="#池化数据源中链接的等价性"></a> 池化数据源中链接的等价性</h3><p>一个数据源的连接池必须保证池中的每个链接都是等价的，PooledDataSource通过存储在expectedConnectionTypeCode中的数据源连接类型编码保证这一点。PooledDataSource在每次给出链接时会给链接写入编码，在收回连接时会校验编码。这就避免了非本池连接放入该池。   <br />如果在使用连接时更改了dirver、url等属性也不会造成非本池连接放入该池的结果。因为修改这些属性的时候必定会调用其setter方法，以setDriver为例，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDriver</span><span class="params">(String driver)</span> </span>&#123;</span><br><span class="line">  dataSource.setDriver(driver);</span><br><span class="line">  forceCloseAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在set以后都调用了forceCloseAll方法来将所有的活动和空闲连接全部关闭，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forceCloseAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 增加同步锁</span></span><br><span class="line">  <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">    <span class="comment">// 重新计算和更新连接类型代码</span></span><br><span class="line">    expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword());</span><br><span class="line">    <span class="comment">// 依次循环所有的活动链接</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = state.activeConnections.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        PooledConnection conn = state.activeConnections.remove(i - <span class="number">1</span>);</span><br><span class="line">        conn.invalidate();</span><br><span class="line"></span><br><span class="line">        Connection realConn = conn.getRealConnection();</span><br><span class="line">        <span class="keyword">if</span> (!realConn.getAutoCommit()) &#123;</span><br><span class="line">          realConn.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        realConn.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依次关闭所有的空闲连接  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = state.idleConnections.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        PooledConnection conn = state.idleConnections.remove(i - <span class="number">1</span>);</span><br><span class="line">        conn.invalidate();</span><br><span class="line"></span><br><span class="line">        Connection realConn = conn.getRealConnection();</span><br><span class="line">        <span class="keyword">if</span> (!realConn.getAutoCommit()) &#123;</span><br><span class="line">          realConn.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        realConn.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;PooledDataSource forcefully closed/removed all connections.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种机制保证了池化数据源的链接始终等价的。<br /><a name="XJgus"></a></p><h2 id="池化连接"><a class="markdownIt-Anchor" href="#池化连接"></a> 池化连接</h2><p>关闭一个池化连接时，不应该真正的关闭掉，而是应该将自己放回连接池。正因为如此，PooledDataSource获得的数据库连接不能是普通的Connection类而是PooledConnection类。这类事普通Connection类的代理类。其最终的一个重要工作就是修改Connection的close方法行为。<br />PooledConnection类继承了InvocationHandler接口实现了动态代理类，其invoke源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// 获取方法名</span></span><br><span class="line">  String methodName = method.getName();</span><br><span class="line">  <span class="keyword">if</span> (CLOSE.hashCode() == methodName.hashCode() &amp;&amp; CLOSE.equals(methodName)) &#123;</span><br><span class="line">    <span class="comment">// 把Connection返回给连接池</span></span><br><span class="line">    dataSource.pushConnection(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 检查连接是否可用</span></span><br><span class="line">    <span class="keyword">if</span> (!Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="comment">// issue #579 toString() should never fail</span></span><br><span class="line">      <span class="comment">// throw an SQLException instead of a Runtime</span></span><br><span class="line">      checkConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用真正的连接去执行</span></span><br><span class="line">    <span class="keyword">return</span> method.invoke(realConnection, args);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;datasource包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#datasource包&quot;&gt;&lt;/a&gt; datasource包&lt;/h1&gt;
&lt;p&gt;通过dataSource包Mybatis将完成数据源的获取、数据连接的建立等工作为操作语句</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="配置解析包" scheme="https://jie-blog.icu/categories/mybatis/%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>scripting包</title>
    <link href="https://jie-blog.icu/posts/mybatis-scripting/"/>
    <id>https://jie-blog.icu/posts/mybatis-scripting/</id>
    <published>2020-11-04T04:04:21.000Z</published>
    <updated>2020-11-04T04:05:26.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="scripting包"><a class="markdownIt-Anchor" href="#scripting包"></a> scripting包</h1><p>mapper中的SQL语句支持使用非常灵活的SQL语句组建方式，比如可以在组建语句时使用foreach、where、if等标签。但是，无论使用哪种方式，最终还是会被解析成为最基本的SQL语句才能被数据库接受，这个解析过程主要由scripting包完成。<br /><a name="Wf20I"></a></p><h1 id="语言驱动接口及语言驱动注册表"><a class="markdownIt-Anchor" href="#语言驱动接口及语言驱动注册表"></a> 语言驱动接口及语言驱动注册表</h1><p><a name="MjFF3"></a></p><h2 id="languagedriver"><a class="markdownIt-Anchor" href="#languagedriver"></a> LanguageDriver</h2><p>LanguageDriver为语言驱动类的接口。该接口内部一共定义了三个方法，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LanguageDriver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建参数处理器，参数处理器能够将实参传给JDBC statement</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> mappedStatement 完整的数据库操作节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> parameterObject 参数对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> boundSql 数据库操作语句转化的BoundSql对象.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 参数处理器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">ParameterHandler <span class="title">createParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建SqlSource对象（基于映射文件方式）。该方法在Mybatis启动阶段读取映射接口或映射文件时被调用</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> configuration 配置信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> script 映射文件中的数据库操作节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> parameterType 参数类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> SqlSource 对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, XNode script, Class&lt;?&gt; parameterType)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建SqlSource对象（基于注解的方式）。该方式在Mybatis启动阶段读取映射接口或映射文件时被调用</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> configuration 配置信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> script 注解中的SQL字符串</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> parameterType 参数类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> SqlSource 对象 准确地说是DynamicSqlSource和RowSqlSource中的一中</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, String script, Class&lt;?&gt; parameterType)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LanguageDriver接口默认有两个实现，分别是RawLanguageDriver和XMLLanguageDriver，其中RawLanguageDriver是XMLLanguageDriver的子类。<br />RawLanguageDriver的所有方法其实都是XMLLanguageDriver完成的。并且在XMLLanguageDriver类完成操作后通过checkIsNotDynamic方法校验SqlSource必须为RowSqlSource类型。因此说RawLanguageDriver实际上是通过checkIsNotDynamic方法对XMLLanguageDriver类的裁剪，使得自身仅仅支持RowSqlSource类型的SqlSource。这种自身功能是父类功能子集的模型是一种先繁再简的方法。<br />此外，Mybatis还允许用户自己给出LanguageDriver的实现类，通过配置文件中的defaultScriptingLanguage实行将其指定为默认的脚本驱动。<br /><a name="ILV7A"></a></p><h2 id="languagedriverregistry"><a class="markdownIt-Anchor" href="#languagedriverregistry"></a> LanguageDriverRegistry</h2><p>LanguageDriverRegistry作为语言驱动的注册表管理所有的语言驱动，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有的语言驱动类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;? extends LanguageDriver&gt;, LanguageDriver&gt; LANGUAGE_DRIVER_MAP = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 默认的语言驱动类</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;? extends LanguageDriver&gt; defaultDriverClass;</span><br></pre></td></tr></table></figure><p>该类内部主要包括注册驱动、选取驱动。<br /><a name="dVsCk"></a></p><h1 id="sql节点树组建"><a class="markdownIt-Anchor" href="#sql节点树组建"></a> SQL节点树组建</h1><p>众多SQL节点组成的就是一棵树，首先要做的就是将XML中的信息读取出来，然后在内存中将XML树组建为一个SQL节点树。SQL节点树的组建就是由XMLScriptBuilder类负责的。<br />该类内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前要处理的XML节点  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> XNode context;</span><br><span class="line"><span class="comment">// 当前节点是否为动态节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isDynamic;</span><br><span class="line"><span class="comment">// 输入参数的类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; parameterType;</span><br><span class="line"><span class="comment">// 节点类型和对应的处理器组成的Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, NodeHandler&gt; nodeHandlerMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>在该类的内部定义了一个内部接口NodeHandler，该接口主要负责将节点拼装到节点数中。其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">NodeHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 该方法将当前节点拼装到节点数中</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleNode</span><span class="params">(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个SQL节点都对应了一个NodeHandler实现类，NodeHandler接口与其实现类的类图如下图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602289550226-bbe5ed50-bdda-4587-8460-16be900103dd.png#align=left&amp;display=inline&amp;height=244&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=488&amp;originWidth=1123&amp;size=925441&amp;status=done&amp;style=none&amp;width=561.5" alt="image.png" /><br />SQL节点与NodeHandler的对应关系由nodeHandlerMap所存储。<br />以IfHandler为例来分析XML信息如何组建成SQL节点树，IfHandler源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">IfHandler</span> <span class="keyword">implements</span> <span class="title">NodeHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">IfHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Prevent Synthetic Access</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNode</span><span class="params">(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解析该节点的下级节点</span></span><br><span class="line">    MixedSqlNode mixedSqlNode = parseDynamicTags(nodeToHandle);</span><br><span class="line">    <span class="comment">// 获取该节点的test节点</span></span><br><span class="line">    String test = nodeToHandle.getStringAttribute(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建一个IfSqlNode</span></span><br><span class="line">    IfSqlNode ifSqlNode = <span class="keyword">new</span> IfSqlNode(mixedSqlNode, test);</span><br><span class="line">    <span class="comment">// 将创建的IfSqlNode存放到SQL树中</span></span><br><span class="line">    targetContents.add(ifSqlNode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，组件SQL节点树的过程是一个深度优先遍历的过程。在下级节点处理完毕后，提取了XML中的信息组建成IfSqlNode对象，然后将IfSqlNode对象放入到了SQL节点数中。<br />从根节点组建方法的入口方法是parseScriptNode，目的是为了解析节点生成SqlSource对象，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parseScriptNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 解析节点得到MixedSqlNode</span></span><br><span class="line">  MixedSqlNode rootSqlNode = parseDynamicTags(context);</span><br><span class="line">  SqlSource sqlSource;</span><br><span class="line">  <span class="comment">// 根据是否有动态，创建对应的SqlSource</span></span><br><span class="line">  <span class="keyword">if</span> (isDynamic) &#123;</span><br><span class="line">    sqlSource = <span class="keyword">new</span> DynamicSqlSource(configuration, rootSqlNode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sqlSource = <span class="keyword">new</span> RawSqlSource(configuration, rootSqlNode, parameterType);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sqlSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其主要操作在parseDynamicTags完成，即把对象解析为节点树，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> MixedSqlNode <span class="title">parseDynamicTags</span><span class="params">(XNode node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// XNode拆分出的SqlNode列表</span></span><br><span class="line">  List&lt;SqlNode&gt; contents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 输入XNode的子XNode</span></span><br><span class="line">  NodeList children = node.getNode().getChildNodes();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">    <span class="comment">// 循环遍历每一个XNode</span></span><br><span class="line">    XNode child = node.newXNode(children.item(i));</span><br><span class="line">    <span class="comment">// CDTATASection类型或者是Test类型的XNode节点</span></span><br><span class="line">    <span class="keyword">if</span> (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) &#123;</span><br><span class="line">      <span class="comment">// 获取XNode的信息</span></span><br><span class="line">      String data = child.getStringBody(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      TextSqlNode textSqlNode = <span class="keyword">new</span> TextSqlNode(data);</span><br><span class="line">      <span class="comment">// 只要有一个TestSqlNode对象是动态的，那么整个MixedSqlNode就是动态的</span></span><br><span class="line">      <span class="keyword">if</span> (textSqlNode.isDynamic()) &#123;</span><br><span class="line">        contents.add(textSqlNode);</span><br><span class="line">        isDynamic = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        contents.add(<span class="keyword">new</span> StaticTextSqlNode(data));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 子XNode也是Node类型</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getNode().getNodeType() == Node.ELEMENT_NODE) &#123; <span class="comment">// issue #628</span></span><br><span class="line">      String nodeName = child.getNode().getNodeName();</span><br><span class="line">      <span class="comment">// 找到对应的处理器</span></span><br><span class="line">      NodeHandler handler = nodeHandlerMap.get(nodeName);</span><br><span class="line">      <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Unknown element &lt;&quot;</span> + nodeName + <span class="string">&quot;&gt; in SQL statement.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 用处理器节点处理</span></span><br><span class="line">      handler.handleNode(child, contents);</span><br><span class="line">      isDynamic = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个混合节点，其实就是一个SQL节点树</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MixedSqlNode(contents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parseDynamicTags会逐步分析XML文件中的节点并使用对应的NodeHandler实现来处理该节点，最终将所有的节点整合到一个MixedSqlNode对象中。MixedSqlNode对象就是SQL节点树。<br />在整合节点树的过程中，只要存在一个动态节点，那么该SQL树就会被认作动态的，动态的SQL节点树将用来创建DynamicSqlSource对象，否则就创建RawSqlSource。<br /><a name="mQHfY"></a></p><h1 id="sql节点树的解析"><a class="markdownIt-Anchor" href="#sql节点树的解析"></a> SQL节点树的解析</h1><p>对创建好的SQL节点数的解析主要是在scripting包的xmltags子包中进行展开。<br /><a name="uMgGN"></a></p><h2 id="ognl"><a class="markdownIt-Anchor" href="#ognl"></a> OGNL</h2><p>在分析源码之前，首先要了解一下OGNL。<br />OGNL（对象导航语言）是一种强大的表达式语言（EL）。通过它能够完成从集合中选取对象、读写对象的属性、调用对象和类的方法、表达式求值与判断等工作。<br />OGNL有Java工具包，只要引用它就可以在Java中使用OGNL的功能，OGNL主要有三个概念：</p><ul><li>表达式（expression）：是一个带有语法含义的字符串，是整个OGNL的核心内容，通过表达式来确定需要进行的OGNL操作。</li><li>根对象（root）：可以理解为OGNL的被操作对象。表达式中表示的操作就是针对根对象展开的。</li><li>上下文（context）：整个OGNL处理的上下文环境，该环境是Map对象。在进行OGNL处理之前，可以传入一个初始化过得上下文环境。<br /><a name="MFVMQ"></a></li></ul><h2 id="xmltags中的ognl"><a class="markdownIt-Anchor" href="#xmltags中的ognl"></a> xmltags中的OGNL</h2><p>为了更好地完成OGNL的解析工作，xmltags中还设置了三个相关的类，分别是：OgnlCache、OgnlClassResolver、OgnlMemberAccess。<br /><a name="JayZh"></a></p><h3 id="ognlclassresolver"><a class="markdownIt-Anchor" href="#ognlclassresolver"></a> OgnlClassResolver</h3><p>该类是OGNL定义的一个类，OGNL可以通过该类进行类的读取，即将类名转化为一个类。<br />OgnlClassResolver继承自DefaultClassResolver，并覆盖了其toClassForName方法，这样就可以通过Resources来读取类了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OgnlClassResolver</span> <span class="keyword">extends</span> <span class="title">DefaultClassResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Class <span class="title">toClassForName</span><span class="params">(String className)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Resources.classForName(className);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="UQ8Qq"></a></p><h3 id="ognlmemberaccess"><a class="markdownIt-Anchor" href="#ognlmemberaccess"></a> OgnlMemberAccess</h3><p>MemberAccess是OGNL提供的一个钩子接口，OGNL借助这个接口为访问对象的属性做好准备。<br />OgnlMemberAccess实现了MemberAccess接口，并基于反射修改了对象的访问性功能，这样OGNL便可以基于这些功能为访问对象的属性做好准备。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OgnlMemberAccess</span> <span class="keyword">implements</span> <span class="title">MemberAccess</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当前环境下，通过反射是否能够修改对象属性的可访问性</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> canControlMemberAccessible;</span><br><span class="line"></span><br><span class="line">  OgnlMemberAccess() &#123;</span><br><span class="line">    <span class="keyword">this</span>.canControlMemberAccessible = Reflector.canControlMemberAccessible();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置属性的可访问性</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">setup</span><span class="params">(Map context, Object target, Member member, String propertyName)</span> </span>&#123;</span><br><span class="line">    Object result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果允许修改属性的可访问性</span></span><br><span class="line">    <span class="keyword">if</span> (isAccessible(context, target, member, propertyName)) &#123;</span><br><span class="line">      AccessibleObject accessible = (AccessibleObject) member;</span><br><span class="line">      <span class="comment">// 如果属性原本不可访问</span></span><br><span class="line">      <span class="keyword">if</span> (!accessible.isAccessible()) &#123;</span><br><span class="line">        result = Boolean.FALSE;</span><br><span class="line">        <span class="comment">// 将属性修改为可访问</span></span><br><span class="line">        accessible.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将属性的可访问性恢复到指定状态</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restore</span><span class="params">(Map context, Object target, Member member, String propertyName,</span></span></span><br><span class="line"><span class="function"><span class="params">      Object state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ((AccessibleObject) member).setAccessible((Boolean) state);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断对象属性是否可访问</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccessible</span><span class="params">(Map context, Object target, Member member, String propertyName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> canControlMemberAccessible;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="Cwk3y"></a></p><h3 id="ognlcache"><a class="markdownIt-Anchor" href="#ognlcache"></a> OgnlCache</h3><p>为了提升OGNL的运行效率，Mybatis还提供了该缓存类，其内部源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OgnlCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> OgnlMemberAccess MEMBER_ACCESS = <span class="keyword">new</span> OgnlMemberAccess();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> OgnlClassResolver CLASS_RESOLVER = <span class="keyword">new</span> OgnlClassResolver();</span><br><span class="line">  <span class="comment">// 缓存解析后的OGNL表达式，提高效率</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; expressionCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">OgnlCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Prevent Instantiation of Static Class</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 读取表达式结果</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getValue</span><span class="params">(String expression, Object root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建默认的上下文</span></span><br><span class="line">      Map context = Ognl.createDefaultContext(root, MEMBER_ACCESS, CLASS_RESOLVER, <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">// 依次传入表达式树、上下文、根，从而获得表达式的结果</span></span><br><span class="line">      <span class="keyword">return</span> Ognl.getValue(parseExpression(expression), context, root);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OgnlException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error evaluating expression &#x27;&quot;</span> + expression + <span class="string">&quot;&#x27;. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 解析表达式，得到解析后的表达式树</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">parseExpression</span><span class="params">(String expression)</span> <span class="keyword">throws</span> OgnlException </span>&#123;</span><br><span class="line">    <span class="comment">// 先从缓存中获取</span></span><br><span class="line">    Object node = expressionCache.get(expression);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 直接解析，放入缓存</span></span><br><span class="line">      node = Ognl.parseExpression(expression);</span><br><span class="line">      expressionCache.put(expression, node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="bLd3f"></a></p><h2 id="表达式求值"><a class="markdownIt-Anchor" href="#表达式求值"></a> 表达式求值</h2><p>Mybatis没有将OGNL暴露给各个SQL节点使用，而是进一步的易用封装，得到了ExpressionEvaluator类，即表达式求值器，该类内部一共有两个方法，一个是evaluateBoolean一个是evaluateIterable。<br /><a name="B2R01"></a></p><h3 id="evaluateboolean"><a class="markdownIt-Anchor" href="#evaluateboolean"></a> evaluateBoolean</h3><p>该方法能够根据结果为判断语句求值（<if test="name!=xx">），其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">evaluateBoolean</span><span class="params">(String expression, Object parameterObject)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取表达式</span></span><br><span class="line">  Object value = OgnlCache.getValue(expression, parameterObject);</span><br><span class="line">  <span class="comment">// 如果是Boolean类型</span></span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">    <span class="keyword">return</span> (Boolean) value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是数字形式</span></span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Number) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(String.valueOf(value)).compareTo(BigDecimal.ZERO) != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="pMRpz"></a></p><h3 id="evaluateiterable"><a class="markdownIt-Anchor" href="#evaluateiterable"></a> evaluateIterable</h3><p>该方法能够为迭代形式的表达式求值，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterable&lt;?&gt; evaluateIterable(String expression, Object parameterObject) &#123;</span><br><span class="line">  <span class="comment">// 获取表达式结果</span></span><br><span class="line">  Object value = OgnlCache.getValue(expression, parameterObject);</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;The expression &#x27;&quot;</span> + expression + <span class="string">&quot;&#x27; evaluated to a null value.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 结果是Iterable类型</span></span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Iterable) &#123;</span><br><span class="line">    <span class="keyword">return</span> (Iterable&lt;?&gt;) value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 结果是Array</span></span><br><span class="line">  <span class="keyword">if</span> (value.getClass().isArray()) &#123;</span><br><span class="line">    <span class="comment">// 如果Array是原始的调用asList会抛出异常，因此要手动转为ArrayList</span></span><br><span class="line">    <span class="keyword">int</span> size = Array.getLength(value);</span><br><span class="line">    List&lt;Object&gt; answer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      Object o = Array.get(value, i);</span><br><span class="line">      answer.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果结果为Map</span></span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">    <span class="keyword">return</span> ((Map) value).entrySet();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error evaluating expression &#x27;&quot;</span> + expression + <span class="string">&quot;&#x27;.  Return value (&quot;</span> + value + <span class="string">&quot;) was not iterable.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="WM3QQ"></a></p><h2 id="动态上下文"><a class="markdownIt-Anchor" href="#动态上下文"></a> 动态上下文</h2><p>在SQL节点树解析时，需要不断保存已完成的SQL片段。在进行SQL节点树的解析时也需要一些参数和环境信息为解析的依据。以上两个功能都由DynamicContext提供。其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上下文环境</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ContextMap bindings;</span><br><span class="line"><span class="comment">// 用于拼装SQL语句片段的SpringJoiner</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StringJoiner sqlBuilder = <span class="keyword">new</span> StringJoiner(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">// 解析时的唯一编号，防止解析混乱</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> uniqueNumber = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>ContextMap是DynamicContext的内部类，是HashMap的子类。在进行数据查询的时候会先从ContextMap中查询，如果查询失败会从参数对象属性中查询，因此在编写SQL语句时可以直接引用参数对象的的属性。<br />DynamicContext类的构造方法中有上下文环境初始化的主要逻辑，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DynamicContext</span><span class="params">(Configuration configuration, Object parameterObject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parameterObject != <span class="keyword">null</span> &amp;&amp; !(parameterObject <span class="keyword">instanceof</span> Map)) &#123;</span><br><span class="line">    <span class="comment">// 获得参数对象的元对象</span></span><br><span class="line">    MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">    <span class="comment">// 判断参数对象本身是否有对应的类型处理器</span></span><br><span class="line">    <span class="keyword">boolean</span> existsTypeHandler = configuration.getTypeHandlerRegistry().hasTypeHandler(parameterObject.getClass());</span><br><span class="line">    <span class="comment">// 放入上下文信息</span></span><br><span class="line">    bindings = <span class="keyword">new</span> ContextMap(metaObject, existsTypeHandler);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 上下文信息为空</span></span><br><span class="line">    bindings = <span class="keyword">new</span> ContextMap(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把参数对象放入上下文信息</span></span><br><span class="line">  bindings.put(PARAMETER_OBJECT_KEY, parameterObject);</span><br><span class="line">  <span class="comment">// 把数据库id放入上下文信息</span></span><br><span class="line">  bindings.put(DATABASE_ID_KEY, configuration.getDatabaseId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，bingdings属性中存储了以下信息：</p><ul><li>数据库id。因此在编写SQL语句时可以直接使用DATABASE_ID_KEY变量引用数据库id的值。</li><li>参数对象。在编写SQL语句时可以直接使用PARAMETER_OBJECT_KEY变量来引用整个参数对象。</li><li>参数对象的元数据。基于参数对象元数据可以方便的引用参数对象的属性值，因此，编写SQL语句时可以直接引用参数对象的属性。<br /><a name="BLXZm"></a></li></ul><h2 id="sql节点及其解析"><a class="markdownIt-Anchor" href="#sql节点及其解析"></a> SQL节点及其解析</h2><p>Mybatis会将动态节点解析后才交给数据库执行，这些节点在Mybatis中都会被认为SqlNode。<br />SqlNode是一个接口，其内部只定义了一个apply方法，该方法负责完成节点自身的解析，并将解析结果合并到输入参数提供的上下文环境中。该接口的类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602295821126-63be2991-78e6-46c0-8e34-f5d10fb7cd42.png#align=left&amp;display=inline&amp;height=304&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=608&amp;originWidth=1115&amp;size=743466&amp;status=done&amp;style=none&amp;width=557.5" alt="image.png" /><br />接下来以典型的IfSqlSource、ForEachSqlSource、TextSqlNode为例对SqlNode接口的实现类进行介绍。<br /><a name="rvTby"></a></p><h3 id="ifsqlsource"><a class="markdownIt-Anchor" href="#ifsqlsource"></a> IfSqlSource</h3><p>该类的目标是if标签，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表达式求值器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExpressionEvaluator evaluator;</span><br><span class="line"><span class="comment">// if判断时的测试条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String test;</span><br><span class="line"><span class="comment">// 如果if成立，要被拼接的SQL片段信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlNode contents;</span><br></pre></td></tr></table></figure><p>apply方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断if条件是否成立</span></span><br><span class="line">  <span class="keyword">if</span> (evaluator.evaluateBoolean(test, context.getBindings())) &#123;</span><br><span class="line">    <span class="comment">// contents拼接到context</span></span><br><span class="line">    contents.apply(context);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="95RzH"></a></p><h3 id="foreachsqlnode"><a class="markdownIt-Anchor" href="#foreachsqlnode"></a> ForEachSqlNode</h3><p>ForEachSqlNode节点对应了foreach标签，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表达式求值器 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExpressionEvaluator evaluator;</span><br><span class="line"><span class="comment">// conllection属性的值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String collectionExpression;</span><br><span class="line"><span class="comment">// 节点内的内容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlNode contents;</span><br><span class="line"><span class="comment">// 左侧插入的字符串</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String open;</span><br><span class="line"><span class="comment">// 右侧插入的字符串</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String close;</span><br><span class="line"><span class="comment">// 元素分隔符</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String separator;</span><br><span class="line"><span class="comment">// 元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String item;</span><br><span class="line"><span class="comment">// 元素编号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String index;</span><br><span class="line"><span class="comment">// 配置信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br></pre></td></tr></table></figure><p>apply实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取上下文信息</span></span><br><span class="line">  Map&lt;String, Object&gt; bindings = context.getBindings();</span><br><span class="line">  <span class="comment">// 交给表达式求值器解析表达式从而获取迭代器</span></span><br><span class="line">  <span class="keyword">final</span> Iterable&lt;?&gt; iterable = evaluator.evaluateIterable(collectionExpression, bindings);</span><br><span class="line">  <span class="comment">// 没有可迭代的元素</span></span><br><span class="line">  <span class="keyword">if</span> (!iterable.iterator().hasNext()) &#123;</span><br><span class="line">    <span class="comment">// 不需要拼接信息直接返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">boolean</span> first = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">// 添加open字符串</span></span><br><span class="line">  applyOpen(context);</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (Object o : iterable) &#123;</span><br><span class="line">    DynamicContext oldContext = context;</span><br><span class="line">    <span class="comment">// 第一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (first || separator == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 添加元素</span></span><br><span class="line">      context = <span class="keyword">new</span> PrefixedContext(context, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 添加间隔符</span></span><br><span class="line">      context = <span class="keyword">new</span> PrefixedContext(context, separator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> uniqueNumber = context.getUniqueNumber();</span><br><span class="line">    <span class="comment">// Issue #709</span></span><br><span class="line">    <span class="comment">// 迭代的对象是map</span></span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      <span class="comment">// 迭代对象放入上下文环境</span></span><br><span class="line">      Map.Entry&lt;Object, Object&gt; mapEntry = (Map.Entry&lt;Object, Object&gt;) o;</span><br><span class="line">      applyIndex(context, mapEntry.getKey(), uniqueNumber);</span><br><span class="line">      applyItem(context, mapEntry.getValue(), uniqueNumber);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 将被迭代对象放入上下文环境</span></span><br><span class="line">      applyIndex(context, i, uniqueNumber);</span><br><span class="line">      applyItem(context, o, uniqueNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据上下文环境等信息构建内容</span></span><br><span class="line">    contents.apply(<span class="keyword">new</span> FilteredDynamicContext(configuration, context, index, item, uniqueNumber));</span><br><span class="line">    <span class="keyword">if</span> (first) &#123;</span><br><span class="line">      first = !((PrefixedContext) context).isPrefixApplied();</span><br><span class="line">    &#125;</span><br><span class="line">    context = oldContext;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加close字符串</span></span><br><span class="line">  applyClose(context);</span><br><span class="line">  <span class="comment">// 清理此次操作对环境的影响</span></span><br><span class="line">  context.getBindings().remove(item);</span><br><span class="line">  context.getBindings().remove(index);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，其主要流程是解析被迭代元素获得的迭代对象，然后迭代对象的信息添加到上下文中，根据上下文信息拼接字符串。字符串拼接完成后，对此次操作产生的临时变量清除。<br /><a name="vJJl8"></a></p><h3 id="textsqlnode"><a class="markdownIt-Anchor" href="#textsqlnode"></a> TextSqlNode</h3><p>该标签对应了SQL语句的字符串节点。字符串节点应用广泛，TextSqlNode能替换掉其中的“<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 142: …c0a46e47b54.png#̲align=left&amp;disp…'>{}”占位符。&lt;br /&gt;该类内部类图如下：&lt;br /&gt;![image.png](https://cdn.nlark.com/yuque/0/2020/png/485026/1602297072525-c1dd57e6-87ab-4b64-ada5-6c0a46e47b54.png#align=left&amp;display=inline&amp;height=246&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=492&amp;originWidth=1092&amp;size=771788&amp;status=done&amp;style=none&amp;width=546)&lt;br /&gt;TokenHandler接口会和通用占位符解析器GenericTokenParser配合使用，GenericTokenParser解析到匹配的占位符时会将占位符中的内容交给TokenHandler对象的handleToken方法处理。在TextSqlNode对象中占位符就是“</span>{}”符号，该对象会将SQL语句交给其两个内部类分别处理：</p><ul><li>BindingTokenParser：该对象的handleToken方法会取出占位符中的变量，然后使用该变量作为键去上下文环境中寻找对应的值然后替换占位符。</li><li>DynamicCheckerTokenParser：该对象的handleToken方法会置位成员属性isDynamic，因此该对象可以记录是否自身读到过占位符。</li></ul><p>TextSqlNode的apply方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建通用占位符解析器</span></span><br><span class="line">  GenericTokenParser parser = createParser(<span class="keyword">new</span> BindingTokenParser(context, injectionFilter));</span><br><span class="line">  <span class="comment">// 替换掉$&#123;&#125;</span></span><br><span class="line">  context.appendSql(parser.parse(text));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> GenericTokenParser <span class="title">createParser</span><span class="params">(TokenHandler handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> GenericTokenParser(<span class="string">&quot;$&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于TextSqlNode而言，如果内部含有${}那就是动态的，否则就不是动态的。<br /><a name="7j58t"></a></p><h1 id="sqlsource总结"><a class="markdownIt-Anchor" href="#sqlsource总结"></a> SqlSource总结</h1><p>语言驱动类的主要工作就是生成SqlSource，在语言驱动接口LanguageDriver的三个方法中，有两个方法是用来生成SqlSource的。而SqlSource子类的转化工作也是主要在scripting包中完成的。<br />SqlSource的子类的区别：</p><ul><li>DynamicSqlSource：动态Sql语句。所谓动态SQL语句是指含有动态SQL节点或者含有“${}”占位符。</li><li>RawSqlSource：原生SQL语句。指非动态语句，语句中可能含有“#{}”占位符，但不含有动态的SQL节点与“${}”占位符。</li><li>StaticSqlSource：静态语句。语句中可能含有“?”，可以直接交给数据库执行。</li><li>ProviderSqlSource：上面几种都是通过XML文件获取SQL语句，而P它是通过注解映射的形式获取的SQL语句。<br /><a name="lE8Jv"></a></li></ul><h2 id="sqlsource的生成"><a class="markdownIt-Anchor" href="#sqlsource的生成"></a> SqlSource的生成</h2><p><a name="Xap9B"></a></p><h3 id="解析映射文件生成sqlsource"><a class="markdownIt-Anchor" href="#解析映射文件生成sqlsource"></a> 解析映射文件生成SqlSource</h3><p>LanguageDiriver的下述方法用来解析配置文件中的节点信息，从而获取SqlSource对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, XNode script, Class&lt;?&gt; parameterType)</span></span>;</span><br></pre></td></tr></table></figure><p>其实现在XMLLanguageDriver中，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, XNode script, Class&lt;?&gt; parameterType)</span> </span>&#123;</span><br><span class="line">  XMLScriptBuilder builder = <span class="keyword">new</span> XMLScriptBuilder(configuration, script, parameterType);</span><br><span class="line">  <span class="keyword">return</span> builder.parseScriptNode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parseScriptNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MixedSqlNode rootSqlNode = parseDynamicTags(context);</span><br><span class="line">  SqlSource sqlSource;</span><br><span class="line">  <span class="keyword">if</span> (isDynamic) &#123;</span><br><span class="line">    sqlSource = <span class="keyword">new</span> DynamicSqlSource(configuration, rootSqlNode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sqlSource = <span class="keyword">new</span> RawSqlSource(configuration, rootSqlNode, parameterType);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sqlSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，解析映射文件生成的SqlSource不是DynamicSqlSource就是RawSqlSource。<br /><a name="VYEmq"></a></p><h3 id="解析注解信息生成sqlsource"><a class="markdownIt-Anchor" href="#解析注解信息生成sqlsource"></a> 解析注解信息生成SqlSource</h3><p>ProviderSqlSource通过调用LanguageDriver中的下述接口方法来生成SqlSource接口子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, String script, Class&lt;?&gt; parameterType)</span></span>;</span><br></pre></td></tr></table></figure><p>其是现在XMLLanguageDriver中，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, String script, Class&lt;?&gt; parameterType)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果注解是以&lt;script&gt;开头</span></span><br><span class="line">  <span class="keyword">if</span> (script.startsWith(<span class="string">&quot;&lt;script&gt;&quot;</span>)) &#123;</span><br><span class="line">    XPathParser parser = <span class="keyword">new</span> XPathParser(script, <span class="keyword">false</span>, configuration.getVariables(), <span class="keyword">new</span> XMLMapperEntityResolver());</span><br><span class="line">    <span class="keyword">return</span> createSqlSource(configuration, parser.evalNode(<span class="string">&quot;/script&quot;</span>), parameterType);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果注解中的内容不以&lt;script&gt;开头</span></span><br><span class="line">    script = PropertyParser.parse(script, configuration.getVariables());</span><br><span class="line">    TextSqlNode textSqlNode = <span class="keyword">new</span> TextSqlNode(script);</span><br><span class="line">    <span class="keyword">if</span> (textSqlNode.isDynamic()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DynamicSqlSource(configuration, textSqlNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RawSqlSource(configuration, script, parameterType);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果以<script>开头的SQL语句将使用和映射文件相同的解析方式，从而生成DynamicSqlSource或者RawSqlSource。<br />如果不以<script>开头则直接生成DynamicSqlSource或者RawSqlSource。<br />对象转化图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602386804982-42427fa6-cd4e-4a24-b1cc-588c075e0b78.png#align=left&amp;display=inline&amp;height=455&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=455&amp;originWidth=824&amp;size=601302&amp;status=done&amp;style=none&amp;width=824" alt="image.png" /><br /><a name="rrzvq"></a></p><h2 id="dynamicsqlsource的转化"><a class="markdownIt-Anchor" href="#dynamicsqlsource的转化"></a> DynamicSqlSource的转化</h2><p>DynamicSqlSource类在scripting的xmltags子包中，无论是DynamicSqlSource还是RawSqlSource最终都会转化为StaticSqlSource，然后才能给出一个BoundSql对象。<br />DynamicSqlSource的getBoundSql源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;.</span><br><span class="line">  <span class="comment">// 创建DynamicSqlSource的辅助类，用来记录DynamicSqlSource解析出来的SQL片段信息</span></span><br><span class="line">  DynamicContext context = <span class="keyword">new</span> DynamicContext(configuration, parameterObject);</span><br><span class="line">  <span class="comment">// 这里会从根节点开始，对节点逐层调用apply方法，此后所有的动态节点和“$&#123;&#125;”都会被替换</span></span><br><span class="line">  rootSqlNode.apply(context);</span><br><span class="line">  <span class="comment">// 处理占位符、汇总参数信息</span></span><br><span class="line">  SqlSourceBuilder sqlSourceParser = <span class="keyword">new</span> SqlSourceBuilder(configuration);</span><br><span class="line">  Class&lt;?&gt; parameterType = parameterObject == <span class="keyword">null</span> ? Object.class : parameterObject.getClass();</span><br><span class="line">  <span class="comment">// 处理“#&#123;&#125;”为?，最终圣城StaticSqlSource对象                                                   </span></span><br><span class="line">  SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());</span><br><span class="line">  BoundSql boundSql = sqlSource.getBoundSql(parameterObject);</span><br><span class="line">  <span class="comment">// getBindings的信息放入到boundSql的metaParameters中保存                                                 </span></span><br><span class="line">  context.getBindings().forEach(boundSql::setAdditionalParameter);</span><br><span class="line">  <span class="keyword">return</span> boundSql;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中parse方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parse</span><span class="params">(String originalSql, Class&lt;?&gt; parameterType, Map&lt;String, Object&gt; additionalParameters)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 完成#&#123;&#125;处理的处理器  </span></span><br><span class="line">  ParameterMappingTokenHandler handler = <span class="keyword">new</span> ParameterMappingTokenHandler(configuration, parameterType, additionalParameters);</span><br><span class="line">  <span class="comment">// 通用占位符解析器，用来进行占位符替换  </span></span><br><span class="line">  GenericTokenParser parser = <span class="keyword">new</span> GenericTokenParser(<span class="string">&quot;#&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>, handler);</span><br><span class="line">  <span class="comment">// 将#&#123;&#125;替换为?</span></span><br><span class="line">  String sql = parser.parse(originalSql);</span><br><span class="line">  <span class="comment">// 生成StaticSqlSource并返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> StaticSqlSource(configuration, sql, handler.getParameterMappings());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="A1TQ1"></a></p><h2 id="rawsqlsource的转化"><a class="markdownIt-Anchor" href="#rawsqlsource的转化"></a> RawSqlSource的转化</h2><p>RawSqlSource比DynamicSqlSource简单，它不包含动态节点和${}，因此其在构造方法中就完成了到StaticSqlSource的转化，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RawSqlSource</span><span class="params">(Configuration configuration, String sql, Class&lt;?&gt; parameterType)</span> </span>&#123;</span><br><span class="line">  SqlSourceBuilder sqlSourceParser = <span class="keyword">new</span> SqlSourceBuilder(configuration);</span><br><span class="line">  Class&lt;?&gt; clazz = parameterType == <span class="keyword">null</span> ? Object.class : parameterType;</span><br><span class="line">  <span class="comment">// 处理RawSqlSOurce中的#&#123;&#125;占位符</span></span><br><span class="line">  sqlSource = sqlSourceParser.parse(sql, clazz, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getBoundSql方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 由StaticSqlSource对象返回</span></span><br><span class="line">  <span class="keyword">return</span> sqlSource.getBoundSql(parameterObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="SS2ll"></a></p><h2 id="sqlsource接口实现类总结"><a class="markdownIt-Anchor" href="#sqlsource接口实现类总结"></a> SqlSource接口实现类总结</h2><p>SqlSource实现了的转化图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602387869042-782cd122-28ec-4e15-8d02-3f908636f2e0.png#align=left&amp;display=inline&amp;height=364&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=364&amp;originWidth=1186&amp;size=854514&amp;status=done&amp;style=none&amp;width=1186" alt="image.png" /><br />不管经历了怎样的过程，最终SqlSource接口定义的getBoundSql都是由StaticSqlSource对象来完成的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;scripting包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#scripting包&quot;&gt;&lt;/a&gt; scripting包&lt;/h1&gt;
&lt;p&gt;mapper中的SQL语句支持使用非常灵活的SQL语句组建方式，比如可以在组建语句时使用fore</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="配置解析包" scheme="https://jie-blog.icu/categories/mybatis/%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>mapping包</title>
    <link href="https://jie-blog.icu/posts/mybatis-mapping/"/>
    <id>https://jie-blog.icu/posts/mybatis-mapping/</id>
    <published>2020-11-04T04:04:07.000Z</published>
    <updated>2020-11-04T04:05:00.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mapping包"><a class="markdownIt-Anchor" href="#mapping包"></a> mapping包</h1><p>mapping中定义了众多的解析实体类。mapping包主要有以下功能：</p><ul><li>SQL语句处理功能。</li><li>输出结果处理功能。</li><li>输入参数处理功能。</li><li>多数据库种类处理功能。</li><li>其他功能。<br /><a name="e7nfx"></a></li></ul><h1 id="sql语句处理功能"><a class="markdownIt-Anchor" href="#sql语句处理功能"></a> SQL语句处理功能</h1><p>与SQL处理语句功能相关的类有三个，分别是MappedStatement、SqlSource和BoundSql。<br />其中，MappedStatement表示的是数据库操作节点（select、update、delete和insert）内的所有内容。SqlSource是数据库操作标签中包含的SQL语句。BoundSql是SqlSource的进一步处理产物。三者关系图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602126804963-c1fe5389-2d84-4cdb-a5c0-706f5e788b35.png#align=left&amp;display=inline&amp;height=124&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=249&amp;originWidth=1402&amp;size=498735&amp;status=done&amp;style=none&amp;width=701" alt="image.png" /><br /><a name="lk7FI"></a></p><h2 id="mappedstatement"><a class="markdownIt-Anchor" href="#mappedstatement"></a> MappedStatement</h2><p>这是一个典型的解析实体类，该类的属性和数据库操作标签十分相似。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602126921123-0983655e-b19b-4cd9-8cb6-dc236bca90af.png#align=left&amp;display=inline&amp;height=375&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=749&amp;originWidth=449&amp;size=156937&amp;status=done&amp;style=none&amp;width=224.5" alt="image.png" /><br />这里就不做过多的扩展了。<br /><a name="U1Hpb"></a></p><h2 id="sqlsource"><a class="markdownIt-Anchor" href="#sqlsource"></a> SqlSource</h2><p>SqlSource本身是一个接口，该接口只定义了一个返回BoundSql对象的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlSource</span> </span>&#123;</span><br><span class="line">  <span class="function">BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602127086507-90185b29-a121-4a20-8e7c-7847070a53df.png#align=left&amp;display=inline&amp;height=155&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=309&amp;originWidth=1258&amp;size=577094&amp;status=done&amp;style=none&amp;width=629" alt="image.png" /><br />四种实现类的区别如下：</p><ul><li>DynamicSqlSource：动态SQL语句。即SQL中含有动态SQL节点（如“if”）或者含有占位符（${}）。</li><li>RawSqlSource：原生的SQL语句。指非动态语句，语句中可能含有“#{}”占位符，但是不含动态SQL节点或者“${}”。</li><li>StaticSqlSource：静态语句。语句中可能含有“？”，直接可以交给数据库执行。</li><li>ProviderSqlSource：上面几种都是XML获取的SQL语句，而ProviderSqlSource是通过注解映射形式取得的SQL语句。</li></ul><p>DynamicSqlSource和RawSqlSource都会被处理成StaticSqlSource，然后通过StaticSqlSource的getBoundSql得到BoundSql对象。<br /><a name="WauoH"></a></p><h2 id="boundsql"><a class="markdownIt-Anchor" href="#boundsql"></a> BoundSql</h2><p>BoundSql是参数绑定完成后的SQL语句，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能含有&quot;?&quot;占位符的SQL语句</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String sql;</span><br><span class="line"><span class="comment">// 参数映射列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;ParameterMapping&gt; parameterMappings;</span><br><span class="line"><span class="comment">// 实参对象本身</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object parameterObject;</span><br><span class="line"><span class="comment">// 实参</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; additionalParameters;</span><br><span class="line"><span class="comment">// additionalParameters的包装对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MetaObject metaParameters;</span><br></pre></td></tr></table></figure><p>BoundSql是SQL语句的一个重要的中间产物，它既存储了转化结束的SQL信息，又包含了实参信息和一些附加的环境信息。<br /><a name="nrIcM"></a></p><h1 id="输出结果处理功能"><a class="markdownIt-Anchor" href="#输出结果处理功能"></a> 输出结果处理功能</h1><p>resultMap是一个十分强大的功能，它支持输出结果的组装、判断、懒加载等。<br />其在解析的时候设计的类包括：ResultMap、ResultMapping、Duscriminator，他们都是解析实体类，对应关系如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602127934737-76278523-dfff-4257-a21f-4acd9b343bb1.png#align=left&amp;display=inline&amp;height=148&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=295&amp;originWidth=1118&amp;size=522140&amp;status=done&amp;style=none&amp;width=559" alt="image.png" /><br /><a name="QOspf"></a></p><h2 id="resultmap"><a class="markdownIt-Anchor" href="#resultmap"></a> ResultMap</h2><p>该类和resultMap节点对应的信息高度一致，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局配置信息</span></span><br><span class="line"><span class="keyword">private</span> Configuration configuration;</span><br><span class="line"><span class="comment">// resultMap的编号</span></span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"><span class="comment">// 最终输出结果对应的Java类</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; type;</span><br><span class="line"><span class="comment">// XML中的&lt;result&gt;列表，即ResultMapping列表</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ResultMapping&gt; resultMappings;</span><br><span class="line"><span class="comment">// XML中的&lt;id&gt;和&lt;idArg&gt;</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ResultMapping&gt; idResultMappings;</span><br><span class="line"><span class="comment">// XML中的&lt;constructor&gt;</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ResultMapping&gt; constructorResultMappings;</span><br><span class="line"><span class="comment">// XML中的非&lt;constructor&gt;相关的属性列表</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ResultMapping&gt; propertyResultMappings;</span><br><span class="line"><span class="comment">// 所有参与映射的数据库中字段的集合</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; mappedColumns;</span><br><span class="line"><span class="comment">// 所有参与映射的Java对象属性集合</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; mappedProperties;</span><br><span class="line"><span class="comment">// 鉴别器</span></span><br><span class="line"><span class="keyword">private</span> Discriminator discriminator;</span><br><span class="line"><span class="comment">// 是否存在嵌套映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasNestedResultMaps;</span><br><span class="line"><span class="comment">// 是否存在嵌套查询</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasNestedQueries;</span><br><span class="line"><span class="comment">// 是否启动自动映射</span></span><br><span class="line"><span class="keyword">private</span> Boolean autoMapping;</span><br></pre></td></tr></table></figure><p>在resultMap中，属性被分为了两类：构造方法和非构造方法中的属性。非构造方法中的属性又被分为了两类：id属性和非id属性。根据这两个分类方式就产生了如下四个属性：</p><ul><li>resultMappings：所有的属性</li><li>idResultMappings：所有的id属性</li><li>constructorResultMappings：所有构造方法中的属性</li><li>propertyResultMappings：所有非构造方法中的属性<br /><a name="fOffb"></a></li></ul><h2 id="resultmapping"><a class="markdownIt-Anchor" href="#resultmapping"></a> ResultMapping</h2><p>上述涉及到的idArg、id、result等标签都对应着一个ResultMapping对象，该类内部结构如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602128431586-baf0e1c0-b9cf-4c3b-b788-564d0d79b560.png#align=left&amp;display=inline&amp;height=274&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=548&amp;originWidth=445&amp;size=111856&amp;status=done&amp;style=none&amp;width=222.5" alt="image.png" /><br />该类由于属性较多，因此创建ResultMapping对象会非常复杂，为了改善这个过程，ResultMapping使用了建造者模式。并且它的建造者模式直接放在了类的内部作为内部静态类出现。内部静态类中的方法调用不需要创建类的对象，而它却可以生成类的对象。<br />这种实现方法提升了类的内聚性，可以借鉴这种实现。<br /><a name="bngoH"></a></p><h2 id="discriminator"><a class="markdownIt-Anchor" href="#discriminator"></a> Discriminator</h2><p>Discriminator是resultMap内部的鉴别器，就像程序中的选择语句一样，它使得数据库查询结果能够根据某些条件的不同而进行不同的映射。<br />该类内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储条件判断行信息</span></span><br><span class="line"><span class="keyword">private</span> ResultMapping resultMapping;</span><br><span class="line"><span class="comment">// 存储选择项的信息，键为value的值，值为resultMap的值</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, String&gt; discriminatorMap;</span><br></pre></td></tr></table></figure><p>在DefaultResultSetHandler的resolveDiscriminatedResultMap方法中有该类属性生效的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultMap <span class="title">resolveDiscriminatedResultMap</span><span class="params">(ResultSet rs, ResultMap resultMap, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 已经处理过得鉴别器  </span></span><br><span class="line">  Set&lt;String&gt; pastDiscriminators = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  Discriminator discriminator = resultMap.getDiscriminator();</span><br><span class="line">  <span class="keyword">while</span> (discriminator != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 求解条件判断的结果，这个结果值就是鉴别器鉴别的依据</span></span><br><span class="line">    <span class="keyword">final</span> Object value = getDiscriminatorValue(rs, discriminator, columnPrefix);</span><br><span class="line">    <span class="comment">// 根据真实值判断属于哪个分支</span></span><br><span class="line">    <span class="keyword">final</span> String discriminatedMapId = discriminator.getMapIdFor(String.valueOf(value));</span><br><span class="line">    <span class="comment">// 从接下来的case里找到这个分支</span></span><br><span class="line">    <span class="keyword">if</span> (configuration.hasResultMap(discriminatedMapId)) &#123;</span><br><span class="line">      <span class="comment">// 找出指定的resultMap</span></span><br><span class="line">      resultMap = configuration.getResultMap(discriminatedMapId);</span><br><span class="line">      <span class="comment">// 继续分析下一层</span></span><br><span class="line">      Discriminator lastDiscriminator = discriminator;</span><br><span class="line">      <span class="comment">// 查看本resultMap内是否还有鉴别器</span></span><br><span class="line">      discriminator = resultMap.getDiscriminator();</span><br><span class="line">      <span class="comment">// 判别器出现了环</span></span><br><span class="line">      <span class="keyword">if</span> (discriminator == lastDiscriminator || !pastDiscriminators.add(discriminatedMapId)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resultMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求解鉴别器的条件判断结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getDiscriminatorValue</span><span class="params">(ResultSet rs, Discriminator discriminator, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ResultMapping resultMapping = discriminator.getResultMapping();</span><br><span class="line">  <span class="keyword">final</span> TypeHandler&lt;?&gt; typeHandler = resultMapping.getTypeHandler();</span><br><span class="line">  <span class="keyword">return</span> typeHandler.getResult(rs, prependPrefix(resultMapping.getColumn(), columnPrefix));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="15bMa"></a></p><h1 id="输入参数处理功能"><a class="markdownIt-Anchor" href="#输入参数处理功能"></a> 输入参数处理功能</h1><p>输入参数处理功能设计的两个类关系图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602129369295-91fd796c-bf99-4ae4-bc57-d34e4763768e.png#align=left&amp;display=inline&amp;height=81&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=161&amp;originWidth=1173&amp;size=264140&amp;status=done&amp;style=none&amp;width=586.5" alt="image.png" /><br />这两个类与RestMap和ResultMapping十分类似，并且在现在编译中已经弱化了parameterMap标签（建议使用内联参数），因此在这里就不做过多的分析了。<br /><a name="hcUdR"></a></p><h1 id="多数据库种类处理功能"><a class="markdownIt-Anchor" href="#多数据库种类处理功能"></a> 多数据库种类处理功能</h1><p>Mybatis支持多种数据库。在使用多种数据库前，需要先在配置文件中列举出要使用的数据库类型，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;databaseIdProvider type=<span class="string">&quot;DB_VENDOR&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;MySQL&quot;</span> value=<span class="string">&quot;mysql&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;SQL Server&quot;</span> value=<span class="string">&quot;sqlserver&quot;</span> /&gt;</span><br><span class="line">&lt;/databaseIdProvider&gt;</span><br></pre></td></tr></table></figure><p>然后在SQL语句上书写databaseId，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectByAge&quot;</span> resultMap=<span class="string">&quot;userMap&quot;</span> databaseId=<span class="string">&quot;sqlserver&quot;</span>&gt;</span><br><span class="line">    SELECT * FROM `user` WHERE `age` = #&#123;age&#125; TOP 5</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">&quot;selectByAge&quot;</span> resultMap=<span class="string">&quot;userMap&quot;</span> databaseId=<span class="string">&quot;mysql&quot;</span>&gt;</span><br><span class="line">    SELECT * FROM `user` WHERE `age` = #&#123;age&#125; LIMIT 5</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>多种数据库支持的实现由DatabaseIdProvider接口负责，它有一个VendorDatabaseIdProvider实现类和一个即将废除的DefaultDatabaseIdProvider的子类。<br /><a name="RniON"></a></p><h2 id="vendordatabaseidprovider"><a class="markdownIt-Anchor" href="#vendordatabaseidprovider"></a> VendorDatabaseIdProvider</h2><p>VendorDatabaseIdProvider中的两个重要方法均继承自DatabaseIdProvider接口，分别是setProperties和getDatabaseId。<br /><a name="eoCcQ"></a></p><h3 id="setproperties"><a class="markdownIt-Anchor" href="#setproperties"></a> setProperties</h3><p>setProperties方法是用来将Mybatis配置文件中设置在databaseIdProvider节点中的信息写入到VendorDatabaseIdProvider对象中。<br /><a name="3hOCF"></a></p><h3 id="getdatabaseid"><a class="markdownIt-Anchor" href="#getdatabaseid"></a> getDatabaseId</h3><p>getDatabaseId方法是用来给出当前传入的DataSource对应的databaseId。主要逻辑位于getDatabaseName中，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getDatabaseName</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 获取当前连接的数据库名</span></span><br><span class="line">  String productName = getDatabaseProductName(dataSource);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.properties != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果设置了properties的值，则将获取的数据库名称作为模糊的key，映射为对应的value</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; property : properties.entrySet()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (productName.contains((String) property.getKey())) &#123;</span><br><span class="line">        <span class="keyword">return</span> (String) property.getValue();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// no match, return null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> productName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，他一共做了两个工作：</p><ul><li>获取当前数据源的类型。</li><li>将数据源类型映射为databaseIdProvider中设置的别名。<br /><a name="ETqAY"></a></li></ul><h1 id="其他功能"><a class="markdownIt-Anchor" href="#其他功能"></a> 其他功能</h1><p>mapping包中还有两个重要的类：Envirment和CacheBuiler。<br /><a name="QCzrd"></a></p><h2 id="environment"><a class="markdownIt-Anchor" href="#environment"></a> Environment</h2><p>Environment也是一个解析实体类，它对应着environments节点，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line"><span class="comment">// 事务工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TransactionFactory transactionFactory;</span><br><span class="line"><span class="comment">// 数据源信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DataSource dataSource;</span><br></pre></td></tr></table></figure><p><a name="StyrD"></a></p><h2 id="cachebuilder"><a class="markdownIt-Anchor" href="#cachebuilder"></a> CacheBuilder</h2><p>CacheBuilder是缓存建造者，他负责完成缓存对象的创建，具体的实现将在后续分析。<br /><a name="iTE1p"></a></p><h2 id="其他枚举类"><a class="markdownIt-Anchor" href="#其他枚举类"></a> 其他枚举类</h2><p>mapping中还存在着其他的一些枚举类，作用分别如下：</p><ul><li>FetchType：延迟加载设置</li><li>ParameterType：参数类型，指输入参数、输出参数等。</li><li>ResultFlag：返回结果中属性的特殊标志，表示是否为id属性、是否为构造器属性。</li><li>ResultSetType：结果集支持的访问方式。</li><li>SqlCommandType：SQL类型，指增删改查等。</li><li>StatementType：SQL语句类型，指是否为预编译语句，是否为存储过程等。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mapping包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#mapping包&quot;&gt;&lt;/a&gt; mapping包&lt;/h1&gt;
&lt;p&gt;mapping中定义了众多的解析实体类。mapping包主要有以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SQL语</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="配置解析包" scheme="https://jie-blog.icu/categories/mybatis/%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>builder包</title>
    <link href="https://jie-blog.icu/posts/mybatis-builder/"/>
    <id>https://jie-blog.icu/posts/mybatis-builder/</id>
    <published>2020-11-04T04:03:15.000Z</published>
    <updated>2020-11-04T04:03:31.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="builder包"><a class="markdownIt-Anchor" href="#builder包"></a> builder包</h1><p>build包是一个按照类型划分出来的包，包中含有很多建造者类。虽然这个包是一个按照类型方式划分的包，但是该包也完成了如下两个比较完整的功能：</p><ul><li>解析XML配置文件和映射文件，这部分在功能xml子包中。</li><li>解析注解形式的Mapper声明，这部分功能在annotation子包中。<br /><a name="2JNa8"></a></li></ul><h1 id="建造者模式"><a class="markdownIt-Anchor" href="#建造者模式"></a> 建造者模式</h1><p>在仔细分析该包前首先要回忆一下建造者模式。<br />使用建造者模式对象建造的细节均交给了建造者来完成，调用者只需掌控总体流程即可，而不需要过多的关注建造对象的细节。<br />基于建造者创建的对象有以下几个优点：</p><ul><li>可以一次也可以分次设置被建造对象的属性。</li><li>调用者只需调用建造者的主要流程而不需要关心建造者的细节。</li><li>可以方便的修改建造者的行为来建造出不同的对象。</li></ul><p>建造者的实现有两种方法：</p><ul><li>属性设置方法。这类方法一般有多个，可以接受不同类型的参数来设置建造者的属性。</li><li>目标对象生成方法。这类方法一般只有一个，根据目前建造者的属性创建出一个目标对象。<br /><a name="IQfCQ"></a></li></ul><h2 id="建造者基类与工具类"><a class="markdownIt-Anchor" href="#建造者基类与工具类"></a> 建造者基类与工具类</h2><p>builder包中BaseBuilder是所有建造者的子类，其类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602034919258-c4700aa1-ab51-4647-ad59-84f70ebd37b5.png#align=left&amp;display=inline&amp;height=299&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=598&amp;originWidth=1157&amp;size=1077520&amp;status=done&amp;style=none&amp;width=578.5" alt="image.png" /><br />BaseBuilder更像一个工具类，为继承他的制造者提供了很多实用的方法：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602034997465-a81d025b-3fb2-4430-9336-92f2ce61e3c7.png#align=left&amp;display=inline&amp;height=229&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=458&amp;originWidth=511&amp;size=114178&amp;status=done&amp;style=none&amp;width=255.5" alt="image.png" /><br />BaseBuilder提供的工具方法大致分为如下几个类型：</p><ul><li>*ValueOf：类型转化函数，负责将输入参数转化为指定的类型，并支持默认值设置。</li><li>resolve*：字符串转枚举类型函数，根据字符串找出指定的枚举类型并返回。</li><li>createInstance：根据类型别名创建类型实例。</li><li>resolveTypeHandler：根据类型处理器别名返回类型处理器实例。</li></ul><p>也有一些类不需要BaseBuilder提供的方法，因此没有继承自它。<br />还有一些不是建造者模式也继承自该类，以MapperBuilderAssistant为例，它本身不是建造者类而是一个建造者辅助类，但是也继承自BaseBuilder。<br /><a name="WH1lA"></a></p><h3 id="mapperbuilderassistant"><a class="markdownIt-Anchor" href="#mapperbuilderassistant"></a> MapperBuilderAssistant</h3><p>Mybatis内部有很多设置项，比如命名空间、缓存共享、结果映射等等。最终这些设置将解析成不同的类，而MapperBuilderAssistant就是这些解析类的辅助类。其内部有很多辅助方法，如Mapper命名空间的设置、缓存的创建、鉴别器的创建等等。<br /><a name="laWXi"></a></p><h1 id="sqlsourcebuilder与staticsqlsource"><a class="markdownIt-Anchor" href="#sqlsourcebuilder与staticsqlsource"></a> SqlSourceBuilder与StaticSqlSource</h1><p>SqlSourceBuillder是一个建造者类，与它的名字不同，它并不能用来创建所有的SqlSource对象，而是只能通过parse方法生产出一个StaticSqlSource方法。<br />换句话说，SqlSourceBuillder类能够将DynamicSqlSource中的“#{}”替换掉，从而将其转化为StaticSqlSource。因此，把SqlSourceBuillder称作一个解析器或者转化器更为合适。在许多引用SqlSourceBuillder对象的地方都将对象的变量名定为“sqlSourceParser”。<br />其parse源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parse</span><span class="params">(String originalSql, Class&lt;?&gt; parameterType, Map&lt;String, Object&gt; additionalParameters)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 用来完成#&#123;&#125;处理的处理器  </span></span><br><span class="line">  ParameterMappingTokenHandler handler = <span class="keyword">new</span> ParameterMappingTokenHandler(configuration, parameterType, additionalParameters);</span><br><span class="line">  <span class="comment">// 通用的占位符解析器，用来进行占位符替换  </span></span><br><span class="line">  GenericTokenParser parser = <span class="keyword">new</span> GenericTokenParser(<span class="string">&quot;#&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>, handler);</span><br><span class="line">  <span class="comment">// 将#&#123;&#125;替换为?的SQL语句</span></span><br><span class="line">  String sql = parser.parse(originalSql);</span><br><span class="line">  <span class="comment">// 生成一个StaticSqlSource对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> StaticSqlSource(configuration, sql, handler.getParameterMappings());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="6PNJ5"></a></p><h2 id="staticsqlsource"><a class="markdownIt-Anchor" href="#staticsqlsource"></a> StaticSqlSource</h2><p>StaticSqlSource是SqlSource的一个子类，期内部的SQL语句已经不存在‘${}’或‘#{}’，而只存在？。其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只剩?的SQL语句  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String sql;</span><br><span class="line"><span class="comment">// SQL语句对应的参数列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;ParameterMapping&gt; parameterMappings;</span><br><span class="line"><span class="comment">// 配置信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br></pre></td></tr></table></figure><p>StaticSqlSource最重要的功能就是返回一个BoundSql对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> BoundSql(configuration, sql, parameterMappings, parameterObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BoundSql将在未来进行详细分析。<br /><a name="tmZ5S"></a></p><h1 id="caserefresolver和resultmapresolver"><a class="markdownIt-Anchor" href="#caserefresolver和resultmapresolver"></a> CaseRefResolver和ResultMapResolver</h1><p>这两个类都是某些类的解析器类，属性中包含被解析类相关的属性，同时还包含一个解析器（Mybatis把被解析对象命名为A，整合后的自解析类命名为AResolver）。<br /><a name="HIgT8"></a></p><h2 id="caserefresovler"><a class="markdownIt-Anchor" href="#caserefresovler"></a> CaseRefResovler</h2><p>Mybatis支持多个namespace之间共享缓存。CaseRefResolver就是用来处理多个命名空间共享缓存问题的，他自身有两个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mapper建造者辅助类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MapperBuilderAssistant assistant;</span><br><span class="line"><span class="comment">// 被应用的namespace，即使用cacheRef的Namespace缓存空间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String cacheRefNamespace;</span><br></pre></td></tr></table></figure><p>借助于MapperBuilderAssiant的useCacheRef方法，CaseRefResolver可以解析缓存共享问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Cache <span class="title">useCacheRef</span><span class="params">(String namespace)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (namespace == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;cache-ref element requires a namespace attribute.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    unresolvedCacheRef = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 获取namespace的缓存</span></span><br><span class="line">    Cache cache = configuration.getCache(namespace);</span><br><span class="line">    <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteElementException(<span class="string">&quot;No cache for namespace &#x27;&quot;</span> + namespace + <span class="string">&quot;&#x27; could be found.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 替换本地缓存，从而实现缓存共享</span></span><br><span class="line">    currentCache = cache;</span><br><span class="line">    unresolvedCacheRef = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteElementException(<span class="string">&quot;No cache for namespace &#x27;&quot;</span> + namespace + <span class="string">&quot;&#x27; could be found.&quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="PLejX"></a></p><h2 id="resultmapresovler"><a class="markdownIt-Anchor" href="#resultmapresovler"></a> ResultMapResovler</h2><p>Mybatis的resultMap标签支持继承，如下列代码所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id=<span class="string">&quot;girlUserMap&quot;</span> type=<span class="string">&quot;Girl&quot;</span> extends=<span class="string">&quot;userMap&quot;</span>&gt;</span><br><span class="line">    &lt;result property=<span class="string">&quot;email&quot;</span> column=<span class="string">&quot;email&quot;</span>/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;resultMap id=<span class="string">&quot;userMap&quot;</span> type=<span class="string">&quot;User&quot;</span> autoMapping=<span class="string">&quot;false&quot;</span>&gt;</span><br><span class="line">    &lt;id property=<span class="string">&quot;id&quot;</span> column=<span class="string">&quot;id&quot;</span> javaType=<span class="string">&quot;Integer&quot;</span> jdbcType=<span class="string">&quot;INTEGER&quot;</span></span><br><span class="line">        typeHandler=<span class="string">&quot;org.apache.ibatis.type.IntegerTypeHandler&quot;</span>/&gt;</span><br><span class="line">    &lt;result property=<span class="string">&quot;name&quot;</span> column=<span class="string">&quot;name&quot;</span>/&gt;</span><br><span class="line">    &lt;discriminator javaType=<span class="string">&quot;int&quot;</span> column=<span class="string">&quot;sex&quot;</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">case</span> value=<span class="string">&quot;0&quot;</span> resultMap=<span class="string">&quot;boyUserMap&quot;</span>/&gt;</span><br><span class="line">        &lt;<span class="keyword">case</span> value=<span class="string">&quot;1&quot;</span> resultMap=<span class="string">&quot;girlUserMap&quot;</span>/&gt;</span><br><span class="line">    &lt;/discriminator&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><p>其继承关系可以由ResultMapResovler所处理，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mapper建造者辅助类  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MapperBuilderAssistant assistant;</span><br><span class="line"><span class="comment">// ResultMap的id</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line"><span class="comment">// ResultMap的type属性，即目标对象类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line"><span class="comment">// ResultMap的extends属性，即继承属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String extend;</span><br><span class="line"><span class="comment">// ResultMap的Discriminator节点，即鉴别器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Discriminator discriminator;</span><br><span class="line"><span class="comment">// ResultMap中的属性映射列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;ResultMapping&gt; resultMappings;</span><br><span class="line"><span class="comment">// ResultMap的autoMapping属性，即是否开启自动映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Boolean autoMapping;</span><br></pre></td></tr></table></figure><p>借助MapperBuilderAssiant的addResultMap方法，ResultMapResovler完成了继承关系解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> ResultMap <span class="title">addResultMap</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     String id,</span></span></span><br><span class="line"><span class="function"><span class="params">     Class&lt;?&gt; type,</span></span></span><br><span class="line"><span class="function"><span class="params">     String extend,</span></span></span><br><span class="line"><span class="function"><span class="params">     Discriminator discriminator,</span></span></span><br><span class="line"><span class="function"><span class="params">     List&lt;ResultMapping&gt; resultMappings,</span></span></span><br><span class="line"><span class="function"><span class="params">     Boolean autoMapping)</span> </span>&#123;</span><br><span class="line">   id = applyCurrentNamespace(id, <span class="keyword">false</span>);</span><br><span class="line">   extend = applyCurrentNamespace(extend, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 解析ResultMap继承关系</span></span><br><span class="line">   <span class="comment">// 如果存在ResultMap的继承</span></span><br><span class="line">   <span class="keyword">if</span> (extend != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (!configuration.hasResultMap(extend)) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteElementException(<span class="string">&quot;Could not find a parent resultmap with id &#x27;&quot;</span> + extend + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 获取父级的ResultMap</span></span><br><span class="line">     ResultMap resultMap = configuration.getResultMap(extend);</span><br><span class="line">     <span class="comment">// 获取父级的属性映射</span></span><br><span class="line">     List&lt;ResultMapping&gt; extendedResultMappings = <span class="keyword">new</span> ArrayList&lt;&gt;(resultMap.getResultMappings());</span><br><span class="line">     <span class="comment">// 删除当前ResultMap已有的父级属性映射</span></span><br><span class="line">     extendedResultMappings.removeAll(resultMappings);</span><br><span class="line">     <span class="comment">// 如果ResultMap设有构造器，则移除父级构造器</span></span><br><span class="line">     <span class="keyword">boolean</span> declaresConstructor = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">for</span> (ResultMapping resultMapping : resultMappings) &#123;</span><br><span class="line">       <span class="keyword">if</span> (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">         declaresConstructor = <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (declaresConstructor) &#123;</span><br><span class="line">       extendedResultMappings.removeIf(resultMapping -&gt; resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 最终从父级继承而来的所有属性映射</span></span><br><span class="line">     resultMappings.addAll(extendedResultMappings);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 创建当前的ResultMap</span></span><br><span class="line">   ResultMap resultMap = <span class="keyword">new</span> ResultMap.Builder(configuration, id, type, resultMappings, autoMapping)</span><br><span class="line">       .discriminator(discriminator)</span><br><span class="line">       .build();</span><br><span class="line">   <span class="comment">// 将当前的ResultMap加入到configuration</span></span><br><span class="line">   configuration.addResultMap(resultMap);</span><br><span class="line">   <span class="keyword">return</span> resultMap;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><a name="mEf1o"></a></p><h1 id="parameterexpression类"><a class="markdownIt-Anchor" href="#parameterexpression类"></a> ParameterExpression类</h1><p>该类是一个属性解析器，用来将描述的字符串解析为键值对的形式。ParameterExpression继承自HashMap，内部能以键值对的形式保存最后的解析结果。<br />注意：对于没有属性声明的属性会以默认名称expression的形式出现。<br /><a name="Daltb"></a></p><h1 id="xml文件解析"><a class="markdownIt-Anchor" href="#xml文件解析"></a> XML文件解析</h1><p>Mybatis的XML文件都会被解析成对应的类，builder的xml包就负责完成这种工作。<br />Mybatis的配置文件和映射文件的节点很多，这些节点的解析是由xml子包中的五个解析器来配合完成的。范围如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602038458012-d9e972f9-c984-4d30-877d-fae496622b57.png#align=left&amp;display=inline&amp;height=481&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=627&amp;originWidth=808&amp;size=736922&amp;status=done&amp;style=none&amp;width=620" alt="image.png" /><br /><a name="mzE6P"></a></p><h2 id="xml文件声明解析"><a class="markdownIt-Anchor" href="#xml文件声明解析"></a> XML文件声明解析</h2><p>在DOCTYE声明中可以表明当前XML文件引用的地址，在EntityResolver接口中存在一个resolveEntity方法，可以通过实现这个方法自定义给出DTD文件流的方式，而不是只能从互联网下载。<br />XMLMapperEntityResolver就继承自该接口，其内部实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InputSource <span class="title">resolveEntity</span><span class="params">(String publicId, String systemId)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (systemId != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">// 将systemId转换为小写</span></span><br><span class="line">      String lowerCaseSystemId = systemId.toLowerCase(Locale.ENGLISH);</span><br><span class="line">      <span class="comment">// 通过判断说明是配置文档</span></span><br><span class="line">      <span class="keyword">if</span> (lowerCaseSystemId.contains(MYBATIS_CONFIG_SYSTEM) || lowerCaseSystemId.contains(IBATIS_CONFIG_SYSTEM)) &#123;</span><br><span class="line">        <span class="comment">// 把本地配置文档的DTD文件返回  </span></span><br><span class="line">        <span class="keyword">return</span> getInputSource(MYBATIS_CONFIG_DTD, publicId, systemId);</span><br><span class="line">      <span class="comment">// 通过判断说明是映射文档</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lowerCaseSystemId.contains(MYBATIS_MAPPER_SYSTEM) || lowerCaseSystemId.contains(IBATIS_MAPPER_SYSTEM)) &#123;</span><br><span class="line">        <span class="keyword">return</span> getInputSource(MYBATIS_MAPPER_DTD, publicId, systemId);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SAXException(e.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="priUa"></a></p><h2 id="配置文件解析"><a class="markdownIt-Anchor" href="#配置文件解析"></a> 配置文件解析</h2><p>配置文件解析是由XMLConfigBuilder完成的，同时该类还会建造出一个Configuration对象，其入口方法就是parse方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 不允许重复解析</span></span><br><span class="line">  <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Each XMLConfigBuilder can only be used once.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  parsed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">// 从根节点开始解析</span></span><br><span class="line">  parseConfiguration(parser.evalNode(<span class="string">&quot;/configuration&quot;</span>));</span><br><span class="line">  <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parseConfiguration：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 解析信息放入Configuration</span></span><br><span class="line">    <span class="comment">// 首先解析properties，以保证在解析其他节点时就可以生效</span></span><br><span class="line">    propertiesElement(root.evalNode(<span class="string">&quot;properties&quot;</span>));</span><br><span class="line">    Properties settings = settingsAsProperties(root.evalNode(<span class="string">&quot;settings&quot;</span>));</span><br><span class="line">    loadCustomVfs(settings);</span><br><span class="line">    loadCustomLogImpl(settings);</span><br><span class="line">    typeAliasesElement(root.evalNode(<span class="string">&quot;typeAliases&quot;</span>));</span><br><span class="line">    pluginElement(root.evalNode(<span class="string">&quot;plugins&quot;</span>));</span><br><span class="line">    objectFactoryElement(root.evalNode(<span class="string">&quot;objectFactory&quot;</span>));</span><br><span class="line">    objectWrapperFactoryElement(root.evalNode(<span class="string">&quot;objectWrapperFactory&quot;</span>));</span><br><span class="line">    reflectorFactoryElement(root.evalNode(<span class="string">&quot;reflectorFactory&quot;</span>));</span><br><span class="line">    settingsElement(settings);</span><br><span class="line">    <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">    environmentsElement(root.evalNode(<span class="string">&quot;environments&quot;</span>));</span><br><span class="line">    databaseIdProviderElement(root.evalNode(<span class="string">&quot;databaseIdProvider&quot;</span>));</span><br><span class="line">    typeHandlerElement(root.evalNode(<span class="string">&quot;typeHandlers&quot;</span>));</span><br><span class="line">    mapperElement(root.evalNode(<span class="string">&quot;mappers&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的调用一样是嵌套调用，这里以mapper为例继续解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理子节点，即mapper节点或package节点</span></span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="comment">// 是否为package</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">        <span class="comment">// 取出包路径</span></span><br><span class="line">        String mapperPackage = child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">// 全部存入mappers</span></span><br><span class="line">        configuration.addMappers(mapperPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// resource url mapperClass只有一个生效</span></span><br><span class="line">        String v = child.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">        String url = child.getStringAttribute(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        String mapperClass = child.getStringAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(resource);</span><br><span class="line">          <span class="comment">// 获取文件输入流</span></span><br><span class="line">          InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">          <span class="comment">// 使用XMLMapperBuilder解析映射文件</span></span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(url);</span><br><span class="line">          <span class="comment">// 获得网络输入流</span></span><br><span class="line">          InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">          <span class="comment">// 使用XMLMapperBuilder解析映射文件</span></span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 获取映射接口</span></span><br><span class="line">          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">          configuration.addMapper(mapperInterface);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XMLConfigBuilder在Mybatis中起到了引导的作用，正是从其parse方法开始引发了配置的解析。<br /><a name="ojvIG"></a></p><h2 id="数据库语句解析"><a class="markdownIt-Anchor" href="#数据库语句解析"></a> 数据库语句解析</h2><p>映射文件的解析由XMLMapperBuilder来负责，其parse方法为入口方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 判断是否重复解析</span></span><br><span class="line">   <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">     <span class="comment">// 处理mapper节点</span></span><br><span class="line">     configurationElement(parser.evalNode(<span class="string">&quot;/mapper&quot;</span>));</span><br><span class="line">     <span class="comment">// 加入已解析的列表，防止重复解析</span></span><br><span class="line">     configuration.addLoadedResource(resource);</span><br><span class="line">     <span class="comment">// 将mapper注册给Configuration</span></span><br><span class="line">     bindMapperForNamespace();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 分别处理失败的resultMap、cache-ref、SQL</span></span><br><span class="line">   parsePendingResultMaps();</span><br><span class="line">   parsePendingCacheRefs();</span><br><span class="line">   parsePendingStatements();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>处理mapper结点的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 读取当前配置文件的命名空间</span></span><br><span class="line">    String namespace = context.getStringAttribute(<span class="string">&quot;namespace&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (namespace == <span class="keyword">null</span> || namespace.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Mapper&#x27;s namespace cannot be empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">    <span class="comment">// 映射文件中其他配置节点的解析</span></span><br><span class="line">    cacheRefElement(context.evalNode(<span class="string">&quot;cache-ref&quot;</span>));</span><br><span class="line">    cacheElement(context.evalNode(<span class="string">&quot;cache&quot;</span>));</span><br><span class="line">    parameterMapElement(context.evalNodes(<span class="string">&quot;/mapper/parameterMap&quot;</span>));</span><br><span class="line">    resultMapElements(context.evalNodes(<span class="string">&quot;/mapper/resultMap&quot;</span>));</span><br><span class="line">    sqlElement(context.evalNodes(<span class="string">&quot;/mapper/sql&quot;</span>));</span><br><span class="line">    <span class="comment">// 处理各种数据库操作语句</span></span><br><span class="line">    buildStatementFromContext(context.evalNodes(<span class="string">&quot;select|insert|update|delete&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error parsing Mapper XML. The XML location is &#x27;&quot;</span> + resource + <span class="string">&quot;&#x27;. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类的parse方法在结尾有三个parsePending方法来处理解析过程中的暂时错误。<br />解析上下文读取文件时，可能会读取到一个节点是其还没有被定义，这种时候有两种解决方法：</p><ul><li>第一轮只读入所有结点但不处理依赖，在第二轮再处理依赖关系。Spring初始化时就用的这种方案。</li><li>如果为被定义就设为暂时性的错误，显然Mybatis默认采用这种方案。<br /><a name="O6ETX"></a></li></ul><h2 id="statement解析"><a class="markdownIt-Anchor" href="#statement解析"></a> Statement解析</h2><p>数据库的操作节点解析由XMLStatementBuilder的parseStatementNode方法完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseStatementNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取当前节点的id与databaseId</span></span><br><span class="line">   String id = context.getStringAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">   String databaseId = context.getStringAttribute(<span class="string">&quot;databaseId&quot;</span>);</span><br><span class="line"><span class="comment">// 验证id与databaseId是否匹配。Mybatis允许多种数据库配置，有些语句只能针对特定数据库生效</span></span><br><span class="line">   <span class="keyword">if</span> (!databaseIdMatchesCurrent(id, databaseId, <span class="keyword">this</span>.requiredDatabaseId)) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 获取节点名</span></span><br><span class="line">   String nodeName = context.getNode().getNodeName();</span><br><span class="line">   <span class="comment">// 读取和判断语句类型</span></span><br><span class="line">   SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">   <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">   <span class="keyword">boolean</span> flushCache = context.getBooleanAttribute(<span class="string">&quot;flushCache&quot;</span>, !isSelect);</span><br><span class="line">   <span class="keyword">boolean</span> useCache = context.getBooleanAttribute(<span class="string">&quot;useCache&quot;</span>, isSelect);</span><br><span class="line">   <span class="keyword">boolean</span> resultOrdered = context.getBooleanAttribute(<span class="string">&quot;resultOrdered&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理语句的include节点</span></span><br><span class="line">   XMLIncludeTransformer includeParser = <span class="keyword">new</span> XMLIncludeTransformer(configuration, builderAssistant);</span><br><span class="line">   includeParser.applyIncludes(context.getNode());</span><br><span class="line"><span class="comment">// 获取参数类型</span></span><br><span class="line">   String parameterType = context.getStringAttribute(<span class="string">&quot;parameterType&quot;</span>);</span><br><span class="line">   Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);</span><br><span class="line"><span class="comment">// 获取语句类型</span></span><br><span class="line">   String lang = context.getStringAttribute(<span class="string">&quot;lang&quot;</span>);</span><br><span class="line">   LanguageDriver langDriver = getLanguageDriver(lang);</span><br><span class="line"><span class="comment">// 处理SelectKey节点，这里会将KeyGenerator加入到Configuration.keyGenerators中</span></span><br><span class="line">   processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 所有的selectKey和include已经被解析并删除完毕，开始SQL解析</span></span><br><span class="line">   KeyGenerator keyGenerator;</span><br><span class="line">   String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">   keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="keyword">true</span>);</span><br><span class="line">   <span class="comment">// 判断是否已经有解析好的KeyGenerator</span></span><br><span class="line">   <span class="keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">     keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 全局或者本语句只要一启动自动key生成就会使用key生成</span></span><br><span class="line">     keyGenerator = context.getBooleanAttribute(<span class="string">&quot;useGeneratedKeys&quot;</span>,</span><br><span class="line">         configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">         ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 读取各个配置属性</span></span><br><span class="line">   SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line">   StatementType statementType = StatementType.valueOf(context.getStringAttribute(<span class="string">&quot;statementType&quot;</span>, StatementType.PREPARED.toString()));</span><br><span class="line">   Integer fetchSize = context.getIntAttribute(<span class="string">&quot;fetchSize&quot;</span>);</span><br><span class="line">   Integer timeout = context.getIntAttribute(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">   String parameterMap = context.getStringAttribute(<span class="string">&quot;parameterMap&quot;</span>);</span><br><span class="line">   String resultType = context.getStringAttribute(<span class="string">&quot;resultType&quot;</span>);</span><br><span class="line">   Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">   String resultMap = context.getStringAttribute(<span class="string">&quot;resultMap&quot;</span>);</span><br><span class="line">   String resultSetType = context.getStringAttribute(<span class="string">&quot;resultSetType&quot;</span>);</span><br><span class="line">   ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);</span><br><span class="line">   <span class="keyword">if</span> (resultSetTypeEnum == <span class="keyword">null</span>) &#123;</span><br><span class="line">     resultSetTypeEnum = configuration.getDefaultResultSetType();</span><br><span class="line">   &#125;</span><br><span class="line">   String keyProperty = context.getStringAttribute(<span class="string">&quot;keyProperty&quot;</span>);</span><br><span class="line">   String keyColumn = context.getStringAttribute(<span class="string">&quot;keyColumn&quot;</span>);</span><br><span class="line">   String resultSets = context.getStringAttribute(<span class="string">&quot;resultSets&quot;</span>);</span><br><span class="line"><span class="comment">// 在MapperBuilderAssistant帮助下创建MappedStatement对象并写入Configuration</span></span><br><span class="line">   builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">       fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">       resultSetTypeEnum, flushCache, useCache, resultOrdered,</span><br><span class="line">       keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="ZUVk0"></a></p><h2 id="引用解析"><a class="markdownIt-Anchor" href="#引用解析"></a> 引用解析</h2><p>Mybatis支持在数据库操作语句中编写引用语句片段。<br />在之前statement解析中也可以看到include节点是由XMLIncludeTransformer来负责的，他可以将include中的include节点替换为被引用的SQL片段。其applyInclude（Node）方法时解析include结点的入口方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyIncludes</span><span class="params">(Node source, <span class="keyword">final</span> Properties variablesContext, <span class="keyword">boolean</span> included)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (source.getNodeName().equals(<span class="string">&quot;include&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 找出被应用的节点</span></span><br><span class="line">    Node toInclude = findSqlFragment(getStringAttribute(source, <span class="string">&quot;refid&quot;</span>), variablesContext);</span><br><span class="line">    Properties toIncludeContext = getVariablesContext(source, variablesContext);</span><br><span class="line">    <span class="comment">// 递归处理被引用节点中的include节点</span></span><br><span class="line">    applyIncludes(toInclude, toIncludeContext, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (toInclude.getOwnerDocument() != source.getOwnerDocument()) &#123;</span><br><span class="line">      toInclude = source.getOwnerDocument().importNode(toInclude, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完成include节点的替换</span></span><br><span class="line">    source.getParentNode().replaceChild(toInclude, source);</span><br><span class="line">    <span class="keyword">while</span> (toInclude.hasChildNodes()) &#123;</span><br><span class="line">      toInclude.getParentNode().insertBefore(toInclude.getFirstChild(), toInclude);</span><br><span class="line">    &#125;</span><br><span class="line">    toInclude.getParentNode().removeChild(toInclude);</span><br><span class="line">   <span class="comment">// 元素节点</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">    <span class="keyword">if</span> (included &amp;&amp; !variablesContext.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// 用属性替换变量</span></span><br><span class="line">      NamedNodeMap attributes = source.getAttributes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; attributes.getLength(); i++) &#123;</span><br><span class="line">        Node attr = attributes.item(i);</span><br><span class="line">        attr.setNodeValue(PropertyParser.parse(attr.getNodeValue(), variablesContext));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环到下层节点递归处理的下层的include节点</span></span><br><span class="line">    NodeList children = source.getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">      applyIncludes(children.item(i), variablesContext, included);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (included &amp;&amp; source.getNodeType() == Node.TEXT_NODE</span><br><span class="line">      <span class="comment">// 文本节点</span></span><br><span class="line">      &amp;&amp; !variablesContext.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// 用属性值来替代变量</span></span><br><span class="line">    source.setNodeValue(PropertyParser.parse(source.getNodeValue(), variablesContext));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="e3QAH"></a></p><h3 id="解析过程示意图"><a class="markdownIt-Anchor" href="#解析过程示意图"></a> 解析过程示意图：</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602041595938-b2808eab-bcf7-4d37-bb5f-294e45545484.png#align=left&amp;display=inline&amp;height=211&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=275&amp;originWidth=692&amp;size=234735&amp;status=done&amp;style=none&amp;width=530" alt="image.png" /><br /><a name="MWkYB"></a></p><h1 id="注解映射解析"><a class="markdownIt-Anchor" href="#注解映射解析"></a> 注解映射解析</h1><p>Mybatis也支持使用注解来配置映射，builder包中的annocation子包就可以用来完成这种形式的映射解析。<br /><a name="unVX5"></a></p><h2 id="解析触发"><a class="markdownIt-Anchor" href="#解析触发"></a> 解析触发</h2><p>注解解析是从MapperAnnotationBuilder中的parse方法开始的。<br />该类在触发方法之前就已经在静态代码块中完成了一些初始化工作了，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  SQL_ANNOTATION_TYPES.add(Select.class);</span><br><span class="line">  SQL_ANNOTATION_TYPES.add(Insert.class);</span><br><span class="line">  SQL_ANNOTATION_TYPES.add(Update.class);</span><br><span class="line">  SQL_ANNOTATION_TYPES.add(Delete.class);</span><br><span class="line"></span><br><span class="line">  SQL_PROVIDER_ANNOTATION_TYPES.add(SelectProvider.class);</span><br><span class="line">  SQL_PROVIDER_ANNOTATION_TYPES.add(InsertProvider.class);</span><br><span class="line">  SQL_PROVIDER_ANNOTATION_TYPES.add(UpdateProvider.class);</span><br><span class="line">  SQL_PROVIDER_ANNOTATION_TYPES.add(DeleteProvider.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SQL_ANNOTATION_TYPES中放入了四种直接注解，SQL_PROVIDER_ANNOTATION_TYPES中放入了四种间接注解。<br />在mappers中标注出dao层接口以后就会触发MapperAnnotationBuilder的parse方法开始解析工作。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String resource = type.toString();</span><br><span class="line">  <span class="comment">// 防止重复分析</span></span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    <span class="comment">// 寻找类名对应的resources路径下是否有xml配置，如果有则解析。这样就可以两种模式双管齐下。</span></span><br><span class="line">    loadXmlResource();</span><br><span class="line">    <span class="comment">// 记录资源路径</span></span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    <span class="comment">// 设置命名空间</span></span><br><span class="line">    assistant.setCurrentNamespace(type.getName());</span><br><span class="line">    <span class="comment">// 处理缓存</span></span><br><span class="line">    parseCache();</span><br><span class="line">    parseCacheRef();</span><br><span class="line">    Method[] methods = type.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 排除桥接方法</span></span><br><span class="line">        <span class="keyword">if</span> (!method.isBridge()) &#123;</span><br><span class="line">          <span class="comment">// 解析方法</span></span><br><span class="line">          parseStatement(method);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">        <span class="comment">// 暂存解析异常</span></span><br><span class="line">        configuration.addIncompleteMethod(<span class="keyword">new</span> MethodResolver(<span class="keyword">this</span>, method));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  parsePendingMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>桥接方法是为了匹配泛型类型擦除而由编译器自动引入的，并非用户编写的，所以需要排除。<br />注意：在解析接口方法时可能会遇到一些尚未读取的其他信息，如尚未解析的ResultMap、命名空间信息等。这时会将该方法放入到Configuration类中的incompleteMethods属性中，在最后再次处理。在再次处理时，用到了MethodResolver对象，该对象通过调用parseStatement方法对解析失败的接口方法进行再一次解析。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parseStatement</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 通过子方法获取参数类型</span></span><br><span class="line">  Class&lt;?&gt; parameterTypeClass = getParameterType(method);</span><br><span class="line">  <span class="comment">// 获取方法的脚本语言驱动</span></span><br><span class="line">  LanguageDriver languageDriver = getLanguageDriver(method);</span><br><span class="line">  <span class="comment">// 通过注解获取SqlSource</span></span><br><span class="line">  SqlSource sqlSource = getSqlSourceFromAnnotations(method, parameterTypeClass, languageDriver);</span><br><span class="line">  <span class="keyword">if</span> (sqlSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取方法上可能存在的配置信息，配置信息由@Options注解指定</span></span><br><span class="line">    Options options = method.getAnnotation(Options.class);</span><br><span class="line">    <span class="keyword">final</span> String mappedStatementId = type.getName() + <span class="string">&quot;.&quot;</span> + method.getName();</span><br><span class="line"> <span class="comment">// 用默认值初始化各项设置，省略具体代码。</span></span><br><span class="line">    <span class="comment">// 处理主键自动生成的问题，省略具体代码</span></span><br><span class="line">    <span class="comment">// 如果存在@Options注解，则根据其中的配置信息重新配置，省略具体代码</span></span><br><span class="line">    <span class="comment">// 返回结果ResultMap处理，省略具体代码</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 将获取的映射信息存入configuration</span></span><br><span class="line">    assistant.addMappedStatement(</span><br><span class="line">        <span class="comment">// 省略代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最关键的方法就是getSqlSourceFromAnnotations，通过该方法获取了SqlSource对象，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSource <span class="title">getSqlSourceFromAnnotations</span><span class="params">(Method method, Class&lt;?&gt; parameterType, LanguageDriver languageDriver)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历寻找是否有直接注解</span></span><br><span class="line">    Class&lt;? extends Annotation&gt; sqlAnnotationType = getSqlAnnotationType(method);</span><br><span class="line">    <span class="comment">// 遍历寻找是否有间接注解</span></span><br><span class="line">    Class&lt;? extends Annotation&gt; sqlProviderAnnotationType = getSqlProviderAnnotationType(method);</span><br><span class="line">    <span class="keyword">if</span> (sqlAnnotationType != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sqlProviderAnnotationType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 两类注解不可同时使用</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;You cannot supply both a static SQL and SqlProvider to method named &quot;</span> + method.getName());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 含有直接注解的</span></span><br><span class="line">      Annotation sqlAnnotation = method.getAnnotation(sqlAnnotationType);</span><br><span class="line">      <span class="comment">// 取出value值</span></span><br><span class="line">      <span class="keyword">final</span> String[] strings = (String[]) sqlAnnotation.getClass().getMethod(<span class="string">&quot;value&quot;</span>).invoke(sqlAnnotation);</span><br><span class="line">      <span class="comment">// 基于字符串构建SqlSource</span></span><br><span class="line">      <span class="keyword">return</span> buildSqlSourceFromStrings(strings, parameterType, languageDriver);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sqlProviderAnnotationType != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 含有间接注解的</span></span><br><span class="line">      Annotation sqlProviderAnnotation = method.getAnnotation(sqlProviderAnnotationType);</span><br><span class="line">      <span class="comment">// 根据对应的方法获取SqlSource</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ProviderSqlSource(assistant.getConfiguration(), sqlProviderAnnotation, type, method);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Could not find value method on SQL annotation.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="77H4A"></a></p><h3 id="直接注解"><a class="markdownIt-Anchor" href="#直接注解"></a> 直接注解</h3><p>上述方法中直接注解映射由buildSqlSourceFromStrings负责生成，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSource <span class="title">buildSqlSourceFromStrings</span><span class="params">(String[] strings, Class&lt;?&gt; parameterTypeClass, LanguageDriver languageDriver)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> StringBuilder sql = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">  <span class="keyword">for</span> (String fragment : strings) &#123;</span><br><span class="line">    sql.append(fragment);</span><br><span class="line">    sql.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> languageDriver.createSqlSource(configuration, sql.toString().trim(), parameterTypeClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作很简单，就是直接将SQL语句的字符串拼接交给languageDriver进行处理并返回。<br /><a name="uwopA"></a></p><h2 id="间接注解"><a class="markdownIt-Anchor" href="#间接注解"></a> 间接注解</h2><p>在分析间接注解前首先要分析ProviderContext和ProviderMethodDriver两个类。<br /><a name="dmxZq"></a></p><h3 id="providercontext"><a class="markdownIt-Anchor" href="#providercontext"></a> ProviderContext</h3><p>该类的功能就是将以下三个属性整合为一个整体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供映射信息类 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; mapperType;</span><br><span class="line"><span class="comment">// 提供映射信息的方法，该方法属于mapperType类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Method mapperMethod;</span><br><span class="line"><span class="comment">// 数据库编号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String databaseId;</span><br></pre></td></tr></table></figure><p><a name="grMCT"></a></p><h3 id="providermethodresolver"><a class="markdownIt-Anchor" href="#providermethodresolver"></a> ProviderMethodResolver</h3><p>该接口默认方法是resoveMethod，其作用是从@*Provider注解的type属性所指向的类中挑出method属性中所指定的方法。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Method <span class="title">resolveMethod</span><span class="params">(ProviderContext context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 找出同名方法</span></span><br><span class="line">  List&lt;Method&gt; sameNameMethods = Arrays.stream(getClass().getMethods())</span><br><span class="line">      .filter(m -&gt; m.getName().equals(context.getMapperMethod().getName()))</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">  <span class="comment">// 如果没有找到，则抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (sameNameMethods.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Cannot resolve the provider method because &#x27;&quot;</span></span><br><span class="line">        + context.getMapperMethod().getName() + <span class="string">&quot;&#x27; not found in SqlProvider &#x27;&quot;</span> + getClass().getName() + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据返回类型再次判断，返回类型必须是CharSequence及其子类</span></span><br><span class="line">  List&lt;Method&gt; targetMethods = sameNameMethods.stream()</span><br><span class="line">      .filter(m -&gt; CharSequence.class.isAssignableFrom(m.getReturnType()))</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">  <span class="keyword">if</span> (targetMethods.size() == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 若唯一则返回该方法</span></span><br><span class="line">    <span class="keyword">return</span> targetMethods.get(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (targetMethods.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Cannot resolve the provider method because &#x27;&quot;</span></span><br><span class="line">        + context.getMapperMethod().getName() + <span class="string">&quot;&#x27; does not return the CharSequence or its subclass in SqlProvider &#x27;&quot;</span></span><br><span class="line">        + getClass().getName() + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Cannot resolve the provider method because &#x27;&quot;</span></span><br><span class="line">        + context.getMapperMethod().getName() + <span class="string">&quot;&#x27; is found multiple in SqlProvider &#x27;&quot;</span> + getClass().getName() + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要分为两个步骤：</p><ol><li>找到符合方法名的所有方法。</li><li>根据方法返回值进一步校验。<br /><a name="ymVAL"></a></li></ol><h3 id="providersqlsource"><a class="markdownIt-Anchor" href="#providersqlsource"></a> ProviderSqlSource</h3><p>该类内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Configuration对象  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line"><span class="comment">// *Provider注解上type属性所指的类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; providerType;</span><br><span class="line"><span class="comment">// 语言驱动</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LanguageDriver languageDriver;</span><br><span class="line"><span class="comment">// 含有注解的接口方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Method mapperMethod;</span><br><span class="line"><span class="comment">// *Provider注解上，method属性所指的方法</span></span><br><span class="line"><span class="keyword">private</span> Method providerMethod;</span><br><span class="line"><span class="comment">// 给定SQL语句的方法对应的参数</span></span><br><span class="line"><span class="keyword">private</span> String[] providerMethodArgumentNames;</span><br><span class="line"><span class="comment">// 给定SQL语句的方法对应的参数类型</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt;[] providerMethodParameterTypes;</span><br><span class="line"><span class="comment">// ProviderContext对象</span></span><br><span class="line"><span class="keyword">private</span> ProviderContext providerContext;</span><br><span class="line"><span class="comment">// ProviderContext对象</span></span><br><span class="line"><span class="keyword">private</span> Integer providerContextIndex;</span><br></pre></td></tr></table></figure><p>该类作为SqlSource接口的子类，实现了getBoundSql方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取sqlSource对象</span></span><br><span class="line">  SqlSource sqlSource = createSqlSource(parameterObject);</span><br><span class="line">  <span class="comment">// 从SqlSource中获取BoundSql对象</span></span><br><span class="line">  <span class="keyword">return</span> sqlSource.getBoundSql(parameterObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createSqlSource方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSource <span class="title">createSqlSource</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// SQL字符串信息存储</span></span><br><span class="line">    String sql;</span><br><span class="line">    <span class="comment">// 如果是map类型</span></span><br><span class="line">    <span class="keyword">if</span> (parameterObject <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">      <span class="keyword">int</span> bindParameterCount = providerMethodParameterTypes.length - (providerContext == <span class="keyword">null</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (bindParameterCount == <span class="number">1</span> &amp;&amp;</span><br><span class="line">        (providerMethodParameterTypes[Integer.valueOf(<span class="number">0</span>).equals(providerContextIndex) ? <span class="number">1</span> : <span class="number">0</span>].isAssignableFrom(parameterObject.getClass()))) &#123;</span><br><span class="line">        <span class="comment">// 调用*Provider注解的type类中的method方法，从而获取SQL字符串</span></span><br><span class="line">        sql = invokeProviderMethod(extractProviderMethodArguments(parameterObject));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Map&lt;String, Object&gt; params = (Map&lt;String, Object&gt;) parameterObject;</span><br><span class="line">        <span class="comment">// 调用*Provider注解的type类中的method方法，从而获得SQL字符串  </span></span><br><span class="line">        sql = invokeProviderMethod(extractProviderMethodArguments(params, providerMethodArgumentNames));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (providerMethodParameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 无需参数</span></span><br><span class="line">      sql = invokeProviderMethod();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (providerMethodParameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (providerContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 只有一个参数</span></span><br><span class="line">        sql = invokeProviderMethod(parameterObject);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 参数为providerContext</span></span><br><span class="line">        sql = invokeProviderMethod(providerContext);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (providerMethodParameterTypes.length == <span class="number">2</span>) &#123;</span><br><span class="line">      sql = invokeProviderMethod(extractProviderMethodArguments(parameterObject));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Cannot invoke SqlProvider method &#x27;&quot;</span> + providerMethod</span><br><span class="line">        + <span class="string">&quot;&#x27; with specify parameter &#x27;&quot;</span> + (parameterObject == <span class="keyword">null</span> ? <span class="keyword">null</span> : parameterObject.getClass())</span><br><span class="line">        + <span class="string">&quot;&#x27; because SqlProvider method arguments for &#x27;&quot;</span> + mapperMethod + <span class="string">&quot;&#x27; is an invalid combination.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt; parameterType = parameterObject == <span class="keyword">null</span> ? Object.class : parameterObject.getClass();</span><br><span class="line">    <span class="keyword">return</span> languageDriver.createSqlSource(configuration, sql, parameterType);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (BuilderException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error invoking SqlProvider method &#x27;&quot;</span> + providerMethod</span><br><span class="line">        + <span class="string">&quot;&#x27; with specify parameter &#x27;&quot;</span> + (parameterObject == <span class="keyword">null</span> ? <span class="keyword">null</span> : parameterObject.getClass()) + <span class="string">&quot;&#x27;.  Cause: &quot;</span> + extractRootCause(e), e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法可以概括为三步：</p><ul><li>调用*Provider注解的type类中的method方法，从而获得SQL字符串。</li><li>向languageDriver的createSqlSource方法传入SQL字符串等参数生成一个SqlSource对象。</li><li>调用SqlSource的getBoundSql方法，获得BoundSql对象。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;builder包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#builder包&quot;&gt;&lt;/a&gt; builder包&lt;/h1&gt;
&lt;p&gt;build包是一个按照类型划分出来的包，包中含有很多建造者类。虽然这个包是一个按照类型方式划分的包，但是该包</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="配置解析包" scheme="https://jie-blog.icu/categories/mybatis/%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>binding包</title>
    <link href="https://jie-blog.icu/posts/mybatis-binding/"/>
    <id>https://jie-blog.icu/posts/mybatis-binding/</id>
    <published>2020-11-04T04:01:32.000Z</published>
    <updated>2020-11-04T04:02:59.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="binding包"><a class="markdownIt-Anchor" href="#binding包"></a> binding包</h1><p>binding包主要负责处理Java方法与SQL语句之间绑定关系。<br />binding包主要有以下两个功能：</p><ul><li>维护映射接口中抽象方法与数据库操作节点之间的映射关系。</li><li>为映射接口中的抽象方法接入相应的数据库操作。<br /><a name="4DnUf"></a></li></ul><h1 id="数据库接入操作"><a class="markdownIt-Anchor" href="#数据库接入操作"></a> 数据库接入操作</h1><p>binding包是基于映射的动态代理实现的，该包内与接入数据库相关的类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601946515109-39ebd2b0-853d-4912-b054-e96cc74268fe.png#align=left&amp;display=inline&amp;height=358&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=715&amp;originWidth=1129&amp;size=1152659&amp;status=done&amp;style=none&amp;width=564.5" alt="image.png" /><br /><a name="w0LHb"></a></p><h2 id="mappermethod"><a class="markdownIt-Anchor" href="#mappermethod"></a> MapperMethod</h2><p>首先要做的就是要把数据库操作节点转换为一个方法。MapperMethod对象就表示数据库操作转化后的方法。每个MapperMethod对象都对应一个数据库操作节点，调用MapperMethod的execute方法就可以触发节点中的SQL语句操作数据库。<br /><a name="G2IIP"></a></p><h3 id="内部类"><a class="markdownIt-Anchor" href="#内部类"></a> 内部类</h3><p>MapperMethod类中有两个重要的属性，分别对应着两个内部类，即SqlCommand和MethodSignature。<br />还有一个重要的ParamMap属性来作为取值使用。<br /><a name="t2kzl"></a></p><h4 id="methodsignature"><a class="markdownIt-Anchor" href="#methodsignature"></a> MethodSignature</h4><p>该类指代一个具体方法的签名（细节），其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值是否是集合    </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsMany;</span><br><span class="line"><span class="comment">// 返回值是否是map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsMap;</span><br><span class="line"><span class="comment">// 返回值是否为空</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsVoid;</span><br><span class="line"><span class="comment">// 返回值类型是否是Cursor</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsCursor;</span><br><span class="line"><span class="comment">// 返回值类型是否是Optional</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsOptional;</span><br><span class="line"><span class="comment">// 该方法的返回值类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; returnType;</span><br><span class="line"><span class="comment">// 如果返回值类型是map 则在这里记录key</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String mapKey;</span><br><span class="line"><span class="comment">// resultHandle参数的位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Integer resultHandlerIndex;</span><br><span class="line"><span class="comment">// rowBounds参数的位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Integer rowBoundsIndex;</span><br><span class="line"><span class="comment">// 参数名称解析器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ParamNameResolver paramNameResolver;</span><br></pre></td></tr></table></figure><p><a name="z2YEm"></a></p><h4 id="sqlcommand"><a class="markdownIt-Anchor" href="#sqlcommand"></a> SqlCommand</h4><p>该类是指代一个SQL语句，内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SQL语句的名称   </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"><span class="comment">// SQL语句的种类，包含增、删、改、查、清缓存和未知</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlCommandType type;</span><br></pre></td></tr></table></figure><p>SqlCommand会根据传入参数完成对name和type的赋值。resolveMappedStatement字方法会根据接口找到对应的MappedStatement，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> MappedStatement <span class="title">resolveMappedStatement</span><span class="params">(Class&lt;?&gt; mapperInterface, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;?&gt; declaringClass, Configuration configuration)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数据库操作语句编号是：接口名.方法名</span></span><br><span class="line">    String statementId = mapperInterface.getName() + <span class="string">&quot;.&quot;</span> + methodName;</span><br><span class="line">    <span class="comment">// configuration保存了解析后的所有操作语句，所以在这里判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (configuration.hasStatement(statementId)) &#123;</span><br><span class="line">      <span class="comment">// 找到语句并返回</span></span><br><span class="line">      <span class="keyword">return</span> configuration.getMappedStatement(statementId);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mapperInterface.equals(declaringClass)) &#123;</span><br><span class="line">      <span class="comment">// 递归到头了都没找到，返回空值</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向上寻找直到找到接口（递归调用）</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; superInterface : mapperInterface.getInterfaces()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (declaringClass.isAssignableFrom(superInterface)) &#123;</span><br><span class="line">        MappedStatement ms = resolveMappedStatement(superInterface, methodName,</span><br><span class="line">            declaringClass, configuration);</span><br><span class="line">        <span class="keyword">if</span> (ms != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> ms;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="YzfJ8"></a></p><h3 id="总结分析"><a class="markdownIt-Anchor" href="#总结分析"></a> 总结分析</h3><p>显然MapperMethod类将一个数据库操作语句和Java语句绑定在了一起，其MethodSignature属性保存了这个方法的详细信息，SqlCommand对象持有这个方法对应的SQL语句，如下图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601948351931-e618b729-205e-42fc-89a2-f6ea1fda9ad0.png#align=left&amp;display=inline&amp;height=137&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=274&amp;originWidth=1121&amp;size=456941&amp;status=done&amp;style=none&amp;width=560.5" alt="image.png" /><br /><a name="lUEmO"></a></p><h3 id="parammap"><a class="markdownIt-Anchor" href="#parammap"></a> ParamMap</h3><p>该类是HashMap的子类，但是它比HashMap要严格：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">super</span>.containsKey(key)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Parameter &#x27;&quot;</span> + key + <span class="string">&quot;&#x27; not found. Available parameters are &quot;</span> + keySet());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获取值时，如果不存在直接抛出异常。<br /><a name="X2drJ"></a></p><h3 id="execute"><a class="markdownIt-Anchor" href="#execute"></a> execute</h3><p>只要触发了MapperMethod的execute方法就可以触发具体的数据库操作，于是数据库就被转化成了具体的方法。exectue源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">   Object result;</span><br><span class="line"><span class="comment">// 根据SQL语句不同执行不同的操作</span></span><br><span class="line">   <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">     <span class="comment">// 如果是插入语句</span></span><br><span class="line">     <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">       <span class="comment">// 调整参数和实参顺序</span></span><br><span class="line">       Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">       <span class="comment">// 执行并返回</span></span><br><span class="line">       result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果是更新语句</span></span><br><span class="line">     <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">       Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">       result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果是删除语句</span></span><br><span class="line">     <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">       Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">       result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果是查询语句</span></span><br><span class="line">     <span class="keyword">case</span> SELECT:</span><br><span class="line">       <span class="comment">// 方法返回值是void，但是方法有结果</span></span><br><span class="line">       <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">         <span class="comment">// 使用结果处理器执行查询</span></span><br><span class="line">         executeWithResultHandler(sqlSession, args);</span><br><span class="line">         result = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 方法返回值是集合</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">         result = executeForMany(sqlSession, args);</span><br><span class="line">       <span class="comment">// 方法返回值是map</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">         result = executeForMap(sqlSession, args);</span><br><span class="line">       <span class="comment">// 方法返回值是Cursor</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">         result = executeForCursor(sqlSession, args);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 单条结果查询</span></span><br><span class="line">         Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">         result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">         <span class="comment">// 查询结果为null或者返回值类型不匹配，返回值是Optional</span></span><br><span class="line">         <span class="keyword">if</span> (method.returnsOptional()</span><br><span class="line">             &amp;&amp; (result == <span class="keyword">null</span> || !method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">           result = Optional.ofNullable(result);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     <span class="comment">// 如果是刷新语句</span></span><br><span class="line">     <span class="keyword">case</span> FLUSH:</span><br><span class="line">       result = sqlSession.flushStatements();</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Unknown execution method for: &quot;</span> + command.getName());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 查询结果为空，但返回值为基本类型且不为空</span></span><br><span class="line">   <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Mapper method &#x27;&quot;</span> + command.getName()</span><br><span class="line">         + <span class="string">&quot; attempted to return null from a method with a primitive return type (&quot;</span> + method.getReturnType() + <span class="string">&quot;).&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><a name="qPA1A"></a></p><h2 id="mapperproxy"><a class="markdownIt-Anchor" href="#mapperproxy"></a> MapperProxy</h2><p>在MapperMethod方法把数据库操作转换成了一个方法，这里又要通过MapperProxy来将数据库操作方法接入映射接口的抽象方法中，即可以使用动态代理来调用MapperMethod的方法实现mapper文件中定义的方法的功能。<br />MapperProxy是基于动态代理针对接口映射方法调用转接成了对MapperMethod对象execute方法的调用从而实现了接口调用数据库操作的功能。<br />MapperProxy继承自InvocationHandler，是个标准的动态代理的类。当实例替代被代理对象后，对被代理对象的方法调用会被转接到MapperProxy的invoke方法上，invoke方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否继承自object</span></span><br><span class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="comment">// 直接执行原有方法</span></span><br><span class="line">      <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">    <span class="comment">// 判断是否是默认方法</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.isDefault()) &#123;</span><br><span class="line">     <span class="comment">// 执行默认方法</span></span><br><span class="line">      <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 找到对应的MapperMethod对象</span></span><br><span class="line">  <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">  <span class="comment">// 调用excute方法</span></span><br><span class="line">  <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="XocJR"></a></p><h2 id="mapperproxyfactory"><a class="markdownIt-Anchor" href="#mapperproxyfactory"></a> MapperProxyFactory</h2><p>该类的实现比较简单，就是MapperProxy的生产工厂，newInstance方法会生成一个MapperProxy对象。<br /><a name="JS5IX"></a></p><h1 id="抽象方法与数据库操作节点的关联"><a class="markdownIt-Anchor" href="#抽象方法与数据库操作节点的关联"></a> 抽象方法与数据库操作节点的关联</h1><p>前面的操作已经将与各数据库操作转换成了一个方法，甚至是一个动态代理乃至一个生产工厂，并将这个方法接入一个映射接口的抽象方法中。<br />Mapper文件如此之多，因此要在确定关联关系是个很重要的事情，Mybatis分两步完成了该任务：<br /><a name="ltuUv"></a></p><h2 id="绑定接口和映射文件"><a class="markdownIt-Anchor" href="#绑定接口和映射文件"></a> 绑定接口和映射文件</h2><p>将映射接口与MapperProxyFactory关联起来，这种关联关系是在MapperRegistry中的knowMappers属性中维护的，其属性定义：<code>private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap&lt;&gt;();</code><br />因为MapperProxyFactory的构造方法只接受一个接口类型，且不允许修改，因此MapperProxyFactory和映射接口的对应是唯一的，同样MapperProxyFactory和MapperProxy也是一一对应的，因此knowMappers间接对应了唯一的MapperProxy。<br />MapperRegistry的getMapper方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 找出指定映射接口的映射工厂</span></span><br><span class="line">  <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">  <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is not known to the MapperRegistry.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 通过mapperProxyFactory返回对应的处理器实例</span></span><br><span class="line">    <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样映射文件就和接口就通过返回的代理对象绑定了起来。<br /><a name="adtHd"></a></p><h2 id="绑定抽象方法"><a class="markdownIt-Anchor" href="#绑定抽象方法"></a> 绑定抽象方法</h2><p>现在范围已经缩减到了映射接口和MapperProxy的关系映射，接下来由MapperProxy中的MethodCache属性维护接口抽象方法和MapperMethod的映射。其属性定义如下：<code>private final Map&lt;Method, MapperMethod&gt; methodCache;</code><br />在cachedMapperMethod方法中完成了赋值操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> methodCache.computeIfAbsent(method, k -&gt; <span class="keyword">new</span> MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="aaoJk"></a></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>经过了上述两个步骤形成了下图的结构：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601951581210-b79f8609-55ae-43f2-bef5-a4fd24141d6f.png#align=left&amp;display=inline&amp;height=304&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=608&amp;originWidth=1214&amp;size=1164326&amp;status=done&amp;style=none&amp;width=607" alt="image.png" /><br />代理关系建立完成后，只要调用映射接口中的方法都会被MapperProxy截获，而MapperProxy会创建或选取合适的MapperMethod对象，并触发execute方法完成数据库操作。因而，抽象方法的调用变成了数据库操作。<br /><a name="eMsVp"></a></p><h1 id="数据库操作的总结"><a class="markdownIt-Anchor" href="#数据库操作的总结"></a> 数据库操作的总结</h1><p><a name="OCqE5"></a></p><h2 id="初始化阶段"><a class="markdownIt-Anchor" href="#初始化阶段"></a> 初始化阶段</h2><p>对各个映射文件解析时，各个数据库操作的节点信息会被记录到Configuration对象的mappedStatements属性中。该属性结构是一种StrictMap，键值为SQL语句的namespace.语句id，值为数据库操作节点信息。<br />Mybatis还会根据扫描的所有映射接口，根据映射接口创建与之关联的MapperProxyFactory，两者关联关系由MapperRegistry维护。当调用getMapper方法时，MapperProxyFactory会生产出一个MapperProxy对象作为映射接口代理。<br /><a name="DNIQ1"></a></p><h2 id="读写阶段"><a class="markdownIt-Anchor" href="#读写阶段"></a> 读写阶段</h2><p>当接口方法被调用时会被MapperProxy所劫持，触发内部的invoke方法，从而创建MapperMethod对象。<br />在创建MapperMethod的过程中，MapperMethod中的sqlCommond子类的构造方法会去Configuration对象的mappedStatements属性中获取当前映射接口名、其他的SQL语句信息。<br />之后execute方法会被触发来执行数据库操作。<br /><a name="X35TD"></a></p><h1 id="spring整合"><a class="markdownIt-Anchor" href="#spring整合"></a> Spring整合</h1><p>在Spring的application.xml中配置mapper文件所在的位置后，Spring在启动阶段会对指定路径进行扫描。对于扫描到的映射接口，mybatis-spring会将其当做MapperFactoryBean对象注册到Spring的Bean列表中。而MapperFactoryBean可以给出映射接口的代理类。这样就可以实现自动注入的功能。<br />springboot同理，知识增加了负责完成自动配置工作的mybatis-spring-boot-autoconfigure项目而已。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;binding包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#binding包&quot;&gt;&lt;/a&gt; binding包&lt;/h1&gt;
&lt;p&gt;binding包主要负责处理Java方法与SQL语句之间绑定关系。&lt;br /&gt;binding包主要有以下两个</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="配置解析包" scheme="https://jie-blog.icu/categories/mybatis/%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>配置解析概述</title>
    <link href="https://jie-blog.icu/posts/mybatis-title/"/>
    <id>https://jie-blog.icu/posts/mybatis-title/</id>
    <published>2020-11-04T04:00:08.000Z</published>
    <updated>2020-11-04T04:01:02.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置解析概述"><a class="markdownIt-Anchor" href="#配置解析概述"></a> 配置解析概述</h1><p>Mybatis的配置解析依赖两个文件进行：</p><ul><li>配置文件，里面包含了Mybatis的基本信息，该文件只有一个。</li><li>映射文件，这里面设置了Java对象和数据库属性之间的映射关系、数据库操作语句等。该文件可以有多个。</li></ul><p>Mybatis首先要完成以上两类文件的解析，并根据解析的信息设置好Mybatis的运行环境以备使用。<br />所谓的解析过程就是将配置信息提取、转化，最终在Java对象中保存的过程。</p><hr /><p>按照上述思路，从类的角度分析，可以将配置解析相关的类分为以下两种：</p><ul><li>解析类（含接口）：提供配置的解析功能，完成配置信息的提取、转化。</li><li>解析实体类（含接口）：提供配置保存功能。该类在结构上与配置信息有对应的关系。配置信息最终会保存到解析实体类的属性中。</li></ul><p>注意：这种划分不是绝对的，因为存在一个二者皆是的。<br /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;配置解析概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#配置解析概述&quot;&gt;&lt;/a&gt; 配置解析概述&lt;/h1&gt;
&lt;p&gt;Mybatis的配置解析依赖两个文件进行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置文件，里面包含了Mybatis的基本信息，该文</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="配置解析包" scheme="https://jie-blog.icu/categories/mybatis/%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>parsing包</title>
    <link href="https://jie-blog.icu/posts/mybatis-parsing/"/>
    <id>https://jie-blog.icu/posts/mybatis-parsing/</id>
    <published>2020-11-04T03:59:14.000Z</published>
    <updated>2020-11-04T04:00:44.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="parsing包"><a class="markdownIt-Anchor" href="#parsing包"></a> parsing包</h1><p>Mybatis的parsing包就是用来解析XML文件的包，要了解该包前，要先回顾一下以下基础知识。<br /><a name="VawTP"></a></p><h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1><p><a name="CLYI0"></a></p><h2 id="xml文件"><a class="markdownIt-Anchor" href="#xml文件"></a> XML文件</h2><p>扩展标记语言（XML）是一种标记语言。标记语言即指计算机所能理解的信息符号，通过标记可以实现软件开发者与计算机之间的信息沟通。<br />XML可扩展的一个重要表现就是XML文档的结构是可以自由定义的。XML的节点包括元素节点、属性节点、文本节点、文档节点等。定义的XML文档可以用DTD，也可以用XML Schema。<br /><a name="c8zEb"></a></p><h2 id="xpath"><a class="markdownIt-Anchor" href="#xpath"></a> XPath</h2><p>XML表述的是一种树状结构，而XPath（XML路径语言）作为一种小型的查询语言能够根据XML结构树在树上寻找节点。<br />解析样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String resource = <span class="string">&quot;info.xml&quot;</span>;</span><br><span class="line">            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">            DocumentBuilder db = dbf.newDocumentBuilder();</span><br><span class="line">            Document doc = db.parse(Thread.currentThread().getContextClassLoader().getResourceAsStream(resource));</span><br><span class="line">            XPathFactory factory = XPathFactory.newInstance();</span><br><span class="line">            XPath xpath = factory.newXPath();</span><br><span class="line">            XPathExpression compile = xpath.compile(<span class="string">&quot;/members/user[id=1]&quot;</span>);</span><br><span class="line">            System.out.println(compile.evaluate(doc));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="s8sls"></a></p><h1 id="xml解析"><a class="markdownIt-Anchor" href="#xml解析"></a> XML解析</h1><p>Mybatis的配置文件与映射文件均是XML文件，因此解析并读取XML文档的内容是Mybatis展开后续工作的基础。<br />XPathParser和XNode类是两个最为关键的类，其主要关系如下图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601866214309-2172d457-bd4b-4692-a083-85a164bb8b5d.png#align=left&amp;display=inline&amp;height=188&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=375&amp;originWidth=1055&amp;size=491882&amp;status=done&amp;style=none&amp;width=527.5" alt="image.png" /><br /><a name="CUkwH"></a></p><h2 id="xpathparser"><a class="markdownIt-Anchor" href="#xpathparser"></a> XpathParser</h2><p>XpathParser内部封装了XPath类的对象，因此XpathParser具有解析XML的能力，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要解析的XML文档  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Document document;</span><br><span class="line"><span class="comment">// 是否开启验证</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> validation;</span><br><span class="line"><span class="comment">// 声明寻找DTD文件的方法，本地寻找还是网络下载</span></span><br><span class="line"><span class="keyword">private</span> EntityResolver entityResolver;</span><br><span class="line"><span class="comment">// Mybatis配置文件的Properties节点</span></span><br><span class="line"><span class="keyword">private</span> Properties variables;</span><br><span class="line"><span class="comment">// XPath工具</span></span><br><span class="line"><span class="keyword">private</span> XPath xpath;</span><br></pre></td></tr></table></figure><p>该类内部有很多重载的构造，他们均是传入参数并且初始化document属性的此外。此外，其还提供大量的eval*方法，这些方法最后都调用了evaluate方法，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">evaluate</span><span class="params">(String expression, Object root, QName returnType)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> xpath.evaluate(expression, root, returnType);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error evaluating XPath.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，这里调用的是xpath的方法，因此，整个XPathParser类的本质是对XPath的封装和调用。<br /><a name="807Iu"></a></p><h2 id="xnode"><a class="markdownIt-Anchor" href="#xnode"></a> XNode</h2><p>同理，可以把XNode看作是Node类的包装类。其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XML的一个节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node node;</span><br><span class="line"><span class="comment">// 节点名</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"><span class="comment">// 节点体</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String body;</span><br><span class="line"><span class="comment">// 节点属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Properties attributes;</span><br><span class="line"><span class="comment">// Mybatis Properties信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Properties variables;</span><br><span class="line"><span class="comment">// XML解析器XPathParser</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> XPathParser xpathParser;</span><br></pre></td></tr></table></figure><p>XNode里封装了XPathParser对象。显然，XNode封装了自身的解析器，在一个类中封装自身的解析器是一种常见的做法，如此一来他便获得了解析自身的能力，从而减少了对外部的依赖，具有内聚性。<br /><a name="8tsij"></a></p><h2 id="变量替换"><a class="markdownIt-Anchor" href="#变量替换"></a> 变量替换</h2><p>XPathParser类中还有一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">evalString</span><span class="params">(Object root, String expression)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 解析出来的字符结果</span></span><br><span class="line">  String result = (String) evaluate(expression, root, XPathConstants.STRING);</span><br><span class="line">  <span class="comment">// 对字符中的属性进行处理</span></span><br><span class="line">  result = PropertyParser.parse(result, variables);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PropertyParser.parse方法对解析出来的结果进行了进一步的处理。<br />PropertyParser是属性解析器，其类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601868758405-fa3a10f2-5e25-4ded-8476-f4920fc1e362.png#align=left&amp;display=inline&amp;height=292&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=584&amp;originWidth=868&amp;size=663796&amp;status=done&amp;style=none&amp;width=434" alt="image.png" /><br /><a name="yFB0h"></a></p><h3 id="generictokenparser"><a class="markdownIt-Anchor" href="#generictokenparser"></a> GenericTokenParser</h3><p>GenericTokenParser是通用的占位符解析器，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 占位符起始标志</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String openToken;</span><br><span class="line"><span class="comment">// 占位符结束标志</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String closeToken;</span><br><span class="line"><span class="comment">// 占位符处理器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TokenHandler handler;</span><br></pre></td></tr></table></figure><p>其内部仅有的方法时parse方法，其主要完成的是占位符的定位工作，然后替换工作交给TokenHandler来处理。<br />此外，GenericTokenParser提供的占位符定位功能应用十分广泛，不仅仅局限在XML解析中，SQL语句中的“#{}”或“${}”也离不开该类的解析。<br /><a name="sqcfP"></a></p><h3 id="tokenhandler"><a class="markdownIt-Anchor" href="#tokenhandler"></a> TokenHandler</h3><p>PropertyParser内部类VariableTokenHandler就实现了该接口，其属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入的属性变量，是HashTable的子类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Properties variables;</span><br><span class="line"><span class="comment">// 是否启用默认值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> enableDefaultValue;</span><br><span class="line"><span class="comment">// 如果启用默认值则表示键和默认值之间的分隔符</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String defaultValueSeparator;</span><br></pre></td></tr></table></figure><p>向handleToken方法中传入参数后，该方法会以输入参数为键尝试从variables中获取值并返回，这个键值寻找的过程中还支持默认值，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">handleToken</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (variables != <span class="keyword">null</span>) &#123;</span><br><span class="line">      String key = content;</span><br><span class="line">      <span class="comment">// 如果启动默认值，则设置默认值</span></span><br><span class="line">      <span class="keyword">if</span> (enableDefaultValue) &#123;</span><br><span class="line">        <span class="comment">// 找出键与默认值分隔符的位置</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> separatorIndex = content.indexOf(defaultValueSeparator);</span><br><span class="line">        String defaultValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (separatorIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 分隔符以前是键</span></span><br><span class="line">          key = content.substring(<span class="number">0</span>, separatorIndex);</span><br><span class="line">          <span class="comment">// 分隔符以后是默认值</span></span><br><span class="line">          defaultValue = content.substring(separatorIndex + defaultValueSeparator.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (defaultValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 非默认值方式寻值</span></span><br><span class="line">          <span class="keyword">return</span> variables.getProperty(key, defaultValue);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (variables.containsKey(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> variables.getProperty(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果variables为空，原样返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;$&#123;&quot;</span> + content + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到parse方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parse</span><span class="params">(String string, Properties variables)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 负责替换字符串的类</span></span><br><span class="line">  VariableTokenHandler handler = <span class="keyword">new</span> VariableTokenHandler(variables);</span><br><span class="line">  <span class="comment">// 创建通用占位符的类</span></span><br><span class="line">  GenericTokenParser parser = <span class="keyword">new</span> GenericTokenParser(<span class="string">&quot;$&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>, handler);</span><br><span class="line">  <span class="comment">// 开展解析，即替换占位符中的值</span></span><br><span class="line">  <span class="keyword">return</span> parser.parse(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样只要XML中使用“${}”包围一个变量名，该变量名就会被解析替换成properties节点中对应的值。<br />s</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;parsing包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#parsing包&quot;&gt;&lt;/a&gt; parsing包&lt;/h1&gt;
&lt;p&gt;Mybatis的parsing包就是用来解析XML文件的包，要了解该包前，要先回顾一下以下基础知识。&lt;br </summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="基础功能包" scheme="https://jie-blog.icu/categories/mybatis/%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>logging包</title>
    <link href="https://jie-blog.icu/posts/mybatis-logging/"/>
    <id>https://jie-blog.icu/posts/mybatis-logging/</id>
    <published>2020-11-04T03:58:08.000Z</published>
    <updated>2020-11-04T03:58:38.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="logging包"><a class="markdownIt-Anchor" href="#logging包"></a> logging包</h1><p>logging包负责完成Mybatis操作中的日志记录工作。<br /><a name="CCKd0"></a></p><h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1><p><a name="FjPog"></a></p><h2 id="适配器模式"><a class="markdownIt-Anchor" href="#适配器模式"></a> 适配器模式</h2><p>适配器模式是一种结构性模式，基于该模式设计的类能够在两个或者多个不兼容的类之间起到沟通桥梁的作用。<br />适配器模式能够使得原本不兼容的类可以一起工作。通常情况下，如果目标类是可以修改的，则不需要使用适配器模式进行干预了，直接修改目标类即可。但如果目标类是不可修改的（例如目标类由外部提供，或者目标类被众多其他类依赖必须保持不变），那么就可以使用适配器模式。<br /><a name="C4OCm"></a></p><h2 id="日志框架与日志级别"><a class="markdownIt-Anchor" href="#日志框架与日志级别"></a> 日志框架与日志级别</h2><p>日志框架是一种在目标对象发生变化时将相关信息记录进日志文件框架。这样，当目标对象出现问题或需要检查目标对象变动历史时，日志框架记录的日志文件便可以提供翔实的资料。<br />常见日志等级划分如下：</p><ul><li>Fatal：致命等级的日志，指发生了严重的会导致应用程序退出的事件。</li><li>Error：错误等级的日志，指发生了错误，但是不影响系统运行。</li><li>Warn：警告等级的日志，指发生了异常没可能是潜在的错误。</li><li>Info：信息登记的日志，指一些在颗粒度级别上需要强调的应用程序运行信息。</li><li>Debug：调试等级日志，指一些颗粒对于程序调试有帮助的信息。</li><li>Trace：跟踪等级的日志，指一些包含程序运行调试过程的信息。</li></ul><p>很多日志框架都可以定义日志的级别，也可以根据日志等级进行输出，防止大量的日志信息混杂在一起。<br /><a name="wOB2d"></a></p><h2 id="基于反射的动态代理"><a class="markdownIt-Anchor" href="#基于反射的动态代理"></a> 基于反射的动态代理</h2><p>之前回顾过静态代理，这里回顾一下基于反射的动态代理。<br />动态代理灵活性很多，它在代码运行时动态的为一个对象增加代理，并且能为代理对象动态的增加方法。<br />具体实现方法详见后续的源码分析。<br /><a name="FJEpx"></a></p><h1 id="log接口"><a class="markdownIt-Anchor" href="#log接口"></a> Log接口</h1><p>logger包中最核心的就是Log接口，其有11个实现类分布在logging包的不同子包中。<br />Log接口中定义了如下几个抽象方法：<br /><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601807799081-eea08218-79c5-4357-8c0b-f2df6d38409d.png#align=left&amp;display=inline&amp;height=114&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=228&amp;originWidth=370&amp;size=38052&amp;status=done&amp;style=none&amp;width=185" alt="image.png" /></strong><br />其含义分别是：</p><ul><li>error：打印Error级别的日志。</li><li>warn：打印Warn级别日志。</li><li>debug：打印Debug级别日志。</li><li>trace：打印Trace级别的日志。</li><li>isDebugEnable：判断打印Debug级别日志的功能是否开启。</li><li>isTraceEnable：判断打印Trace级别日志的功能是否开启。<br /><a name="nz0kq"></a></li></ul><h1 id="log接口的实现类"><a class="markdownIt-Anchor" href="#log接口的实现类"></a> Log接口的实现类</h1><p>Log接口的实现类一共有11个，这里就不进行逐一详细的分析。<br />NoLoggingImpl：望文生义，其内部没有什么具体的实现，只是一种Log接口的实现罢了。<br />StdOutImpl：其方法也没什么特别，只是对error级别的日志进行err级别的打印罢了。<br />Slf4jLocationAwareLoggerImpl和Sl4jLoggerImpl类只是Slf4jImpl的装饰器。<br />Log4jAbstractLoggerImpl和Log4j2LoggerImpl类是Log4j2Impl的装饰器。<br />这样 就剩下了五个实现类。接下来以JakartaCommonsLoggingImpl类的为例来分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JakartaCommonsLoggingImpl</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">ibatis</span>.<span class="title">logging</span>.<span class="title">Log</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Log log;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JakartaCommonsLoggingImpl</span><span class="params">(String clazz)</span> </span>&#123;</span><br><span class="line">    log = LogFactory.getLog(clazz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isDebugEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isTraceEnabled();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略其他源码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JakartaCommonsLoggingImpl是一个典型的对象适配器，其内部持有一个org.apache.ibatis.logging.Log对象，然后所有方法都将操作委托给了该对象。<br /><a name="3ni1T"></a></p><h1 id="logfactory"><a class="markdownIt-Anchor" href="#logfactory"></a> LogFactory</h1><p>该类就是一个制造实现类的工厂，最终，该工厂会给出一个可用的Log实现类，有它来完成日志打印的工作。<br />Log接口的实现类都是对象适配器，最终的实际工作都要委托给被适配的目标对象来完成。LogFactory的主要工作就是尝试生成各个目标对象。该功能是通过如下静态代码块实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  tryImplementation(LogFactory::useSlf4jLogging);</span><br><span class="line">  tryImplementation(LogFactory::useCommonsLogging);</span><br><span class="line">  tryImplementation(LogFactory::useLog4J2Logging);</span><br><span class="line">  tryImplementation(LogFactory::useLog4JLogging);</span><br><span class="line">  tryImplementation(LogFactory::useJdkLogging);</span><br><span class="line">  tryImplementation(LogFactory::useNoLogging);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tryImplementation</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (logConstructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      runnable.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="comment">// ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用runnable.run方法不会触发不会触发多线程，因此这里的多个tryImplementation是依次执行的，而这里的useNoLogging就是他的保底实现类，即不输出任何日志。<br />跟随断点来到了setImplementation方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setImplementation</span><span class="params">(Class&lt;? extends Log&gt; implClass)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 当前日志实现类的构造方法</span></span><br><span class="line">    Constructor&lt;? extends Log&gt; candidate = implClass.getConstructor(String.class);</span><br><span class="line">    <span class="comment">// 尝试生成日志实现类的实例</span></span><br><span class="line">    Log log = candidate.newInstance(LogFactory.class.getName());</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;Logging initialized using &#x27;&quot;</span> + implClass + <span class="string">&quot;&#x27; adapter.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果运行到这里，说明没有异常发生，则实例化日志实现类成功</span></span><br><span class="line">    logConstructor = candidate;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> LogException(<span class="string">&quot;Error setting Log implementation.  Cause: &quot;</span> + t, t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当外部调用getLog方法时，便可以由logConstructor创建一个Log类的实例。.<br /><a name="p9hgu"></a></p><h1 id="jdbc日志打印"><a class="markdownIt-Anchor" href="#jdbc日志打印"></a> JDBC日志打印</h1><p>jdbc子包基于代理模式，让Mybatis能够将JDBC的操作日志打印出来。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601811138309-d5a08dd6-effe-4ce2-938b-1784c8a9bcbe.png#align=left&amp;display=inline&amp;height=169&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=337&amp;originWidth=1195&amp;size=600702&amp;status=done&amp;style=none&amp;width=597.5" alt="image.png" /><br />BaseJdbcLogger各个子类使用动态代理（继承InvactionHandler接口）来实现日志的打印。<br />以下以ConnectionLogger为例进行的invoke方法进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获得方法来源，如果方法继承来自Object类，则直接交给目标对象执行</span></span><br><span class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, params);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;prepareStatement&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDebugEnabled()) &#123;</span><br><span class="line">        <span class="comment">// 输出方法中的参数信息</span></span><br><span class="line">        debug(<span class="string">&quot; Preparing: &quot;</span> + removeBreakingWhitespace((String) params[<span class="number">0</span>]), <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 交由目标对象执行</span></span><br><span class="line">      PreparedStatement stmt = (PreparedStatement) method.invoke(connection, params);</span><br><span class="line">      <span class="comment">// 返回一个PreparedStatementLogger对象，代理PreparedStatement完成日志打印</span></span><br><span class="line">      stmt = PreparedStatementLogger.newInstance(stmt, statementLog, queryStack);</span><br><span class="line">      <span class="keyword">return</span> stmt;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;prepareCall&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDebugEnabled()) &#123;</span><br><span class="line">        debug(<span class="string">&quot; Preparing: &quot;</span> + removeBreakingWhitespace((String) params[<span class="number">0</span>]), <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 交由目标对象执行</span></span><br><span class="line">      PreparedStatement stmt = (PreparedStatement) method.invoke(connection, params);</span><br><span class="line">      <span class="comment">// 返回一个PreparedStatementLogger对象，代理PreparedStatement完成日志打印</span></span><br><span class="line">      stmt = PreparedStatementLogger.newInstance(stmt, statementLog, queryStack);</span><br><span class="line">      <span class="keyword">return</span> stmt;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;createStatement&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">      <span class="comment">// 交由目标对象执行</span></span><br><span class="line">      Statement stmt = (Statement) method.invoke(connection, params);</span><br><span class="line">      <span class="comment">// 返回一个StatementLogger对象，代理Statement完成日志打印</span></span><br><span class="line">      stmt = StatementLogger.newInstance(stmt, statementLog, queryStack);</span><br><span class="line">      <span class="keyword">return</span> stmt;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 其他方法</span></span><br><span class="line">      <span class="keyword">return</span> method.invoke(connection, params);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;logging包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#logging包&quot;&gt;&lt;/a&gt; logging包&lt;/h1&gt;
&lt;p&gt;logging包负责完成Mybatis操作中的日志记录工作。&lt;br /&gt;
&lt;a name=&quot;CCKd0&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="基础功能包" scheme="https://jie-blog.icu/categories/mybatis/%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>I/O包</title>
    <link href="https://jie-blog.icu/posts/mybatis-i_o/"/>
    <id>https://jie-blog.icu/posts/mybatis-i_o/</id>
    <published>2020-11-04T03:57:01.000Z</published>
    <updated>2020-11-04T03:57:51.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="io包"><a class="markdownIt-Anchor" href="#io包"></a> I/O包</h1><p>顾名思义，I/O包即输入输出包，负责完成对Mybatis的输入输出相关的操作。<br />在Mybatis中，与磁盘文件的交互主要是对xml配置文件的读写。因此，I/O包中主要提供对磁盘文件读操作的支持。此外，I/O包还提供对内存中类文件（class文件）的操作。<br /><a name="Zlflf"></a></p><h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1><p>要想细致分析I/O包，要对以下知识点留有概念。<br /><a name="YdFbS"></a></p><h2 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h2><p>使用单例模式的类提供的一个方法得到该类的对象就可以保证该类的对象是唯一的。<br /><a name="aBTVC"></a></p><h2 id="代理模式"><a class="markdownIt-Anchor" href="#代理模式"></a> 代理模式</h2><p>代理模式是指建立某一个对象的代理对象，并且由代理对象控制对原对象的引用。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601706025779-12f34328-cbee-460b-af68-af3e764f17a2.png#align=left&amp;display=inline&amp;height=352&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=352&amp;originWidth=839&amp;size=400691&amp;status=done&amp;style=none&amp;width=839" alt="image.png" /><br />代理类能够实现很多功能：</p><ul><li>隔离功能：能够建立一个目标对象的代理对象。从而防止外部对目标对象的访问。可以在代理对象中增加身份验证等功能，从而实现对目标对象的安全防护。</li><li>扩展功能：对一个目标对象建立代理对象后，可以在代理对象中增加更多的扩展功能。</li><li>直接替换：对一个目标对象建立代理对象后，可以直接使用代理对象完全替换目标对象，由代理对象实现全部的功能。<br /><a name="Y5NxH"></a></li></ul><h3 id="静态代理"><a class="markdownIt-Anchor" href="#静态代理"></a> 静态代理</h3><p>所谓静态，是指代理对象和被代理对象在程序中是确定的，不会在程序运行过程中发生变化。<br /><a name="GzGiG"></a></p><h3 id="动态代理"><a class="markdownIt-Anchor" href="#动态代理"></a> 动态代理</h3><p>静态代理的特点就是其局限性，这样的代理方法十分不灵活，动态代理就可以完美的解决这一问题。<br /><a name="MRCtQ"></a></p><h2 id="vfs"><a class="markdownIt-Anchor" href="#vfs"></a> VFS</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601706043407-f2b5b78a-e0fe-4982-a0ac-097c2edfa1b9.png#align=left&amp;display=inline&amp;height=546&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=546&amp;originWidth=938&amp;size=769135&amp;status=done&amp;style=none&amp;width=938" alt="image.png" /><br />磁盘文件系统可以分为很多种，如：FAT、VFAT、NFS、NTFS等。不同的文件系统操作不同，VFS作为一个虚拟的文件系统，将各个磁盘文件系统的差异屏蔽起来，提供了统一的操作。在操作磁盘文件时，软件程序只需要和VFS沟通即可。<br /><a name="0aK5T"></a></p><h1 id="vfs的实现类"><a class="markdownIt-Anchor" href="#vfs的实现类"></a> VFS的实现类</h1><p>Mybatis的io包中的VFS的作用是从应用服务器中寻找和读取资源文件。IO包中VFS相关类主要有三个：VFS、DefaultVFS、JBoss6VFS。<br />DefaultVFS和JBoss6VFS是VFS的两个实现类，在确定了具体实现类之后，外部只需调用VFS中的方法就可以完成外部文件读取的操作。<br /><a name="pStL4"></a></p><h2 id="vfs分析"><a class="markdownIt-Anchor" href="#vfs分析"></a> VFS分析</h2><p>VFS的内部核心属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储内置的VFS实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] IMPLEMENTATIONS = &#123; JBoss6VFS.class, DefaultVFS.class &#125;;</span><br><span class="line"><span class="comment">// 存储用户自定的VFS实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Class&lt;? extends VFS&gt;&gt; USER_IMPLEMENTATIONS = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>观察其内部接口可知，VFS有一个VFSHolder内部类，其使用了单例模式的方法定义了VFS的实现类。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最终生成的VFS对象    </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> VFS INSTANCE = createVFS();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> VFS <span class="title">createVFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// VFS实现类列表</span></span><br><span class="line">      List&lt;Class&lt;? extends VFS&gt;&gt; impls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="comment">// 先添加用户自定义的实现类，因此用户自定义实现类的优先级最高</span></span><br><span class="line">      impls.addAll(USER_IMPLEMENTATIONS);</span><br><span class="line">      impls.addAll(Arrays.asList((Class&lt;? extends VFS&gt;[]) IMPLEMENTATIONS));</span><br><span class="line"></span><br><span class="line">      VFS vfs = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 依次生成实现类实例，找出第一个可用实例并返回</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; vfs == <span class="keyword">null</span> || !vfs.isValid(); i++) &#123;</span><br><span class="line">        Class&lt;? extends VFS&gt; impl = impls.get(i);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 生成一个实现类对象</span></span><br><span class="line">          vfs = impl.newInstance();</span><br><span class="line">          <span class="comment">// 判断对象是否可用</span></span><br><span class="line">          <span class="keyword">if</span> (vfs == <span class="keyword">null</span> || !vfs.isValid()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">              log.debug(<span class="string">&quot;VFS implementation &quot;</span> + impl.getName() +</span><br><span class="line">                  <span class="string">&quot; is not valid in this environment.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">          log.error(<span class="string">&quot;Failed to instantiate &quot;</span> + impl, e);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Using VFS adapter &quot;</span> + vfs.getClass().getName());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> vfs;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><a name="l9axx"></a></p><h2 id="defaultvfs"><a class="markdownIt-Anchor" href="#defaultvfs"></a> DefaultVFS</h2><p>该类是VFS的默认实现类之一，其isVaild返回的值恒为true，因此，VFS最终生成的对象至少会为DefaultVFS实例。除此之外，其内部还有如下几个方法：</p><ul><li>list：列出指定url下符合条件的资源名称。</li><li>listResources：列出给定Jar包中符合条件的资源名称。</li><li>findJarForResource：找出指定路径上的jar包中符合条件的资源名称。</li><li>getPackagePath：将jar包名称转换为路径。</li><li>isJar：判断指定路径上是否为jar包。<br /><a name="jXfL0"></a></li></ul><h2 id="jboss6vfs"><a class="markdownIt-Anchor" href="#jboss6vfs"></a> JBoss6VFS</h2><p>JBoss6VFS是借鉴JBoss6设计的一套VFS实现类。其主要存在两个内部类：</p><ul><li>Virsual6VFS：仿照JBoss中VirsualFile设计的一个功能子集。</li><li>VFS：仿照JBoss中VFS类设计的一个功能子集。</li></ul><p>经过源码分析发现，这两个类的方法都没实现具体的操作，而是通过invoke调用JBoss的相关方法。因此可以认为其内部类都是代理类，只负责完成将相关操作传给被代理类工作。至于确定被代理类是否存在的工作，在initialize方法中完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  initialize();</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (valid == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 假设可用</span></span><br><span class="line">    valid = Boolean.TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L校验所需的类是否存在，不存在变为不可用</span></span><br><span class="line">    VFS.VFS = checkNotNull(getClass(<span class="string">&quot;org.jboss.vfs.VFS&quot;</span>));</span><br><span class="line">    VirtualFile.VirtualFile = checkNotNull(getClass(<span class="string">&quot;org.jboss.vfs.VirtualFile&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检验所需的方法是否存在，不存在便不可用</span></span><br><span class="line">    VFS.getChild = checkNotNull(getMethod(VFS.VFS, <span class="string">&quot;getChild&quot;</span>, URL.class));</span><br><span class="line">    VirtualFile.getChildrenRecursively = checkNotNull(getMethod(VirtualFile.VirtualFile,</span><br><span class="line">        <span class="string">&quot;getChildrenRecursively&quot;</span>));</span><br><span class="line">    VirtualFile.getPathNameRelativeTo = checkNotNull(getMethod(VirtualFile.VirtualFile,</span><br><span class="line">        <span class="string">&quot;getPathNameRelativeTo&quot;</span>, VirtualFile.VirtualFile));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断上述方法的返回值是否达到预期，否则不可用</span></span><br><span class="line">    checkReturnType(VFS.getChild, VirtualFile.VirtualFile);</span><br><span class="line">    checkReturnType(VirtualFile.getChildrenRecursively, List.class);</span><br><span class="line">    checkReturnType(VirtualFile.getPathNameRelativeTo, String.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="xE7I5"></a></p><h1 id="类文件的加载"><a class="markdownIt-Anchor" href="#类文件的加载"></a> 类文件的加载</h1><p>除了读取普通文件外，有时还需要读取类文件，并加载成一个类。<br />把类文件加载成类需要类加载器的支持，ClassLoaderWrapper类中封装了五种加载器，而Resources类又对ClassLoaderWrapper进行了简单的封装，下列将会详细分析ClassLoaderWrapper。<br />五种加载器在getClassLoaders方法中进行了定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader[] getClassLoaders(ClassLoader classLoader) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ClassLoader[]&#123;</span><br><span class="line">      <span class="comment">// 作为参数传入的类加载器，可能为null</span></span><br><span class="line">      classLoader,</span><br><span class="line">      <span class="comment">// 系统默认的类加载器，如果没设置可以为null</span></span><br><span class="line">      defaultClassLoader,</span><br><span class="line">      <span class="comment">// 当前线程的线程上下文中的类加载器</span></span><br><span class="line">      Thread.currentThread().getContextClassLoader(),</span><br><span class="line">      <span class="comment">// 当前对象的类加载器</span></span><br><span class="line">      getClass().getClassLoader(),</span><br><span class="line">      <span class="comment">// 系统类加载器，在ClassLoaderWrapper构造函数中设置</span></span><br><span class="line">      systemClassLoader&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述五种类加载器优先级由高到低进行排序，在方法classForName根据类名找出指定类的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> Class&lt;?&gt; classForName(String name, ClassLoader[] classLoader) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"><span class="comment">// 对上述五种加载器进行尝试</span></span><br><span class="line">   <span class="keyword">for</span> (ClassLoader cl : classLoader) &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">null</span> != cl) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 使用当前类加载器尝试是否能够成功</span></span><br><span class="line">         Class&lt;?&gt; c = Class.forName(name, <span class="keyword">true</span>, cl);</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">null</span> != c) &#123;</span><br><span class="line">           <span class="comment">// 只要能找到目标则返回结果</span></span><br><span class="line">           <span class="keyword">return</span> c;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">         <span class="comment">// 忽略这个异常，在下面所有加载器未找到时统一抛出</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;Cannot find class: &quot;</span> + name);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><a name="05Nhw"></a></p><h1 id="resolverutil类"><a class="markdownIt-Anchor" href="#resolverutil类"></a> ResolverUtil类</h1><p>该类是一个工具类，其主要完成的是对类的筛选，这些条件可以是：</p><ul><li>是否是某个接口或类的子类</li><li>是否具有某个注解</li></ul><p>ResolverUtil设置了一个内部接口Test，该接口是一个筛选器，内部类中有一个抽象方法matches来判断指定类是否满足筛选条件。该工具类内部类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601708320241-dde058a0-da42-46f5-a990-07b18cc30b16.png#align=left&amp;display=inline&amp;height=401&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=401&amp;originWidth=1094&amp;size=624104&amp;status=done&amp;style=none&amp;width=1094" alt="image.png" /><br />如上图所示，其内部的两个实现类都重写了matches方法：</p><ul><li>IsA类中的matches方法可以判断目标类是否实现了某个接口或者继承了某个类。</li><li>AnnotatedWith的matches方法可以判断目标类是否具有某个注解。</li></ul><p>上述校验的类会放入到工具类的matches属性里。这样一来，读取某个路径上的类文件是，可以借助该工具类进行筛选，其内部的find方法支持筛选出指定路径下符合条件的类文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResolverUtil&lt;T&gt; <span class="title">find</span><span class="params">(Test test, String packageName)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获得起始包路径</span></span><br><span class="line">  String path = getPackagePath(packageName);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 找出包内的各个文件</span></span><br><span class="line">    List&lt;String&gt; children = VFS.getInstance().list(path);</span><br><span class="line">    <span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">      <span class="comment">// 判断后缀</span></span><br><span class="line">      <span class="keyword">if</span> (child.endsWith(<span class="string">&quot;.class&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 判断是否符合条件（Test可以是IsA或者AnnotatedWith）</span></span><br><span class="line">        addIfMatching(test, child);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;Could not read package: &quot;</span> + packageName, ioe);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addIfMatching方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addIfMatching</span><span class="params">(Test test, String fqn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 转化为外部名称</span></span><br><span class="line">    String externalName = fqn.substring(<span class="number">0</span>, fqn.indexOf(<span class="string">&#x27;.&#x27;</span>)).replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="comment">// 获取类加载器</span></span><br><span class="line">    ClassLoader loader = getClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;Checking to see if class &quot;</span> + externalName + <span class="string">&quot; matches criteria [&quot;</span> + test + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// 加载类文件</span></span><br><span class="line">    Class&lt;?&gt; type = loader.loadClass(externalName);</span><br><span class="line">    <span class="keyword">if</span> (test.matches(type)) &#123;</span><br><span class="line">      <span class="comment">// 添加到matches属性中</span></span><br><span class="line">      matches.add((Class&lt;T&gt;) type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;Could not examine class &#x27;&quot;</span> + fqn + <span class="string">&quot;&#x27;&quot;</span> + <span class="string">&quot; due to a &quot;</span> +</span><br><span class="line">        t.getClass().getName() + <span class="string">&quot; with message: &quot;</span> + t.getMessage());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;io包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#io包&quot;&gt;&lt;/a&gt; I/O包&lt;/h1&gt;
&lt;p&gt;顾名思义，I/O包即输入输出包，负责完成对Mybatis的输入输出相关的操作。&lt;br /&gt;在Mybatis中，与磁盘文件的交互主要是对x</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="基础功能包" scheme="https://jie-blog.icu/categories/mybatis/%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>type包</title>
    <link href="https://jie-blog.icu/posts/mybatis-type/"/>
    <id>https://jie-blog.icu/posts/mybatis-type/</id>
    <published>2020-11-04T03:56:18.000Z</published>
    <updated>2020-11-04T03:58:12.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="type包"><a class="markdownIt-Anchor" href="#type包"></a> type包</h1><p>type包里有55个类，为了不头大，这里先进行简单的分类，方便进一步的分析。</p><ul><li>类型处理器<ul><li>TypeHandler：类型处理器接口。</li><li>BaseTypeHandler：类型处理器的基础实现。</li><li>TypeReference：类型参考器。</li><li>*TypeHandler：43个类型处理器。</li></ul></li><li>类型注册表：<ul><li>SimpleTypeRegistry：基本类型注册表，内部使用Set维护了所有Java基本数据类型的集合。</li><li>TypeAliasRegistry：类型别名注册表，内部使用HashMap维护了所有的类型的别名和类型关系映射。</li><li>TypeHandlerRegistry：类型处理器注册表，内部维护了所有类型与对应类型处理器的映射关系。</li></ul></li><li>注解类：<ul><li>Alias：使用该注解可以给类设置别名，设置后，别名和类型的映射关系便存入TypeAliasTypes中。</li><li>MappedJdbcTypes：想要使用自己的处理器来处理某些JDBC类型时，只需创建BaseTypeHandler的子类然后加上该注解声明其要处理的JDBC类型即可。</li><li>MappedTypes：想要使用自己的处理器处理某些Java类型时，只需创建BaseTypeHandler的子类然后加上该注解，然后声明要处理的Java类型即可。</li></ul></li><li>异常类：<ul><li>TypeException：表示类型处理相关的异常。</li></ul></li><li>枚举类：<ul><li>JdbcType：在Enum中定义了所有的JDBC类型。<br /><a name="DdBtH"></a></li></ul></li></ul><h1 id="模板模式"><a class="markdownIt-Anchor" href="#模板模式"></a> 模板模式</h1><p>分析处理器前要先了解一下模板模式。<br />在模板模式中，需要使用一个抽象类定义一套整体的步骤（即模板），而抽象类的子类则完成每个步骤的具体实现。<br /><a name="G2CfO"></a></p><h1 id="类型处理器"><a class="markdownIt-Anchor" href="#类型处理器"></a> 类型处理器</h1><p><a name="J9SFk"></a></p><h2 id="basetypehandler"><a class="markdownIt-Anchor" href="#basetypehandler"></a> BaseTypeHandler</h2><p>作为一个ORM框架，对象关系映射中的数据类型映射也就十分重要，不同字段所需的读写方法各不相同，因此需要对不同类型的字段采取相应的处理方法。<br />在type包中，将每种类型对应的处理方法封装在了对应的类型处理器中。TypeHandler和BaseTypeHandler分别是类型处理器的接口和基类，其类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601634542762-145aaf65-3411-4031-a224-12051e27a51c.png#align=left&amp;display=inline&amp;height=500&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=500&amp;originWidth=1049&amp;size=614400&amp;status=done&amp;style=none&amp;width=1049" alt="image.png" /><br />这里的BaseTypeHandler就引用了模板模式的思想，以getResult方法为例，该方法完成了异常处理等统一的工作，而与具体类型相关的getNullableResult则通过抽象方法交给具体类型处理器实现。该方法的四种定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向 PreparedStatement对象中的指定变量位置写入一个不为null的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, T parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">// 从  ResultSet中按照字段名读出一个可能为null的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">// 从  ResultSet中按照字段编号读出一个可能为null的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">getNullableResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">// 从  CallableStatement中按照字段编号读出一个可能为null的数据  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">getNullableResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><p>因为抽象方法跟具体类型相关，因此存在泛型参数T。在每种类型处理器的实现中，都给出了泛型参数的值。<br /><a name="Dg6PO"></a></p><h2 id="typereference"><a class="markdownIt-Anchor" href="#typereference"></a> TypeReference</h2><p>所有类型处理器都是TypeHandler接口的实现，因此都可以通过TypeHandler来调用。但是TypeHandler的实现如此多，就需要一种参照书来查看当前的调用使用的是哪种目标类型。<br />Mybatis定义了一个TypeReference类，它能够判断出一个TypeHandler用来处理的目标类型。其判断方法很简单，就是取出TypeHandler实现类中的泛型参数T的类型而已，这个值的类型就是要处理的目标类型。其子类BaseTypeHandler通过传入泛型的值，从而递交给TypeReference来获取目标类型。<br />该功能由getSuperclassTypeParameter实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">Type <span class="title">getSuperclassTypeParameter</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 获取clazz类带有泛型的直接父类</span></span><br><span class="line">   Type genericSuperclass = clazz.getGenericSuperclass();</span><br><span class="line">   <span class="keyword">if</span> (genericSuperclass <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">     <span class="comment">// try to climb up the hierarchy until meet something useful</span></span><br><span class="line">     <span class="keyword">if</span> (TypeReference.class != genericSuperclass) &#123;</span><br><span class="line">       <span class="comment">// 说明没有解析到足够上层，将clazz类的父类作为输入参数递归调用</span></span><br><span class="line">       <span class="keyword">return</span> getSuperclassTypeParameter(clazz.getSuperclass());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">&quot;&#x27;&quot;</span> + getClass() + <span class="string">&quot;&#x27; extends TypeReference but misses the type parameter. &quot;</span></span><br><span class="line">       + <span class="string">&quot;Remove the extension or add a type parameter to it.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 说明genericSuperclass是泛型，获取泛型的第一个参数</span></span><br><span class="line">   Type rawType = ((ParameterizedType) genericSuperclass).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">   <span class="comment">// TODO remove this when Reflector is fixed to return Types</span></span><br><span class="line">   <span class="comment">// 判断是否是参数化类型</span></span><br><span class="line">   <span class="keyword">if</span> (rawType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">     <span class="comment">// 获取参数化类型的实际类型</span></span><br><span class="line">     rawType = ((ParameterizedType) rawType).getRawType();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> rawType;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>该方法通过TypeReference的构造器中调用。<br /><a name="oNnJJ"></a></p><h1 id="类型注册表"><a class="markdownIt-Anchor" href="#类型注册表"></a> 类型注册表</h1><p>推断出目标类型以后，Mybatis还需要根据目标类型来找到相应的类型处理器，这个过程就需要各种类型注册表的帮助。<br />SimpleTypeRegistry是一个非常简单的注册表，其内部通过SIMPLE_TYPE_SET定义了很多基本类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Class&lt;?&gt;&gt; SIMPLE_TYPE_SET = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  SIMPLE_TYPE_SET.add(String.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Byte.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Short.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Character.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Integer.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Long.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Float.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Double.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Boolean.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Date.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Class.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(BigInteger.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(BigDecimal.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TypeAliasRegistry是一个别名注册表，其内部使用typeAliases属性维护了类型和别名的对应关系。<br />TypeHandlerRegistry是这三个注册表中最核心也是最关键的一个，数据类型和相关处理器都是它来维护的。接下来要详细的分析一下这个类。<br /><a name="LjNW2"></a></p><h2 id="typehandlerregistry"><a class="markdownIt-Anchor" href="#typehandlerregistry"></a> TypeHandlerRegistry</h2><p>在分析之前，要明确Java类型参数和JDBC中的类型参数是一对多的关系，比如一个String会对应数据库的varchar、char。<br />其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDBC类型与对应类型处理器的映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;  jdbcTypeHandlerMap = <span class="keyword">new</span> EnumMap&lt;&gt;(JdbcType.class);</span><br><span class="line"><span class="comment">// Java类型与Map&lt;JdbcType,TypeHandler&lt;?&gt;&gt;的映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; typeHandlerMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 未知类型的处理器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TypeHandler&lt;Object&gt; unknownTypeHandler = <span class="keyword">new</span> UnknownTypeHandler(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 键与typeHandler.getClass()，值为typeHandler。里面存储了所有的类型处理器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt; allTypeHandlersMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 空的Map&lt;jdbcType,TypeHandler&lt;?&gt;&gt;，表示该Java类型没有对应的Map&lt;jdbcType,TypeHandler&lt;?&gt;&gt;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; NULL_TYPE_HANDLER_MAP = Collections.emptyMap();</span><br><span class="line"><span class="comment">// 默认的枚举类型处理器</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;? extends TypeHandler&gt; defaultEnumTypeHandler = EnumTypeHandler.class;</span><br></pre></td></tr></table></figure><p>其实际的获取处理器的方式就是两次映射的过程：</p><ul><li>根据传入的Java类型，调用getJdbcHandlerMap字方法寻找对应的jdbcTypeHandler后返回。</li><li>基于jdbcTypeHandlerMap，根据JDBC类型找到对应的TypeHandler。</li></ul><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">TypeHandler&lt;T&gt; <span class="title">getTypeHandler</span><span class="params">(Type type, JdbcType jdbcType)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否是单一的Java类型</span></span><br><span class="line">  <span class="keyword">if</span> (ParamMap.class.equals(type)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据Java类型找到对应的jdbcHandlerMap</span></span><br><span class="line">  Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; jdbcHandlerMap = getJdbcHandlerMap(type);</span><br><span class="line">  TypeHandler&lt;?&gt; handler = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (jdbcHandlerMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据JDBC类型找寻对应的处理器</span></span><br><span class="line">    handler = jdbcHandlerMap.get(jdbcType);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      handler = jdbcHandlerMap.get(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// #591</span></span><br><span class="line">      handler = pickSoleHandler(jdbcHandlerMap);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// type drives generics here</span></span><br><span class="line">  <span class="keyword">return</span> (TypeHandler&lt;T&gt;) handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;type包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#type包&quot;&gt;&lt;/a&gt; type包&lt;/h1&gt;
&lt;p&gt;type包里有55个类，为了不头大，这里先进行简单的分类，方便进一步的分析。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型处理器
&lt;ul&gt;
</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="基础功能包" scheme="https://jie-blog.icu/categories/mybatis/%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>annocations包与lang包</title>
    <link href="https://jie-blog.icu/posts/mybatis-annocations&amp;lang/"/>
    <id>https://jie-blog.icu/posts/mybatis-annocations&amp;lang/</id>
    <published>2020-11-04T03:54:39.000Z</published>
    <updated>2020-11-04T03:55:19.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="annocations包与lang包"><a class="markdownIt-Anchor" href="#annocations包与lang包"></a> annocations包与lang包</h1><p>这两个包中存放的都是自定义的注解类，这里只分析其共性，就不一一进行分析了。<br /><a name="pwrG6"></a></p><h1 id="java的注解详解"><a class="markdownIt-Anchor" href="#java的注解详解"></a> Java的注解详解</h1><p>以随机一个注解为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.PARAMETER)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Param &#123;</span><br><span class="line">  <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，这个自定义的注解类还会包含很多其他的注解，这些注解其他注解的注解称为元注解。<br />元注解共有五个：@Target、@Retention、@Documented、@Interited、@Repeatable。其分别含义：<br /><a name="FlT6B"></a></p><h2 id="target"><a class="markdownIt-Anchor" href="#target"></a> @Target</h2><p>该注解是用来声明注解可以用在什么地方的，他的值需要从枚举类ElementType中选取，ElementType的枚举值如下：</p><ul><li>TYPE：类、接口、注释、枚举。</li><li>FIELD：字段。</li><li>METHOD：方法。</li><li>PARMETER：参数。</li><li>CONSTRUCTOR：构造方法。</li><li>LOCAL_VARIABLE：本地变量。</li><li>ANNOTATION_TYPE：注解。</li><li>PACKAGE：包。</li><li>TYPE_PARAMETER：参数类型。</li><li>TYPE_USER：类型使用。</li></ul><p>注：元属性也有Target、枚举值可以选择多个。<br /><a name="8fLTd"></a></p><h1 id="retention"><a class="markdownIt-Anchor" href="#retention"></a> @Retention</h1><p>该注解是用来声明注解的生命周期的，即表明注解会被保存到哪一个阶段。他的值需要从枚举类RetentionType中选取，其枚举值如下：</p><ul><li>SOURCE：保留到源码阶段。这一类注解一把留给编译器使用，在编译时会被擦除。</li><li>CLASS：保留到类文件阶段。这是默认的生命周期，JVM运行时不包含这类信息。</li><li>RUNTIME：保留到JVM运行阶段。<br /><a name="uAKak"></a></li></ul><h2 id="document"><a class="markdownIt-Anchor" href="#document"></a> @Document</h2><p>不需要设置具体的值，被注解的注解会在javadoc中生成。<br /><a name="kl0zk"></a></p><h2 id="inherited"><a class="markdownIt-Anchor" href="#inherited"></a> @Inherited</h2><p>不需要设置具体的值，被该注解的注解的注解可以被继承（不能从接口继承）。<br /><a name="VLWw3"></a></p><h2 id="repeatable"><a class="markdownIt-Anchor" href="#repeatable"></a> @Repeatable</h2><p>表示该注解可以重复在一个地方使用多次。<br /><a name="80JyB"></a></p><h1 id="param注解分析"><a class="markdownIt-Anchor" href="#param注解分析"></a> Param注解分析</h1><p>这里以Param注解为例来分析自定义注解类。<br />在调用dao层方法时加上@Param注解，便可以在Mapper中引用id所指代的变量。接下来将分析该功能是如何实现的。<br />随着调试来到ParamNameResolver的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ParamNameResolver</span><span class="params">(Configuration config, Method method)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取参数参数类型列表</span></span><br><span class="line">  <span class="keyword">final</span> Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line">  <span class="comment">// 准备用二维数组存取所有参数的注解</span></span><br><span class="line">  <span class="keyword">final</span> Annotation[][] paramAnnotations = method.getParameterAnnotations();</span><br><span class="line">  <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">int</span> paramCount = paramAnnotations.length;</span><br><span class="line">  <span class="comment">// 循环处理各个参数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> paramIndex = <span class="number">0</span>; paramIndex &lt; paramCount; paramIndex++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isSpecialParameter(paramTypes[paramIndex])) &#123;</span><br><span class="line">      <span class="comment">// 跳过特别的参数</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数名字</span></span><br><span class="line">    String name = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : paramAnnotations[paramIndex]) &#123;</span><br><span class="line">      <span class="comment">// 找到param注解</span></span><br><span class="line">      <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Param) &#123;</span><br><span class="line">        hasParamAnnotation = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 以param的值作为参数名</span></span><br><span class="line">        name = ((Param) annotation).value();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 否则保留参数</span></span><br><span class="line">      <span class="keyword">if</span> (config.isUseActualParamName()) &#123;</span><br><span class="line">        name = getActualParamName(method, paramIndex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// use the parameter index as the name (&quot;0&quot;, &quot;1&quot;, ...)</span></span><br><span class="line">        <span class="comment">// gcode issue #71</span></span><br><span class="line">        name = String.valueOf(map.size());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存入位置序号+名字</span></span><br><span class="line">    map.put(paramIndex, name);</span><br><span class="line">  &#125;</span><br><span class="line">  names = Collections.unmodifiableSortedMap(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;annocations包与lang包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#annocations包与lang包&quot;&gt;&lt;/a&gt; annocations包与lang包&lt;/h1&gt;
&lt;p&gt;这两个包中存放的都是自定义的注解类，这里只分析其</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="基础功能包" scheme="https://jie-blog.icu/categories/mybatis/%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>reflection包</title>
    <link href="https://jie-blog.icu/posts/mybatis-annocations&amp;lang/"/>
    <id>https://jie-blog.icu/posts/mybatis-annocations&amp;lang/</id>
    <published>2020-11-04T03:54:22.000Z</published>
    <updated>2020-11-04T03:55:42.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="reflection包"><a class="markdownIt-Anchor" href="#reflection包"></a> reflection包</h1><p><a name="vA04i"></a></p><h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1><p><a name="Pw5mh"></a></p><h2 id="装饰器模式"><a class="markdownIt-Anchor" href="#装饰器模式"></a> 装饰器模式</h2><p>装饰器模式又称包装模式，是一种结构型模式。在使用装饰器模式对包装类进行扩展后不会影响原有类。通常使用的场景是在一个核心基本类的基础上提供大量的装饰类，从而使核心基本类经过不同的装饰类修饰后获得不同的功能。此外，装饰器类还可以叠加使用，从而使一个基本类同时具有多个装饰类的功能。<br />装饰器模式归在本人的理解就是在一杯奶茶里加上波霸、芋圆、椰果后，这杯奶茶变成了一杯加料的“奶茶”。好比FileInputStream和InputStream的关系。<br /><a name="7LE5V"></a></p><h2 id="反射"><a class="markdownIt-Anchor" href="#反射"></a> 反射</h2><p>通过Java的反射能够在类的运行过程中知道这个类有哪些属性和方法。此外，还可以修改属性、调用方法、建立类的实例。例如平常进行的复制操作就可以利用反射书写一个适用于任何类的对象的赋值工作。<br />反射主要提供了以下几个功能：</p><ul><li>在运行时判断任意一个对象所属的类。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时修改任意一个对象的成员变量。</li><li>在运行时调用任意一个对象的方法。<br /><a name="lqoZy"></a></li></ul><h2 id="type接口及其子类"><a class="markdownIt-Anchor" href="#type接口及其子类"></a> Type接口及其子类</h2><p>在反射中经常会遇到一个位于java.lang.reflect包下的Type接口，该接口子类类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601365504161-8d341197-8b6a-42c1-ab12-762df6a6052a.png#align=left&amp;display=inline&amp;height=147&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=294&amp;originWidth=1262&amp;size=581414&amp;status=done&amp;style=none&amp;width=631" alt="image.png" /></p><ul><li>Class类：它代表运行的Java程序中的类和接口。</li><li>WildcardType接口：它代表通配符表达式。例如：“？”，“？ extends Number”。</li><li>TypeVariable接口：它代表参数化的类型，例如：“Map&lt;K，V&gt;”中的K，V。</li><li>ParameterizedType接口：它代表参数化的类型。例如：“Collection<String>”就是参数化类型。</li><li>GenericArrayType接口：它代表包含ParameterizedType或者TypeVariable元素的列表。<br /><a name="YSlQP"></a></li></ul><h1 id="对象工厂子包"><a class="markdownIt-Anchor" href="#对象工厂子包"></a> 对象工厂子包</h1><p>reflection包下的factory子包就是一个对象工厂子包，该对象常用来基于反射生产出各种对象，子包结构：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601365848909-95047bfd-6944-44cc-8aa4-b02c99110907.png#align=left&amp;display=inline&amp;height=68&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=109&amp;originWidth=316&amp;size=14545&amp;status=done&amp;style=none&amp;width=197" alt="image.png" /><br />观察ObjectFacory接口，有如下三个方法：</p><ul><li><code>void setProperties(Properties properties)</code>：设置工厂属性</li><li><code>&lt;T&gt; T create(Class&lt;T&gt; type)</code>：传入到下一个create</li><li><code>&lt;T&gt; T create(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</code>：传入目标类型、参数类型列表、参数值列表，根据相应的含参构造方法生成这个类型的实例。</li><li><code>&lt;T&gt; boolean isCollection(Class&lt;T&gt; type)</code>：判断传入的类型是否是一个集合类。</li></ul><p>DefaultObjectFactory类实现了该接口，其create最终返回的是instantiateClass方法生成的对象，其方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>  &lt;T&gt; <span class="function">T <span class="title">instantiateClass</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 构造方法对象</span></span><br><span class="line">    Constructor&lt;T&gt; constructor;</span><br><span class="line">    <span class="comment">// 判断是否不含参或者参数列表为null</span></span><br><span class="line">    <span class="keyword">if</span> (constructorArgTypes == <span class="keyword">null</span> || constructorArgs == <span class="keyword">null</span>) &#123;</span><br><span class="line">      constructor = type.getDeclaredConstructor();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 返回空构造函数生成对象</span></span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="comment">// 如果访问异常，判断构造函数访问属性可否修改</span></span><br><span class="line">        <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) &#123;</span><br><span class="line">          <span class="comment">// 修改构造函数访问属性</span></span><br><span class="line">          constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">          <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据输入参数类型找到对应的构造器</span></span><br><span class="line">    constructor = type.getDeclaredConstructor(constructorArgTypes.toArray(<span class="keyword">new</span> Class[constructorArgTypes.size()]));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 采用有参构造函数创建实例并返回</span></span><br><span class="line">      <span class="keyword">return</span> constructor.newInstance(constructorArgs.toArray(<span class="keyword">new</span> Object[constructorArgs.size()]));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) &#123;</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance(constructorArgs.toArray(<span class="keyword">new</span> Object[constructorArgs.size()]));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 收集所有参数类型</span></span><br><span class="line">    String argTypes = Optional.ofNullable(constructorArgTypes).orElseGet(Collections::emptyList)</span><br><span class="line">        .stream().map(Class::getSimpleName).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">    <span class="comment">// 收集所有参数</span></span><br><span class="line">    String argValues = Optional.ofNullable(constructorArgs).orElseGet(Collections::emptyList)</span><br><span class="line">        .stream().map(String::valueOf).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">&quot;Error instantiating &quot;</span> + type + <span class="string">&quot; with invalid types (&quot;</span> + argTypes + <span class="string">&quot;) or values (&quot;</span> + argValues + <span class="string">&quot;). Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外该实现类里还有一个resolveInterface方法，其作用是判断如果传入的类型是容器接口的话，返回相应的容器对象，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveInterface(Class&lt;?&gt; type) &#123;</span><br><span class="line">  Class&lt;?&gt; classToCreate;</span><br><span class="line">  <span class="keyword">if</span> (type == List.class || type == Collection.class || type == Iterable.class) &#123;</span><br><span class="line">    classToCreate = ArrayList.class;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Map.class) &#123;</span><br><span class="line">    classToCreate = HashMap.class;</span><br><span class="line">  &#125; else if (type == SortedSet.class) &#123; // issue #510 Collections Support</span><br><span class="line">    classToCreate = TreeSet.class;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Set.class) &#123;</span><br><span class="line">    classToCreate = HashSet.class;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    classToCreate = type;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> classToCreate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="duvQU"></a></p><h1 id="执行器子包"><a class="markdownIt-Anchor" href="#执行器子包"></a> 执行器子包</h1><p>reflection包下的invoker子包是执行器的子包，该子包中的类能够基于反射实现对象方法的调用和对象属性的读写，该包下的类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601366988466-8ad4d0f5-6c8d-4f7a-b5c6-7dcff3ef3098.png#align=left&amp;display=inline&amp;height=182&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=364&amp;originWidth=1126&amp;size=630938&amp;status=done&amp;style=none&amp;width=563" alt="image.png" /><br />Invoker的三种实现分别用于处理环境如下：</p><ul><li>GetFieldInvoker：负责对象属性的读操作。</li><li>SetFiledInvoker：负责对象属性的写操作。</li><li>MethodInvoker：负责对象其他方法的操作。</li></ul><p>此外，Invoker接口中定义的两个抽象方法的功能分别是：</p><ul><li>invoker：执行方法，该方法负责完成对象方法的调用和对象属性的读写。在三个实现类中，分别是属性读写操作、属性赋值操作、方法触发操作。</li><li>getType：用来获取方法。它对于GetFieldInvoker、SetFiledInvoker的含义是获取目标属性类型，而MethodInvoker取略有不同，详见下文。<br /><a name="GCbzN"></a></li></ul><h2 id="methodinvoker的gettype"><a class="markdownIt-Anchor" href="#methodinvoker的gettype"></a> MethodInvoker的getType</h2><p>该类的getType源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getType() &#123;</span><br><span class="line">  <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅仅是返回一个type对象，其对象又是在其构造方法中定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MethodInvoker</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.method = method;</span><br><span class="line"><span class="comment">// 有且仅有一个参数时</span></span><br><span class="line">   <span class="keyword">if</span> (method.getParameterTypes().length == <span class="number">1</span>) &#123;</span><br><span class="line">     type = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     type = method.getReturnType();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当有且仅有一个参数时，type为输入参数的类型，否则type将为返回值类型。<br /><a name="ef7BF"></a></p><h2 id="invoke的实现"><a class="markdownIt-Anchor" href="#invoke的实现"></a> invoke的实现</h2><p>这里以GetFieldInvoker为示例，其实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object target, Object[] args)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 直接获取反射目标对象的值</span></span><br><span class="line">    <span class="keyword">return</span> field.get(target);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    <span class="comment">// 如果属性的访问性可以修改</span></span><br><span class="line">    <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) &#123;</span><br><span class="line">      <span class="comment">// 修改访问属性</span></span><br><span class="line">      field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">return</span> field.get(target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><a name="RkJTo"></a></p><h1 id="属性子包"><a class="markdownIt-Anchor" href="#属性子包"></a> 属性子包</h1><p>reflection包下的properties子包是属性的子包，该子包中的类用来完成与对象属性相关的操作，其包结构如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601367880256-db406b71-8690-4b05-8f40-46765dfc1c2d.png#align=left&amp;display=inline&amp;height=81&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=106&amp;originWidth=272&amp;size=14096&amp;status=done&amp;style=none&amp;width=208" alt="image.png" /><br /><a name="i1U8m"></a></p><h2 id="propertiescopier"><a class="markdownIt-Anchor" href="#propertiescopier"></a> PropertiesCopier</h2><p>其中，PropertiesCopier负责复制属性的值，该类中的唯一方法就是实现拷贝功能的方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyBeanProperties</span><span class="params">(Class&lt;?&gt; type, Object sourceBean, Object destinationBean)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 两个对象同属的类</span></span><br><span class="line">  Class&lt;?&gt; parent = type;</span><br><span class="line">  <span class="keyword">while</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取该类的全部属性</span></span><br><span class="line">    <span class="keyword">final</span> Field[] fields = parent.getDeclaredFields();</span><br><span class="line">    <span class="comment">// 遍历属性</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 调用set方法进行赋值</span></span><br><span class="line">          field.set(destinationBean, field.get(sourceBean));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">          <span class="comment">// 判断是否有属性访问权限</span></span><br><span class="line">          <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) &#123;</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            field.set(destinationBean, field.get(sourceBean));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// Nothing useful to do, will only fail on final fields, which will be ignored.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parent = parent.getSuperclass();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：该方法无法完成继承得来的属性的赋值，因为copyBeanProperties方法在赋值的时候不包含继承属性。<br /><a name="MY2un"></a></p><h2 id="propertynamer"><a class="markdownIt-Anchor" href="#propertynamer"></a> PropertyNamer</h2><p>该类用于提供属性名称相关的操作功能，其正常运行的前提下是对象的属性符合JavaBean命名规范。<br /><a name="x1caz"></a></p><h2 id="propertytokenizer"><a class="markdownIt-Anchor" href="#propertytokenizer"></a> PropertyTokenizer</h2><p>该类是一个属性标记器，当传入一个形如“student[sId].name”的字符串时，标记器会将其拆开放入到各个属性中。<br /><a name="81yad"></a></p><h1 id="对象包装器子包"><a class="markdownIt-Anchor" href="#对象包装器子包"></a> 对象包装器子包</h1><p>reflection包下的wrapper子包是对象包装器的子包，该子包中的类使用装饰器模式对各种类型的对象进行进一步封装，使其增加新的功能。包内类图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601448001468-5b168440-ce42-4f74-9f73-4a0eaea7ef81.png#align=left&amp;display=inline&amp;height=305&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=610&amp;originWidth=1107&amp;size=855226&amp;status=done&amp;style=none&amp;width=553.5" alt="image.png" /><br />其中DefaultObjectWrapperFactory是对象包装器工厂接口的实现，但是这个类中并没有任何功能。因此用户可以通过这个接口定义自己的工厂实现类。<br /><a name="pNTCp"></a></p><h2 id="beanwrapper"><a class="markdownIt-Anchor" href="#beanwrapper"></a> BeanWrapper</h2><p>ObjectWrapper接口是所有对象包装器的总接口，下面将以BeanWrapper为例介绍一下包装器的实现，但是此前要先了解一下MetaObject和MetaClass类：</p><ul><li>MetaObject：涵盖对象中更多细节信息和功能的一个类，又称元对象。</li><li>MetaClass：涵盖了类型中更多细节信息和功能的类，称为元类。</li></ul><p>BeanWrapper有三个重要的属性，其中metaObject属性是由父类BaseWrappper继承而来的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被包装对象的元对象（继承自父类BaseWrapper）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> MetaObject metaObject;</span><br><span class="line"><span class="comment">// 被包装的对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object object;</span><br><span class="line"><span class="comment">// 被包装对象所属类的元类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MetaClass metaClass;</span><br></pre></td></tr></table></figure><p>类中方法的解释：</p><ul><li>get：获得被包装对象某个属性的值。</li><li>set：设置被包装对象某个属性的值。</li><li>findProperty：找到对应属性的名称。</li><li>getGetterNames：获得所有的属性get方法的名字。</li><li>getSetterNames：获得所有的属性set方法的名字。</li><li>getSetterType：获得指定属性的set方法的类型。</li><li>getGetterType：获得指定属性的get方法的类型。</li><li>hasSetter：判断某个属性是否有对应的set方法。</li><li>hasGetter：判断某个属性是否有对应的get方法。</li><li>instantiatePropertyValue：实例化某个属性的值。</li></ul><p>因此，一个Bean经过BeanWrapper包装后就可以暴露出很多易用的方法，从而实现对属性、方法的一系列操作。<br /><a name="z8pZE"></a></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>类似于BeanWrapper，CollectionWrapper、MapWrapper也可以通过这样的包装使Collection和Map暴露出很多易用的方法。<br />BaseWrapper作为MapWrapper和BeanWrapper的父类，提供了两个有用的基础方法为set和get使用。<br /><a name="4u9Mv"></a></p><h1 id="父包类"><a class="markdownIt-Anchor" href="#父包类"></a> 父包类</h1><p><a name="BXLDN"></a></p><h2 id="反射核心类"><a class="markdownIt-Anchor" href="#反射核心类"></a> 反射核心类</h2><p>reflection包中最核心的类就是Reflector类。<br />Refection的相关类类图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601450359300-46397827-be8f-4554-96a2-58fed10099ae.png#align=left&amp;display=inline&amp;height=150&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=299&amp;originWidth=866&amp;size=390074&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br /><a name="jsJNi"></a></p><h3 id="reflection"><a class="markdownIt-Anchor" href="#reflection"></a> Reflection</h3><p>该类将一个类反射解析后会将该类的属性、方法等一一归类放到下述各个属性中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要被反射解析的类  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line"><span class="comment">// 能够读的属性列表，即有get方法的属性列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] readablePropertyNames;</span><br><span class="line"><span class="comment">// 能够写的属性列表，即有set方法的属性列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] writablePropertyNames;</span><br><span class="line"><span class="comment">// set方法映射表。键为属性名，值为set方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Invoker&gt; setMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// get方法映射表。键为属性名，值为get方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Invoker&gt; getMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// set方法输入类型。键为属性名，值为对应的该属性的set方法的类型（set方法第一个参数的类型）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; setTypes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// get方法输出类型。键为属性名，值为对应的该属性的get方法的类型（get方法返回值的类型）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; getTypes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="keyword">private</span> Constructor&lt;?&gt; defaultConstructor;</span><br><span class="line"><span class="comment">// 大小无关的属性映射表。键为属性全大写值，值为属性名。</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, String&gt; caseInsensitivePropertyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>Reflection类反射解析一个类的过程是由构造函数触发的，构造函数源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Reflector</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 要被反射解析的类</span></span><br><span class="line">  type = clazz;</span><br><span class="line">  <span class="comment">// 设置无参构造函数属性</span></span><br><span class="line">  addDefaultConstructor(clazz);</span><br><span class="line">  <span class="comment">// 解析所有的getter</span></span><br><span class="line">  addGetMethods(clazz);</span><br><span class="line">  <span class="comment">// 解析所有的setter</span></span><br><span class="line">  addSetMethods(clazz);</span><br><span class="line">  <span class="comment">// 解析所有的属性</span></span><br><span class="line">  addFields(clazz);</span><br><span class="line">  <span class="comment">// 设置可读参数</span></span><br><span class="line">  readablePropertyNames = getMethods.keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// 设置可写参数</span></span><br><span class="line">  writablePropertyNames = setMethods.keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// 将可读可写参数放入大小写无关的属性映射表</span></span><br><span class="line">  <span class="keyword">for</span> (String propName : readablePropertyNames) &#123;</span><br><span class="line">    caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (String propName : writablePropertyNames) &#123;</span><br><span class="line">    caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的几个方法实现较为基础，暂不做分析。<br /><a name="ReqH3"></a></p><h3 id="defaultreflectorfactory"><a class="markdownIt-Anchor" href="#defaultreflectorfactory"></a> DefaultReflectorFactory</h3><p>ReflectorFactory是Reflector的接口工厂，DefaultReflectorFactory是该接口的实现，于是将分析DefaultReflectorFactory类。<br />该类中只有一个业务相关的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Reflector <span class="title">findForClass</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否允许缓存</span></span><br><span class="line">  <span class="keyword">if</span> (classCacheEnabled) &#123;</span><br><span class="line">    <span class="comment">// synchronized (type) removed see issue #461</span></span><br><span class="line">    <span class="comment">// 生产输入参数Type的反射器对象并放入缓存</span></span><br><span class="line">    <span class="keyword">return</span> reflectorMap.computeIfAbsent(type, Reflector::<span class="keyword">new</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Reflector(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="2bgpx"></a></p><h2 id="反射包装类"><a class="markdownIt-Anchor" href="#反射包装类"></a> 反射包装类</h2><p>之前在wrapper涉及到的两个基础类：MetaClass和MetaObject这里将详细分析。<br /><a name="HoWcP"></a></p><h3 id="metaobject"><a class="markdownIt-Anchor" href="#metaobject"></a> MetaObject</h3><p>MetaObject被称为元对象，是一个针对普通Object对象的包装类，其属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object originalObject;</span><br><span class="line"><span class="comment">// 对象包装器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ObjectWrapper objectWrapper;</span><br><span class="line"><span class="comment">// 对象工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ObjectFactory objectFactory;</span><br><span class="line"><span class="comment">// 对象包装器工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ObjectWrapperFactory objectWrapperFactory;</span><br><span class="line"><span class="comment">// 反射工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReflectorFactory reflectorFactory;</span><br></pre></td></tr></table></figure><p>该类提供很多和objectWrapper一样的方法：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601452010427-e85d7658-a737-4b16-a09c-f1a3e3e49c2d.png#align=left&amp;display=inline&amp;height=164&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=327&amp;originWidth=495&amp;size=76636&amp;status=done&amp;style=none&amp;width=247.5" alt="image.png" /><br />并且在实现的时候调用了objectWrapper的响应方法。<br />然而在objectWrapper的实现中却调用了MetaClass对象的相应方法。<br /><a name="YUEZC"></a></p><h3 id="metaclass"><a class="markdownIt-Anchor" href="#metaclass"></a> MetaClass</h3><p>MetaClass被称为元类，它是针对类的进一步封装，内部集成了类可能使用的反射器和反射工厂。<br /><a name="0BB5j"></a></p><h3 id="systemmetaobject"><a class="markdownIt-Anchor" href="#systemmetaobject"></a> SystemMetaObject</h3><p>该类中限定了一些默认值，源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemMetaObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectFactory DEFAULT_OBJECT_FACTORY = <span class="keyword">new</span> DefaultObjectFactory();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectWrapperFactory DEFAULT_OBJECT_WRAPPER_FACTORY = <span class="keyword">new</span> DefaultObjectWrapperFactory();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MetaObject NULL_META_OBJECT = MetaObject.forObject(NullObject.class, DEFAULT_OBJECT_FACTORY, DEFAULT_OBJECT_WRAPPER_FACTORY, <span class="keyword">new</span> DefaultReflectorFactory());</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SystemMetaObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Prevent Instantiation of Static Class</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NullObject</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MetaObject <span class="title">forObject</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MetaObject.forObject(object, DEFAULT_OBJECT_FACTORY, DEFAULT_OBJECT_WRAPPER_FACTORY, <span class="keyword">new</span> DefaultReflectorFactory());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中forObject方法只能使用默认MetaObject工厂。<br /><a name="dqzQN"></a></p><h2 id="异常拆包类"><a class="markdownIt-Anchor" href="#异常拆包类"></a> 异常拆包类</h2><p>该类的设计比较有趣，ExcepetionUtil是一个异常工具类，他提供了一个拆包异常的工具方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Throwable <span class="title">unwrapThrowable</span><span class="params">(Throwable wrapped)</span> </span>&#123;</span><br><span class="line">  Throwable unwrapped = wrapped;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (unwrapped <span class="keyword">instanceof</span> InvocationTargetException) &#123;</span><br><span class="line">      <span class="comment">// 拆包获得内部异常</span></span><br><span class="line">      unwrapped = ((InvocationTargetException) unwrapped).getTargetException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unwrapped <span class="keyword">instanceof</span> UndeclaredThrowableException) &#123;</span><br><span class="line">      <span class="comment">// 拆包获得内部异常</span></span><br><span class="line">      unwrapped = ((UndeclaredThrowableException) unwrapped).getUndeclaredThrowable();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> unwrapped;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类将InvocationTargetException和UndeclaredThrowableException两个异常进行拆包来得到真正的异常类。<br />这里InvocationTargetException属于必检异常，UndeclaredThrowableException属于免检异常，他们都不属于Mybatis，来自java.lang.reflect包。<br />反射过程中抛出的异常是无法确定是哪种异常，因此通常都会以Throwable抛出。Throwable又可以分为必检型和免检型，因此就要交给这两个异常分别处理：<br /><a name="jlTRv"></a></p><h3 id="invocationtargetexception"><a class="markdownIt-Anchor" href="#invocationtargetexception"></a> InvocationTargetException</h3><p>反射操作的目标方法中出现异常时都会统一的包装成一个必检异常InvocationTargetException，在InvocationTargetException内部的target保存了原始的异常。<br />内部核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationTargetException</span> <span class="keyword">extends</span> <span class="title">ReflectiveOperationException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4085088731926701167L</span>;</span><br><span class="line">    <span class="keyword">private</span> Throwable target;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvocationTargetException</span><span class="params">(Throwable target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((Throwable)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Throwable <span class="title">getTargetException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="1fPcs"></a></p><h3 id="undeclaredthrowableexception"><a class="markdownIt-Anchor" href="#undeclaredthrowableexception"></a> UndeclaredThrowableException</h3><p>在代码实现的时候，如果子类想要抛出必检异常，那么父类必定要声明过这个必检异常。同样的，如果代理类和被代理类实现了共同的接口，则代理类方法中抛出的必检异常必须是在共同接口声明过的。<br />可是当代理类想抛出异常时，其共同的接口或父类并没有声明该必检异常，那又该如何处理。<br />答案就是将这个必检异常包装成免检异常UndeclaredThrowableException，所以说UndeclaredThrowableException并不代表着真实的免检异常，其内部也可能包裹着必检异常InvocationTargetException。<br /><a name="IU6N3"></a></p><h3 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3><p>经过分析UndeclaredThrowableException和InvocationTargetException后可以了解为什么要在ExceptionUtil中会有一个while(true)，因为只有这样才能把这两个包装类拆包拆出真正的异常。<br /><a name="aBJJp"></a></p><h2 id="参数名解析器"><a class="markdownIt-Anchor" href="#参数名解析器"></a> 参数名解析器</h2><p>ParamNameResolver是一个参数名解析器，用来按顺序列出方法中的虚参，并对实参进行命名标注。<br />其内部参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法输入参数的参数次序表，键为参数次序，值为参数名称或者参数@Param注解的值  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; names;</span><br><span class="line"><span class="comment">// 该方法输入参数中是否含有@Param</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasParamAnnotation;</span><br></pre></td></tr></table></figure><p>其主要方法有ParamNameResolver构造函数和getNamedParams方法，暂不做解析。<br /><a name="Y7kWy"></a></p><h2 id="泛型解析器"><a class="markdownIt-Anchor" href="#泛型解析器"></a> 泛型解析器</h2><p><a name="0O0EW"></a></p><h3 id="解析器作用"><a class="markdownIt-Anchor" href="#解析器作用"></a> 解析器作用</h3><p>TypeParameterResolver是一个泛型参数解析器，下面用一段简单的代码演示其功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用TypeParameterResolver分析User类中getInfo方法输出结果的具体类型</span></span><br><span class="line">            Type type1 = TypeParameterResolver.resolveReturnType(User.class.getMethod(&quot;getInfo&quot;), User.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;User类中getInfo方法的输出结果类型 :\n&quot;</span> + type1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用TypeParameterResolver分析Student类中getInfo方法输出结果的具体类型</span></span><br><span class="line">            Type type2 = TypeParameterResolver.resolveReturnType(User.class.getMethod(&quot;getInfo&quot;), Student.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;Student类中getInfo方法的输出结果类型 :\n&quot;</span> + type2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601454537014-490989df-40ce-40e3-bbc8-0e9ba5ed4f9a.png#align=left&amp;display=inline&amp;height=92&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=183&amp;originWidth=1027&amp;size=193417&amp;status=done&amp;style=none&amp;width=513.5" alt="image.png" /><br />显然，其作用就是帮助Mybatis解析出属性返回值、输入参数的泛型的具体类型。<br /><a name="autgF"></a></p><h3 id="解析器原理分析"><a class="markdownIt-Anchor" href="#解析器原理分析"></a> 解析器原理分析</h3><p>其对外提供了三个方法：</p><ul><li>resolveFieldType：解析属性的泛型</li><li>resolveReturnType：解析方法的返回值泛型</li><li>resolveParamTypes：解析方法输入参数的泛型</li></ul><p>这三个方法实现方法大致相同，先选择一个最难的resolveParamTypes进行解析。<br />其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Type[] resolveParamTypes(Method method, Type srcType) &#123;</span><br><span class="line">  <span class="comment">// 取出方法所有的参数</span></span><br><span class="line">  Type[] paramTypes = method.getGenericParameterTypes();</span><br><span class="line">  <span class="comment">// 定义目标方法的类或接口</span></span><br><span class="line">  Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line">  <span class="comment">// 创建解析结果的集合</span></span><br><span class="line">  Type[] result = <span class="keyword">new</span> Type[paramTypes.length];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paramTypes.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 对输入的每个参数调用resolveType方法解析结果</span></span><br><span class="line">    result[i] = resolveType(paramTypes[i], srcType, declaringClass);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resolveType需要传入三个参数：</p><ul><li>Type type：指要分析的字段或者参数的类型。这里要分析的是getInfo的输出参数，即List<T>。</li><li>Type srcType：指要分析的字段或者参数所属的类。这里要分析的是Student类中的getInfo方法，故所属的类是Student</li><li>Class_&lt;<em>?</em>&gt; _declaringClass：指要分析的字段或者参数的类。getInfo方法在User类中被定义，故这里是User类。</li></ul><p>其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Type <span class="title">resolveType</span><span class="params">(Type type, Type srcType, Class&lt;?&gt; declaringClass)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是类型变量，如Map&lt;K,V&gt;的 K，V</span></span><br><span class="line">  <span class="keyword">if</span> (type <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">    <span class="keyword">return</span> resolveTypeVar((TypeVariable&lt;?&gt;) type, srcType, declaringClass);</span><br><span class="line">  <span class="comment">// 如果是参数化类型，如Collection&lt;String&gt;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">    <span class="keyword">return</span> resolveParameterizedType((ParameterizedType) type, srcType, declaringClass);</span><br><span class="line">  <span class="comment">// 如果是包含ParameterizedType或者TypeVariable元素的列表</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type <span class="keyword">instanceof</span> GenericArrayType) &#123;</span><br><span class="line">    <span class="keyword">return</span> resolveGenericArrayType((GenericArrayType) type, srcType, declaringClass);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，resolveType会根据不同的参数类型调用不同的子方法处理。<br />追随端点来到相应的resolveParameterizedType方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ParameterizedType <span class="title">resolveParameterizedType</span><span class="params">(ParameterizedType parameterizedType, Type srcType, Class&lt;?&gt; declaringClass)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取变量的原始类型，本次为List</span></span><br><span class="line">  Class&lt;?&gt; rawType = (Class&lt;?&gt;) parameterizedType.getRawType();</span><br><span class="line">  <span class="comment">// 获取类型参数，本例只有一个T</span></span><br><span class="line">  Type[] typeArgs = parameterizedType.getActualTypeArguments();</span><br><span class="line">  <span class="comment">// 类型参数的实际类型</span></span><br><span class="line">  Type[] args = <span class="keyword">new</span> Type[typeArgs.length];</span><br><span class="line">  <span class="comment">// 依次处理每一个类型参数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; typeArgs.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 类型参数是类型变量，本次符合</span></span><br><span class="line">    <span class="keyword">if</span> (typeArgs[i] <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">      args[i] = resolveTypeVar((TypeVariable&lt;?&gt;) typeArgs[i], srcType, declaringClass);</span><br><span class="line">    <span class="comment">// 类型参数是参数化类型，例如List&lt;List&lt;T&gt;&gt;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeArgs[i] <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">      args[i] = resolveParameterizedType((ParameterizedType) typeArgs[i], srcType, declaringClass);</span><br><span class="line">    <span class="comment">// 类型参数是通配符泛型，例如&lt;? extends XXX&gt;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeArgs[i] <span class="keyword">instanceof</span> WildcardType) &#123;</span><br><span class="line">      args[i] = resolveWildcardType((WildcardType) typeArgs[i], srcType, declaringClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 类型参数时确定类型，例如 Conllection&lt;String&gt;</span></span><br><span class="line">      args[i] = typeArgs[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ParameterizedTypeImpl(rawType, <span class="keyword">null</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟踪resolveTypeVar：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Type <span class="title">resolveTypeVar</span><span class="params">(TypeVariable&lt;?&gt; typeVar, Type srcType, Class&lt;?&gt; declaringClass)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 解析出来的类型参数结果</span></span><br><span class="line">   Type result;</span><br><span class="line">   Class&lt;?&gt; clazz;</span><br><span class="line">   <span class="comment">// 该类型参数是一个Class，本例符合</span></span><br><span class="line">   <span class="keyword">if</span> (srcType <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">     clazz = (Class&lt;?&gt;) srcType;</span><br><span class="line">   <span class="comment">// 该类型属于参数化类型</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (srcType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">     ParameterizedType parameterizedType = (ParameterizedType) srcType;</span><br><span class="line">     <span class="comment">// 获取参数化类型的原始类型</span></span><br><span class="line">     clazz = (Class&lt;?&gt;) parameterizedType.getRawType();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;The 2nd arg must be Class or ParameterizedType, but was: &quot;</span> + srcType.getClass());</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 变量所属的类和定义变量的类一致。本例中T属于Student定义属于User</span></span><br><span class="line">   <span class="keyword">if</span> (clazz == declaringClass) &#123;</span><br><span class="line">     <span class="comment">// 确定边界上限（边界类型，本次Number）</span></span><br><span class="line">     Type[] bounds = typeVar.getBounds();</span><br><span class="line">     <span class="keyword">if</span> (bounds.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> bounds[<span class="number">0</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> Object.class;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 获取所属类的父类</span></span><br><span class="line">   Type superclass = clazz.getGenericSuperclass();</span><br><span class="line">   <span class="comment">// 扫描父类，确定边界（边界类型，本次Number）</span></span><br><span class="line">   result = scanSuperTypes(typeVar, srcType, declaringClass, clazz, superclass);</span><br><span class="line">   <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 获取变量所属类的接口</span></span><br><span class="line">   Type[] superInterfaces = clazz.getGenericInterfaces();</span><br><span class="line">   <span class="comment">// 遍历父接口确定边界</span></span><br><span class="line">   <span class="keyword">for</span> (Type superInterface : superInterfaces) &#123;</span><br><span class="line">     result = scanSuperTypes(typeVar, srcType, declaringClass, clazz, superInterface);</span><br><span class="line">     <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> Object.class;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>此外还有resolveTypeVar和resolveGenericArrayType方法。<br />方法就是resolveParameterizedType的简化版。<br />resolveGenericArrayType源码解析如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Type <span class="title">resolveGenericArrayType</span><span class="params">(GenericArrayType genericArrayType, Type srcType, Class&lt;?&gt; declaringClass)</span> </span>&#123;</span><br><span class="line">  Type componentType = genericArrayType.getGenericComponentType();</span><br><span class="line">  Type resolvedComponentType = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 元素类型是类的变量，例如T[]</span></span><br><span class="line">  <span class="keyword">if</span> (componentType <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">    resolvedComponentType = resolveTypeVar((TypeVariable&lt;?&gt;) componentType, srcType, declaringClass);</span><br><span class="line">  <span class="comment">// 元素类型是泛型列表，例如T[][]</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (componentType <span class="keyword">instanceof</span> GenericArrayType) &#123;</span><br><span class="line">    resolvedComponentType = resolveGenericArrayType((GenericArrayType) componentType, srcType, declaringClass);</span><br><span class="line">  <span class="comment">// 元素类型是参数化类型，例如Collection&lt;T&gt;[]</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (componentType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">    resolvedComponentType = resolveParameterizedType((ParameterizedType) componentType, srcType, declaringClass);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是Class类</span></span><br><span class="line">  <span class="keyword">if</span> (resolvedComponentType <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">    <span class="keyword">return</span> Array.newInstance((Class&lt;?&gt;) resolvedComponentType, <span class="number">0</span>).getClass();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GenericArrayTypeImpl(resolvedComponentType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;reflection包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#reflection包&quot;&gt;&lt;/a&gt; reflection包&lt;/h1&gt;
&lt;p&gt;&lt;a name=&quot;vA04i&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a cla</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="基础功能包" scheme="https://jie-blog.icu/categories/mybatis/%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>exceptions包</title>
    <link href="https://jie-blog.icu/posts/mybatis-exceptions/"/>
    <id>https://jie-blog.icu/posts/mybatis-exceptions/</id>
    <published>2020-11-04T03:43:48.000Z</published>
    <updated>2020-11-04T03:53:03.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="exceptions包"><a class="markdownIt-Anchor" href="#exceptions包"></a> exceptions包</h1><p>exceptions为Mybatis定义了绝大多数异常类的父类，同时也提供了异常类的生产工厂。<br /><a name="c7D3m"></a></p><h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1><p>了解excepetions包之前首先要对如下几个内容有所了解。<br /><a name="rAvLz"></a></p><h2 id="java的异常"><a class="markdownIt-Anchor" href="#java的异常"></a> Java的异常</h2><p>Java的异常类都是以Throwable为父类，Throwable又派生出了Error和Exception两大子类：</p><ul><li>Error及其子类代表着JVM异常。这类异常发生时无法通过程序来矫正，最可靠的方法就是停止JVM的运行。因此这类异常属于免检异常。</li><li>Excepetion及其子类代表程序运行中发生了意料之外的事情，这些异常可以被Java的异常处理机制所处理。Exception又可以分为两类：<ul><li>RuntimeException及其子类：这类异常是程序设计的错误，通过修复程序才可以避免，如数组越界、数值异常等。因此这类异常也属于免检异常。</li><li>非RuntimeException及其子类：这类异常通常由外部因素所导致的，是不可预知和避免的，如IO异常、类型寻找异常等。因此，这类异常属于必检异常。</li></ul></li></ul><p>注：免检异常即不需要对这类异常做强制检查。必检异常即在表写程序时要用try、catch进行包围的。<br /><a name="LRUTt"></a></p><h2 id="序列化和反序列化"><a class="markdownIt-Anchor" href="#序列化和反序列化"></a> 序列化和反序列化</h2><p>序列化是把对象转换为字节序列的过程。反序列化是把字节序列恢复成对象的过程。<br />对象序列化通常有两个目的：</p><ul><li>将对象转换为字节后保存到存储介质中，即为了对象的持久化。</li><li>将对象转换为字节后在网络上传输，即为了传输对象。</li></ul><p>在实现序列化时通常都是实现Serializabale接口即可，实现即表明这个类的对象是可序列化的，而不需要任何额外操作。（当然，还有其他方法）<br />在反序列化时，涉及到了一个serialVersionUID的字段，该字段叫做序列化版本控制字段。如果对象自己序列中的该字段与当前类不同，则反序列化失败且抛出版本不一致异常（InvaidClassException），反之则成功。<br />注意：如果没有显式的定义serialVersionUID属性，系统则会自动的生成一个serialVersionUID，当类的类名、类及属性修饰符、接口及接口顺序、属性、构造函数等相关内容任何一项发生改变serialVersionUID都会发生变化。<br />因此，通常手动定义一个serialVersionUID，这样便可以：</p><ul><li>希望版本间兼容时保持serialVersionUID不变。</li><li>希望不兼容时serialVersionUID改变。<br /><a name="p7SfU"></a></li></ul><h1 id="exception类"><a class="markdownIt-Anchor" href="#exception类"></a> Exception类</h1><p>在exceptions包中有三个异常类和一个工厂类：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601360526991-3191f2b9-ec1b-450f-95b3-d7f201fd0994.png#align=left&amp;display=inline&amp;height=62&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=123&amp;originWidth=331&amp;size=19204&amp;status=done&amp;style=none&amp;width=165.5" alt="image.png" /><br />但是实际的Mybatis的异常图谱远不止这三个异常类，如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601360626312-37fab0c6-dc6a-4192-ab1e-902b34975900.png#align=left&amp;display=inline&amp;height=266&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=531&amp;originWidth=1173&amp;size=926070&amp;status=done&amp;style=none&amp;width=586.5" alt="image.png" /><br />注意：IbatisException是PersistenceException的父类，而其他的异常类却都继承自PersistenceEception，于是IbatisException被架空了，因此IbatisException类上有了一个大大的@Deprecated。<br />此外，在所有Exception的类中的定义都十分简单，基本上都是由一个serialVersionUID字段和四种构造方法组成的，因此也不做过多分析了。<br /><a name="AWz9d"></a></p><h1 id="exceptionfactory类"><a class="markdownIt-Anchor" href="#exceptionfactory类"></a> ExceptionFactory类</h1><p>该类是负责生产Exception的工厂，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ExceptionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Prevent Instantiation</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RuntimeException <span class="title">wrapException</span><span class="params">(String message, Exception e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PersistenceException(ErrorContext.instance().message(message).cause(e).toString(), e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wrapException方法负责执行主要的逻辑，ErrorContext将在后续进行分析。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;exceptions包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#exceptions包&quot;&gt;&lt;/a&gt; exceptions包&lt;/h1&gt;
&lt;p&gt;exceptions为Mybatis定义了绝大多数异常类的父类，同时也提供了异常类的生产工</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    <category term="基础功能包" scheme="https://jie-blog.icu/categories/mybatis/%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%8C%85/"/>
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis之基础概念</title>
    <link href="https://jie-blog.icu/posts/mybatis-title/"/>
    <id>https://jie-blog.icu/posts/mybatis-title/</id>
    <published>2020-11-04T03:41:14.000Z</published>
    <updated>2020-11-04T03:53:21.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis之基础概念"><a class="markdownIt-Anchor" href="#mybatis之基础概念"></a> Mybatis之基础概念</h1><p><a name="GPKvu"></a></p><h1 id="orm框架的引入"><a class="markdownIt-Anchor" href="#orm框架的引入"></a> ORM框架的引入</h1><p>传统的JDBC的代码是复杂且冗余的，因此就引入了ORM的思想来简化面向对象的开发和实现关系型数据库的持久化方案。其中，Mybatis就是一个优秀的ORM框架。<br />ORM多是将Java对象和数据库表直接关联起来（类似于Spring Data JPA），而Mybatis则是将Java方法与SQL语句关联起来，除此之外，Mybatis还提供了一种映射机制，将SQL语句的参数或结果与对象关联起来。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601097939314-71d8e6d3-5853-4df5-8cdb-eae14f066349.png#align=left&amp;display=inline&amp;height=156&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=193&amp;originWidth=648&amp;size=193912&amp;status=done&amp;style=none&amp;width=524" alt="image.png" /><br />如图，在调用方法时可以给方法传递对象作为SQL语句的参数，而SQL语句的执行结果也会被映射成对象后返回。这样，读写过程就成了一个传统的面向对象的过程。<br /><a name="XHFJx"></a></p><h2 id="mybatis的功能"><a class="markdownIt-Anchor" href="#mybatis的功能"></a> Mybatis的功能</h2><p>经过以前的项目积累，现在结合ORM总结一下Mybatis的核心功能：</p><ul><li>将包含if等标签的复杂数据库操作语句解析成纯粹的SQL语句。</li><li>将数据库操作节点和映射接口中的抽象方法进行绑定，在抽象方法被调用时执行数据库操作。</li><li>将输入参数对象转化为数据库操作语句的参数。</li><li>将数据库操作语句的返回结果转换为对象。<br /><a name="9KVjd"></a></li></ul><h1 id="使用mybatis"><a class="markdownIt-Anchor" href="#使用mybatis"></a> 使用Mybatis</h1><p>配置Mybatis有三种方式：</p><ol><li>纯代码配置：配置信息和业务耦合在一起，很少使用。</li><li>基于XML配置：经常使用。</li><li>外部框架配置：类似于Spring、Spring Boot这类框架提供了与Mybatis对接的相关组件，可以在其配置文件中直接配置Mybatis。切记：接口方法上一定要加上@Mapper注解。<br /><a name="ofHqy"></a></li></ol><h2 id="配置参数"><a class="markdownIt-Anchor" href="#配置参数"></a> 配置参数</h2><p>Mybatis的配置文件通常会被命名为mybatis-config.xml，其根节点为configuration，根节点包含的一级节点如下：</p><ul><li>properties：属性信息，相当于Mybatis的局部变量。</li><li>settings：设置信息，通过这个来对Mybatis的功能进行调整。</li><li>typeAliases：类型别名，在这里可以为类型设置一些简短的名字。</li><li>typeHandlers：类型处理器，在这里可以为不同的类型设置相应的处理器。</li><li>objectFactory：对象工厂，在这里可以指定Mybatis创建新对象时使用的工厂。</li><li>objectWrapperFactory：对象包装工厂，在这里可以指定Mybatis使用的对象包装器工厂。</li><li>reflectorFacotry：反射器工厂，在这里可以设置反射器工厂。</li><li>plugins：插件，在这里可以为Mybatis配置插件，从而修改或扩展Mybatis的行为。</li><li>environments：环境，这里可以配置Mybatis运行的环境信息。</li><li>databaseIdProvider：数据库编号，在这里可以为不同的数据库配置不同的编号，这样可以对不同类型的数据库设置不同数据库操作语句。</li><li>mappers：映射文件，在这里可以设置映射文件或映射接口文件地址。</li></ul><p>注意，配置文件的节点顺序必须按照上述所示！<br /><a name="Jg2b3"></a></p><h2 id="映射文件"><a class="markdownIt-Anchor" href="#映射文件"></a> 映射文件</h2><p>映射文件的根节点为mapper，在mapper节点下可以包含的节点及其含义如下：</p><ul><li>cache：缓存，通过它可以对命名空间进行缓存配置。</li><li>cache-ref：缓存引用，通过它可以引用其他命名空间的缓存作为当前命名空间的缓存。</li><li>resultMap：结果映射，通过它来配置如何将SQL查询结果映射为对象。</li><li>parameterMap：参数映射，通过它可以配置如何将参数映射为SQL参数。注意：该节点已被废除，建议直接使用内联参数。</li><li>sql：SQL语句片段，通过它来设置可以被复用的语句片段。</li><li>insert：插入语句。</li><li>update：更新语句。</li><li>delete：删除语句。</li><li>select：查询语句。<br /><a name="eC5C7"></a></li></ul><h2 id="映射接口文件"><a class="markdownIt-Anchor" href="#映射接口文件"></a> 映射接口文件</h2><p>映射接口文件中可以定义一些抽象方法，这些抽象方法有两种方式可以实现映射且执行SQL语句：</p><ul><li>抽象方法与对应的映射文件的数据库操作节点相对应。</li><li>通过注释声明自身的数据库操作语句。</li></ul><p>其中，当整个接口文件中均为类抽象方法时，该接口文件可以没有对应的映射文件。<br /><a name="3IiaQ"></a></p><h1 id="mybatis运行过程初探"><a class="markdownIt-Anchor" href="#mybatis运行过程初探"></a> Mybatis运行过程初探</h1><p>现有一段可以运行的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一阶段：MyBatis的初始化阶段</span></span><br><span class="line">        String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="comment">// 得到配置文件的输入流</span></span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到SqlSessionFactory</span></span><br><span class="line">        SqlSessionFactory sqlSessionFactory =</span><br><span class="line">                <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二阶段：数据读写阶段</span></span><br><span class="line">        <span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">            <span class="comment">// 找到接口对应的实现</span></span><br><span class="line">            UserMapper userMapper = session.getMapper(UserMapper.class);</span><br><span class="line">            <span class="comment">// 组建查询参数</span></span><br><span class="line">            User userParam = <span class="keyword">new</span> User();</span><br><span class="line">            userParam.setSchoolName(<span class="string">&quot;Sunny School&quot;</span>);</span><br><span class="line">            <span class="comment">// 调用接口展开数据库操作</span></span><br><span class="line">            List&lt;User&gt; userList =  userMapper.queryUserBySchoolName(userParam);</span><br><span class="line">            <span class="comment">// 打印查询结果</span></span><br><span class="line">            <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;name : &quot;</span> + user.getName() + <span class="string">&quot; ;  email : &quot;</span> + user.getEmail());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，其可以分为两个阶段：</p><ol><li>Mybatis初始化阶段，在这个阶段完成Mybatis环境的准备工作，这个工作只在Mybatis的启动时运行一次。</li><li>数据读写阶段，该阶段由数据读写操作触发，将根据要求完成具体的增删改查等数据库操作。</li></ol><p>以下将按照这个两个阶段划分逐步探究。<br /><a name="w9934"></a></p><h2 id="初始化阶段"><a class="markdownIt-Anchor" href="#初始化阶段"></a> 初始化阶段</h2><p><a name="oVDYs"></a></p><h3 id="静态代码块执行"><a class="markdownIt-Anchor" href="#静态代码块执行"></a> 静态代码块执行</h3><p>既然是详细分析，那就要从第一行来看：<br /><code>public static void main(String[] args)</code><br />注意关键字static，这个关键字把整个方法声明成了一个静态代码块。<br />类的初始化就是把Class文件加载到JVM的过程，这一过程会经过如图所示的几个步骤：<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/485026/1601289600816-a46f78e2-458b-40b6-be75-1e39f593addd.jpeg?x-oss-process=image/auto-orient,1#align=left&amp;display=inline&amp;height=289&amp;margin=%5Bobject%20Object%5D&amp;name=QQ%E5%9B%BE%E7%89%8720200928183903.jpg&amp;originHeight=289&amp;originWidth=1515&amp;size=56487&amp;status=done&amp;style=none&amp;width=1515" alt="QQ图片20200928183903.jpg" /><br />静态代码块会在类加载过程中的初始化阶段执行，且只执行一次，一个类可以有多个静态代码块，他们会按照顺序执行。<br /><a name="o1krW"></a></p><h3 id="获取inputstream"><a class="markdownIt-Anchor" href="#获取inputstream"></a> 获取InputStream</h3><p>进入静态代码块后即将执行的语句就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="comment">// 得到配置文件的输入流</span></span><br><span class="line">InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>追随getResourceAsStream方法得到源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InputStream <span class="title">getResourceAsStream</span><span class="params">(String resource, ClassLoader[] classLoader)</span> </span>&#123;</span><br><span class="line">    ClassLoader[] var3 = classLoader;</span><br><span class="line">    <span class="keyword">int</span> var4 = classLoader.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">        ClassLoader cl = var3[var5];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != cl) &#123;</span><br><span class="line">            InputStream returnValue = cl.getResourceAsStream(resource);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == returnValue) &#123;</span><br><span class="line">                returnValue = cl.getResourceAsStream(<span class="string">&quot;/&quot;</span> + resource);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != returnValue) &#123;</span><br><span class="line">                <span class="keyword">return</span> returnValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里除了资源路径名称resource以外，还有一组额外的参数ClassLoader。ClassLoader叫做类加载器，是负责加载类的对象。一般情况下，类加载器会将给定类的二进制名称转换为文件名，然后从文件系统中读取该名称的类文件。<br />如代码所示，如果找不到会添加上“/”继续查找，成功后会将指定文件的输入流返回。<br /><a name="Iu3ad"></a></p><h3 id="配置信息读取"><a class="markdownIt-Anchor" href="#配置信息读取"></a> 配置信息读取</h3><p>获取完输入流就要执行以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory =</span><br><span class="line">              <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure><p>这一步首先创建了SqlSessionFactory的对象，然后调用了build方法。<br />追随build方法得到以下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">    SqlSessionFactory var5;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">        var5 = <span class="keyword">this</span>.build(parser.parse());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var14) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error building SqlSession.&quot;</span>, var14);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var13) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最核心的代码是第4、5行。<br />这两句代码实现了如下两个步骤：</p><ul><li>生成了一个XMLConfigBuilder对象，并调用器parse方法返回一个Configuration对象。</li><li>调用SqlSessionFactoryBuilder自身的build方法并返回一个SqlSessionFactory对象。</li></ul><p>这里再猜拆分这两个步骤进行分析。<br /><a name="jLB4S"></a></p><h4 id="parse"><a class="markdownIt-Anchor" href="#parse"></a> parse</h4><p>追随其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parsed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Each XMLConfigBuilder can only be used once.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.parsed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.parseConfiguration(<span class="keyword">this</span>.parser.evalNode(<span class="string">&quot;/configuration&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.configuration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里出现了“/configuration”关键字，其中“configuration”为mybatis-config.xml的根节点，因此这里是解析整个配置文件的入口，parseConfiguration是解析配置文件的方法，将返回的结果填入到configuration中并返回。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.propertiesElement(root.evalNode(<span class="string">&quot;properties&quot;</span>));</span><br><span class="line">        Properties settings = <span class="keyword">this</span>.settingsAsProperties(root.evalNode(<span class="string">&quot;settings&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.loadCustomVfs(settings);</span><br><span class="line">        <span class="keyword">this</span>.loadCustomLogImpl(settings);</span><br><span class="line">        <span class="keyword">this</span>.typeAliasesElement(root.evalNode(<span class="string">&quot;typeAliases&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.pluginElement(root.evalNode(<span class="string">&quot;plugins&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.objectFactoryElement(root.evalNode(<span class="string">&quot;objectFactory&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.objectWrapperFactoryElement(root.evalNode(<span class="string">&quot;objectWrapperFactory&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.reflectorFactoryElement(root.evalNode(<span class="string">&quot;reflectorFactory&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.settingsElement(settings);</span><br><span class="line">        <span class="keyword">this</span>.environmentsElement(root.evalNode(<span class="string">&quot;environments&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.databaseIdProviderElement(root.evalNode(<span class="string">&quot;databaseIdProvider&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.typeHandlerElement(root.evalNode(<span class="string">&quot;typeHandlers&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.mapperElement(root.evalNode(<span class="string">&quot;mappers&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + var3, var3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="p4gh3"></a></p><h4 id="build"><a class="markdownIt-Anchor" href="#build"></a> build</h4><p>build方法接受了Configuration参数并返回了一个SqlSessionFacory的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：DefaultSqlSessionFactory 是SqlSessionFacory的实现类。<br /><a name="YNU7q"></a></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>总结初始化阶段，其主要完成了如下几个工作：</p><ul><li>根据配置文件的位置获取相应的输入流。</li><li>从配置文件的根节点开始，逐层解析配置文件，也包括映射文件，解析过程中不断将解析结果放入configuration中。</li><li>将configuration对象传入DefaultSqlSessionFactory并返回，获取一个SqlSessionFactory对象。<br /><a name="3jOO2"></a></li></ul><h2 id="数据库读写阶段"><a class="markdownIt-Anchor" href="#数据库读写阶段"></a> 数据库读写阶段</h2><p><a name="nB9L4"></a></p><h3 id="获得sqlsession"><a class="markdownIt-Anchor" href="#获得sqlsession"></a> 获得SqlSession</h3><p>结束初始化工作后，执行读写操作的第一步就是获取SqlSession对象，其语句如下：<br /><code>SqlSession session = sqlSessionFactory.openSession()</code><br />追如openSession方法得到源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    DefaultSqlSession var8;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Environment environment = <span class="keyword">this</span>.configuration.getEnvironment();</span><br><span class="line">        TransactionFactory transactionFactory = <span class="keyword">this</span>.getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">        tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">        Executor executor = <span class="keyword">this</span>.configuration.newExecutor(tx, execType);</span><br><span class="line">        var8 = <span class="keyword">new</span> DefaultSqlSession(<span class="keyword">this</span>.configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var12) &#123;</span><br><span class="line">        <span class="keyword">this</span>.closeTransaction(tx);</span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error opening session.  Cause: &quot;</span> + var12, var12);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> var8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中生成了一系列对象：Environment、TransactionFactory、Transaction、Executor，并将他们传递给DefaultSqlSession的构造方法生成DefaultSqlSession对象并返回。在DefaultSqlSession类中可以看到他提供的查询、增加、更新、删除、回滚、提交等方法。<br /><a name="Ig561"></a></p><h3 id="映射接口和映射文件绑定"><a class="markdownIt-Anchor" href="#映射接口和映射文件绑定"></a> 映射接口和映射文件绑定</h3><p>获取到了SqlSession的对象后，即将执行：<br /><code>UserMapper userMapper = session.getMapper(UserMapper.class);</code><br />进入到getMapper方法，得到源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory)<span class="keyword">this</span>.knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is not known to the MapperRegistry.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + var5, var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法通过映射接口信息从所有已经解析的映射文件中找到了对应的映射文件，然后根据这个映射文件组建并返回了接口的一个实现对象。这个实现对象通过mapperProxyFactory.newInstance(sqlSession)的语句返回，追随newInstance方法得到源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy(sqlSession, <span class="keyword">this</span>.mapperInterface, <span class="keyword">this</span>.methodCache);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，返回的是一个动态代理对象。<br /><a name="5gbkD"></a></p><h3 id="映射接口注入实现"><a class="markdownIt-Anchor" href="#映射接口注入实现"></a> 映射接口注入实现</h3><p>获得userMapper的动态代理对象后，就要执行下列语句：<br /><code>List&lt;User&gt; userList = userMapper.queryUserBySchoolName(userParam);</code><br />在这里，要真正的执行SQL语句。<br />既然调用动态代理对象的方法，那么就要回到MapperProxy的invoke方法中查看接口方法调用过程。（被代理对象的方法会被代理对象的方法拦截）<br />追溯invoke方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (method.isDefault()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.invokeDefaultMethod(proxy, method, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(var5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MapperMethod mapperMethod = <span class="keyword">this</span>.cachedMapperMethod(method);</span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(<span class="keyword">this</span>.sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据调试追踪到execute方法，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    Object param;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="keyword">this</span>.command.getType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> INSERT:</span><br><span class="line">        param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = <span class="keyword">this</span>.rowCountResult(sqlSession.insert(<span class="keyword">this</span>.command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> UPDATE:</span><br><span class="line">        param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = <span class="keyword">this</span>.rowCountResult(sqlSession.update(<span class="keyword">this</span>.command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DELETE:</span><br><span class="line">        param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = <span class="keyword">this</span>.rowCountResult(sqlSession.delete(<span class="keyword">this</span>.command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SELECT:</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.method.returnsVoid() &amp;&amp; <span class="keyword">this</span>.method.hasResultHandler()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.executeWithResultHandler(sqlSession, args);</span><br><span class="line">            result = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.method.returnsMany()) &#123;</span><br><span class="line">            result = <span class="keyword">this</span>.executeForMany(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.method.returnsMap()) &#123;</span><br><span class="line">            result = <span class="keyword">this</span>.executeForMap(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.method.returnsCursor()) &#123;</span><br><span class="line">            result = <span class="keyword">this</span>.executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</span><br><span class="line">            result = sqlSession.selectOne(<span class="keyword">this</span>.command.getName(), param);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.method.returnsOptional() &amp;&amp; (result == <span class="keyword">null</span> || !<span class="keyword">this</span>.method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">                result = Optional.ofNullable(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FLUSH:</span><br><span class="line">        result = sqlSession.flushStatements();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Unknown execution method for: &quot;</span> + <span class="keyword">this</span>.command.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.method.getReturnType().isPrimitive() &amp;&amp; !<span class="keyword">this</span>.method.returnsVoid()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Mapper method &#x27;&quot;</span> + <span class="keyword">this</span>.command.getName() + <span class="string">&quot; attempted to return null from a method with a primitive return type (&quot;</span> + <span class="keyword">this</span>.method.getReturnType() + <span class="string">&quot;).&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里根据不同的处理方法选择不同的语句，这里以select为例进入到了SELECT的语句块中，根据返回类型，这里将要执行<code>result = this.executeForMany(sqlSession, args);</code>方法，追入得到源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">executeForMany</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</span><br><span class="line">    List result;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.method.hasRowBounds()) &#123;</span><br><span class="line">        RowBounds rowBounds = <span class="keyword">this</span>.method.extractRowBounds(args);</span><br><span class="line">        result = sqlSession.selectList(<span class="keyword">this</span>.command.getName(), param, rowBounds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = sqlSession.selectList(<span class="keyword">this</span>.command.getName(), param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.method.getReturnType().isAssignableFrom(result.getClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.method.getReturnType().isArray() ? <span class="keyword">this</span>.convertToArray(result) : <span class="keyword">this</span>.convertToDeclaredCollection(sqlSession.getConfiguration(), result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里实现了映射接口注入实现的过程，对接口的抽象方法的调用转变成了数据库的调用过程。<br /><a name="m69km"></a></p><h3 id="sql查找的实现"><a class="markdownIt-Anchor" href="#sql查找的实现"></a> SQL查找的实现</h3><p>以查找为例，这里深入探究其执行过程。<br />根据端点追寻其执行到<code>result = sqlSession.selectList(this.command.getName(), param);</code>语句，获得selectList源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">    List var5;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MappedStatement ms = <span class="keyword">this</span>.configuration.getMappedStatement(statement);</span><br><span class="line">        var5 = <span class="keyword">this</span>.executor.query(ms, <span class="keyword">this</span>.wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error querying database.  Cause: &quot;</span> + var9, var9);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的MappedStatement对象对应了设置的一个数据库操作节点，其主要定义了数据库操作语句、输入/输出参数等操作信息。这里通过statement（SQL语句）将要执行的MappedStatement对象从configuration中获取出来。<br />紧接着将要执行query语句来实现具体的查询操作。<br />注意，这里有两个query的实现类：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601294695203-d739b09d-daca-4534-ba37-f63f6cb69f4d.png#align=left&amp;display=inline&amp;height=56&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=112&amp;originWidth=667&amp;size=15746&amp;status=done&amp;style=none&amp;width=333.5" alt="image.png" /><br />根据调试，先进入到了CachingExecutor的实现方法中。<br />获得实现方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">    CacheKey key = <span class="keyword">this</span>.createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中BoundSql负责将复杂的标签类似于if、where转换为普通的SQL语句。CacheKey是本次查询操作计算出来的缓存键。<br />继续跟踪query语句得到源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.flushCacheIfRequired(ms);</span><br><span class="line">        <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.ensureNoOutParams(ms, boundSql);</span><br><span class="line">            List&lt;E&gt; list = (List)<span class="keyword">this</span>.tcm.getObject(cache, key);</span><br><span class="line">            <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">                list = <span class="keyword">this</span>.delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">                <span class="keyword">this</span>.tcm.putObject(cache, key, list);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里先判断缓存是否命中，如果命中则直接从缓存中拿取数据结果。否则，将调用delegate的query语句。<br />这里假设没有命中，继续进行调试。发现现在进入到了BaseExecutor的query实现方法中。<br />获得其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.closed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.clearLocalCache();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List list;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ++<span class="keyword">this</span>.queryStack;</span><br><span class="line">            list = resultHandler == <span class="keyword">null</span> ? (List)<span class="keyword">this</span>.localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                list = <span class="keyword">this</span>.queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            --<span class="keyword">this</span>.queryStack;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">            Iterator var8 = <span class="keyword">this</span>.deferredLoads.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var8.hasNext()) &#123;</span><br><span class="line">                BaseExecutor.DeferredLoad deferredLoad = (BaseExecutor.DeferredLoad)var8.next();</span><br><span class="line">                deferredLoad.load();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.deferredLoads.clear();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">                <span class="keyword">this</span>.clearLocalCache();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里逻辑比较复杂，根据调试执行到语句：<code>list = this.queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</code>中，获得源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.localCache.putObject(key, ExecutionPlaceholder.EXECUTION_PLACEHOLDER);</span><br><span class="line"></span><br><span class="line">    List list;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        list = <span class="keyword">this</span>.doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.localCache.removeObject(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.localCache.putObject(key, list);</span><br><span class="line">    <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">        <span class="keyword">this</span>.localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，这里先在缓存中放入了一个占位符，然后执行了doQuery方法查询到结果后将缓存中的数据替换为了真的结果集。<br />根据调试获得doQuery源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    List var9;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Configuration configuration = ms.getConfiguration();</span><br><span class="line">        StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>.wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        stmt = <span class="keyword">this</span>.prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">        var9 = handler.query(stmt, resultHandler);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法生成了Statement的对象stmt，这个Statement并非Mybatis的类，而是java.sql的类，Statement能执行静态的SQL语句并返回结果。继续追踪query语句得到源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    PreparedStatement ps = (PreparedStatement)statement;</span><br><span class="line">    ps.execute();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将Statement转换成了PreparedStatement类，然后执行了execute方法来进行数据库查询。这里的操作与JDBC操作一致。查询过后将PreparedStatement的对象传入到handleResultSets方法中从而完成了整个查找的过程。<br />此时，数据库中已经出现了SQL的查询语句：<br /><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601296041530-eafc98c9-32f5-4611-9148-ef2eac2db67b.png#align=left&amp;display=inline&amp;height=64&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=128&amp;originWidth=1202&amp;size=155994&amp;status=done&amp;style=none&amp;width=601" alt="image.png" /></strong><br /><a name="f7Y3A"></a></p><h4 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h4><p>查询过程涉及的步骤较多，这里进行流程的梳理：</p><ul><li>查询前先查询Mybatis的缓存，如果缓存未命中的话才进行查询，并且将查询后将结果存入到Mybatis的缓存中。</li><li>SQL语句经过了层层转化，依次经过了MappedStatement对象、Statement对象、PreparedStatement对象以后再执行基本的JDBC的操作。</li><li>查询后将结果交给ResultHandler对象处理。<br /><a name="8wBe0"></a></li></ul><h3 id="结果集的处理"><a class="markdownIt-Anchor" href="#结果集的处理"></a> 结果集的处理</h3><p>继续追踪<code>return this.resultSetHandler.handleResultSets(ps);</code>语句得到源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().activity(<span class="string">&quot;handling results&quot;</span>).object(<span class="keyword">this</span>.mappedStatement.getId());</span><br><span class="line">    List&lt;Object&gt; multipleResults = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">int</span> resultSetCount = <span class="number">0</span>;</span><br><span class="line">    ResultSetWrapper rsw = <span class="keyword">this</span>.getFirstResultSet(stmt);</span><br><span class="line">    List&lt;ResultMap&gt; resultMaps = <span class="keyword">this</span>.mappedStatement.getResultMaps();</span><br><span class="line">    <span class="keyword">int</span> resultMapCount = resultMaps.size();</span><br><span class="line">    <span class="keyword">this</span>.validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(rsw != <span class="keyword">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">        ResultMap resultMap = (ResultMap)resultMaps.get(resultSetCount);</span><br><span class="line">        <span class="keyword">this</span>.handleResultSet(rsw, resultMap, multipleResults, (ResultMapping)<span class="keyword">null</span>);</span><br><span class="line">        rsw = <span class="keyword">this</span>.getNextResultSet(stmt);</span><br><span class="line">        <span class="keyword">this</span>.cleanUpAfterHandlingResultSet();</span><br><span class="line">        ++resultSetCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] resultSets = <span class="keyword">this</span>.mappedStatement.getResultSets();</span><br><span class="line">    <span class="keyword">if</span> (resultSets != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(rsw != <span class="keyword">null</span> &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</span><br><span class="line">            ResultMapping parentMapping = (ResultMapping)<span class="keyword">this</span>.nextResultMaps.get(resultSets[resultSetCount]);</span><br><span class="line">            <span class="keyword">if</span> (parentMapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">                String nestedResultMapId = parentMapping.getNestedResultMapId();</span><br><span class="line">                ResultMap resultMap = <span class="keyword">this</span>.configuration.getResultMap(nestedResultMapId);</span><br><span class="line">                <span class="keyword">this</span>.handleResultSet(rsw, resultMap, (List)<span class="keyword">null</span>, parentMapping);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rsw = <span class="keyword">this</span>.getNextResultSet(stmt);</span><br><span class="line">            <span class="keyword">this</span>.cleanUpAfterHandlingResultSet();</span><br><span class="line">            ++resultSetCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.collapseSingleResultList(multipleResults);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法将查询出来的结果遍历后放入到multipleResults中并返回，其中multipleResults就是最终想要拿到的List<User>。<br />根据调试绘制出调用链路图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601296641320-b0592228-f64c-47e9-beff-88d78c777d92.png#align=left&amp;display=inline&amp;height=392&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=784&amp;originWidth=1166&amp;size=997528&amp;status=done&amp;style=none&amp;width=583" alt="image.png" /><br />其中三个重要方法如下：</p><ul><li>createResultObject：该方法创建了输出结果对象，即User。</li><li>applyAutomaticMappings：在自动属性映射功能开启情况下，将数据赋值给输出结果对象。</li><li>applyPropertyMappings：按照用户的映射设置，将数据赋值给输出结果对象。<br /><a name="zqWeY"></a></li></ul><h2 id="运行过程总结"><a class="markdownIt-Anchor" href="#运行过程总结"></a> 运行过程总结</h2><p>梳理完执行流程，这里进行一下Mybatis工作概述：</p><ul><li>建立数据库的SqlSession。</li><li>查找当前映射接口中的抽象方法对应数据库操作节点，根据节点生成接口代理类对象（实现）。</li><li>接口的实现拦截对映射接口中抽象方法的调用，并将其转换成数据查询操作。</li><li>对数据库操作节点中的数据库操作语句进行多次处理，最终得到标准的SQL语句。</li><li>尝试从缓存查找结果，如果找到则返回，找不到则继续从数据库中查找。</li><li>从数据库中查询结果。</li><li>处理结果集<ul><li>建立输出对象</li><li>根据输出结果对输出对象赋值。</li></ul></li><li>在缓存中存储查询结果。</li><li>返回查询结果。</li></ul><p>显然，数据库操作是相当耗时的，因此开发中要尽量减少对数据库的操作。<br /><a name="LcX17"></a></p><h1 id="mybatis的源码结构概述"><a class="markdownIt-Anchor" href="#mybatis的源码结构概述"></a> Mybatis的源码结构概述</h1><p>在开始分析Mybatis包之前，首先要知道Mybatis的包如何划分。其划分标准如下：</p><ul><li>按照类型划分，例如将所有接口类型放入一个包。这种分类方式从类型上看更为清晰，但是会导致一个功能的多个类分散到不同的包中，不利于模块化开发。</li><li>按照功能方式划分，例如将所有与加/解密有关的类放入一个包。这种分类方式下，同一个功能的类内聚性高，便于模块化开发，但是也会导致同一包内的类型混乱。</li></ul><p>Mybatis按照类型划分出了exceptions、annotations等包，按照功能划分出了基础功能包、配置解析包、核心操作包。<br />Mybatis包结构如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601297882858-2a28fea0-a867-4e7d-8b48-94f486a80e14.png#align=left&amp;display=inline&amp;height=286&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=572&amp;originWidth=244&amp;size=54153&amp;status=done&amp;style=none&amp;width=122" alt="image.png" /><br />按照包功能划分三大类：</p><ul><li>基础功能包：提供外围基础功能，如文件读取、反射等。该类包的特点就是相对独立，与业务耦合小。</li><li>配置解析包：完成配置解析、存储等工作。该类包主要在系统初始化阶段运行。</li><li>核心操作包：这些包完成数据库的操作。在工作过程中，其可能会依赖基础功能包提供的基础功能和配置解析包提供的配置信息。该类包一般在数据库操作阶段运行。</li></ul><p>划分如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601298118046-f9f00e1d-3b4a-4516-a5b2-9f60c606ab9b.png#align=left&amp;display=inline&amp;height=334&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=667&amp;originWidth=248&amp;size=187071&amp;status=done&amp;style=none&amp;width=124" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601298179631-2fe38c26-eeb7-432b-b83f-4b3226be9aeb.png#align=left&amp;display=inline&amp;height=362&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=724&amp;originWidth=957&amp;size=722888&amp;status=done&amp;style=none&amp;width=478.5" alt="image.png" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mybatis之基础概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#mybatis之基础概念&quot;&gt;&lt;/a&gt; Mybatis之基础概念&lt;/h1&gt;
&lt;p&gt;&lt;a name=&quot;GPKvu&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;orm框架的引入&quot;</summary>
      
    
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/categories/mybatis/"/>
    
    
    <category term="mybatis" scheme="https://jie-blog.icu/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>hashMap 核心与原理分析</title>
    <link href="https://jie-blog.icu/posts/hashmap/"/>
    <id>https://jie-blog.icu/posts/hashmap/</id>
    <published>2020-10-19T07:59:10.000Z</published>
    <updated>2020-10-19T08:09:38.128Z</updated>
    
    <content type="html"><![CDATA[<p><a name="KYF8R"></a></p><h1 id="实现概述"><a class="markdownIt-Anchor" href="#实现概述"></a> 实现概述</h1><p>首先明确HashMap是数组+链表+红黑树的形式存储的。<br />存储数据的数组的类型是内部Node类，在resize方法可以找到：<code>new HashMap.Node[newCap];</code><br />在添加元素是首先会计算key的hash值，并根据hash值找数组对应的下标：<code>p = tab[i = n - 1 &amp; hash]</code><br />如果该位置目前并没有元素，则直接将该元素放入数组中：<br /><code>tab[i] = this.newNode(hash, key, value, (HashMap.Node)null)</code><br />如果该位置有元素，则把新的元素加入到链表中：<br /><code>((HashMap.Node)e).value = value;</code><br />当元素的长度超过阈值时，链表则会转换为红黑树（转换为红黑树还需要满足其他的条件，链表长度达到阈值只是其中的一个条件）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount &gt;= <span class="number">7</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.treeifyBin(tab, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法是为了减少哈希的碰撞概率，最极端的情况就是，当所有的元素都具有相同的哈希值，那么HashMap会退化为一个链表，查找时间也从O(1)上升到O(N)。实现了红黑树后使用哈希值作为树的分支变量，如果两个哈希值不等，但指向同一个桶的话，较大的那个会插入到右子树里。如果哈希值相等，HashMap希望key值最好是实现了Comparable接口的，这样它可以按照顺序来进行插入。<br /><a name="nqo7k"></a></p><h1 id="加载阶段源码分析"><a class="markdownIt-Anchor" href="#加载阶段源码分析"></a> 加载阶段源码分析</h1><p><a name="tEq1K"></a></p><h2 id="类的定义及属性"><a class="markdownIt-Anchor" href="#类的定义及属性"></a> 类的定义及属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1073741824</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75F</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">transient</span> HashMap.Node&lt;K, V&gt;[] table;</span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Entry&lt;K, V&gt;&gt; entrySet;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p>HashMap继承自AbstractMap，实现了Map、Cloneable、Serializable接口。</p><ul><li>Table数组的初始化长度是DEFAULT_INITIAL_CAPACITY（16）</li><li>Table数组最大长度MAXIMUM_CAPACITY（1073741824）</li><li>默认的加载因子是DEFAULT_LOAD_FACTOR（0.75）（即当HashMap存储的元素超过初始值与加载因子的乘积时HashMap会进行扩容，即默认超过16*0.75=12时会进行扩容）</li><li>当链表长度超过TREEIFY_THRESHOLD（8）时会转化为红黑树</li><li>当红黑树resize时发现长度小于UNTREEIFY_THRESHOLD（6）时转换回链表</li><li>当Table数组的长度超过了MIN_TREEIFY_CAPACITY（64）才会进行树化（为了防止前期阶段频繁扩容和树化过程冲突）<br /><a name="7XXmp"></a></li></ul><h2 id="node内部类"><a class="markdownIt-Anchor" href="#node内部类"></a> Node内部类</h2><p>其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    HashMap.Node&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法略</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// setter、getter略</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Entry) &#123;</span><br><span class="line">                Entry&lt;?, ?&gt; e = (Entry)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(<span class="keyword">this</span>.key, e.getKey()) &amp;&amp; Objects.equals(<span class="keyword">this</span>.value, e.getValue())) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，这是一个单向链表。HashMap中用一个数组table来存储这个单向链表，每⼀个键值对组成了⼀个Entry实体。<br /><a name="qvqn5"></a></p><h3 id="链表数组作用"><a class="markdownIt-Anchor" href="#链表数组作用"></a> 链表+数组作用</h3><p>由于数组的值是限制死的，在对key值进行散列取到下标以后，放入到数组中时，难免出现两个key值不同，但是却放入到下标相同的数组格子中，此时就可以使用链表来对其进行链式的存放，形成样式如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603088089108-229ccb63-9329-48e7-a3ea-0bc57259a002.png#align=left&amp;display=inline&amp;height=102&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=151&amp;originWidth=589&amp;size=28790&amp;status=done&amp;style=none&amp;width=397" alt="image.png" /><br /><a name="fXmoN"></a></p><h4 id="为什么不用arraylist代替数组"><a class="markdownIt-Anchor" href="#为什么不用arraylist代替数组"></a> 为什么不用ArrayList代替数组</h4><p>原因很简单，因为数组的自由度高，可让HashMap任由摆布。<br /><a name="wWG1z"></a></p><h2 id="hashmap构造方法"><a class="markdownIt-Anchor" href="#hashmap构造方法"></a> HashMap构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法类型一</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (initialCapacity &gt; <span class="number">1073741824</span>) &#123;</span><br><span class="line">                initialCapacity = <span class="number">1073741824</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (loadFactor &gt; <span class="number">0.0F</span> &amp;&amp; !Float.isNaN(loadFactor)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">                <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 构造方法类型二</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, <span class="number">0.75F</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 构造方法类型三</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = <span class="number">0.75F</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 构造方法类型四</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = <span class="number">0.75F</span>;</span><br><span class="line">        <span class="keyword">this</span>.putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这几个方法主要完成了加载因子的赋值和容器大小的限定，之所以限定容器大小是因为HashMap的容量始终都是2的次幂，所以当我们传入一个指定的容量时，还会调用一个tableSizeFor(int cap)方法来计算容量的大小。<br /><a name="1cxSr"></a></p><h1 id="放入取出源码分析"><a class="markdownIt-Anchor" href="#放入取出源码分析"></a> 放入/取出源码分析</h1><p><a name="QmFkQ"></a></p><h2 id="放入"><a class="markdownIt-Anchor" href="#放入"></a> 放入</h2><p>putVal源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">     HashMap.Node[] tab;</span><br><span class="line">     <span class="keyword">int</span> n;</span><br><span class="line">     <span class="comment">// 数组为空时进行扩容，显然，resize的第一次运行是在这里开始的</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = <span class="keyword">this</span>.table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">         n = (tab = <span class="keyword">this</span>.resize()).length;</span><br><span class="line">     &#125;</span><br><span class="line">     Object p;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="comment">// 当数组当前对象为空时直接创建一个新的节点放入</span></span><br><span class="line">     <span class="keyword">if</span> ((p = tab[i = n - <span class="number">1</span> &amp; hash]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">         tab[i] = <span class="keyword">this</span>.newNode(hash, key, value, (HashMap.Node)<span class="keyword">null</span>);</span><br><span class="line">     <span class="comment">// 如果当前位置非空，产生哈希冲突</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         Object e;</span><br><span class="line">         Object k;</span><br><span class="line">         <span class="comment">// key也完全相等</span></span><br><span class="line">         <span class="keyword">if</span> (((HashMap.Node)p).hash == hash &amp;&amp; ((k = ((HashMap.Node)p).key) == key || key != <span class="keyword">null</span> &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">             e = p;</span><br><span class="line">         <span class="comment">// 判断当前是否是红黑树</span></span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> HashMap.TreeNode) &#123;</span><br><span class="line">             e = ((HashMap.TreeNode)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                 <span class="comment">// 遍历到链表尾部把当前值加进去</span></span><br><span class="line">                 <span class="keyword">if</span> ((e = ((HashMap.Node)p).next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     ((HashMap.Node)p).next = <span class="keyword">this</span>.newNode(hash, key, value, (HashMap.Node)<span class="keyword">null</span>);</span><br><span class="line">                     <span class="comment">// 如果达到阈值则进入treeifyBin方法判断64的阈值，如果没达到则只进行扩容</span></span><br><span class="line">                     <span class="comment">// 如果table容量达到64的阈值，则将该单向链表转化为红黑树</span></span><br><span class="line">                     <span class="keyword">if</span> (binCount &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">                         <span class="keyword">this</span>.treeifyBin(tab, hash);</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line"><span class="comment">// 如果key值重复</span></span><br><span class="line">                 <span class="keyword">if</span> (((HashMap.Node)e).hash == hash &amp;&amp; ((k = ((HashMap.Node)e).key) == key || key != <span class="keyword">null</span> &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 p = e;</span><br><span class="line">                 ++binCount;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">// 如果key相同则覆盖value，并返回value</span></span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">             V oldValue = ((HashMap.Node)e).value;</span><br><span class="line">             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 ((HashMap.Node)e).value = value;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">this</span>.afterNodeAccess((HashMap.Node)e);</span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ++<span class="keyword">this</span>.modCount;</span><br><span class="line">     <span class="comment">// 数组扩容检测</span></span><br><span class="line">     <span class="keyword">if</span> (++<span class="keyword">this</span>.size &gt; <span class="keyword">this</span>.threshold) &#123;</span><br><span class="line">         <span class="keyword">this</span>.resize();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">this</span>.afterNodeInsertion(evict);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><a name="TsfWv"></a></p><h3 id="put总结"><a class="markdownIt-Anchor" href="#put总结"></a> put总结</h3><p>以上一共经历了如下几个关键步骤：</p><ul><li>对key的hashCode做哈希运算，计算出index脚标。</li><li>判断是否碰撞？如果未碰撞则直接生成链表放入数组</li><li>如果碰撞，比较key是否存在，如果不存在加入到之前的链表的next的位置</li><li>如果不存在则替换value返回oldvalue</li><li>判断链表是否过长，如果是就判断数组是否达到64的阈值，如果达到了则转换为红黑树。</li><li>如果没达到则resize。</li></ul><p><a name="JIpkU"></a></p><h2 id="获取"><a class="markdownIt-Anchor" href="#获取"></a> 获取</h2><p>getNode源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap.<span class="function">Node&lt;K, V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    HashMap.Node[] tab;</span><br><span class="line">    HashMap.Node first;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// 判断table数组不为空，找到第一个插入的node</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = <span class="keyword">this</span>.table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (first = tab[n - <span class="number">1</span> &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">// 判断第一个是不是想要的节点</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; ((k = first.key) == key || key != <span class="keyword">null</span> &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap.Node e;</span><br><span class="line">        <span class="comment">// 第二个节点不为空</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是红黑树存储</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> HashMap.TreeNode) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((HashMap.TreeNode)first).getTreeNode(hash, key);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 遍历链表</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key != <span class="keyword">null</span> &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span>((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>get的过程和put可以对比来看，其会先获取可以的hash值，并计算得到此key在数组中的位置，如果first节点不是需要获取的key，则往下遍历，直到找到需要获取的键值，并返回对应的value即可。<br /><a name="mjoyu"></a></p><h1 id="扩容机制"><a class="markdownIt-Anchor" href="#扩容机制"></a> 扩容机制</h1><p>当HashMap中的元素越来越多的时候，因为数组的长度是固定的，所以产生哈希冲突的几率也就越来越大。为了减小哈希冲突的几率，同时也是为了提高查询效率，就需要对HashMap适当的进行扩容。扩容不是达到数字7就开始扩容，或者产生哈希冲突就开始扩容，而是需要满足一定条件才开始扩容，比如：</p><ul><li>达到table.length * loadFactory时。</li><li>多次碰撞后达到链表阈值8且table小于64时。</li><li>等等</li></ul><p>总之，扩容是个耗时的操作，扩容后的大小一般为之前的两倍。resize源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap.Node&lt;K, V&gt;[] resize() &#123;</span><br><span class="line">       <span class="comment">// 存储旧table</span></span><br><span class="line">       HashMap.Node&lt;K, V&gt;[] oldTab = <span class="keyword">this</span>.table;</span><br><span class="line">       <span class="keyword">int</span> oldCap = oldTab == <span class="keyword">null</span> ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="keyword">int</span> oldThr = <span class="keyword">this</span>.threshold;</span><br><span class="line">       <span class="keyword">int</span> newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> newCap;</span><br><span class="line">       <span class="comment">// 旧数组不为空</span></span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果旧数组容量大于1073741824</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= <span class="number">1073741824</span>) &#123;</span><br><span class="line">               <span class="comment">// 将阈值扩大到Int MAX</span></span><br><span class="line">               <span class="keyword">this</span>.threshold = <span class="number">2147483647</span>;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">// 如果旧数组没有达到最大值，但是大鱼初始值</span></span><br><span class="line">           <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; <span class="number">1073741824</span> &amp;&amp; oldCap &gt;= <span class="number">16</span>) &#123;</span><br><span class="line">               <span class="comment">// 扩容两倍</span></span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       <span class="comment">// 阈值大于0</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 将hash表的长度设为阈值大小</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       <span class="comment">// 未初始化，table为空</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           newCap = <span class="number">16</span>;</span><br><span class="line">           newThr = <span class="number">12</span>;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">// 如果阈值等于0</span></span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 重新计算阈值</span></span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * <span class="keyword">this</span>.loadFactor;</span><br><span class="line">           newThr = newCap &lt; <span class="number">1073741824</span> &amp;&amp; ft &lt; <span class="number">1.07374182E9F</span> ? (<span class="keyword">int</span>)ft : <span class="number">2147483647</span>;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">// 存储阈值</span></span><br><span class="line">       <span class="keyword">this</span>.threshold = newThr;</span><br><span class="line">       <span class="comment">// 创建新数组</span></span><br><span class="line">       HashMap.Node&lt;K, V&gt;[] newTab = <span class="keyword">new</span> HashMap.Node[newCap];</span><br><span class="line">       <span class="comment">// 扩容替换</span></span><br><span class="line">       <span class="keyword">this</span>.table = newTab;</span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 遍历旧数组</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               HashMap.Node e;</span><br><span class="line">               <span class="comment">// 如果当前位置不为空</span></span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="comment">// 如果下个链表为空</span></span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">// 重新放置该链表位置</span></span><br><span class="line">                       newTab[e.hash &amp; newCap - <span class="number">1</span>] = e;</span><br><span class="line">                    <span class="comment">// 如果当前链表是红黑树</span></span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> HashMap.TreeNode) &#123;</span><br><span class="line">                       <span class="comment">// 把新的hash表也变为红黑树</span></span><br><span class="line">                       ((HashMap.TreeNode)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="comment">// 保留旧hash表中的链表</span></span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       HashMap.Node&lt;K, V&gt; loHead = <span class="keyword">null</span>;</span><br><span class="line">                       HashMap.Node&lt;K, V&gt; loTail = <span class="keyword">null</span>;</span><br><span class="line">                       HashMap.Node&lt;K, V&gt; hiHead = <span class="keyword">null</span>;</span><br><span class="line">                       HashMap.Node hiTail = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                       HashMap.Node next;</span><br><span class="line">                       <span class="comment">// 遍历当前Table的node，赋值给新的table</span></span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="comment">// 将节点分为两类，e.hash &amp; oldCap为0和e.hash &amp; oldCap为1</span></span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               &#125;</span><br><span class="line"></span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               &#125;</span><br><span class="line"></span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line"></span><br><span class="line">                           e = next;</span><br><span class="line">                       &#125; <span class="keyword">while</span>(next != <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 将为0的索引链放入到newTab[j]中</span></span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line"><span class="comment">// 将为1的索引链放入到newTab[j + oldCap]中</span></span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><a name="HGy1Y"></a></p><h1 id="包含算法"><a class="markdownIt-Anchor" href="#包含算法"></a> 包含算法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a name=&quot;KYF8R&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;实现概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#实现概述&quot;&gt;&lt;/a&gt; 实现概述&lt;/h1&gt;
&lt;p&gt;首先明确HashMap是数组+链表+红黑树的形式存储的。&lt;br /&gt;存储数据</summary>
      
    
    
    
    <category term="零散知识" scheme="https://jie-blog.icu/categories/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java基础" scheme="https://jie-blog.icu/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之I/O设备</title>
    <link href="https://jie-blog.icu/posts/operating_system_input/output/"/>
    <id>https://jie-blog.icu/posts/operating_system_input/output/</id>
    <published>2020-09-15T11:30:41.000Z</published>
    <updated>2020-09-15T11:32:06.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统之io设备"><a class="markdownIt-Anchor" href="#操作系统之io设备"></a> 操作系统之I/O设备</h1><p><a name="R8WGO"></a></p><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>I/O就是输入输出，IO设备就是可以将数据输入到计算机或者接收计算机输出数据的外部设备，属于计算机的硬件部分。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599968367174-ce374900-829a-440a-b005-751be266ad40.png#align=left&amp;display=inline&amp;height=208&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=265&amp;originWidth=601&amp;size=142776&amp;status=done&amp;style=none&amp;width=471" alt="image.png" /><br />UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。<br /><a name="Pqlyz"></a></p><h2 id="io设备分类"><a class="markdownIt-Anchor" href="#io设备分类"></a> I/O设备分类</h2><p>I/O设备分类可以用三种分类方法，分别是按照使用特性分、按照传输速率分和按照信息交换的单位划分。<br /><a name="sy7UT"></a></p><h3 id="使用特性划分"><a class="markdownIt-Anchor" href="#使用特性划分"></a> 使用特性划分</h3><p>使用特性划分又可以分为人机交互类外部设备、存储设备和网络通信设备。<br />其中人机交互外部设备传输速率最慢，存储设备最快，网络通信设备适中。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599968632250-639b0214-2afa-47d2-afdb-215801e2c906.png#align=left&amp;display=inline&amp;height=175&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=249&amp;originWidth=758&amp;size=127098&amp;status=done&amp;style=none&amp;width=534" alt="image.png" /><br /><a name="jzEZA"></a></p><h3 id="按传输速率分"><a class="markdownIt-Anchor" href="#按传输速率分"></a> 按传输速率分</h3><p>按传输速率可以划分为低速、中速和高速设备。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599968697833-83e501eb-8aad-4c44-82d8-35c30922b2ee.png#align=left&amp;display=inline&amp;height=176&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=236&amp;originWidth=711&amp;size=97506&amp;status=done&amp;style=none&amp;width=529" alt="image.png" /><br /><a name="HuyHU"></a></p><h3 id="按信息交换单位分"><a class="markdownIt-Anchor" href="#按信息交换单位分"></a> 按信息交换单位分</h3><p>按信息交换单位可划分为块设备和字符设备。<br />其中块设备传输速率高，可寻址即对它可随机的读、写任一块。<br />字符设备传输速率较慢，不可寻址，在输入输出时常采用中断驱动方式。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599968831902-3dac54e2-824f-4267-8a8c-c2ff23bc3de6.png#align=left&amp;display=inline&amp;height=176&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=205&amp;originWidth=505&amp;size=64478&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br /><a name="usnYz"></a></p><h1 id="io控制器"><a class="markdownIt-Anchor" href="#io控制器"></a> I/O控制器</h1><p><a name="3UjyR"></a></p><h2 id="io控制器的组成"><a class="markdownIt-Anchor" href="#io控制器的组成"></a> I/O控制器的组成</h2><p>I/O设备由机械部件和电子部件组成。<br /><a name="WAuJP"></a></p><h3 id="机械部件"><a class="markdownIt-Anchor" href="#机械部件"></a> 机械部件</h3><p>I/O设备的机械部件主要用来执行具体的I/O操作。如常见的鼠标、键盘、LED显示屏、移动硬盘的磁臂、磁盘盘面等。<br />I/O设备的电子部件通常是一块插入主板扩充槽的印刷电路板。<br /><a name="hU5BX"></a></p><h3 id="电子部件"><a class="markdownIt-Anchor" href="#电子部件"></a> 电子部件</h3><p>CPU无法直接控制I/O设备的机械部件，因此还要有一个电子部件作为CPU和I/O设备机械部件之间的中介，用于实现CPU对设备的控制。这个部件就是I/O控制器，又称设备控制器。CPU可控制I/O控制器，又由I/O控制器来控制设备的机械部件。<br /><a name="U4Itp"></a></p><h2 id="io控制器的功能"><a class="markdownIt-Anchor" href="#io控制器的功能"></a> I/O控制器的功能</h2><p>其总共拥有如下四个功能：<br /><a name="LyVyY"></a></p><h3 id="接受和识别cpu发出的命令"><a class="markdownIt-Anchor" href="#接受和识别cpu发出的命令"></a> 接受和识别CPU发出的命令</h3><p>如CPU发来的read/wirte命令，I/O控制器会有相应的控制寄存器来存放命令和参数。<br /><a name="eNGL4"></a></p><h3 id="向cpu报告设备的状态"><a class="markdownIt-Anchor" href="#向cpu报告设备的状态"></a> 向CPU报告设备的状态</h3><p>I/O控制器中会有相应的状态寄存器用于记录I/O设备的当前状态，如：1表示空闲，0表示忙碌。<br /><a name="ej9OQ"></a></p><h3 id="数据交换"><a class="markdownIt-Anchor" href="#数据交换"></a> 数据交换</h3><p>I/O控制器中会设置相应的数据寄存器。输出时，数据寄存器用于暂存CPU发来的数据，之后再由控制器发送设备。输入时，数据寄存器用于暂存设备发来的数据，之后CPU从寄存器中取走数据。<br /><a name="F7o7e"></a></p><h3 id="地址识别"><a class="markdownIt-Anchor" href="#地址识别"></a> 地址识别</h3><p>类似于内存的地址，为了区分设备控制器中的各个寄存器，也许要给各个寄存器，也许要给各个寄存器设置一个特定的地址。I/O控制器通过CPU提供的地址来判断CPU要读写的是哪个寄存器。<br /><a name="lU3Kc"></a></p><h2 id="io控制器结构"><a class="markdownIt-Anchor" href="#io控制器结构"></a> I/O控制器结构</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599975121635-a454816f-d2e3-43c1-ba3a-ff9bb15f2bca.png#align=left&amp;display=inline&amp;height=305&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=432&amp;originWidth=734&amp;size=154862&amp;status=done&amp;style=none&amp;width=519" alt="image.png" /><br />注意：</p><ol><li>一个I/O控制器可能会对应多个设备。</li><li>数据寄存器、控制寄存器、状态寄存器可能有多个（如：每个控制器/状态寄存器对应一个具体的设备），且这些寄存器都要有对应的地址才方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为内存映像I/O。其他计算机采用I/O专用地址，即寄存器独立编址。<br /><a name="2FssT"></a></li></ol><h3 id="内存映像io和寄存器独立编址"><a class="markdownIt-Anchor" href="#内存映像io和寄存器独立编址"></a> 内存映像I/O和寄存器独立编址</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599975544113-b4559ee0-5a37-4bb4-85f2-29e720571d3a.png#align=left&amp;display=inline&amp;height=309&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=364&amp;originWidth=723&amp;size=129477&amp;status=done&amp;style=none&amp;width=613" alt="image.png" /><br /><a name="gHL5Q"></a></p><h1 id="io控制方式"><a class="markdownIt-Anchor" href="#io控制方式"></a> I/O控制方式</h1><p>I/O设备的数据读写有如下四种控制方式：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599975696963-f4925b66-f5d2-47a6-ad99-685e46f6f713.png#align=left&amp;display=inline&amp;height=136&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=271&amp;originWidth=226&amp;size=36116&amp;status=done&amp;style=none&amp;width=113" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599978106061-da85f714-6b79-4afd-a17f-cb1966b00922.png#align=left&amp;display=inline&amp;height=287&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=416&amp;originWidth=808&amp;size=210679&amp;status=done&amp;style=none&amp;width=557" alt="image.png" /><br /><a name="hoWfu"></a></p><h2 id="程序直接控制方式"><a class="markdownIt-Anchor" href="#程序直接控制方式"></a> 程序直接控制方式</h2><p>以读操作为例，其操作流程如下：</p><ol><li>CPU向控制器发出指令， 于是设备启动并且状态寄存器设为1.</li><li>轮询检查控制器的状态（即不断的执行程序的循环，若状态位一直是1，说明设备还没准备好要输入数据，因此CPU会不断的轮询检查）</li><li>输入设备准备好数据后将数据传送给控制器并报告自身状态。</li><li>控制器将数据放入数据寄存器中，并将状态改为0（已就绪）</li><li>CPU发现设备已经就绪，于是将数据寄存器中的内容读入到CPU的寄存器中，然后把CPU寄存器中的内容放入到内存。</li><li>如还要继续读出擦操作，CPU继续发出指令。</li></ol><p>程序代码：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599976036806-53554c79-0492-41fd-b4f8-d44c8690bf74.png#align=left&amp;display=inline&amp;height=243&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=340&amp;originWidth=422&amp;size=110283&amp;status=done&amp;style=none&amp;width=301" alt="image.png" /><br />流程图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599976108878-a1b5ab64-6092-48f3-935f-6dfded44f4a9.png#align=left&amp;display=inline&amp;height=436&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=452&amp;originWidth=361&amp;size=87531&amp;status=done&amp;style=none&amp;width=348" alt="image.png" /><br /><a name="d4o23"></a></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>该方法实现简单，加上实现循环检查的一系列指令即可（因此称为“程序直接控制方式”）<br />数据流向：<br />读操作（数据输入）：I/O设备-&gt;CPU-&gt;内存<br />写操作（数据输出）：内存-&gt;CPU-&gt;I/O设备<br />显然，每次读写都需要CPU的帮助<br />CPU干预很频繁，I/O操作开始之前、完成之后需要CPU介入，甚至在等待I/O完成过程中CPU还需要不断地轮询检查。每次读/写仅操作一个字。<br />因此，其缺点是CPU和I/O设备只能串行工作，CPU需要一直轮询检查，长期忙等，CPU利用率低。<br /><a name="Nmoyj"></a></p><h2 id="中断驱动方式"><a class="markdownIt-Anchor" href="#中断驱动方式"></a> 中断驱动方式</h2><p>引入中断机制，用于I/O设备速度慢，因此CPU发出读/写命令后可将等待I/O的进程阻塞，先切换到别的进程执行。当I/O完成后，控制器回向CPU发送一个中断信号，CPU检测到中断信号后会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。处理中断的过程中，CPU从I/O设备控制器读一个字的数据传送到CPU寄存器，在写入主存。接着，CPU恢复等待I/O的进程（或其他进程）的运行环境然后再执行。<br />注意：</p><ul><li>CPU会在每个指令周期的末尾检查中断</li><li>中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。显然，如果中断发生频率太高也会降低系统性能。</li></ul><p>流程图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599976855535-189473c7-b158-40ae-8073-a0888da39623.png#align=left&amp;display=inline&amp;height=327&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=413&amp;originWidth=294&amp;size=38172&amp;status=done&amp;style=none&amp;width=233" alt="image.png" /><br /><a name="8zZOs"></a></p><h3 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3><p>与程序直接控制方式相比，在中断驱动方式中，I/O控制器会通过中断信号主动报告I/O已完成，CPU不需要不断的轮询。CPU和I/O设备可以并行工作，CPU利用率显著提升。<br />每次I/O操作开始之前、完成之后需要CPU接入，等待I/O完成的过程中CPU可以切换到其他的进程执行。每次读/写一个字。<br />数据流向：<br />读操作（数据输入）：I/O设备-&gt;CPU-&gt;内存<br />写操作（数据输出）：内存-&gt;CPU-&gt;I/O设备<br />综上，其缺点为：每个字在I/O设备之间的传输都需要经过CPU，而频繁的中断处理会消耗比较多的CPU时间。<br /><a name="wGGr8"></a></p><h2 id="dma方式"><a class="markdownIt-Anchor" href="#dma方式"></a> DMA方式</h2><p>与中断驱动方式相比，DMA方式（Direct Memory Access，直接存储器存储，主要用于设备的I/O控制）有如下几个改进：</p><ul><li>数据传送单位是“块”</li><li>数据的流向是从设备直接放入内存或者从内存直接到设备。不再需要CPU中转。</li><li>仅在传送一个或多个数据块的开始或结束时才需要CPU的干预。</li></ul><p>流程图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599977296598-7e08c259-db46-4f10-be55-dfe0adfc6b84.png#align=left&amp;display=inline&amp;height=151&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=247&amp;originWidth=722&amp;size=100367&amp;status=done&amp;style=none&amp;width=440" alt="image.png" /><br /><a name="Okh5p"></a></p><h3 id="dma控制器"><a class="markdownIt-Anchor" href="#dma控制器"></a> DMA控制器</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599977354856-7129c428-4315-4a13-b2de-f3c4b625538d.png#align=left&amp;display=inline&amp;height=171&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=264&amp;originWidth=814&amp;size=43625&amp;status=done&amp;style=none&amp;width=527" alt="image.png" /><br />DR（Data Register 数据寄存器）：暂存从设备到内存或从内存到设备的数据。<br />MAR（Memory Address Register，内存地址寄存器）：在输入时，MAR表示数据应该放在内存的什么位置，输出时MAR表示要输出的数据放在内存中的什么位置。<br />DC（Data Counter 数据计数器）：表示剩余要读/写的字节数。<br />CR（Command Register，命令/状态寄存器）：用于存放CPU发来的I/O命令，或设备的状态信息。<br /><a name="SrPpa"></a></p><h3 id="总结-3"><a class="markdownIt-Anchor" href="#总结-3"></a> 总结</h3><p>数据以块为单位，CPU介入频率进一步降低。数据的传输不再需要经过CPU再写入内存，数据传输效率进一步增加。CPU和I/O设备的并行性得到提升。<br />但是其缺点是CPU每发出一个I/O指令，只能读/写一个或多个连续的数据块，如果要读/写多个和离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条I/O指令，进行多次中断处理才能完成。<br /><a name="NC4lY"></a></p><h2 id="通道控制方法"><a class="markdownIt-Anchor" href="#通道控制方法"></a> 通道控制方法</h2><p>通道是一种硬件，可以当作简化版的CPU，其可以识别并执行一系列的通道指令。<br />执行流程如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599977910044-22291a90-235f-41b8-86d2-ff0a12534620.png#align=left&amp;display=inline&amp;height=237&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=361&amp;originWidth=804&amp;size=128319&amp;status=done&amp;style=none&amp;width=527" alt="image.png" /><br /><a name="Jy5Yp"></a></p><h3 id="总结-4"><a class="markdownIt-Anchor" href="#总结-4"></a> 总结</h3><p>与CPU相比通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与CPU共享内存。<br />在这个环境下CPU、通道、I/O设备可以并行的工作，资源利用率高。<br />但是实现比较复杂，需要专门的通道硬件支持。<br /><a name="VnpzA"></a></p><h1 id="软件的层次结构"><a class="markdownIt-Anchor" href="#软件的层次结构"></a> 软件的层次结构</h1><p>软件的层次结构如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599978167148-2e9de087-8903-4f66-8854-3bf9c8f2154e.png#align=left&amp;display=inline&amp;height=225&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=449&amp;originWidth=941&amp;size=153318&amp;status=done&amp;style=none&amp;width=470.5" alt="image.png" />   <br />直接涉及到硬件具体细节、且与终端无关的操作肯定是在设备驱动层完成的，没有设计硬件的、对各种设备都需要进行的管理工作都是在设备独立性软件层进行的。<br /><a name="6DhFd"></a></p><h2 id="用户层软件"><a class="markdownIt-Anchor" href="#用户层软件"></a> 用户层软件</h2><p>用户层软件实现了与用户交互的接口，用户可以直接使用该层提供的、与I/O操作相关的库函数对设备进行操作。例如：printf(“hello, world!”);<br />用户层软件将用户请求翻译成格式化的I/O请求，并通过“系统调用”请求操作系统内核的服务。例如：printf(“hello, world!”); 会被翻译成等价的write系统调用，当然，用户层软件也会在系统调用是填入相应的参数。<br />Windiws操作系统向外提供的一系列系统调用由于操作系统调用的格式严格、使用麻烦，因此在用户层上封装了一系列更方便的库函数接口供用户使用。<br /><a name="80AXY"></a></p><h2 id="设备独立性软件"><a class="markdownIt-Anchor" href="#设备独立性软件"></a> 设备独立性软件</h2><p>设备独立性软件又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。<br />其主要功能：</p><ul><li>向上层提供统一的调用接口，如read/write系统调用。</li><li>设备的保护，其原理类似于文件保护。设备被看做是一种特殊的文件，不同用户对各个文件的访问权限是不一样的，同理对设备的访问权限也是不一样的。</li><li>差错处理。设备独立性软件需要对一些设备的错误进行处理。</li><li>设备的分配与回收。</li><li>数据缓冲区管理。可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异。</li><li>建立逻辑设备名到物理设备名的映射关系，根据设备类型选择调用相应的驱动。<ul><li>用户或用户层软件发出I/O操作相关系统调用的系统调用时，需要指明此次要操作的I/O设备的逻辑设备名，例如打印机1、打印机2等等。</li><li>设备独立性软件需要通过“逻辑设备表（LUT,Logical Unit Table）”来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序。<br /><a name="0ef5w"></a></li></ul></li></ul><h3 id="逻辑设备表"><a class="markdownIt-Anchor" href="#逻辑设备表"></a> 逻辑设备表</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599978967376-4b5d6029-3358-40af-a728-6c094189ee02.png#align=left&amp;display=inline&amp;height=160&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=240&amp;originWidth=609&amp;size=64990&amp;status=done&amp;style=none&amp;width=405" alt="image.png" /><br />操作系统可以采用两种方式管理逻辑设备表（LUT）<br />第一种方式是整个系统只设置一张LUT，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单个用户的操作系统。<br />第二种方式是为每个用户设置一张LUT，各个用户使用的逻辑设备名称可以重复，是用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。<br /><a name="4LXUP"></a></p><h4 id="为什么需要不同的驱动程序"><a class="markdownIt-Anchor" href="#为什么需要不同的驱动程序"></a> 为什么需要不同的驱动程序</h4><p>对比下述两张图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599979254681-83b4afcd-0b23-4c56-ac69-9f3913bcec38.png#align=left&amp;display=inline&amp;height=301&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=463&amp;originWidth=847&amp;size=96217&amp;status=done&amp;style=none&amp;width=550" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599979306493-5eb3a1bc-b0bd-4e0f-8149-503e02e89e3b.png#align=left&amp;display=inline&amp;height=306&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=472&amp;originWidth=843&amp;size=110130&amp;status=done&amp;style=none&amp;width=546" alt="image.png" /><br />不同设备的内部硬件特性可能也不同，这些特性只有厂家才知道，因此厂家必须提供与设备相对应的驱动程序，CPU执行驱动程序的指令序列来完成设备寄存器、检查设备状态等工作。<br /><a name="ydA1S"></a></p><h2 id="设备驱动程序"><a class="markdownIt-Anchor" href="#设备驱动程序"></a> 设备驱动程序</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599979663757-63020a2d-971b-441e-b6b7-a5b655529c9c.png#align=left&amp;display=inline&amp;height=480&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=960&amp;originWidth=1410&amp;size=169139&amp;status=done&amp;style=none&amp;width=705" alt="image.png" /><br />主要负责对硬件设备的具体控制，将上层发出的一系列命令（如：write、read等）转化为特定的设备了解的一系列操作，包括设置设备寄存器、检查设备状态等。<br />不同的I/O设备有着不同的硬件特性，具体细节只有厂家才知道，因此厂家要根据设备的硬件特性设计并提供相应的驱动程序。<br />注：驱动程序一般会以一个独立进程的方式存在。<br /><a name="8ivvI"></a></p><h2 id="中断处理程序"><a class="markdownIt-Anchor" href="#中断处理程序"></a> 中断处理程序</h2><p>当I/O任务完成时，I/O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。中断处理程序处理流程如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599979766704-d0c5bc97-71a4-4426-abb7-4b78d2d81b41.png#align=left&amp;display=inline&amp;height=210&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=242&amp;originWidth=363&amp;size=46814&amp;status=done&amp;style=none&amp;width=315" alt="image.png" /><br /><a name="yLcHd"></a></p><h2 id="流程演示"><a class="markdownIt-Anchor" href="#流程演示"></a> 流程演示</h2><ol><li>用户通过调用用户层软件提供的库函数发出I/O请求</li><li>用户层软件通过系统调用请求设备独立性软件层的服务</li><li>设备独立性软件层根据LUT调用设备对应的驱动程序</li><li>驱动程序向I/O控制器发出具体命令</li><li>等待I/O完成的进程应该被阻塞，因此需要进程切换，而进程切换必然需要终端操作。<br /><a name="Bawuk"></a></li></ol><h1 id="io核心子系统功能"><a class="markdownIt-Anchor" href="#io核心子系统功能"></a> I/O核心子系统功能</h1><p>设备独立性软件层、设备驱动程序层和中断处理程序层属于操作系统的内核部分，即I/O系统或称I/O核心子系统，因此I/O核心字系统要实现的功能就是中间三层要实现的功能。<br />其核心功能所在分区如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599980508664-a2fa5cca-2f25-45e9-a156-03f0287712c0.png#align=left&amp;display=inline&amp;height=213&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=426&amp;originWidth=959&amp;size=281991&amp;status=done&amp;style=none&amp;width=479.5" alt="image.png" /><br /><a name="ArKKs"></a></p><h2 id="假脱机技术spooling"><a class="markdownIt-Anchor" href="#假脱机技术spooling"></a> 假脱机技术（SPOOLing）</h2><p>需要请求磁盘设备的设备独立性软件的服务，因此一般来说假脱机技术是在用户层软件实现的，但是在新版教材中把假脱机技术归在了I/O核心子系统的功能。<br /><a name="h5psE"></a></p><h3 id="什么是脱机技术"><a class="markdownIt-Anchor" href="#什么是脱机技术"></a> 什么是脱机技术</h3><p>在手工阶段，主机直接从I/O设备获得数据，由于设备速度按慢，主机速度快。人机速度矛盾明显，主机要浪费很多时间来等待设备。<br />所以在批处理阶段引入了脱机输入/输出技术，通过外围机的控制，慢速输入设备的数据线被输入到更快速的磁带上，之后主机可以从快速的磁带上读入数据，从而减缓速度矛盾。另一方面，即使CPU在忙碌也可以提前将数据输入到磁带，即使慢速的输出设备正在忙碌也可以提前将数据输出到磁带。<br />因此，脱机即脱离主机控制进行输入/输出操作。<br /><a name="hazKE"></a></p><h3 id="什么是假脱机技术"><a class="markdownIt-Anchor" href="#什么是假脱机技术"></a> 什么是假脱机技术</h3><p>假脱机技术又称SPOOLing技术，是用软件的方式模拟脱机技术。SPOOLing系统的组成如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599981344173-6dfe5d4a-289a-45c7-bae6-f0fa73f1918d.png#align=left&amp;display=inline&amp;height=294&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=588&amp;originWidth=1160&amp;size=320535&amp;status=done&amp;style=none&amp;width=580" alt="image.png" /><br />在输入/出进程的控制下，输入/出缓冲区用于暂时从输入/出设备输入/出的数据，之后再转存到输入/出井中。<br />注意：输入缓冲区和输出缓冲区是在内存中的缓冲区。<br /><a name="eWmu4"></a></p><h4 id="输入井"><a class="markdownIt-Anchor" href="#输入井"></a> 输入井</h4><p>模拟脱机输入时的磁带，用于收容I/O设备输入的数据。<br /><a name="OnN3m"></a></p><h4 id="输出井"><a class="markdownIt-Anchor" href="#输出井"></a> 输出井</h4><p>模拟脱机输出时的磁带，用于收容用户进程输出的数据。<br /><a name="lP5fr"></a></p><h2 id="io调度"><a class="markdownIt-Anchor" href="#io调度"></a> I/O调度</h2><p>用某种算法确定一个好的顺序来处理各个I/O请求。<br />如：磁盘调度（先来先去服务算法、最短寻道优先算法、SCAN算法、C-SCAN算法、LOOK算法、C-LOOK算法）。当多个磁盘I/O请求到来时，用某种调度算法确定满足I/O请求的顺序。<br />同理，打印机等设备也可以用先来先服务算法、优先算法、短作业优先等算法来确定I/O调度顺序。<br /><a name="MMxxn"></a></p><h2 id="设备保护"><a class="markdownIt-Anchor" href="#设备保护"></a> 设备保护</h2><p>操作系统需要实现文件保护功能，不同的用户对各个文件有不同的访问权限，如：只读、读和写等。<br />在UNIX系统中，设备被看作是一种特殊的文件，每个设备也会有对应的FCB，当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此来实现设备保护功能。<br /><a name="qHbQd"></a></p><h2 id="设备的分配与回收"><a class="markdownIt-Anchor" href="#设备的分配与回收"></a> 设备的分配与回收</h2><p><a name="GoBub"></a></p><h3 id="分配时考虑的因素"><a class="markdownIt-Anchor" href="#分配时考虑的因素"></a> 分配时考虑的因素</h3><p>设备分配时应该考虑的因素有设备的固有属性、设备的分配算法、设备分配中的安全性。<br /><a name="N4nHV"></a></p><h4 id="设备的固有属性"><a class="markdownIt-Anchor" href="#设备的固有属性"></a> 设备的固有属性</h4><p>设备的固有属性可分为三种：独占设备、共享设备、虚拟设备。</p><ul><li>独占设备：一个时间段只能分配给一个进程（如打印机）</li><li>共享设备：可同时分配给多个进程使用（如磁盘），宏观上往往是宏观上同时共享使用设备，而微观上是交替使用。</li><li>虚拟设备：采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用。（如采用SPOOLing技术实现的共享打印机）<br /><a name="MNfOc"></a></li></ul><h4 id="设备的分配算法"><a class="markdownIt-Anchor" href="#设备的分配算法"></a> 设备的分配算法</h4><p>设备的分配算法可以使用先来先服务、优先级高者优先、短任务优先等算法。<br /><a name="2dFjj"></a></p><h4 id="设备分配中的安全性"><a class="markdownIt-Anchor" href="#设备分配中的安全性"></a> 设备分配中的安全性</h4><p>从进程运行的安全性考虑，设备分配有两种方法：<br />安全分配方式：<br />为进程分配一个设备后就将阻塞，本次I/O完成后才将进程唤醒。一个时段内每个进程只能使用一个设备。<br />优点：破坏了请求和保持条件，不会产生死锁。<br />缺点：对于一个进程来说，CPU和I/O设备只能串行工作。<br />不安全分配方式：<br />进程发出I/O请求后，系统为其分配I/O设备，进程可继续执行，之后还可以发出新的I/O请求，只有某个I/O请求得不到满足时才将进程阻塞。一个进程可以同时使用多个设备。<br />优点：进程的计算任务和I/O任务可以并行处理，让进程迅速推进。<br />缺点：可能会发生死锁。<br /><a name="Q93NE"></a></p><h3 id="静态分配和动态分配"><a class="markdownIt-Anchor" href="#静态分配和动态分配"></a> 静态分配和动态分配</h3><p>静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源。破坏了请求和保持条件，不会发生死锁。<br />动态分配：进程运行过程中动态申请设备资源。<br /><a name="ffRm6"></a></p><h3 id="设备分配管理中的数据结构"><a class="markdownIt-Anchor" href="#设备分配管理中的数据结构"></a> 设备分配管理中的数据结构</h3><p>设备、控制器、通道的关系如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599982511496-c13f5850-8f5b-42bb-a7f3-5b85fd36e4d5.png#align=left&amp;display=inline&amp;height=179&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=246&amp;originWidth=672&amp;size=50899&amp;status=done&amp;style=none&amp;width=489" alt="image.png" /><br />设备控制表（DTC）：系统为每个设备配置一张DTC，用于记录设备情况。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599982555247-9af146e5-9a56-45fb-9907-2e2a2fc0dd8b.png#align=left&amp;display=inline&amp;height=155&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=218&amp;originWidth=691&amp;size=110881&amp;status=done&amp;style=none&amp;width=491" alt="image.png" /><br />注：系统会根据阻塞原因不同将进程PCB挂到不同的阻塞队列。<br />控制器控制表（COCT）：每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作管理。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599982653577-b3aa74dd-de19-4f41-885d-24b82decd920.png#align=left&amp;display=inline&amp;height=131&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=186&amp;originWidth=726&amp;size=80066&amp;status=done&amp;style=none&amp;width=510" alt="image.png" /><br />通道控制表（CHCT）：每个通道都会对应一张CHCT，操作系统根据CHCT信息对通道进行操作和管理。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599982701722-772182f2-d403-456d-bf84-991a2f047319.png#align=left&amp;display=inline&amp;height=158&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=202&amp;originWidth=746&amp;size=80147&amp;status=done&amp;style=none&amp;width=584" alt="image.png" /><br />系统设备表（SDT）：记录了系统中全部设备的情况，每个设备都对应一个表目。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599982752025-4d464d24-1244-4590-9ed8-8aba6926c613.png#align=left&amp;display=inline&amp;height=134&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=199&amp;originWidth=643&amp;size=45176&amp;status=done&amp;style=none&amp;width=432" alt="image.png" /><br /><a name="yrBe6"></a></p><h3 id="设备分配的步骤"><a class="markdownIt-Anchor" href="#设备分配的步骤"></a> 设备分配的步骤</h3><ol><li>根据进程请求的设备名查找SDT（注：物理设备名是进程请求分配设备时提供的参数）</li><li>根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程。</li><li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li><li>根据COCT找到CHCT，若通道忙碌泽江金城PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</li></ol><p>只有设备、控制器、通道三者都分配成功时此设备分配才算成功，之后便可启动I/O设备进行数据传输。<br /><a name="RilLL"></a></p><h3 id="设备分配步骤的改进"><a class="markdownIt-Anchor" href="#设备分配步骤的改进"></a> 设备分配步骤的改进</h3><p>上述步骤有如下几个缺点：</p><ul><li>用户编程时必须使用物理设备名，底层细节对用户不透明，不方便编程。</li><li>若换了一个物理设备，则程序无法进行。</li><li>若程序进程请求的物理设备正在忙碌，则及时系统中还有同类型的设备，进程也必须阻塞等待。</li></ul><p>改进方法：建立逻辑设备名与物理设备名的映射机制，用户编程只需要提供逻辑设备名即可。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599983281112-3dfcdf0c-195a-43d5-8444-88788e74b463.png#align=left&amp;display=inline&amp;height=190&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=283&amp;originWidth=830&amp;size=71199&amp;status=done&amp;style=none&amp;width=557" alt="image.png" /><br />逻辑设备表（LUT）建立了逻辑设备名和物理设备名的映射关系。<br />某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在LUT增加相应表项。<br />如果之后用户进程再次通过相同的逻辑请求使用设备，则操作系统通过LUT表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序的入口地址。<br />LUT表设置问题：<br />整个系统只有一张LUT：各个用户所用的逻辑设备名不允许重复<br />每个用户一张LUT：不同的用户的设备名可以重复。<br /><a name="P50x3"></a></p><h1 id="缓冲区管理"><a class="markdownIt-Anchor" href="#缓冲区管理"></a> 缓冲区管理</h1><p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可以利用内存作为缓冲区。<br />使用硬件作为缓冲区的成本比较高，容量也比较小，一般仅用在对速度要求十分高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）<br />一般情况下，更多是利用内存作为缓存区，设备独立性软件的缓冲区管理就是要组织管理好这些缓冲区。<br /><a name="xBSuM"></a></p><h2 id="缓冲区的作用"><a class="markdownIt-Anchor" href="#缓冲区的作用"></a> 缓冲区的作用</h2><p>其主要作用如下：</p><ul><li>缓和CPU与I/O设备之间的速度不匹配的矛盾。</li><li>减少对CPU的中断频率，放宽对CPU中断响应时间的限制。</li><li>解决数据颗粒度不匹配的问题。例如，输出进程每次可以生成一块数据，但是I/O设备每次只能输出一个字符。</li><li>提高CPU与I/O设备之间的并行性。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599983956994-e5e90d79-902c-4ac2-b5a5-3b78a3b51075.png#align=left&amp;display=inline&amp;height=184&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=223&amp;originWidth=346&amp;size=34391&amp;status=done&amp;style=none&amp;width=285" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599983964724-adbe044a-89f2-44f7-8f61-bcfea2074c2d.png#align=left&amp;display=inline&amp;height=191&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=270&amp;originWidth=579&amp;size=63719&amp;status=done&amp;style=none&amp;width=410" alt="image.png" /><br /><a name="i4Rr8"></a></p><h2 id="单缓存"><a class="markdownIt-Anchor" href="#单缓存"></a> 单缓存</h2><p>假设某用户进程请求某种模块设备读入若干块的数据，若采用单缓存的策略，操作系统会在主存中为其分配一个缓冲区。<br />注意：当缓冲区数据非空时，不能往缓冲区中入数据，只能从缓冲区把数据传出，当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满后才能从缓冲区吧数据传出。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984283080-cab8e813-55e1-4892-ab45-f3a9949ed121.png#align=left&amp;display=inline&amp;height=259&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=319&amp;originWidth=530&amp;size=61674&amp;status=done&amp;style=none&amp;width=431" alt="image.png" /><br />时间表变化图：<br />T&gt;C<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984334973-1b68b2ce-ab38-47dc-a0cb-2760a868605f.png#align=left&amp;display=inline&amp;height=217&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=338&amp;originWidth=860&amp;size=103940&amp;status=done&amp;style=none&amp;width=552" alt="image.png" /><br />T&lt;C<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984373185-ffd3755b-0995-47b4-84df-da71e37fb0ed.png#align=left&amp;display=inline&amp;height=205&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=345&amp;originWidth=929&amp;size=110857&amp;status=done&amp;style=none&amp;width=553" alt="image.png" /><br />平均耗时：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984435223-30e9f13c-cc23-4943-aceb-e18782be60c3.png#align=left&amp;display=inline&amp;height=242&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=353&amp;originWidth=835&amp;size=88961&amp;status=done&amp;style=none&amp;width=572" alt="image.png" /><br /><a name="bXD7m"></a></p><h2 id="双缓冲"><a class="markdownIt-Anchor" href="#双缓冲"></a> 双缓冲</h2><p>假设某用户进程请求某种模块设备读入若干块的数据，若采用双缓存的策略，操作系统会在主存中为其分配两个缓冲区。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984548270-3e658a64-1fa1-4b20-b7b2-d09b0b5d7aef.png#align=left&amp;display=inline&amp;height=244&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=352&amp;originWidth=866&amp;size=80104&amp;status=done&amp;style=none&amp;width=601" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984575653-9a2552d3-befa-4991-8a39-0651285f3e4c.png#align=left&amp;display=inline&amp;height=216&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=332&amp;originWidth=785&amp;size=129225&amp;status=done&amp;style=none&amp;width=510" alt="image.png" /><br />显然，采用双缓冲策略处理一个数据块平均耗时为Max(T,C+M)<br /><a name="YAWfy"></a></p><h2 id="两种缓冲区在通信时的区别"><a class="markdownIt-Anchor" href="#两种缓冲区在通信时的区别"></a> 两种缓冲区在通信时的区别</h2><p>两台机器之间通信时，可以配置缓冲区用于数据的发送和接受。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984682990-63b7fcb0-bd41-47b2-bc80-12f28f1e2492.png#align=left&amp;display=inline&amp;height=168&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=271&amp;originWidth=697&amp;size=69199&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br />显然，若两个相互通信的机器只设置单缓冲区，在任一个时刻只能实现数据的单向传输。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984780846-d0cae697-dfd0-4607-803a-b30813005cd3.png#align=left&amp;display=inline&amp;height=223&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=282&amp;originWidth=515&amp;size=32175&amp;status=done&amp;style=none&amp;width=407" alt="image.png" /><br />若两个相互通信的机器设置双缓冲区，则同一时刻可以实现双向的数据传输。<br />注：管道通信中的管道其实就是缓冲区，要实现数据双向传输必须要设置两个管道。<br /><a name="p6wwR"></a></p><h2 id="循环缓冲区"><a class="markdownIt-Anchor" href="#循环缓冲区"></a> 循环缓冲区</h2><p>将多个大小相等的缓冲区链接成一个循环队列。<br />注：以下图示中，橙色未一充满数据的缓冲区，绿色表示空缓冲区。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984919280-8da997c8-9d60-40cd-9144-c82fcc0ead96.png#align=left&amp;display=inline&amp;height=211&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=306&amp;originWidth=564&amp;size=40321&amp;status=done&amp;style=none&amp;width=388" alt="image.png" /><br /><a name="UtQQt"></a></p><h2 id="缓冲池"><a class="markdownIt-Anchor" href="#缓冲池"></a> 缓冲池</h2><p>缓冲池由系统中公用的缓冲区组成，这些缓冲区按使用状况可划分为空缓冲队列、装满输入数据缓冲队列（输入队列）、装满输出数据的缓冲队列（输出队列）。<br />另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了两种工作缓冲区：用于收容输入数据的工作缓冲区（hin）、用于提取输入数据的工作缓冲区（sin）、用户收容输出数据的工作缓冲区（hout）、用于提取输出数据的工作缓冲区（sout）<br /><a name="ydiDs"></a></p><h3 id="执行步骤"><a class="markdownIt-Anchor" href="#执行步骤"></a> 执行步骤</h3><ul><li>输入进程请求输入数据<ul><li>从空缓冲队列中取出一块作为收容输入数据的工作缓冲区（hin），充满数据后将缓冲区挂到输入队列队尾。</li></ul></li><li>计算进程想要取得一块输入数据<ul><li>从输入队列中取得一块冲满输入数据的缓冲区作为“提取输入数据的工作缓冲区（sin）”。缓冲区读空后挂到空缓冲区队列。</li></ul></li><li>计算进程想要准备好的数据冲入缓冲区<ul><li>从空缓冲队列中取出一块作为“收容输出数据的工作缓冲区（hout）”。数据冲满后将缓冲区挂到输出队列队尾。</li></ul></li><li>输出进程请求输出数据<ul><li>从输出队列中取得一块充满输出数据的缓冲区作为“提取输出数据的工作缓冲区（sout）”。缓冲区读空后挂到空缓冲区队列。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统之io设备&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#操作系统之io设备&quot;&gt;&lt;/a&gt; 操作系统之I/O设备&lt;/h1&gt;
&lt;p&gt;&lt;a name=&quot;R8WGO&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a class=&quot;mar</summary>
      
    
    
    
    <category term="操作系统" scheme="https://jie-blog.icu/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://jie-blog.icu/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之磁盘</title>
    <link href="https://jie-blog.icu/posts/operating_system_disk/"/>
    <id>https://jie-blog.icu/posts/operating_system_disk/</id>
    <published>2020-09-15T11:29:05.000Z</published>
    <updated>2020-09-15T11:30:24.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统之磁盘"><a class="markdownIt-Anchor" href="#操作系统之磁盘"></a> 操作系统之磁盘</h1><p><a name="rEcV0"></a></p><h1 id="磁盘的结构"><a class="markdownIt-Anchor" href="#磁盘的结构"></a> 磁盘的结构</h1><p>磁盘实际样子如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/485026/1599889988958-ed10375e-99f6-41f1-9aa7-c66e4ec2b6b8.jpeg#align=left&amp;display=inline&amp;height=283&amp;margin=%5Bobject%20Object%5D&amp;originHeight=283&amp;originWidth=400&amp;size=0&amp;status=done&amp;style=none&amp;width=400" alt="" /><br />磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据。<br />磁盘的圆盘盘面可以横向划分成一个个磁道，一个圈就是一个磁道。最内侧的磁道上扇区最小，因此数据密度最大。<br />每个磁道又被纵向划分成一个个扇区，每个扇区就是一个磁盘块，各个扇区存放的数据量相同。<br /><a name="4oDwH"></a></p><h2 id="如何写入读出数据"><a class="markdownIt-Anchor" href="#如何写入读出数据"></a> 如何写入/读出数据</h2><p>每个磁盘都拥有一个磁头，磁头移动到想要读/写的扇面所在的磁道后磁盘会转动，让目标扇区从磁头下面划过，最后完成对扇区的读/写操作。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599890553886-07d75711-beca-4cbf-b099-3b86cef4a5da.png#align=left&amp;display=inline&amp;height=285&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=305&amp;originWidth=317&amp;size=63129&amp;status=done&amp;style=none&amp;width=296" alt="image.png" /><br /><a name="9SgB5"></a></p><h2 id="盘面-柱面结构"><a class="markdownIt-Anchor" href="#盘面-柱面结构"></a> 盘面、柱面结构</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599890623778-46339110-9587-4f45-9a23-a1b275eaec2b.png#align=left&amp;display=inline&amp;height=323&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=468&amp;originWidth=627&amp;size=225297&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br /><a name="o0fAg"></a></p><h2 id="磁盘的物理地址"><a class="markdownIt-Anchor" href="#磁盘的物理地址"></a> 磁盘的物理地址</h2><p>磁盘的物理地址可以用（柱面号，盘面号，扇区号）来定位任意一个“磁盘块”。在“文件的物理结构”中所指代的文件数据存放在外存的块号可转换为（柱面号，盘面号，扇面号）的地址形式。<br />反之，也可以根据地质读取一个块：</p><ul><li>根据柱面号移动刺臂，让磁头指向指定的柱面。</li><li>激活指定盘面对应的磁头。</li><li>磁盘旋转的过程中，指定的磁区会从磁头下面划过，这样就完成了对指定扇区的读/写。<br /><a name="Kpj2f"></a></li></ul><h2 id="磁盘的分类"><a class="markdownIt-Anchor" href="#磁盘的分类"></a> 磁盘的分类</h2><p>磁盘按照磁头类型划分可以分为活动头磁盘和固定头磁盘，按照盘片分可以划分为可换盘磁盘和固定盘磁盘。<br />按照盘片分望文生义，暂不做解释。<br /><a name="VryLc"></a></p><h3 id="活动头磁盘"><a class="markdownIt-Anchor" href="#活动头磁盘"></a> 活动头磁盘</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599890967111-6a3844c7-ddb1-4cdc-8249-8966074fd076.png#align=left&amp;display=inline&amp;height=333&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=443&amp;originWidth=359&amp;size=163324&amp;status=done&amp;style=none&amp;width=270" alt="image.png" /><br /><a name="u93KE"></a></p><h3 id="固定头磁盘"><a class="markdownIt-Anchor" href="#固定头磁盘"></a> 固定头磁盘</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599890986014-80e55528-4e1e-4163-8f1f-2d1b208c8d03.png#align=left&amp;display=inline&amp;height=330&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=481&amp;originWidth=420&amp;size=165966&amp;status=done&amp;style=none&amp;width=288" alt="image.png" /><br /><a name="bElGf"></a></p><h1 id="磁盘调度算法"><a class="markdownIt-Anchor" href="#磁盘调度算法"></a> 磁盘调度算法</h1><p>在明确算法前，首先要了解如何计算一次磁盘读/写操作需要的时间。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599891211931-f2aad384-5647-4451-8eb2-c1cfcdf756dd.png#align=left&amp;display=inline&amp;height=228&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=336&amp;originWidth=350&amp;size=68409&amp;status=done&amp;style=none&amp;width=237" alt="image.png" /><br /><a name="yIvRE"></a></p><h2 id="耗时计算"><a class="markdownIt-Anchor" href="#耗时计算"></a> 耗时计算</h2><p>耗时计算拥有寻道时间、延迟时间、传输时间三个影响因素。<br />总的平均存取时间公式 Ta=Ts+1/2r+b/(rN)<br />其中，操作系统的磁盘调度算法会直接影响寻道时间。延迟时间和传输时间都与磁盘转速有关，且为线性相关。而转速是硬件的固有属性，因此操作系统无法优化延迟时间和传输时间。所以操作系统只能通过优化调度算法来优化寻道时间来减少耗时。<br /><a name="cdIRj"></a></p><h3 id="寻道时间"><a class="markdownIt-Anchor" href="#寻道时间"></a> 寻道时间</h3><p>寻道时间即在读/写数据前，将磁头移动到指定磁道所花费的时间。<br />寻道时间公式： Ts=s+m*n。<br />参数解释：</p><ul><li>启动磁头臂也是需要时间的，假设耗时为s</li><li>移动磁头也是需要一定时间的，假设磁头匀速转动，每跨越一个磁道耗时为m，总共需要跨越n条磁道。</li></ul><p>现在磁盘移动一个磁道大约耗时0.2s，磁盘启动时间大约为2ms。<br /><a name="iHQve"></a></p><h3 id="延迟时间"><a class="markdownIt-Anchor" href="#延迟时间"></a> 延迟时间</h3><p>延迟时间即通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为r（单位：转/秒，或转/分），则平均所需的延迟时间为TR=（1/2）*（1/r）=1/2r<br />参数解释：</p><ul><li>1/r就是转一圈需要的时间。找到目标扇区的平均需要转半圈因此再乘1/2。</li></ul><p>硬盘的典型转速为5400转/分，或7200转/分。<br /><a name="fdycd"></a></p><h3 id="传输时间"><a class="markdownIt-Anchor" href="#传输时间"></a> 传输时间</h3><p>传输时间即从磁盘读取或向磁盘写入数据所经历的时间。<br />传输时间公式：Tt=（1/r）*（b/N）=b/（rN）<br />参数解释：</p><ul><li>假设磁盘转速为r</li><li>此次读/写的字节数为b</li><li>每个磁道上的字节数为N</li><li>每个磁道要可存N字节的数据，因此b字节的数据需要b/N个磁道才能存储</li><li>读/写一个磁道所需的时间刚好又是转一圈所需要的时间1/r<br /><a name="CrDOI"></a></li></ul><h2 id="先来先去服务算法fcfs"><a class="markdownIt-Anchor" href="#先来先去服务算法fcfs"></a> 先来先去服务算法（FCFS）</h2><p>根据进程请求访问磁盘先后顺序进行调度。<br />假设磁头的初始位置为100号信道，有多个进程先后陆续的请求访问55、58、39、18、90、160、150、38、184号磁道。<br />按照FCFS的规则，按照请求到达的顺序，磁头需要一次移动到55、58、39、18、90、160、150、38、184号磁道。磁针运动轨迹如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599892624881-464008a7-4d87-4c8a-8d95-7f1d05c4e6e7.png#align=left&amp;display=inline&amp;height=106&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=187&amp;originWidth=762&amp;size=21860&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br />磁盘共移动了45+3+19+21+72+70+10+112+146+498个磁道。<br />响应一个请求平均需要移动498/9=55.3个磁道（平均寻道长度）<br />优点：公平，如果请求访问的磁道比较集中，算法性能还算良好。<br />缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间比较长。<br /><a name="9R8k7"></a></p><h2 id="最短寻找时间优先sstf"><a class="markdownIt-Anchor" href="#最短寻找时间优先sstf"></a> 最短寻找时间优先（SSTF）</h2><p>SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道地址最短，但是并不能保证总的寻道地址最短。（贪心算法的思想，只选当前最优，但未必是总体最优）<br />假设磁头的初始位置时100号磁道，有多个进程先后陆续的请求访问55、58、39、18、90、160、150、38、184号磁道。磁针运动轨迹如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599893481736-6d63e7c5-5112-4537-8b8c-afa8f82275ec.png#align=left&amp;display=inline&amp;height=90&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=139&amp;originWidth=666&amp;size=16795&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br />磁头总共移动了（100-18）+（184-18）=248个磁道<br />响应一个请求平均需要移动248/9=27.5个磁道（平均寻道长度）<br />优点：性能良好，平均寻道时间短。<br />缺点：可能产生“饥饿”现象（磁头在一个小区域来回移动，导致其他位置饥饿）<br /><a name="WobQw"></a></p><h2 id="扫描算法scan"><a class="markdownIt-Anchor" href="#扫描算法scan"></a> 扫描算法（SCAN）</h2><p>为了防止SSTF的饥饿产生，可以规定只有磁头移动到最外侧磁道时才能往内侧移动，移动到最内侧时才能往最外侧移动。这就是扫描算法的思想，其磁头移动的方式很像电梯，因此又称电梯算法。<br />假设某磁盘的磁道为0~200号，磁头的初始位置时100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续的请求访问55、58、39、18、90、160、150、38、184号磁道。磁针运动轨迹如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599893970828-a45ece52-9f78-4f2e-a538-3067747e707a.png#align=left&amp;display=inline&amp;height=94&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=143&amp;originWidth=806&amp;size=20385&amp;status=done&amp;style=none&amp;width=529" alt="image.png" /><br />磁头总共移动了（200-100）+（200-18）=282个磁道<br />响应一个请求平均需要移动282/9=31.3个磁道（平均寻找长度）<br />优点：性能良好，平均寻道时间比较短，不会产生饥饿。<br />缺点：</p><ul><li>只有到点了最边上的磁道才能够改变磁头的移动方向。事实上，处理了184号磁道的访问请求以后就不需要向右移动磁头了。</li><li>SCAN算法对于各个位置磁道的响应频率不平均（如：假设此时磁头正在往右移动，且刚处理过的90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离，而响应了184号磁道的请求后，很快又可以再次响应184号磁道请求了）<br /><a name="oJyM9"></a></li></ul><h2 id="look算法"><a class="markdownIt-Anchor" href="#look算法"></a> LOOK算法</h2><p>LOOK算法解决了SCAN算法只有到了最边上的磁道才能改变磁头移动方向的问题：如果磁头移动方向上已经没有别的请求就可以立即改变磁头移动方向。（边移动边观察，因此称作LOOK）<br />假设某磁盘的磁道为0~200号，磁头的初始位置时100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续的请求访问55、58、39、18、90、160、150、38184号磁道。磁针运动轨迹如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599894835528-bcbc28a3-445d-45ff-9f2a-cefe61cc8d3a.png#align=left&amp;display=inline&amp;height=103&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=149&amp;originWidth=845&amp;size=18728&amp;status=done&amp;style=none&amp;width=584" alt="image.png" /><br />磁针总共移动了（184-100）+（184-18）=250个磁道<br />响应一个请求平均需要移动250/9=27.5个磁道（平均寻道长度）<br />优点：比起SCAN算法，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短。<br /><a name="aTIh6"></a></p><h2 id="循环扫描算法c-scan"><a class="markdownIt-Anchor" href="#循环扫描算法c-scan"></a> 循环扫描算法（C-SCAN）</h2><p>SCAN算法对于各个位置磁道的响应频率不平均，而C-SCAN算法就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始段而不处理任何请求。<br />假设某磁盘的磁道为0~200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续的请求访问55、58、39、18、90、160、150、38、184号磁道。磁针运动轨迹如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599895200833-44e51f76-2747-4d10-aecc-54d64eef8c06.png#align=left&amp;display=inline&amp;height=149&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=211&amp;originWidth=899&amp;size=47830&amp;status=done&amp;style=none&amp;width=633" alt="image.png" /><br />磁头总共移动了（200-100）+（200-0）+（90-0）=390个磁道<br />响应一个请求平均需要移动390/9=43.3个磁道（平均寻道长度）<br />优点：比起SCAN，对于各个位置磁道的响应频率很平均。<br />缺点：只有到最边上的磁道才能改变磁头移动方向。事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了，并且，磁头返回时其实只需要返回18号磁道即可，不需要返回到最边远的磁道。另外，比起SCAN算法，平均寻道时间更长。<br /><a name="PrIR9"></a></p><h2 id="c-look调度算法"><a class="markdownIt-Anchor" href="#c-look调度算法"></a> C-LOOK调度算法</h2><p>C-SCAN的主要缺点是只有到达最边上的磁道时才能改变磁头移动的方向，并且磁头返回时不一定需要返回到最边缘的磁道上。C-LOOK算法就是为了解决这个问题。如果磁头移动的方向上已经没有磁道访问请求，这时就可以让磁头返回，并且磁头只需要返回到由此头访问请求的位置即可。<br />假设某磁盘的磁道为0~200号，磁头的初始位置为100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道。磁针运动轨迹如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599896035062-9974b184-cd52-4194-a1a0-ee25f2b68748.png#align=left&amp;display=inline&amp;height=119&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=179&amp;originWidth=899&amp;size=62149&amp;status=done&amp;style=none&amp;width=597" alt="image.png" /><br /><br /><br />磁头总共移动了（184-100）+（184-18）+（90-18）=322个磁道<br />响应一个请求平均需要移动322/9=35.8个磁道（平均寻道长度）<br />优点：比起C-SCAN算法，不需要每次都移动到最外侧或最内侧才能改变磁头方向，使寻道时间进一步缩短。<br /><a name="JihMs"></a></p><h1 id="减少延迟时间方法"><a class="markdownIt-Anchor" href="#减少延迟时间方法"></a> 减少延迟时间方法</h1><p>现有磁盘如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599896244398-d22a5ad1-2f90-4641-95b3-6332680d5552.png#align=left&amp;display=inline&amp;height=228&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=293&amp;originWidth=392&amp;size=63365&amp;status=done&amp;style=none&amp;width=305" alt="image.png" /><br />假设要连续读取橙色区域的2、3、4扇区。<br />磁头读取一块的内容（也就是一个扇区的内容）后，需要一小段时间处理，而盘片又在不停的旋转。<br />因此，如果2、3号扇区相邻着排列，则读完2号扇区后无法连续不断的读入3号扇区，必须等盘片继续旋转，3号扇区再次划过磁头才能完成扇区读入。<br />因此，磁头读入一个扇区数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区可能需要很长的延迟时间。<br /><a name="fR1u4"></a></p><h2 id="交替编号"><a class="markdownIt-Anchor" href="#交替编号"></a> 交替编号</h2><p>让逻辑上相邻的扇区在物理上有一定的时间间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599896937462-08b24e73-c097-4072-a7c5-a5033e2dc95e.png#align=left&amp;display=inline&amp;height=261&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=306&amp;originWidth=334&amp;size=60229&amp;status=done&amp;style=none&amp;width=285" alt="image.png" /><br /><a name="igw5S"></a></p><h2 id="地址结构设计"><a class="markdownIt-Anchor" href="#地址结构设计"></a> 地址结构设计</h2><p>关于为什么磁盘的物理地址是（柱面号，盘面号，扇区号）而不是（盘面号，柱面号，扇区号）：<br />假设某磁盘有8个柱面/磁道（假设最内侧柱面/磁道号为0），4个盘面，8个盘区，则可用3个二进制位表示柱面，2个二进制位表示盘面，3个二进制位表示扇面<br /><a name="js6Pm"></a></p><h3 id="盘面号柱面号扇区号"><a class="markdownIt-Anchor" href="#盘面号柱面号扇区号"></a> （盘面号，柱面号，扇区号）</h3><p>若物理地址的结构是（盘面号，柱面号，扇区号），且需要连续读取物理地址（00,000,000）<sub>（00,001,111）的扇区。（00,000,00）</sub>（00,000,111）转两圈可以读完，之后则需要再读取物理地址相邻的区域，即（00,001,000）~（00,001,111），需要启动磁头臂将磁头移动到下一个磁道。<br /><a name="QbJan"></a></p><h3 id="柱面号-盘面号-扇面号"><a class="markdownIt-Anchor" href="#柱面号-盘面号-扇面号"></a> （柱面号、盘面号、扇面号）</h3><p>若物理地址的结构是（柱面号、盘面号、扇面号），且需要连续读取物理地址（000,00,000）<sub>（000,01,111）的扇区。（000,00,000）</sub>（000,00,111）由盘面0的磁头读取数据之后再读取物理地址相邻的区域，即（000,01,000）~（000,01,111），由于柱面号/磁道号相同，只是盘面号不同，因此不需要移动磁头臂，只需要激活相邻盘面的磁头即可。<br /><a name="gwEFh"></a></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>综上所述，读取地址连续的磁盘块时，采用（柱面号、盘面号、扇面号）的地址结构可以减少磁头移动消耗的时间。<br /><a name="g9RU3"></a></p><h2 id="错位命名"><a class="markdownIt-Anchor" href="#错位命名"></a> 错位命名</h2><p><a name="cVb5A"></a></p><h3 id="不采用错位命名"><a class="markdownIt-Anchor" href="#不采用错位命名"></a> 不采用错位命名：</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599898080591-985d1ad9-494e-471c-85f2-450735d16a1e.png#align=left&amp;display=inline&amp;height=233&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=391&amp;originWidth=645&amp;size=134456&amp;status=done&amp;style=none&amp;width=385" alt="image.png" /><br />若相邻的盘面相对的位置相同处扇区编号相同，因为所有盘面都是连轴转的，因此会产生如下现象：<br />读取完磁盘块（000,00,111）之后，需要短暂的时间处理，而盘面又在不停的转动，因此当（000,01,000）第一次划过1号盘面的磁头下方时并不能读取数据，只能等待该扇区再次划过磁头。<br /><a name="TZQVy"></a></p><h3 id="错位命名后"><a class="markdownIt-Anchor" href="#错位命名后"></a> 错位命名后：</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599898312545-8f2ea97c-d4ab-472e-b5c3-a0998768c21b.png#align=left&amp;display=inline&amp;height=258&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=402&amp;originWidth=675&amp;size=136584&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br />由于采用了错位命名法，因此读取完磁盘块（000,00,111）之后还有一段时间处理，当（000,01,000）第一次划过1号盘面的磁头下方时就可以直接读取数据了，从而减少了延迟时间。<br /><a name="z7dQn"></a></p><h1 id="磁盘管理"><a class="markdownIt-Anchor" href="#磁盘管理"></a> 磁盘管理</h1><p><a name="ZQO0T"></a></p><h2 id="磁盘初始化"><a class="markdownIt-Anchor" href="#磁盘初始化"></a> 磁盘初始化</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599899024356-1b1fc37f-2fa6-4561-a013-0a45821ca811.png#align=left&amp;display=inline&amp;height=219&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=309&amp;originWidth=338&amp;size=52490&amp;status=done&amp;style=none&amp;width=240" alt="image.png" /><br />磁盘初始化有如下三个阶段：</p><ol><li>进行低级格式化（物理格式化），将磁盘的各个隧道划分为扇区，一个扇区通常可分为头、数据区域、尾三个部分。管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码（如奇偶校验、CRC循环冗余校验码等，校验码用于校验山区中的数据是否发生错误）</li><li>将磁盘分区，每个分区由若干柱面形成（即熟悉的C、D、E盘等）</li><li>进行逻辑格式化，创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、空闲分区表）<br /><a name="9CwzB"></a></li></ol><h2 id="引导块"><a class="markdownIt-Anchor" href="#引导块"></a> 引导块</h2><p>计算机开机时需要进行一些列初始化的工作，这些初始化工作是通过执行初始化程序（自举程序）完成的。<br />初始化程序可以放在ROM（只读存储器）中，但是ROM的数据在出厂时就已经写入了，并且以后不可以修改。ROM一般是出厂时就集成在主板上的。所以自举程序如果放在ROM中会很不方便。<br />为了解决上述问题，ROM只存放很小的“自举装入程序”，开启时计算机先运行“自举装入程序”，通过执行该程序就可以找到引导块并将完整的“自举程序”装入内存完成初始化、<br />而完整的自举程序会放在磁盘的启动块（即引导块/自动分区）上，启动块位磁盘的固定位置。拥有启动分区的磁盘称为启动磁盘或系统磁盘。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599899970244-376d03ae-b8c5-4c18-a26b-79a90120ac8e.png#align=left&amp;display=inline&amp;height=283&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=299&amp;originWidth=297&amp;size=54580&amp;status=done&amp;style=none&amp;width=281" alt="image.png" /><br /><a name="b9fJ7"></a></p><h2 id="坏块的管理"><a class="markdownIt-Anchor" href="#坏块的管理"></a> 坏块的管理</h2><p>坏掉、无法正常启动的扇区就是“坏块”，这属于硬件故障，操作系统是无法修复的，应该将坏块标记出来以免错误地使用到它。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599900092244-307ed40a-ed99-48ae-98cd-ae3fcfc69298.png#align=left&amp;display=inline&amp;height=255&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=296&amp;originWidth=299&amp;size=53452&amp;status=done&amp;style=none&amp;width=258" alt="image.png" /><br />对于简单的磁盘，可以再逻辑格式化时（建立文件系统时）对整个磁盘进行坏块检查，标明哪些扇区是坏扇区，比如：FAT表上注明。（在这种方式中，坏块对操作系统不透明）。<br />对于复杂的磁盘，磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表。<br />在磁盘出厂前进行低级格式化（物理格式化）时就将坏块链进行初始化。<br />会保留一些“备用扇区”用于替换坏块。这种方案称为扇区备用。且这种处理方式中，坏块对操作系统透明。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统之磁盘&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#操作系统之磁盘&quot;&gt;&lt;/a&gt; 操作系统之磁盘&lt;/h1&gt;
&lt;p&gt;&lt;a name=&quot;rEcV0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;磁盘的结构&quot;&gt;&lt;a class=&quot;markdow</summary>
      
    
    
    
    <category term="操作系统" scheme="https://jie-blog.icu/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://jie-blog.icu/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之文件系统</title>
    <link href="https://jie-blog.icu/posts/operating_system_file_system/"/>
    <id>https://jie-blog.icu/posts/operating_system_file_system/</id>
    <published>2020-09-15T11:27:17.000Z</published>
    <updated>2020-09-15T11:28:49.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统之文件系统"><a class="markdownIt-Anchor" href="#操作系统之文件系统"></a> 操作系统之文件系统</h1><p><a name="yYAyL"></a></p><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>文件——就是一组有意义的信息/数据集合。<br /><a name="PYlGN"></a></p><h2 id="文件属性"><a class="markdownIt-Anchor" href="#文件属性"></a> 文件属性</h2><ul><li>文件名：由创建文件的用户决定文件名，主要是为了方便用户找到文 件，同一目录下不允许有重名文件。</li><li>标识符：一个系统内的各文件标识 符唯一，对用户来说毫无可读性， 因此标识符只是操作系统用于区分 各个文件的一种内部名称。</li><li>类型：指明文件的类型</li><li>位置：文件存放的路径（让用户使用）、在外存中的地址（操作系统 使用，对用户不可见）</li><li>大小：指明文件大小</li><li>创建时间、上次修改时间</li><li>文件所有者信息</li><li>保护信息：对文件进行保护的访问控制信息<br /><a name="sgnOi"></a></li></ul><h2 id="文件组织形式"><a class="markdownIt-Anchor" href="#文件组织形式"></a> 文件组织形式</h2><p>无结构文件（如文本文件）——由一些二进制或字符流组成，又称“流式文件”<br />有结构文件（如数据库表）——由一组相似的记录组成，又称“记录式文件”<br /><a name="n2MY1"></a></p><h2 id="文件操作功能"><a class="markdownIt-Anchor" href="#文件操作功能"></a> 文件操作功能</h2><p>可用几个基本操作完成更复杂的操作，比如：“复制文件”： 先创建一个新的空文件，再把源文件读入内存，再将内存中的数据写到新文件中。<br /><a name="9bown"></a></p><h3 id="删除文件"><a class="markdownIt-Anchor" href="#删除文件"></a> 删除文件</h3><p>可以“删除文件”（点了“删除”之后， 图形化交互进程通过操作系统提供的 “删除文件”功能，即 delete 系统调用， 将文件数据从外存中删除）<br /><a name="FhswD"></a></p><h3 id="写文件"><a class="markdownIt-Anchor" href="#写文件"></a> 写文件</h3><p>可以“写文件”，将更改过的文件数据写回外存（在“记事本”应用程序中编辑文件内容，点击“保存”后， “记事本”应用程序通过操作系统提供 的“写文件”功能，即 write 系统调用， 将文件数据从内存写回外存）<br /><a name="0wWfA"></a></p><h3 id="读文件"><a class="markdownIt-Anchor" href="#读文件"></a> 读文件</h3><p>可以“读文件”，将文件数据读 内存，才能让CPU处理（双击后，“记事本”应用程序通过操作系统 提供的“读文件”功能，即 read 系 统调用，将文件数据从外存读入内存，并显示在屏幕上）<br /><a name="WtqpT"></a></p><h3 id="创建文件"><a class="markdownIt-Anchor" href="#创建文件"></a> 创建文件</h3><p>可以“创建文件”， （点击新建后，图形化交互进程在背后调 用了“create 系统调用”）<br /><a name="whzMl"></a></p><h3 id="打开文件"><a class="markdownIt-Anchor" href="#打开文件"></a> 打开文件</h3><p>读/写文件之前，需要“打开文件”<br /><a name="4HxXX"></a></p><h3 id="关闭文件"><a class="markdownIt-Anchor" href="#关闭文件"></a> 关闭文件</h3><p>读/写文件结束之后， 需要“关闭文件”<br /><a name="TWWBv"></a></p><h2 id="文件存储"><a class="markdownIt-Anchor" href="#文件存储"></a> 文件存储</h2><p>操作系统以“块”为单位为文件分配存储空间，因此即使一个文件大小只有10B，但它依然需要占用 1KB 的磁盘块。外存中的数据读入内存时同样以块为单位。<br />类似于内存分为一个个“内存块”，外存会分为一个个“块/磁盘块/物理 块”。每个磁盘块的大小是相等的，每块一般包含2的整数幂个地址（如 本例中，一块包含 210 个地址，即 1KB）。同样类似的是，文件的逻辑地址也可以分为（逻辑块号，块内地址），操作系统同样需要将逻辑地址转 换为外存的物理地址（物理块号，块内地址）的形式。块内地址的位数取 决于磁盘块的大小<br />与内存一样，外存也是由一个个存储单元组成的，每个存储单元可以 存储一定量的数据（如 1B）。每个 存储单元对应一个物理地址<br /><a name="mkRHl"></a></p><h2 id="文件管理功能"><a class="markdownIt-Anchor" href="#文件管理功能"></a> 文件管理功能</h2><p>文件共享：使多个用户可以共享使用一个文件<br />文件保护：如何保证不同的用户对文件有不同的操作权限<br /><a name="ljjXO"></a></p><h1 id="文件的逻辑结构"><a class="markdownIt-Anchor" href="#文件的逻辑结构"></a> 文件的逻辑结构</h1><p>所谓的“逻辑结构”，就是指在用户看来， 文件内部的数据应该是如何组织起来的。而 “物理结构”指的是在操作系统看来，文件的数据是如何存放在外存中的。<br />按文件是否有结构分类，可以分为无结构文件、有结构文件两种。 <br />根据有结构文件中的各 条记录在逻辑上如何组织，可以分为三类：顺序文件、索引文件、索引顺序文件。<br /><a name="uIfnX"></a></p><h2 id="按结构分"><a class="markdownIt-Anchor" href="#按结构分"></a> 按结构分</h2><p><a name="ENEQU"></a></p><h3 id="无结构文件"><a class="markdownIt-Anchor" href="#无结构文件"></a> 无结构文件</h3><p>无结构文件：文件内部的数据就是一系列二进制流或字符流组成。又称“流式文件”。如： Windows 操作系统中的 .txt 文件。<br />文件内部的数据其实就是一系列字符流，没有明显的结构特性。因此也不用探讨无结构文件的“逻辑结构”问题。<br /><a name="sW02f"></a></p><h3 id="有结构文件"><a class="markdownIt-Anchor" href="#有结构文件"></a> 有结构文件</h3><p>由一组相似的记录组成，又称“记录式文件”。每条记录又若干个数据项组成。如： 数据库表文件。一般来说，每条记录有一个数据项可作为关键字（作为识别不同记录的ID）。根据各条记录的长度（占用的 存储空间）是否相等，又可分为定长记录和可变长记录两种。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599826000748-1039a343-7e76-4ecd-9432-56a7fea55a56.png#align=left&amp;display=inline&amp;height=256&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=339&amp;originWidth=755&amp;size=192681&amp;status=done&amp;style=none&amp;width=571" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599826149433-bb0403f6-e99e-499c-82aa-740ec40dccf2.png#align=left&amp;display=inline&amp;height=266&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=310&amp;originWidth=435&amp;size=101725&amp;status=done&amp;style=none&amp;width=373" alt="image.png" /><br />这个有结构文件由可变长记录组成，由于各 个学生的特长存在很大区别，因此“特长” 这个数据项的长度不确定，这就导致了各条 记录的长度也不确定。当然，没有特长的学 生甚至可以去掉“特长”数据项。<br /><a name="OAr6n"></a></p><h2 id="按组织方式分"><a class="markdownIt-Anchor" href="#按组织方式分"></a> 按组织方式分</h2><p><a name="uvQ9g"></a></p><h3 id="顺序文件"><a class="markdownIt-Anchor" href="#顺序文件"></a> 顺序文件</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599826700883-18c2b9bd-ac4a-412f-83ea-fa56f7f0ed77.png#align=left&amp;display=inline&amp;height=84&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=139&amp;originWidth=661&amp;size=53855&amp;status=done&amp;style=none&amp;width=400" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599826495705-0eeef89e-8865-42a3-a690-c244f40d4d32.png#align=left&amp;display=inline&amp;height=124&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=179&amp;originWidth=794&amp;size=105315&amp;status=done&amp;style=none&amp;width=552" alt="image.png" /><br />文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。<br />定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取；若能再保证记录的顺序结构，则可实现快速检索 （即根据关键字快速找到对应记录）<br /><a name="WScKQ"></a></p><h4 id="顺序存储"><a class="markdownIt-Anchor" href="#顺序存储"></a> 顺序存储</h4><p>逻辑上相邻的记录 物理上也相邻（类似于顺序表）<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599826361798-f730b8f5-386e-4f6a-8ed7-a639f5a052a9.png#align=left&amp;display=inline&amp;height=32&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=44&amp;originWidth=310&amp;size=7548&amp;status=done&amp;style=none&amp;width=225" alt="image.png" /><br /><a name="4gLwF"></a></p><h4 id="链式存储"><a class="markdownIt-Anchor" href="#链式存储"></a> 链式存储</h4><p>逻辑上相邻 的记录物理上不一定相邻 （类似于链表）<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599826382338-43ba5d0b-6ade-4b22-891c-d088cbf90d26.png#align=left&amp;display=inline&amp;height=130&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=130&amp;originWidth=283&amp;size=10849&amp;status=done&amp;style=none&amp;width=283" alt="image.png" /><br /><a name="aW3qB"></a></p><h3 id="索引文件"><a class="markdownIt-Anchor" href="#索引文件"></a> 索引文件</h3><p>索引表本身是定长记录的顺序文件。因此可以快速找到第 i 个记录对应的索引项。 可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。 每当要增加/删除一个记录时，需要对索引表进行 修改。由于索引文件有很快的检索速度，因此主 要用于对信息处理的及时性要求比较高的场合。<br />另外，可以用不同的数据项建立多个索引表。如： 学生信息表中，可用关键字“学号”建立一张索 引表。也可用“姓名”建立一张索引表。这样就 可以根据“姓名”快速地检索文件了。<br /><a name="OhmvB"></a></p><h3 id="索引顺序文件"><a class="markdownIt-Anchor" href="#索引顺序文件"></a> 索引顺序文件</h3><p>索引文件每个记录对应一个索引表项，因此索引表可能会很大。 比如：文件的每个记录平均只占 8B，而每个索引表项占32个字节，那么索引 表都要比文件内容本身大4倍，这样对存储空间的利用率就太低了。<br />索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立 一张索引表，但不同的是：并不是每个记录对应一个索引表项，而是一组记录对应一个 索引表项<br />索引顺序文件的索引项也不需要按关键字顺序排列，这样可以极大地方便新表项的插入<br /><a name="sHCnW"></a></p><h4 id="检索效率分析"><a class="markdownIt-Anchor" href="#检索效率分析"></a> 检索效率分析</h4><p>若一个顺序文件有10000个记录，则根据关键字检索文件，只能从头开始顺序查找（这里指的并不是定长记录、顺序结构 的顺序文件），平均须查找 5000 个记录。 <br />若采用索引顺序文件结构，可把 10000 个记录分为 √10000 = 100 组，每组 100 个记录。则需要先顺序查找 索引表找到分组（共100个分组，因此索引表长度为 100，平均需要查 50 次），找到分组后，再在分组中 顺序查找记录（每个分组100 个记录，因此平均需要查 50 次）。可见，采用索引顺序文件结构后，平均查 找次数减少为 50+50 = 100 次。<br />若文件共有 10^6个记录，则可分为 1000 个分组，每个分组 1000 个记录。根据关键字检索一个记录 平均需要查找 500+500 = 1000 次。这个查找次数依然很多<br /><a name="X5Qeb"></a></p><h3 id="多级索引顺序文件"><a class="markdownIt-Anchor" href="#多级索引顺序文件"></a> 多级索引顺序文件</h3><p>为了进一步提高检索效率，可以为顺序文件建立多级索引表。例如，对于一个含 10^6个记录的文件，可先 为该文件建立一张低级索引表，每 100 个记录为一组，故低级索引表中共有 10000 个表项（即10000个定长 记录），再把这 10000 个定长记录分组，每组100个，为其建立顶级索引表，故顶级索引表中共有 100 个表项。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599827035523-19717f14-d0bf-4840-8ca0-fd4b7fb3038c.png#align=left&amp;display=inline&amp;height=249&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=338&amp;originWidth=858&amp;size=123521&amp;status=done&amp;style=none&amp;width=633" alt="image.png" /><br /><a name="gLArm"></a></p><h1 id="文件目录"><a class="markdownIt-Anchor" href="#文件目录"></a> 文件目录</h1><p>windows目录结构如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599832160265-5eaee9a3-084f-4f11-bda5-a81545c92583.png#align=left&amp;display=inline&amp;height=378&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=756&amp;originWidth=1200&amp;size=109914&amp;status=done&amp;style=none&amp;width=600" alt="image.png" /><br />这种结构的文件之间的组织结 构清晰，易于查找。编程时也可以很方便的用文件路径找到一个文件。<br />如： FILE *fp; fp=fopen(“F:\data\myfile.dat”); 用户可以轻松实现“按名存取”。<br /><a name="YEHAX"></a></p><h2 id="文件控制块"><a class="markdownIt-Anchor" href="#文件控制块"></a> 文件控制块</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599836889846-8bf15d90-d492-490b-8f38-edac0f9afdc1.png#align=left&amp;display=inline&amp;height=322&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=395&amp;originWidth=869&amp;size=223949&amp;status=done&amp;style=none&amp;width=708" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599839657564-0b1ad476-f4a2-45ec-9809-7a6e53034f78.png#align=left&amp;display=inline&amp;height=246&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=297&amp;originWidth=569&amp;size=76232&amp;status=done&amp;style=none&amp;width=472" alt="image.png" /><br />FCB 实现了文件名和文件之间的映射。使用户（用户程序）可以实现“按名存取”。<br />FCB 的有序集合称为“文件目录”，一个FCB就是一个文件目录项。 FCB 中包含了文件的基本信息（文件名、物理地址、逻辑结构、物理结构等），存取控制信息（是否可读/可写、禁止访问的用户名单等），使用信息（如文件的建立时间、修改时间等）。 最重要，最基本的还是 文件名、文件存放的物理地址。<br /><a name="rheDY"></a></p><h3 id="对目录常用的操作"><a class="markdownIt-Anchor" href="#对目录常用的操作"></a> 对目录常用的操作</h3><p>搜索：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项 <br />创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项<br />删除文件：当删除一个文件时，需要在目录中删除相应的目录项 <br />显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性 <br />修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项（如：文件重命名）<br /><a name="vn2NW"></a></p><h2 id="目录结构"><a class="markdownIt-Anchor" href="#目录结构"></a> 目录结构</h2><p><a name="iAGDt"></a></p><h3 id="单级目录结构"><a class="markdownIt-Anchor" href="#单级目录结构"></a> 单级目录结构</h3><p>早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项。单级目录实现了“按名存取”，但是不允许文件重名。 <br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599839899805-9130f735-8117-4062-a6c2-0b3e8385a3f7.png#align=left&amp;display=inline&amp;height=344&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=344&amp;originWidth=312&amp;size=38073&amp;status=done&amp;style=none&amp;width=312" alt="image.png" /><br />在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件 对应的目录项插入目录表中。 <br />显然，单级目录结构不适用于多用户操作系统。<br /><a name="img6o"></a></p><h3 id="两级目录结构"><a class="markdownIt-Anchor" href="#两级目录结构"></a> 两级目录结构</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599840346470-83950c43-d4d4-49ea-a281-8a1e1933f12f.png#align=left&amp;display=inline&amp;height=318&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=373&amp;originWidth=869&amp;size=162537&amp;status=done&amp;style=none&amp;width=742" alt="image.png" /><br />又称树形目录结构，早期的多用户操作系统，采用两级目录结构。分为主文件目录（MFD，Master File Directory）和用户文件目录（UFD，User Flie Directory）。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599840596104-c7142d0a-3fef-4015-9c5c-a17e5f3ab763.png#align=left&amp;display=inline&amp;height=158&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=244&amp;originWidth=792&amp;size=72734&amp;status=done&amp;style=none&amp;width=513" alt="image.png" /><br />用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串。各级目录之间 用“/”隔开。从根目录出发的路径称为绝对路径。 <br />例如：自拍.jpg 的绝对路径是 “/照片/2015-08/自拍.jpg” 系统根据绝对路径一层一层地找到下一级目录。刚开始从外存读入根目录的目录表；找到“照片”目录的 存放位置后，从外存读入对应的目录表；再找到“2015-08”目录的存放位置，再从外存读入对应目录表； <br />最后才找到文件“自拍.jpg”的存放位置。整个过程需要3次读磁盘I/O操作。 <br />很多时候，用户会连续访问同一目录内的多个文件（比如：接连查看“2015-08”目录内的多个照片文件）， 显然，每次都从根目录开始查找，是很低效的。因此可以设置一个“当前目录”。<br /><a name="MaeQM"></a></p><h4 id="当前目录"><a class="markdownIt-Anchor" href="#当前目录"></a> 当前目录</h4><p>例如，此时已经打开了“照片”的目录文件，也就是说，这张目录表已调入内存，那么可以把它设置为 “当前目录”。当用户想要访问某个文件时，可以使用从当前目录出发的“相对路径” 。 <br />在 Linux 中，“.”表示当前目录，因此如果“照片”是当前目录，则”自拍.jpg”的相对路径    为： “./2015-08/自拍.jpg”。从当前路径出发，只需要查询内存中的“照片”目录表，即可知道”2015-08”目录 表的存放位置，从外存调入该目录，即可知道“自拍.jpg”存放的位置了。<br />可见，引入“当前目录”和“相对路径”后，磁盘I/O的次数减少了。这就ᨀ升了访问文件的效率。<br />用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串。各级目录之间 用“/”隔开。从根目录出发的路径称为绝对路径。例如：自拍.jpg 的绝对路径是 “/照片/2015-08/自 拍.jpg” <br />每次都从根目录开始查找，是很低效的。因此可以设置一个“当前目录”。例如，此时已经打开了“照片” 的目录文件，也就是说，这张目录表已调入内存，那么可以把它设置为“当前目录”。当用户想要访问某 个文件时，可以使用从当前目录出发的“相对路径” 。 在 Linux 中，“.”表示当前目录，因此如果“照片”是当前目录，则”自拍.jpg”的相对路径为： “./2015-08/自拍.jpg”。<br />树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但 是，树形结构不便于实现文件的共享。为此，提出了“无环图目录结构”。<br /><a name="IYlxt"></a></p><h3 id="无环图目录结构"><a class="markdownIt-Anchor" href="#无环图目录结构"></a> 无环图目录结构</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599841753977-d91b6d18-d5a0-48a0-b46d-d7fc35e0e445.png#align=left&amp;display=inline&amp;height=220&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=302&amp;originWidth=861&amp;size=94833&amp;status=done&amp;style=none&amp;width=628" alt="image.png" /><br />可以用不同的文件名指向同一个文件，甚至可以指向同一个目录（共享同一目录下的所有内容）。 需要为每个共享结点设置一个共享计数器，用于记录此时有多少个地方在共享该结点。用户提出删除结 点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除共享结点。 只有共享计数器减为0时，才删除结点。 <br />注意：共享文件不同于复制文件。在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个 用户修改了文件数据，那么所有用户都可以看到文件数据的变化。<br /><a name="yPdJw"></a></p><h3 id="索引结点fcb的改进"><a class="markdownIt-Anchor" href="#索引结点fcb的改进"></a> 索引结点（FCB的改进）</h3><p>其实在查找各级目录的过程中 只需要用到“文件名”这个信 息，只有文件名匹配时，才需 要读出文件的其他信息。因此 可以考虑让目录表“瘦身”来 提升效率。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599841886489-25bd4c82-40d6-456e-b440-6445e9364f24.png#align=left&amp;display=inline&amp;height=156&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=205&amp;originWidth=506&amp;size=49959&amp;status=done&amp;style=none&amp;width=386" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599841929530-4fc756f9-a1bf-4900-8507-e34f8e3d9819.png#align=left&amp;display=inline&amp;height=143&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=206&amp;originWidth=532&amp;size=41272&amp;status=done&amp;style=none&amp;width=369" alt="image.png" /><br />假设一个FCB是64B，磁盘块的大 小为1KB，则每个盘块中只能存放 16个FCB。若一个文件目录中共有 640个目录项，则共需要占用 640/16 = 40 个盘块。因此按照某 文件名检索该目录，平均需要查 询320 个目录项，平均需要启动磁 盘20次（每次磁盘I/O读入一块）。<br />若使用索引结点机制，文件名占14B，索引结点指针站2B，则每 个盘块可存放64个目录项，那么按文件名检索目录平均只需要 读入 320/64 = 5 个磁盘块。显然，这将大大提升文件检索速度。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599842001580-8b83a93e-fc9b-4dab-87df-441455bd38ce.png#align=left&amp;display=inline&amp;height=163&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=221&amp;originWidth=519&amp;size=35388&amp;status=done&amp;style=none&amp;width=382" alt="image.png" /><br />当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括 文件在外存中的存放位置，根据“存放位置”即可找到文件。 <br />存放在外存中的索引结点称为“磁盘索引结点”，当索引结点放入内存后称为“内存索引结点”。 相比之下内存索引结点中需要增加一些信息，比如：文件是否被修改、此时有几个进程正在访问该文件 等。<br /><a name="sCZzl"></a></p><h1 id="文件的物理结构"><a class="markdownIt-Anchor" href="#文件的物理结构"></a> 文件的物理结构</h1><p>文件的物理结构即文件的分配方式，文件的分配方式又分为连续分配、链接分配和索引分配。<br />类似于内存分页，磁盘中的存储单元也会被分为一个个“块/磁盘块/物理块”。很多操作系统中，磁盘块的大小与内存块、页面的大小相同。内存与磁盘之间的数据交换（即 读/写操作、磁盘I/O）都是以 “块”为单位进行的。即每次读入一块，或每次写出一块。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599872068240-9d79eff4-100f-44b0-bacf-9e4eec562ad5.png#align=left&amp;display=inline&amp;height=260&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=369&amp;originWidth=708&amp;size=97204&amp;status=done&amp;style=none&amp;width=498" alt="image.png" /><br />在内存管理中，进程的逻辑地址空间被分为一个一个页面。同样的，在外存管理中，为了方便对文件数据的管理，文件的逻辑地 址空间也被分为了一个一个的文件“块”。 于是文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式。<br /><a name="fTAgH"></a></p><h2 id="连续分配"><a class="markdownIt-Anchor" href="#连续分配"></a> 连续分配</h2><p>连续分配方式要求每个文件在磁盘上占有一组连续的块。<br />用户给出要访问的逻辑块号，操作系统 找到该文件对应的目录项（FCB）… 物理块号 = 起始块号 + 逻辑块号 当然，还需要检查用户提供的逻辑块号 是否合法（逻辑块号 ≥长度就不合法）。可以直接算出逻辑块号对应的物理 块号，因此连续分配支持顺序访问和直接访问（即随机访问）<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599872280037-7913642b-cccc-4afc-ab72-12f6b2a64e63.png#align=left&amp;display=inline&amp;height=267&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=398&amp;originWidth=539&amp;size=74483&amp;status=done&amp;style=none&amp;width=362" alt="image.png" /><br />读取某个磁盘块时，需要移动磁头。访问的两个磁 盘块相隔越远，移动磁头所需时间就越长。因此，连续分配的文件在顺序读/写时速度最快。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599872372104-946bd88b-2cf8-41c1-8487-eba23b2a785b.png#align=left&amp;display=inline&amp;height=280&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=382&amp;originWidth=589&amp;size=66564&amp;status=done&amp;style=none&amp;width=432" alt="image.png" /><br />若此时文件A要拓展，需要再增加一个磁盘块（总共需要连续的4个磁盘块）。 由于采用连续结构，因此文件A占用的磁盘块必须是连续的。 因此只能将文件A全部“迁移”到绿色区域。 所以，物理上采用连续分配的文件不方便拓展。<br /><a name="XMfy0"></a></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599872475326-28e5236a-5775-4c9f-acce-e9fdd4c7e533.png#align=left&amp;display=inline&amp;height=246&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=346&amp;originWidth=510&amp;size=47788&amp;status=done&amp;style=none&amp;width=362" alt="image.png" /><br />物理上采用连续分配， 存储空间利用率低，会产生 难以利用的磁盘碎片 可以用紧凑来处理碎片，但 是需要耗费很大的时间代价。<br />优点：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快 <br />缺点：不方便文件拓展；存储空间利用率低，会产生磁盘碎片<br /><a name="go5cQ"></a></p><h2 id="链接分配"><a class="markdownIt-Anchor" href="#链接分配"></a> 链接分配</h2><p>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。其又分为隐式链接和显式链接两种。<br /><a name="auGlx"></a></p><h3 id="隐式链接"><a class="markdownIt-Anchor" href="#隐式链接"></a> 隐式链接</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599872682048-d0845a64-bf01-4eda-9fe5-a0838c9d9dd5.png#align=left&amp;display=inline&amp;height=306&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=436&amp;originWidth=490&amp;size=102502&amp;status=done&amp;style=none&amp;width=344" alt="image.png" /><br />用户给出要访问的逻辑块号 i，操作系统找到该文件对应的目录项（FCB），从目录项中找到起始块号（即0号块），将0号逻辑块读入内存，由此知道1号逻辑块存放的物理块号，于是读入1号逻辑块，再找到2号逻辑块的存放位置，以此类推。 因此，读入i号逻辑块，总共需要 i+1 次磁盘 I/O。<br />采用链式分配（隐式链接）方式的文件，只支持顺序访问，不支持随机访问，查 找效率低。另外，指向下一个盘块的指针也 需要耗费少量的存储空间。<br />若此时要拓展文件，则可以随便 找一个空闲磁盘块，挂到文件的 磁盘块链尾，并修改文件的FCB，因此采用隐式链接的链接分配方式，很方便文件拓展。 另外，所有的空闲磁盘块都可以被利用，不会有碎片问题， 外存利用率高。<br /><a name="thOYg"></a></p><h4 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h4><p>除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录 包括文件第一块的指针和最后一块的指针。<br />优点：很方便文件拓展，不会有碎片问题，外存利用率高。 <br />缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量 的存储空间。<br /><a name="d4Tgz"></a></p><h3 id="显式链接"><a class="markdownIt-Anchor" href="#显式链接"></a> 显式链接</h3><p>把用于链接文件各物理块的指针显式地存放在一张表中。即 文件分配表（FAT，File Allocation Table）。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599872943166-cab1f85e-3a83-4fd8-ba34-642f3ec3b1f6.png#align=left&amp;display=inline&amp;height=309&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=418&amp;originWidth=528&amp;size=64881&amp;status=done&amp;style=none&amp;width=390" alt="image.png" /><br /><br /><br />假设某个新创建的文件“aaa”依 次存放在磁盘块 2-&gt;5-&gt;0-&gt;1 <br />假设某个新创建的文件“bbb”依次存放在磁盘块 4-&gt;23-&gt;3<br />注意：一个磁盘仅设置一张FAT。 开机时，将FAT读入内存，并常驻 内存。 FAT 的各个表项在物理上 连续存储，且每一个表项长度相 同，因此“物理块号”字段可以 是隐含的。<br />用户给出要访问的逻辑块号 i，操作系统找到该文件对应的目录项 （FCB），从目录项中找到起始块号，若i&gt;0，则查询内存中的文件分配表FAT， 往后找到 i 号逻辑块对应的物理块号。逻辑块号转换成物理块号的过 程不需要读磁盘操作。<br />采用链式分配（显式链接）方式的文件，支持顺序访问，也支 持随机访问（想访问 i 号逻辑块时，并不需要依次访问之前的 0 ~ i-1 号逻辑块），由于块号转换的过程不需要访问磁盘，因此相比于隐式 链接来说，访问速度快很多。<br />显然，显式链接也不会产生外部碎片，也可以很方便地对文件进行拓 展。<br /><a name="mYtdo"></a></p><h4 id="总结-3"><a class="markdownIt-Anchor" href="#总结-3"></a> 总结</h4><p>把用于链接文件各物理块的指针显式地存放在一张表中，即 文件分配表（FAT，File Allocation Table）。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内存。<br />优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接 来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。 <br />缺点：文件分配表的需要占用一定的存储空间。<br /><a name="9HHKW"></a></p><h2 id="索引分配"><a class="markdownIt-Anchor" href="#索引分配"></a> 索引分配</h2><p>索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文 件的各个逻辑块对应的物理块（索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间 的映射关系）。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599873449525-d3c63abe-0a39-4a00-9650-64ff1f087c05.png#align=left&amp;display=inline&amp;height=286&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=367&amp;originWidth=523&amp;size=86521&amp;status=done&amp;style=none&amp;width=407" alt="image.png" /><br />假设某个新创建的文件“aaa”的数据依次存放在磁盘块 2-&gt;5-&gt;13-&gt;9 。 7号磁盘块作为“aaa”的索引块， 索引块中保存了索引表的内容。 <br />注：在显式链接的链式分配方式中，文 件分配表FAT 是一个磁盘对应一张。而 索引分配方式中，索引表是一个文件对 应一张。<br />可以用固定的长度表示物理块号（如： 假设磁盘总容量为1TB=240B，磁盘块大 小为1KB，则共有 230个磁盘块，则可用 4B 表示磁盘块号），因此，索引表中 的“逻辑块号”可以是隐含的。<br />用户给出要访问的逻辑块号 i，操作系统找 到该文件对应的目录项（FCB）,从目录项中可知索引表存放位置，将索引表 从外存读入内存，并查找索引表即可只 i 号 逻辑块在外存中的存放位置。<br />可见，索引分配方式可以支持随机访问。 文件拓展也很容易实现（只需要给文件分配 一个空闲块，并增加一个索引表项即可） 但是索引表需要占用一定的存储空间。<br />若每个磁盘块1KB，一个索 引表项4B，则一个磁盘块只 能存放 256 个索引项。如果一个文件的大小超过了256 块，那么一个磁盘块是装不下 文件的整张索引表的，因此引出了链接方案、多层索引、混合索引的解决方案。<br /><a name="YN9Wb"></a></p><h3 id="链接方案"><a class="markdownIt-Anchor" href="#链接方案"></a> 链接方案</h3><p>如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599873745310-6e5bcaa6-f981-4f1a-8bae-04104575e801.png#align=left&amp;display=inline&amp;height=292&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=386&amp;originWidth=512&amp;size=50281&amp;status=done&amp;style=none&amp;width=387" alt="image.png" /><br />假设磁盘块大小为1KB，一个索引表 项占4B，则一个磁盘块只能存放256 个索引项。 <br />若一个文件大小为 256<em>256KB = 65,536 KB = 64MB 该文件共有 256</em>256 个块，也就对应 256*256个索引项，也就需要 256 个 索引块来存储，这些索引块用链接方案连起来。<br />若想要访问文件的最后一个逻辑块， 就必须找到最后一个索引块（第256 个索引块），而各个索引块之间是用 指针链接起来的，因此必须先顺序地 读入前 255 个索引块。<br /><a name="ibefz"></a></p><h3 id="多层索引"><a class="markdownIt-Anchor" href="#多层索引"></a> 多层索引</h3><p>建立多层索引（原理类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据 文件大小的要求再建立第三层、第四层索引块。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599873865528-4f3bdfb6-88c3-455f-9764-22b233a3a3af.png#align=left&amp;display=inline&amp;height=366&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=389&amp;originWidth=442&amp;size=61051&amp;status=done&amp;style=none&amp;width=416" alt="image.png" /><br />假设磁盘块大小为1KB，一个索引表项占4B，则一个 磁盘块只能存放256 个索引项。 <br />若某文件采用两层索引，则该文件的最大长度可以到 256<em>256</em>1KB = 65,536 KB = 64MB 可根据逻辑块号算出应该查找索引表中的哪个表项。 如：要访问 1026 号逻辑块，则 1026/256 = 4，1026%256 = 2 <br />因此可以先将一级索引表调入内存，查询 4 号表项， 将其对应的二级索引表调入内存，再查询二级索引表 的2号表项即可知道 1026 号逻辑块存放的磁盘块号了。 访问目标数据块，需要3次磁盘I/O。采用 K 层索引结构，且顶级索引表未调入 内存，则访问一个数据块只需要 K + 1 次 读磁盘操作。<br />若采用三层索引，则文件的最大长度为 256<em>256</em>256*1KB = 16GB 类似的，访问目标数据块，需要4次磁盘I/O。<br /><a name="CUoxX"></a></p><h3 id="混合索引"><a class="markdownIt-Anchor" href="#混合索引"></a> 混合索引</h3><p>多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接 指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表） 。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599874002172-45342705-242d-43fc-b462-cb24fcd9ddf5.png#align=left&amp;display=inline&amp;height=235&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=362&amp;originWidth=668&amp;size=43963&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br />这种结构的索引支持的最大文件长度为65800KB。<br /><a name="Sn2SQ"></a></p><h2 id="总结-4"><a class="markdownIt-Anchor" href="#总结-4"></a> 总结</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599874094352-0c171eeb-704c-41c7-bebd-d8f7a4fc39a6.png#align=left&amp;display=inline&amp;height=237&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=349&amp;originWidth=835&amp;size=256474&amp;status=done&amp;style=none&amp;width=568" alt="image.png" /><br />“文件的某种逻辑结构支持随机存取/随机访问”是指：采用 这种逻辑结构的文件，可以根据记录号直接算出该记录对应 的逻辑地址 （逻辑块号，块内地址）。<br /><a name="bsSDz"></a></p><h1 id="文件的存储空间管理"><a class="markdownIt-Anchor" href="#文件的存储空间管理"></a> 文件的存储空间管理</h1><p>安装操作系统的必经步骤就是磁盘分区，即存储空间的划分，将物理地址划分为一个个的文件卷（逻辑卷、逻辑盘）。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599874318211-32cdb647-bc74-4390-8608-06b0caac7272.png#align=left&amp;display=inline&amp;height=222&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=309&amp;originWidth=764&amp;size=84226&amp;status=done&amp;style=none&amp;width=550" alt="image.png" /><br /><a name="131up"></a></p><h2 id="空闲表法"><a class="markdownIt-Anchor" href="#空闲表法"></a> 空闲表法</h2><p>该方法适用于连续分配方式的存储空间管理。<br />与内存管理中的动态分区分配类似，唯一个文件分配连续的存储空间，同样可以采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个分区。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599874544520-b34c12cc-63b9-4d26-93bf-48e685964921.png#align=left&amp;display=inline&amp;height=244&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=312&amp;originWidth=711&amp;size=58263&amp;status=done&amp;style=none&amp;width=556" alt="image.png" /><br /><a name="vRUbT"></a></p><h2 id="空闲链表法"><a class="markdownIt-Anchor" href="#空闲链表法"></a> 空闲链表法</h2><p>操作系统保存着链头、链尾指针。<br />若文件申请K个盘块，则可以采用首次适应、最佳适应等算法从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区分配给文件。若没有适合的连续空闲块也可以将不同盘区的潘快同时分配给一个文件，注意分配后可能需要修改相应的链指针、盘区大小等数据。<br />若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为一个单独的空闲盘区挂在链尾。<br />空闲链表又可以分为空闲盘块链、空闲盘区链。<br /><a name="pExGi"></a></p><h3 id="空闲盘块链"><a class="markdownIt-Anchor" href="#空闲盘块链"></a> 空闲盘块链</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599874668487-4ca972fa-529b-4e44-98e2-106dc971d67b.png#align=left&amp;display=inline&amp;height=287&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=300&amp;originWidth=261&amp;size=35961&amp;status=done&amp;style=none&amp;width=250" alt="image.png" /><br /><a name="00D3I"></a></p><h3 id="空闲盘区链"><a class="markdownIt-Anchor" href="#空闲盘区链"></a> 空闲盘区链</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599874679352-d94a93e8-0f10-4899-8f0b-8144e2fd1e6f.png#align=left&amp;display=inline&amp;height=305&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=308&amp;originWidth=367&amp;size=50185&amp;status=done&amp;style=none&amp;width=364" alt="image.png" /><br /><a name="OZdXd"></a></p><h3 id="位示图法"><a class="markdownIt-Anchor" href="#位示图法"></a> 位示图法</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599875375451-2ef28de0-192f-493e-90fb-c6a52dac6c5c.png#align=left&amp;display=inline&amp;height=273&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=407&amp;originWidth=717&amp;size=72374&amp;status=done&amp;style=none&amp;width=481" alt="image.png" /><br />每个二进制对应一个盘块，在本例中，0代表盘块空闲，1代表盘块已分配。位示图一般用连续的字来表示。如本例中一个字的字长为16位，字中的每一位对应一个盘块。因此可以用（字号，位号）对应一个盘块号。<br />（字号，位号）=（i，j）的二进制位对应的盘块号b=ni+j<br />b盘块对应的字号i=b/n，位号j=b%n<br />若文件需要K个块，则按照以下步骤进行分配：</p><ol><li>顺序扫描位示图，找到K个相邻或不相邻的0</li><li>根据字号、位图算出对应的盘块号，将相应盘块号分配给文件</li><li>将相应位设置为1</li></ol><p>回收方式按照以下步骤进行：</p><ol><li>根据回收的盘位号计算出相应的字号、位号。</li><li>将响应二进制位设为0<br /><a name="gjEuw"></a></li></ol><h2 id="成组链接法"><a class="markdownIt-Anchor" href="#成组链接法"></a> 成组链接法</h2><p>空闲链表法、空闲表法不适用于大型文件系统，因为空闲表或空闲链表可能过大，UNIX采用了成组链接法对磁盘的空闲块进行管理。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599875777382-7e01c0fc-3ff9-49c7-8cc4-30dd4c36413c.png#align=left&amp;display=inline&amp;height=206&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=240&amp;originWidth=307&amp;size=16712&amp;status=done&amp;style=none&amp;width=264" alt="image.png" /><br />文件卷的目录中专门用一个磁盘块作为超级块，当系统启动时，需要将超级块读入内存，并且要保证内存与外存的超级快数据一致。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599875917323-5775ce11-7770-4664-b1b8-6f6738b219be.png#align=left&amp;display=inline&amp;height=241&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=376&amp;originWidth=675&amp;size=63294&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br />如果需要100个空闲块，会按照以下步骤进行分配：</p><ol><li>检查第一个分组的块数是否足够，100=100则为足够。</li><li>分配第一个分组的100个空闲块，然是由于300号快内存放了下一组信息，因此300好快的数据需要复制到超级块中。</li></ol><p>如果每个分组最到位100个空闲块，此时第一个分组已经拥有100个块还要回收，需要将超级快中的数据复制到新的回收快中，并修改超级块的内容，让新的块成为第一个分组。<br /><a name="PsOIf"></a></p><h1 id="文件的基本操作"><a class="markdownIt-Anchor" href="#文件的基本操作"></a> 文件的基本操作</h1><p>文件的基本操作分为如下几个功能：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599876232679-2ae6cae6-e233-4215-a073-dbe327016e9e.png#align=left&amp;display=inline&amp;height=202&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=404&amp;originWidth=364&amp;size=97437&amp;status=done&amp;style=none&amp;width=182" alt="image.png" /><br /><a name="mv3Fb"></a></p><h2 id="创建文件-2"><a class="markdownIt-Anchor" href="#创建文件-2"></a> 创建文件</h2><p>电脑上可以通过如下操作进行创建文件：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599876395511-f50411e4-82bf-48a4-b66d-3f3e2aaf073b.png#align=left&amp;display=inline&amp;height=281&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=562&amp;originWidth=770&amp;size=483918&amp;status=done&amp;style=none&amp;width=385" alt="image.png" /><br />在进行Create系统调用时需要提供如下几个参数：</p><ul><li>所需的内存空间大小</li><li>文件存放路径</li><li>文件名</li></ul><p>其在创建文件时，主要进行了如下两个操作：</p><ul><li>在外存中找到文件所需的空间（结合空闲链表法、位示图、成组链接法等管理策略）</li><li>根据文件存放路径的信息找到该目录对应的目录文件，在目录中创建该文件对应的目录项。目录项中包含了文件名、文件在外存中存放位置等信息。<br /><a name="GpvRc"></a></li></ul><h2 id="删除文件-2"><a class="markdownIt-Anchor" href="#删除文件-2"></a> 删除文件</h2><p>电脑上可以通过如下操作进行删除文件：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599876906859-18144f00-0415-4106-a3c5-5bd4b52a7d4f.png#align=left&amp;display=inline&amp;height=332&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=663&amp;originWidth=366&amp;size=35809&amp;status=done&amp;style=none&amp;width=183" alt="image.png" /><br />进行Delete系统调用时，需要提供几个主要参数：</p><ul><li>文件存放路径</li><li>文件名</li></ul><p>在Delete系统调用时，主要做了如下几件事：</p><ul><li>根据文件存放路径找到对应的目录文件，从目录中找到文件名对应的目录项。</li><li>根据该目录项记录的文件在外村存放位置、文件大小等信息，回收文件占用的磁盘块。（根据空闲表法、空闲链表法、位图法等管理策略的不同做出不同的处理）</li><li>从目录中删除文件对应的目录项。<br /><a name="ddRqH"></a></li></ul><h2 id="打开文件-2"><a class="markdownIt-Anchor" href="#打开文件-2"></a> 打开文件</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599877278097-31bcb91c-dec2-40d7-aad8-3aad46673b88.png#align=left&amp;display=inline&amp;height=328&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=468&amp;originWidth=593&amp;size=78386&amp;status=done&amp;style=none&amp;width=416" alt="image.png" /><br />执行Open系统调用打开文件，需要以下几个主要参数：</p><ul><li>文件存放路径</li><li>文件名</li><li>文件的操作类型（r：只读，rw：读写等）</li></ul><p>操作系统在调用函数时，主要做了以下几件事：</p><ul><li>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项，并检查该用户是否由指定的操作权限。</li><li>将目录项复制到内存中的打开文件表中。并将对应表中的编号返回给用户，之后用户使用打开文件表的编号来指明操作的文件。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599877557471-ccfcda6f-b58a-439e-b4eb-b57256658e92.png#align=left&amp;display=inline&amp;height=343&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=498&amp;originWidth=846&amp;size=217312&amp;status=done&amp;style=none&amp;width=583" alt="image.png" /><br /><a name="MRP07"></a></p><h2 id="关闭文件-2"><a class="markdownIt-Anchor" href="#关闭文件-2"></a> 关闭文件</h2><p>关闭文件主要做了以下几件事：</p><ul><li>将进程的打开文件表响应表项删除</li><li>回收分配给该文件的内存空间等资源</li><li>系统打开文件表的打开计数器count减一，若count=0，则删除对应表项。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599877720626-32def3cd-fee3-46fb-abec-3c4152ca2e62.png#align=left&amp;display=inline&amp;height=243&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=485&amp;originWidth=822&amp;size=102753&amp;status=done&amp;style=none&amp;width=411" alt="image.png" /><br /><a name="vQIgN"></a></p><h2 id="读文件-2"><a class="markdownIt-Anchor" href="#读文件-2"></a> 读文件</h2><p>系统的read调用完成写操作，需要指明是哪个文件、读入多少数据和药存放的内存位置即可。<br />系统在处理read系统调用时，会从读指针指向外存中，将用户指定大小的数据读入用户指定的内存区域中。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599877869415-04db04ce-6c5f-4a42-953d-99fdd2578097.png#align=left&amp;display=inline&amp;height=322&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=430&amp;originWidth=771&amp;size=118038&amp;status=done&amp;style=none&amp;width=578" alt="image.png" /><br /><a name="LGx5w"></a></p><h2 id="写文件-2"><a class="markdownIt-Anchor" href="#写文件-2"></a> 写文件</h2><p>进程使用write完成写操作，需要指明是哪个文件、写出多少数据和写回外存的数据放在内存的位置即可。<br />操作系统在处理write系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599878054614-65c3fc38-48c4-476d-a1df-5029e8dd26db.png#align=left&amp;display=inline&amp;height=298&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=426&amp;originWidth=736&amp;size=120887&amp;status=done&amp;style=none&amp;width=515" alt="image.png" /><br /><a name="SDVum"></a></p><h1 id="文件共享"><a class="markdownIt-Anchor" href="#文件共享"></a> 文件共享</h1><p>系统为用户提供文件共享功能，可以让多个用户共享的使用同一个文件。<br />注意：</p><ul><li>多个用户共享同一个文件，意味着系统中只有一份文件数据，并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化。</li><li>如果是多个用户都复制了同一个文件，那么系统中会有好几分文件数据，其中一个用户修改了自己那份数据对其他用户没有影响。</li></ul><p>文件共享分为基于索引节点的共享方式（硬链接）和基于符号链的共享方式（软链接）。<br /><a name="n0Yv6"></a></p><h2 id="基于索引节点的共享方式"><a class="markdownIt-Anchor" href="#基于索引节点的共享方式"></a> 基于索引节点的共享方式</h2><p>索引节点是一种文件目录瘦身策略，由于索引文件时只需用到文件名，因此可以将除了文件名以外的其他信息放到索引节点中。这样目录项只需要包含文件名、索引节点指针。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599878416647-08497fe2-d547-4e64-8b27-eb8d5790185e.png#align=left&amp;display=inline&amp;height=143&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=220&amp;originWidth=809&amp;size=47896&amp;status=done&amp;style=none&amp;width=527" alt="image.png" /><br />索引节点中设置一个连接计数变量count，用于标识链接到本索引节点上的用户目录项数。<br />若count=2，说明此事有两个用户目录项连接到该索引节点上，或者说有两个用户在共享此文件，若某个用户决定删除这个文件，则只要把用户目录中与该文件对应的目录项删除，则索引节点的count减一。<br />若count&gt;0，说明还有别的用户使用该文件，则不能删除文件数据，否则会导致指针悬空。<br />当count=0时说明系统负责删除文件。<br /><a name="dvJ9P"></a></p><h2 id="基于符号链的共享方式"><a class="markdownIt-Anchor" href="#基于符号链的共享方式"></a> 基于符号链的共享方式</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599878722831-12631b1f-4c86-4b5a-a6a7-8daddc2b1638.png#align=left&amp;display=inline&amp;height=247&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=357&amp;originWidth=802&amp;size=104581&amp;status=done&amp;style=none&amp;width=554" alt="image.png" /><br />当User3访问ccc时，操作系统判断文件ccc属于Link类型文件，于是会根据其中的记录路径层层查找目录，最终找到User1的目录表中的aaa表项，于是就找到了文件1的索引信道。<br />所谓的快捷方式就是软链接的表现。<br /><a name="1Kg9x"></a></p><h1 id="文件保护"><a class="markdownIt-Anchor" href="#文件保护"></a> 文件保护</h1><p>文件保护用来保护文件的数据安全，其分为口令保护、加密保护、访问控制。<br /><a name="WMPtV"></a></p><h2 id="口令保护"><a class="markdownIt-Anchor" href="#口令保护"></a> 口令保护</h2><p>为文件设置一个口令，用户请求访问该文件时必须提供口令。<br />口令一般存放在文件对应的FCB或索引节点中，用户访问文件前需要先输入口令，操作系统会将用户提供的口令与FCB中存储的口令进行对比，如果正确则允许用户访问文件。<br />优点：保存口令的空间开销并不多，验证口令的开销也很少。<br />缺点：正确的口令存放在系统内部不够安全。<br /><a name="Tn26d"></a></p><h2 id="加密保护"><a class="markdownIt-Anchor" href="#加密保护"></a> 加密保护</h2><p>使用某个密码对文件进行加密，再访问文件时需要提供正确的密码才能对文件正确的解密，常用的加密算法：异或加密。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599879185234-846c4306-7c0d-4a94-806d-7aa6b745e520.png#align=left&amp;display=inline&amp;height=162&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=226&amp;originWidth=722&amp;size=63487&amp;status=done&amp;style=none&amp;width=519" alt="image.png" /><br />优点：保密性强，不需要在系统中存储密码。<br />缺点：编解码花费时间较长。<br /><a name="HmLZZ"></a></p><h2 id="访问控制"><a class="markdownIt-Anchor" href="#访问控制"></a> 访问控制</h2><p>在每个文件的FCB或索引节点中增加一个访问控制列表，该表中记录了个用户可对用户执行哪些操作。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599879310154-1176e305-3a4a-43e0-abf2-7b530ebfa37e.png#align=left&amp;display=inline&amp;height=201&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=287&amp;originWidth=733&amp;size=97478&amp;status=done&amp;style=none&amp;width=513" alt="image.png" /><br />精简的访问列表以组为单位，标记各族用户可以对用户执行哪些操作。当某用户想要访问文件时，系统会检查用户所属文组来确定是否有相应的权限。<br /><a name="xYIV9"></a></p><h1 id="系统的层次结构总结"><a class="markdownIt-Anchor" href="#系统的层次结构总结"></a> 系统的层次结构总结</h1><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599879466091-a204042b-a0c4-4cfe-9cab-a8949956837f.png#align=left&amp;display=inline&amp;height=329&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=369&amp;originWidth=754&amp;size=206236&amp;status=done&amp;style=none&amp;width=672" alt="image.png" /><br />举个理解来回忆文件系统的层次结构，假设用户请求删除文件“D:/表格/学生信息表.xlsx”的最后100条记录。</p><ul><li>用户需要通过操作系统系统提供的接口发出上述请求——用户接口</li><li>由于用户提供的是文件的存放路径，因此需要操作系统一层一层的查找目录找到对应的目录项——文件目录系统</li><li>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限——存取控制模块（存取控制验证层）</li><li>验证了用户的访问权限之后，需要把用户提供的记录号转变为对应的逻辑地址——逻辑文件系统与文件信息缓冲区</li><li>知道了目标记录的逻辑地址后，需要转换成实际的物理地址——物理文件系统</li><li>要删除这条记录，必定要对磁盘设备发出请求——设备管理程序模块</li><li>删除这些记录后，会有一些盘块空闲，因此要对这些盘块进行回收——辅助分配模块</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统之文件系统&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#操作系统之文件系统&quot;&gt;&lt;/a&gt; 操作系统之文件系统&lt;/h1&gt;
&lt;p&gt;&lt;a name=&quot;yYAyL&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a class=&quot;mark</summary>
      
    
    
    
    <category term="操作系统" scheme="https://jie-blog.icu/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://jie-blog.icu/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之虚拟内存</title>
    <link href="https://jie-blog.icu/posts/operating_system_virtual_memory/"/>
    <id>https://jie-blog.icu/posts/operating_system_virtual_memory/</id>
    <published>2020-09-15T11:24:33.000Z</published>
    <updated>2020-09-15T11:26:58.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统之虚拟内存"><a class="markdownIt-Anchor" href="#操作系统之虚拟内存"></a> 操作系统之虚拟内存</h1><p><a name="1cKIp"></a></p><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>在之前的内存管理的内存空间扩充知识点里提及到了覆盖技术、交换技术和虚拟存储技术。这里的虚拟存储技术就是在传统存储管理方式的基础上引入了交换技术、覆盖技术，使得内存利用率有所提升，并且能从逻辑上扩充内存容量。<br /><a name="K08FW"></a></p><h2 id="传统存储管理方式的特征-缺点"><a class="markdownIt-Anchor" href="#传统存储管理方式的特征-缺点"></a> 传统存储管理方式的特征、缺点</h2><p>传统的存储管理很多暂时用不到的数据也会长期占用内存， 导致内存利用率不高。其特点如下：</p><ul><li>一次性：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：<ul><li>作业很大时，不能全部装入内存，导致大作业无法运行</li><li>当大量作业要求运行时，由于内存无法容纳所有作业，因此只 少量作业能运行，导致多道程序并发度下降。</li></ul></li><li>驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。<br /><a name="yMx2c"></a></li></ul><h2 id="局部性原理"><a class="markdownIt-Anchor" href="#局部性原理"></a> 局部性原理</h2><p>在虚拟存储技术中引入了局部性原理的概念，其分为两种局部性：时间局部性和空间局部性。<br /><a name="rpi31"></a></p><h3 id="时间局部性"><a class="markdownIt-Anchor" href="#时间局部性"></a> 时间局部性</h3><p>如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）<br /><a name="nl5lT"></a></p><h3 id="空间局部性"><a class="markdownIt-Anchor" href="#空间局部性"></a> 空间局部性</h3><p>一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。 （因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）<br /><a name="V7VQb"></a></p><h2 id="虚拟内存的定义和特征"><a class="markdownIt-Anchor" href="#虚拟内存的定义和特征"></a> 虚拟内存的定义和特征</h2><p>快表机构就是将近期 常访问的页表项副本放到更高速的联想寄存器中。<br />高速缓冲技术的思想： 将近期会频繁访问到的 数据放到更高速的存储 器中，暂时用不到的数据放在更低速存储器中。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599729388643-287a7b45-20d6-4f3d-9d9d-94a43870e25e.png#align=left&amp;display=inline&amp;height=231&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=261&amp;originWidth=437&amp;size=50440&amp;status=done&amp;style=none&amp;width=387" alt="image.png" /><br />基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。 <br />在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。 <br />若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。 在操作系统的管理下，在用户看来似乎有一个比实际 内存大得多的内存，这就是虚拟内存。<br />注意：操作系统虚拟性的一个体现是实际的物理内存大小没有变，只是在逻辑上进行了扩充。<br /><a name="9Jd7i"></a></p><h3 id="易混知识点"><a class="markdownIt-Anchor" href="#易混知识点"></a> 易混知识点</h3><p>虚拟内存的最大容量是由计算机的地址结构（CPU寻址范围）确定的 <br />虚拟内存的实际容量 =min（内存和外存容量之和，CPU寻址范围）<br />如：某计算机地址结构为32位，按字节编址，内存大小为512MB，外存大小为2GB。 <br />则虚拟内存的最大容量为 232B = 4GB <br />虚拟内存的实际容量 = min (232B, 512MB+2GB) = 2GB+512MB<br /><a name="ORhYN"></a></p><h3 id="三个特征"><a class="markdownIt-Anchor" href="#三个特征"></a> 三个特征</h3><ul><li>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</li><li>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。</li><li>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。<br /><a name="usN4I"></a></li></ul><h1 id="虚拟内存技术的实现"><a class="markdownIt-Anchor" href="#虚拟内存技术的实现"></a> 虚拟内存技术的实现</h1><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599733584890-e9c82c12-f3d8-4721-ae2c-a553a2e1e488.png#align=left&amp;display=inline&amp;height=266&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=378&amp;originWidth=747&amp;size=188057&amp;status=done&amp;style=none&amp;width=525" alt="image.png" /><br />虚拟内存技术允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此， 虚拟内存的实现需要建立在离散分配的内存管理方式基础上。<br />虚拟内存和传统方式主要的区别就是在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存（操作系统要提供请求调页（或请求调段）功能），然后继续执行程序。 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。（操作系统要提供页面置换（或段置换）的功能）<br /><a name="PgDPX"></a></p><h2 id="请求分页管理方式"><a class="markdownIt-Anchor" href="#请求分页管理方式"></a> 请求分页管理方式</h2><p>请求分页存储管理与基本分页存储管理的主要区别：在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。 （操作系统要提供请求调页功能， 将缺失页面从外存调入内存）<br />若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。（操作系统要提供页面置换的功能， 将暂时用不到的页面换出外存）<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599730296788-bbe46892-0f5f-4676-8d2c-48b5c9dc6125.png#align=left&amp;display=inline&amp;height=104&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=148&amp;originWidth=486&amp;size=42108&amp;status=done&amp;style=none&amp;width=340" alt="image.png" /><br /><a name="yjiuE"></a></p><h3 id="页表机制"><a class="markdownIt-Anchor" href="#页表机制"></a> 页表机制</h3><p>与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存。如果还没调入，那么也需要知道该页面在外存中存放的位置。<br />当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面；有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面 是否被修改的信息。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599731001373-c68369fe-4e3f-45b2-9189-86320e8df51e.png#align=left&amp;display=inline&amp;height=205&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=243&amp;originWidth=805&amp;size=102450&amp;status=done&amp;style=none&amp;width=679" alt="image.png" /><br /><a name="D0RPx"></a></p><h3 id="缺页中断机构"><a class="markdownIt-Anchor" href="#缺页中断机构"></a> 缺页中断机构</h3><p>在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。 <br />此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。<br />如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。<br />如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。<br />缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断 一条指令在执行期间，可能产生多次缺页中断。（如：copy A to B，即将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断）<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599731641054-0fa80b0b-6de3-4e73-8cbe-d136407ae528.png#align=left&amp;display=inline&amp;height=270&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=270&amp;originWidth=713&amp;size=95554&amp;status=done&amp;style=none&amp;width=713" alt="image.png" /><br /><a name="TTZyY"></a></p><h3 id="地址变换机构"><a class="markdownIt-Anchor" href="#地址变换机构"></a> 地址变换机构</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599732055864-5615cdd7-6099-416e-8165-13773c24c082.png#align=left&amp;display=inline&amp;height=229&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=303&amp;originWidth=832&amp;size=114537&amp;status=done&amp;style=none&amp;width=630" alt="image.png" /><br /><a name="6s36f"></a></p><h4 id="执行流程"><a class="markdownIt-Anchor" href="#执行流程"></a> 执行流程</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599732103560-c9b718ef-987c-448d-affd-ecc8af4690a2.png#align=left&amp;display=inline&amp;height=321&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=403&amp;originWidth=758&amp;size=123533&amp;status=done&amp;style=none&amp;width=604" alt="image.png" /><br />在具有快表机构的请求分页系统中，访问一个逻辑地址 时，若发生缺页，则地址变换步骤是：<br />查快表(未命中)——查慢表(发现未调入内存)——调页(调 入的页面对应的表项会直接加入快表)——查快表(命 中)——访问目标内存单元<br />补充细节：</p><ul><li>只有“写指令”才需要修改 “修改位”。并且，一般来说只 需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。</li><li>和普通的中断处理一样，缺页中断处理依然需要保留CPU现场。</li><li>需要用某种“页面置换算法” 来决定一个换出页面（下节内容）</li><li>换入/换出页面都需要启动慢 速的I/O操作，可见，如果换入/ 换出太频繁，会有很大的开销。</li><li>页面调入内存后，需要修改慢 表，同时也需要将表项复制到快 表中。<br /><a name="vczdA"></a></li></ul><h2 id="页面置换算法"><a class="markdownIt-Anchor" href="#页面置换算法"></a> 页面置换算法</h2><p>页面置换算法分为五种实现方法，分别是：最佳置换算法、先进先出置换算法、最近最久未使用置换算法、时钟置换算法、改进型的时钟置换算法。<br /><a name="bzuTc"></a></p><h3 id="最佳置换算法opt"><a class="markdownIt-Anchor" href="#最佳置换算法opt"></a> 最佳置换算法（OPT）</h3><p>每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。<br />例：假设系统为某进程分配了三个内存块，并考虑到有一下页面号引用串（会依次访问这些页面）：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599732595502-91592f7f-f73b-47d9-8a99-9047d03e45a4.png#align=left&amp;display=inline&amp;height=273&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=327&amp;originWidth=845&amp;size=124834&amp;status=done&amp;style=none&amp;width=706" alt="image.png" /><br /><br /><br />最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到 的是哪个页面。操作系统无法ᨀ前预判页面访问序列。因此，最佳置换算法是无法实现的。<br /><a name="VCDeX"></a></p><h3 id="先进先出置换算法fifo"><a class="markdownIt-Anchor" href="#先进先出置换算法fifo"></a> 先进先出置换算法（FIFO）</h3><p>每次选择淘汰的页面是最早进入内存的页面 <br />实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。 队列的最大长度取决于系统为进程分配了多少个内存块。 <br />例：假设系统为某进程分配了三个内存块，并考虑到有以下页面号引用串<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599732718347-95b47cbf-6007-4d24-919c-f3c56c4ee18a.png#align=left&amp;display=inline&amp;height=242&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=309&amp;originWidth=765&amp;size=62446&amp;status=done&amp;style=none&amp;width=598" alt="image.png" /><br /><a name="1JeGi"></a></p><h4 id="belady-异常"><a class="markdownIt-Anchor" href="#belady-异常"></a> Belady 异常</h4><p>当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。<br />例：假设系统为某进程分配了四个内存块，并考虑到有以下页面号引用串：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599732814429-2963be65-f796-4822-affa-2c1dcd36a251.png#align=left&amp;display=inline&amp;height=139&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=212&amp;originWidth=853&amp;size=73398&amp;status=done&amp;style=none&amp;width=558" alt="image.png" /><br />只有 FIFO 算法会产生 Belady 异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的 规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差<br /><a name="9zf87"></a></p><h3 id="最近最久未使用置换算法lru"><a class="markdownIt-Anchor" href="#最近最久未使用置换算法lru"></a> 最近最久未使用置换算法（LRU）</h3><p>每次淘汰的页面是最近最久未使用的页面 <br />实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。 当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面。<br />该算法的实现需要专门的硬件支持，虽然算法性能好， 但是实现困难，开销大。<br />例：假设系统为某进程分配了四个内存块，并考虑到有以下页面号引用串：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599733053182-274fad21-f858-4c7c-a2ea-dfaa6879cfc4.png#align=left&amp;display=inline&amp;height=133&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=192&amp;originWidth=782&amp;size=48657&amp;status=done&amp;style=none&amp;width=542" alt="image.png" /><br /><a name="8KH3D"></a></p><h3 id="时钟置换算法clock"><a class="markdownIt-Anchor" href="#时钟置换算法clock"></a> 时钟置换算法（CLOCK）</h3><p>最佳置换算法性能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用 置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。 时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法（NRU，Not Recently Used）<br />简单的CLOCK 算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成 一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。 如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会 有访问位为0的页面，因此简单的CLOCK 算法选择一个淘汰页面最多会经过两轮扫描）<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599733417516-f40f2fc3-3f32-4a0e-a55d-f78b63afd878.png#align=left&amp;display=inline&amp;height=91&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=116&amp;originWidth=541&amp;size=31880&amp;status=done&amp;style=none&amp;width=426" alt="image.png" /><br /><a name="TYyD7"></a></p><h3 id="改进型的时钟置换算法"><a class="markdownIt-Anchor" href="#改进型的时钟置换算法"></a> 改进型的时钟置换算法</h3><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过， 就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。 <br />因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他 条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作。这就是改进型的时钟置换算法的思想。 修改位=0，表示页面没有被修改过；修改位=1，表示页面被修改过。 <br />为方便讨论，用（访问位，修改位）的形式表示各页面状态。如（1，1）表示一个页面近期被访问过， 且被修改过。<br />算法规则：将所有可能被置换的页面排成一个循环队列 <br />第一轮：从当前位置开始扫᧿到第一个（0,0）的帧用于替换。本轮扫描不修改任何标志位 （第一优先级：最近没访问， 且没修改的页面）<br />第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0,1）的帧用于 替换。本轮将所有扫描过的帧访问位设为0 （第二优先级：最近没访问， 但修改过的页面）<br />第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0,0）的帧用于替换。本轮扫描不修改任何标志位 （第三优先级：最近访问过， 但没修改的页面）<br />第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0,1）的帧用于替换。 （第四优先级：最近访问过， 且修改过的页面）<br />由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一 定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描<br /><a name="AwSc1"></a></p><h2 id="页面分配策略"><a class="markdownIt-Anchor" href="#页面分配策略"></a> 页面分配策略</h2><p><a name="LOvCb"></a></p><h3 id="驻留集"><a class="markdownIt-Anchor" href="#驻留集"></a> 驻留集</h3><p>指请求分页存储管理中给进程分配的物理块的集合。在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。 若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少； 驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。<br />考虑一个极端情况，若某进程共 有100个页面，则该进程的驻留集大小为100时进程可以全部放入内存，运行期间不可能再发生缺页。若驻留集大小为1，则进程运行期间必定会极频繁地缺页。<br /><a name="wCQOt"></a></p><h3 id="置换策略"><a class="markdownIt-Anchor" href="#置换策略"></a> 置换策略</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599743513768-b03965e5-7f26-42e7-b2a6-3e22cf26ce81.png#align=left&amp;display=inline&amp;height=78&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=155&amp;originWidth=546&amp;size=41155&amp;status=done&amp;style=none&amp;width=273" alt="image.png" /></p><ul><li>固定分配：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变。</li><li>可变分配：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。 即，驻留集大小可变</li><li>局部置换：发生缺页时只能选进程自己的物理块进行置换。</li><li>全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换 到外存，再分配给缺页进程。</li></ul><p>可变分配全局置换：只要缺页就给分配新物理块 <br />可变分配局部置换：要根据发生缺页的频率来动态地增加或减少进程的物理块<br /><a name="CLF9o"></a></p><h4 id="固定分配局部置换"><a class="markdownIt-Anchor" href="#固定分配局部置换"></a> 固定分配局部置换</h4><p>系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运 行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略 的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。（采用这种策略的系统可 以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数）<br /><a name="mGU4d"></a></p><h4 id="可变分配全局置换"><a class="markdownIt-Anchor" href="#可变分配全局置换"></a> 可变分配全局置换</h4><p>刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一 个未锁定（系统会锁定一些页面，这些页面中 的内容不能置换出外存（如：重要 的内核数据可以设为“锁定”））的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，只要某进程发生缺页， 都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页 可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。<br /><a name="CcaKH"></a></p><h4 id="可变分配局部置换"><a class="markdownIt-Anchor" href="#可变分配局部置换"></a> 可变分配局部置换</h4><p>刚开始会为个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配 几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减 少分配给该进程的物理块。<br /><a name="QvFnC"></a></p><h3 id="何时调入页面"><a class="markdownIt-Anchor" href="#何时调入页面"></a> 何时调入页面</h3><p>预调页策略：根据局部性原理（主要指空间局部性，即：如果当前访问了某个内存单元， 在之后很有可能会接着访问 与其相邻的那些内存单元），一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如 果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页 面，将它们预先调入内存，但目前预测成功率只有50%左右。故这种策略主要用于进程的首次调入， 由程序员指出应该先调入哪些部分。<br />请求调页策略：进程在运行期间发现缺页时才将所缺页面调入内存。由这种策略调入的页面一定会 被访问到，但由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此I/O开销较大。<br />系统拥有足够的对换区空间：页面的调入、调 出都是在内存与对换区之间进行，这样可以保 证页面的调入、调出速度很快。在进程运行前， 需将进程相关的数据从文件区复制到对换区。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599744660422-f2ee8b06-8e99-491e-a9cb-a4741586292a.png#align=left&amp;display=inline&amp;height=260&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=360&amp;originWidth=440&amp;size=55915&amp;status=done&amp;style=none&amp;width=318" alt="image.png" /><br />系统缺少足够的对换区空间：凡是不会被修改 的数据都直接从文件区调入，由于这些页面不 会被修改，因此换出时不必写回磁盘，下次需 要时再从文件区调入即可。对于可能被修改的 部分，换出时需写回磁盘对换区，下次需要时 再从对换区调入。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599744703306-8af9e8b9-3365-4551-b4ef-7fae22abaa8e.png#align=left&amp;display=inline&amp;height=299&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=398&amp;originWidth=456&amp;size=70184&amp;status=done&amp;style=none&amp;width=343" alt="image.png" /><br />UNIX 方式：运行之前进程有关的数据全部放在 文件区，故未使用过的页面，都可从文件区调 入。若被使用过的页面需要换出，则写回对换 区，下次需要时从对换区调入。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599744738903-f47af07f-4951-4073-8b01-9f963a2247b7.png#align=left&amp;display=inline&amp;height=312&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=370&amp;originWidth=430&amp;size=51478&amp;status=done&amp;style=none&amp;width=363" alt="image.png" /><br /><a name="wEmec"></a></p><h3 id="抖动颠簸现象"><a class="markdownIt-Anchor" href="#抖动颠簸现象"></a> 抖动（颠簸）现象</h3><p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称 为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数（分配给进程 的物理块不够）<br />为了研究为应该为每个进程分配多 少个物理块，Denning 提出了进程 “工作集”的概念<br />为进程分配的物理块太少，会使进 程发生抖动现象。为进程分配的物 理块太多，又会降低系统整体的并 发度，降低某些资源的利用率<br /><a name="BmfUH"></a></p><h3 id="工作集"><a class="markdownIt-Anchor" href="#工作集"></a> 工作集</h3><p>驻留集：指请求分页存储管理中给进程分配的内存块的集合。 <br />工作集：指在某段时间间隔里，进程实际访问页面的集合。<br />操作系统会根据“窗口尺寸”来算出工作集。<br />例： 某进程的页面访问序列如下，窗口尺寸为 4，各时刻的工作集为？<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599744996558-d9c7d785-a0bd-49ce-bc62-aa95ecf42d69.png#align=left&amp;display=inline&amp;height=61&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=122&amp;originWidth=474&amp;size=21235&amp;status=done&amp;style=none&amp;width=237" alt="image.png" /><br />工作集大小可能小于窗口尺寸，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小 给进程分配若干内存块。如：窗口尺寸为5，经过一段时间的监测发现某进程的工作集最大为3，那么 说明该进程有很好的局部性，可以给这个进程分配3个以上的内存块即可满足进程的运行需要。 一般来说，驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页。<br />拓展：基于局部性原理可知，进程在一段时间内访问的页面与不久之后会访问的页面是有相关性的。 因此，可以根据进程近期访问的页面集合（工作集）来设计一种页面置换算法——选择一个不在工作 集中的页面进行淘汰。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统之虚拟内存&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#操作系统之虚拟内存&quot;&gt;&lt;/a&gt; 操作系统之虚拟内存&lt;/h1&gt;
&lt;p&gt;&lt;a name=&quot;1cKIp&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a class=&quot;mark</summary>
      
    
    
    
    <category term="操作系统" scheme="https://jie-blog.icu/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://jie-blog.icu/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之内存</title>
    <link href="https://jie-blog.icu/posts/operating_system_memory/"/>
    <id>https://jie-blog.icu/posts/operating_system_memory/</id>
    <published>2020-09-15T11:22:44.000Z</published>
    <updated>2020-09-15T11:27:01.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统之内存"><a class="markdownIt-Anchor" href="#操作系统之内存"></a> 操作系统之内存</h1><p><a name="Wsdw3"></a></p><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>如图，圈起来的部分就是内存空间大小：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599645535990-f5599de8-b0dd-409f-8946-7ca8e1a260c2.png#align=left&amp;display=inline&amp;height=138&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=275&amp;originWidth=708&amp;size=19747&amp;status=done&amp;style=none&amp;width=354" alt="image.png" /><br />内存可存放数据。程序执行前需要先放到内存中才能被CPU处理——缓和CPU与硬盘之间的速度矛盾。<br /><a name="36bgH"></a></p><h2 id="内存存储方式"><a class="markdownIt-Anchor" href="#内存存储方式"></a> 内存存储方式</h2><p>在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，内存就通过的存储单元编地址区分各个程序的数据是放在什么地方。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599646016912-d72b2511-5042-4a6f-b1b4-66f47414c4a7.png#align=left&amp;display=inline&amp;height=267&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=367&amp;originWidth=743&amp;size=122411&amp;status=done&amp;style=none&amp;width=540" alt="image.png" /><br /><a name="NAvQW"></a></p><h2 id="内存的数量单位"><a class="markdownIt-Anchor" href="#内存的数量单位"></a> 内存的数量单位</h2><p>一台手机/电脑有4GB 内存，代表着内存中可以存放 4*2<sup>30个字节。如果是按字节编址的话，也就是有4*2</sup>30=2^32个“小房间”，这么多“小房间”，需要 2^32个地址才能一一标识，所以地 址需要用 32 个二进制位来表示（0~ 2^32 -1）。<br /><a name="bMoFd"></a></p><h2 id="指令的工作原理"><a class="markdownIt-Anchor" href="#指令的工作原理"></a> 指令的工作原理</h2><p>指令的工作基于“地址”。 每个地址对应一个数据的存储单元。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599646258921-cdf88793-e80f-4532-accc-8f7d7bf67561.png#align=left&amp;display=inline&amp;height=232&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=345&amp;originWidth=885&amp;size=122997&amp;status=done&amp;style=none&amp;width=594" alt="image.png" /><br />可见，写的代码要翻译成CPU能识别的指令。这些指令会告诉CPU应该去内存的哪个地址读/写数据， 这个数据应该做什么样的处理。在这个例子中，默认让这个进程的相关内容从地址#0开始连续存放，指令中的地址参数直接给出了变量 x 的实际存放地址（物理地址）。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599646578081-91698313-81fc-4700-afcb-1ca7b700f340.png#align=left&amp;display=inline&amp;height=357&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=416&amp;originWidth=803&amp;size=161768&amp;status=done&amp;style=none&amp;width=690" alt="image.png" /><br /><a name="D9rcU"></a></p><h2 id="装入的三种方式"><a class="markdownIt-Anchor" href="#装入的三种方式"></a> 装入的三种方式</h2><p>如图，装入分为了三种方式：绝对装入、可重定位装入、动态运行时装入。<br /><a name="uZZFJ"></a></p><h3 id="绝对装入"><a class="markdownIt-Anchor" href="#绝对装入"></a> 绝对装入</h3><p>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。 装入程序按照装入模块中的地址，将程序和数据装入内存。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599646837879-c8589bf8-fb5f-4b10-b8d8-006169f3234a.png#align=left&amp;display=inline&amp;height=264&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=398&amp;originWidth=877&amp;size=133733&amp;status=done&amp;style=none&amp;width=582" alt="image.png" /><br />绝对装入只适用于单道程序环境。 <br />程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。<br /><a name="AqDgw"></a></p><h3 id="可重定位装入"><a class="markdownIt-Anchor" href="#可重定位装入"></a> 可重定位装入</h3><p>又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599647013485-3e837fca-2994-4eb9-8757-67e787a70cde.png#align=left&amp;display=inline&amp;height=252&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=375&amp;originWidth=864&amp;size=108735&amp;status=done&amp;style=none&amp;width=580" alt="image.png" /><br />静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。 作业一旦进入内存后，在运行期间就不能再移动，也不能再申 请内存空间。<br /><a name="p5hKv"></a></p><h3 id="动态运行时装入"><a class="markdownIt-Anchor" href="#动态运行时装入"></a> 动态运行时装入</h3><p>又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行 时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599647098503-9a5f50a8-6423-49e6-ba2f-6a4d98b15f72.png#align=left&amp;display=inline&amp;height=243&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=358&amp;originWidth=835&amp;size=98953&amp;status=done&amp;style=none&amp;width=567" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599647161106-1f4a5f63-1a88-4f26-970e-86fe125cf466.png#align=left&amp;display=inline&amp;height=229&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=358&amp;originWidth=924&amp;size=154036&amp;status=done&amp;style=none&amp;width=592" alt="image.png" /><br /><a name="G59Ox"></a></p><h2 id="从写程序到程序运行"><a class="markdownIt-Anchor" href="#从写程序到程序运行"></a> 从写程序到程序运行</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599647258685-e7e32481-bf70-4c09-b61e-bc0f40e5d610.png#align=left&amp;display=inline&amp;height=209&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=301&amp;originWidth=911&amp;size=77233&amp;status=done&amp;style=none&amp;width=633" alt="image.png" /></p><ul><li>编译：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言翻译为机器语言）</li><li>链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块</li><li>装入（装载）：由装入程序将装入模块装入内存运行<br /><a name="S22ey"></a></li></ul><h2 id="链接的三种方式"><a class="markdownIt-Anchor" href="#链接的三种方式"></a> 链接的三种方式</h2><p>链接氛围了三种方式：静态链接、装入时动态链接、运行时动态链接。<br /><a name="E5rhb"></a></p><h3 id="静态链接"><a class="markdownIt-Anchor" href="#静态链接"></a> 静态链接</h3><p>在程序运行之前， 先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块）， 之后不再拆开。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599647463370-7ea2579b-ca2c-494c-a1b6-1566578cb6b8.png#align=left&amp;display=inline&amp;height=310&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=430&amp;originWidth=625&amp;size=63243&amp;status=done&amp;style=none&amp;width=451" alt="image.png" /><br /><a name="1WKnU"></a></p><h3 id="装入时动态链接"><a class="markdownIt-Anchor" href="#装入时动态链接"></a> 装入时动态链接</h3><p>将各目标模块装入内存时，边装入边链接的链接方式。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599647511328-128e51be-2edb-4b2f-9035-5270fe675aca.png#align=left&amp;display=inline&amp;height=309&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=374&amp;originWidth=493&amp;size=61970&amp;status=done&amp;style=none&amp;width=407" alt="image.png" /><br /><a name="J5Sq2"></a></p><h3 id="运行时动态链接"><a class="markdownIt-Anchor" href="#运行时动态链接"></a> 运行时动态链接</h3><p>在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599647595628-f8744070-2b0d-4211-a7e0-842d01c1674a.png#align=left&amp;display=inline&amp;height=347&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=398&amp;originWidth=497&amp;size=70386&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br /><a name="yCXSk"></a></p><h1 id="内存空间的管理"><a class="markdownIt-Anchor" href="#内存空间的管理"></a> 内存空间的管理</h1><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599648342397-71682d2e-4364-48d1-8d4e-fa97a9380e2b.png#align=left&amp;display=inline&amp;height=103&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=206&amp;originWidth=534&amp;size=41007&amp;status=done&amp;style=none&amp;width=267" alt="image.png" /><br />操作系统作为系统资源的管理者，当然也需要对内存进行管理，其管理着：</p><ol><li>操作系统负责内存空间的分配与回收</li><li>操作系统需要提供某种技术从逻辑上对内存空间进行扩充</li><li>操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换<ul><li>为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而逻辑地址到物理地址 的转换（这个过程称为地址重定位）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。</li></ul></li><li>操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰。<br /><a name="iORYC"></a></li></ol><h3 id="内存保护"><a class="markdownIt-Anchor" href="#内存保护"></a> 内存保护</h3><p>内存保护可采取两种方法：<br /><a name="et11m"></a></p><h4 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h4><p>在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599647950196-581771ff-9ffd-4fa3-bb62-dbddb768dfe8.png#align=left&amp;display=inline&amp;height=258&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=388&amp;originWidth=754&amp;size=76501&amp;status=done&amp;style=none&amp;width=501" alt="image.png" /><br /><a name="zTpwv"></a></p><h4 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h4><p>采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599648023732-5465281a-41ad-4a9f-a0e1-25232b80f6b5.png#align=left&amp;display=inline&amp;height=276&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=408&amp;originWidth=890&amp;size=102904&amp;status=done&amp;style=none&amp;width=601" alt="image.png" /><br /><a name="DIOZd"></a></p><h2 id="内存空间的扩充"><a class="markdownIt-Anchor" href="#内存空间的扩充"></a> 内存空间的扩充</h2><p>内存空间扩充分为三种技术：覆盖技术、交换技术、虚拟存储技术。<br /><a name="6FOfB"></a></p><h3 id="覆盖技术"><a class="markdownIt-Anchor" href="#覆盖技术"></a> 覆盖技术</h3><p>早期的计算机内存很小，比如 IBM 推出的第一台PC机最大只支持1MB大小的内存。因此经常会出现内存大小不够的情况。后来人们引入了覆盖技术，用来解决“程序大小超过物理内存总和”的问题。<br />覆盖技术的思想：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。 内存中分为一个“固定区”和若干个“覆盖区”。需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束） 不常用的段放在“覆盖区”，需要用到时调入内存， 用不到时调出内存。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599648558366-62ca5e0b-5b65-4bf5-b1c1-4809c1c9712e.png#align=left&amp;display=inline&amp;height=211&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=310&amp;originWidth=799&amp;size=75321&amp;status=done&amp;style=none&amp;width=543" alt="image.png" /><br />必须由程序员声明覆盖结构，操作系统完成自动覆盖。<br />缺点：对用户不透明，增加了用户编程负担。 覆盖技术只用于早期的操作系统中，现在已成为历史。<br /><a name="3vT8f"></a></p><h3 id="交换技术"><a class="markdownIt-Anchor" href="#交换技术"></a> 交换技术</h3><p>交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599648614574-00cc6e40-134c-4a03-91ae-4d671a87596a.png#align=left&amp;display=inline&amp;height=138&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=206&amp;originWidth=645&amp;size=80459&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br />暂时换出外存等待的进程状态为挂起状态（挂起态，suspend） 挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态.:<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599648674372-26ad3d3a-f1b0-4f70-8787-2b3ce3bd0a05.png#align=left&amp;display=inline&amp;height=223&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=319&amp;originWidth=813&amp;size=76050&amp;status=done&amp;style=none&amp;width=568" alt="image.png" /><br /></p><ul><li>具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式；对换区空间只占磁盘空间的小部分，被换出的进程数据就存放 在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理 主要追求换入换出速度，因此通常对换区采用连续分配方式。总之，对换区的I/O速度比文件区的更快。</li><li>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在 发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程； 如果缺页率明显下降，就可以暂停换出。</li><li>可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调 入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599648848043-1737b609-11fc-4412-9a00-3eaaf80c231c.png#align=left&amp;display=inline&amp;height=253&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=253&amp;originWidth=146&amp;size=9651&amp;status=done&amp;style=none&amp;width=146" alt="image.png" /><br /><a name="B9ZY8"></a></p><h2 id="内存空间的分配与回收"><a class="markdownIt-Anchor" href="#内存空间的分配与回收"></a> 内存空间的分配与回收</h2><p>内存空间的分配管理分为连续和非连续的方式。<br />连续分配：为用户进程分配的必须是一个连续的内存空间。 <br />非连续分配：为用户进程分配的可以是一些分散的内存空间。<br /><a name="13hRi"></a></p><h1 id="连续分配分配方式"><a class="markdownIt-Anchor" href="#连续分配分配方式"></a> 连续分配分配方式</h1><p>连续分配管理方式分为单一连续分配、固态连续分配和动态连续分配。<br /><a name="kwpbu"></a></p><h2 id="单一连续分配"><a class="markdownIt-Anchor" href="#单一连续分配"></a> 单一连续分配</h2><p>在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据。用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599649096969-1fe01e25-ccc9-49c5-a7d3-431f551b6840.png#align=left&amp;display=inline&amp;height=372&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=372&amp;originWidth=376&amp;size=29125&amp;status=done&amp;style=none&amp;width=376" alt="image.png" /><br />优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护（eg：早期的 PC 操作系统 MS-DOS）。 <br />缺点：只能用于单用户、单任务的操作系统中；有内部碎片（分配给某进程的内存区域 中，如果有些部分没有用 上，就是“内部碎片”）；存储器利用率极低。<br /><a name="4l0Ij"></a></p><h2 id="固定分区分配"><a class="markdownIt-Anchor" href="#固定分区分配"></a> 固定分区分配</h2><p>20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。<br />固定分区分配又分为：分区大小相等、分区大小不等两种分配方式。<br /><a name="BWsL0"></a></p><h3 id="分区大小相等"><a class="markdownIt-Anchor" href="#分区大小相等"></a> 分区大小相等</h3><p>缺乏灵活性，但是很适合用于用一台计 算机控制多个相同对象的场合（比如：钢铁厂有n个相 同的炼钢炉，就可把内存分为n个大小相等的区域存放 n个炼钢炉控制程序）<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599649623948-ef566414-ff59-4dea-a40e-d375af561592.png#align=left&amp;display=inline&amp;height=352&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=352&amp;originWidth=136&amp;size=22917&amp;status=done&amp;style=none&amp;width=136" alt="image.png" /><br /><a name="xsebV"></a></p><h3 id="分区大小不等"><a class="markdownIt-Anchor" href="#分区大小不等"></a> 分区大小不等</h3><p>分区大小不等：增加了灵活性，可以满足不同大小的进 程需求。根据常在系统中运行的作业大小情况进行划分 （比如：划分多个小分区、适量中等分区、少量大分区）<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599649649672-0f2e7844-bf7e-40b2-a93e-febf702d4987.png#align=left&amp;display=inline&amp;height=345&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=371&amp;originWidth=171&amp;size=28931&amp;status=done&amp;style=none&amp;width=159" alt="image.png" /><br />操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的 大小、起始地址、状态（是否已分配）。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599649714058-bd5e8b4a-4f10-4b8f-8c9b-3273c210cfc1.png#align=left&amp;display=inline&amp;height=104&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=159&amp;originWidth=629&amp;size=38820&amp;status=done&amp;style=none&amp;width=410" alt="image.png" /><br />当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表， 从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状 态为“已分配”。<br />优点：实现简单，无外部碎片。 <br />缺点：a. 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采 用覆盖技术来解决，但这又会降低性能；b. 会产生内部碎片，内存利用率低。<br /><a name="a6fdx"></a></p><h2 id="动态分区分配"><a class="markdownIt-Anchor" href="#动态分区分配"></a> 动态分区分配</h2><p>动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数 目是可变的。（eg：假设某计算机内存大小为 64MB，系统区 8MB，用户区共 56 MB…）<br />动态分区分配没有内部碎片，但是有外部碎片。 内部碎片，分配给某进程的内存区域中，如果有些部分没有用上。 外部碎片，是指内存中的某些空闲分区由于太小而难以利用。<br />如果内存中空闲空间的总和本来可以满足某进程的要求， 但由于进程需要的是一整块连续的内存空间，因此这些 “碎片”不能满足进程的需求。 可以通过紧凑（拼凑，Compaction）技术来解决外部碎片。<br />系统记录内存分配情况通常有以下两种方法之一：空闲分区表和空闲分区链。<br /><a name="2vDSX"></a></p><h3 id="空闲分区表"><a class="markdownIt-Anchor" href="#空闲分区表"></a> 空闲分区表</h3><p>每个空闲分区对应 一个表项。表项 中包含分区号、 分区大小、分区 起始地址等信息<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599649889064-781460a6-8db9-4d16-ab36-f76c7baee5b0.png#align=left&amp;display=inline&amp;height=85&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=120&amp;originWidth=414&amp;size=20341&amp;status=done&amp;style=none&amp;width=293" alt="image.png" /><br /><a name="LRhoc"></a></p><h3 id="空闲分区链"><a class="markdownIt-Anchor" href="#空闲分区链"></a> 空闲分区链</h3><p>每个分区的起始部分和末尾部分分别设置前向指 针和后向指针。起始部分处还可记录分区大小等信息<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599649917651-3a8023a4-0d52-475b-8aef-60de24014cef.png#align=left&amp;display=inline&amp;height=53&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=71&amp;originWidth=434&amp;size=6511&amp;status=done&amp;style=none&amp;width=324" alt="image.png" /><br /><a name="xFp2y"></a></p><h3 id="动态分区的内存分配算法"><a class="markdownIt-Anchor" href="#动态分区的内存分配算法"></a> 动态分区的内存分配算法</h3><p>在动态分区分配方式中， 当很多个空闲分区都能满足需求时，一般有如下四个算法可供选择：首次适应算法、最佳适应算法、最坏适应算法、临近适应算法。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599651129016-7288aea0-0b14-42c7-acd1-abc0fc2f385d.png#align=left&amp;display=inline&amp;height=287&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=382&amp;originWidth=781&amp;size=234013&amp;status=done&amp;style=none&amp;width=586" alt="image.png" /><br /><a name="SzT4N"></a></p><h4 id="首次适应算法"><a class="markdownIt-Anchor" href="#首次适应算法"></a> 首次适应算法</h4><p>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。<br />如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区 表），找到大小能满足要求的第一个空闲分区。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599650809528-bc754cb6-004b-4304-9f3c-5bb1c66eb211.png#align=left&amp;display=inline&amp;height=77&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=112&amp;originWidth=495&amp;size=11006&amp;status=done&amp;style=none&amp;width=339" alt="image.png" /><br /><a name="ixmoR"></a></p><h4 id="最佳适应算法"><a class="markdownIt-Anchor" href="#最佳适应算法"></a> 最佳适应算法</h4><p>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区 域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区， 即，优先使用更小的空闲区。 <br />如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区 表），找到大小能满足要求的第一个空闲分区。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599650832200-ca181b0b-8ea7-401c-9cc2-9f2265f5bea4.png#align=left&amp;display=inline&amp;height=65&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=84&amp;originWidth=484&amp;size=9705&amp;status=done&amp;style=none&amp;width=376" alt="image.png" /><br />缺点：每次都选最小的分区进行分配，会留下越来越多的、很小 的、难以利用的内存块。因此这种方法会产生很多的外部碎片。<br /><a name="4snUf"></a></p><h4 id="最坏适应算法"><a class="markdownIt-Anchor" href="#最坏适应算法"></a> 最坏适应算法</h4><p>又称 最大适应算法（Largest Fit） <br />算法思想：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时 优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。 <br />如何实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区 表），找到大小能满足要求的第一个空闲分区。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599650882164-ab16ff3c-0a58-448d-a832-a95f93ff468b.png#align=left&amp;display=inline&amp;height=66&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=86&amp;originWidth=485&amp;size=10015&amp;status=done&amp;style=none&amp;width=373" alt="image.png" /><br />缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的 空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被 迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。<br /><a name="8Bz6n"></a></p><h4 id="邻近适应算法"><a class="markdownIt-Anchor" href="#邻近适应算法"></a> 邻近适应算法</h4><p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲 分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查 找结束的位置开始检索，就能解决上述问题。 <br />如何实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查 找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599651084803-5ac2602f-bfb4-4e56-9e0d-4f769ff9fd44.png#align=left&amp;display=inline&amp;height=86&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=122&amp;originWidth=536&amp;size=12692&amp;status=done&amp;style=none&amp;width=376" alt="image.png" /><br />首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。 但是这种规则也决定了当低地址部分有更小的分区可以满足需求时， 会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的 大分区保留下来（最佳适应算法的优点） 邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区 都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点） 综合来看，四种算法中，首次适应算法的效果反而更好。<br /><a name="oh5EM"></a></p><h1 id="非连续分配分配方式"><a class="markdownIt-Anchor" href="#非连续分配分配方式"></a> 非连续分配分配方式</h1><p>非连续分配管理分为基本分页存储管理、基本分段存储管理和段页式分配管理。<br /><a name="iqApb"></a></p><h2 id="什么是分页存储"><a class="markdownIt-Anchor" href="#什么是分页存储"></a> 什么是分页存储</h2><p>将内存空间分为一个个大小相等的分区（比如：每个分区 4KB），每个分区就是一个“页框”（页框=页帧=内存块=物理块=物理页面）。每个页框有一个编号，即“页框号”（页框 号=页帧号=内存块号=物理块号=物理页号），页框号从0开始。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599651925056-a484ead8-b5ac-4870-803c-abb2fb0ec07f.png#align=left&amp;display=inline&amp;height=410&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=410&amp;originWidth=190&amp;size=24957&amp;status=done&amp;style=none&amp;width=190" alt="image.png" /><br />将进程的逻辑地址空间也分为与页框大小相等的一个个部分， 每个部分称为一个“页”或“页面” 。每个页面也有一个编号， 即“页号”，页号也是从0开始。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599651682212-848451b5-2731-4e44-938c-2bf53cf169f0.png#align=left&amp;display=inline&amp;height=173&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=173&amp;originWidth=116&amp;size=14728&amp;status=done&amp;style=none&amp;width=116" alt="image.png" /><br />操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。 <br />各个页面不必连续存放，可以放到不相邻的各个页框中。<br />（注：进程的最后一个页面可能没有一个页框那么大。也就是说，分页存储有可能产生内部碎片，因此页框不能太大，否则可能产生过大的内部碎片造成浪费）<br /><a name="UPxp7"></a></p><h3 id="页表"><a class="markdownIt-Anchor" href="#页表"></a> 页表</h3><p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。 <br />注：页表通常存在PCB（进程控制块）中<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599652145535-1643f709-5e93-4c58-952c-0b4829d52f18.png#align=left&amp;display=inline&amp;height=252&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=357&amp;originWidth=803&amp;size=95281&amp;status=done&amp;style=none&amp;width=567" alt="image.png" /><br />假设某系统物理内存大小为 4GB，页面大小为 4KB，则 每个页表项至少应该为多少字节？<br />内存块大小=页面大小=4KB= 2^12B<br />4GB 的内存总共会被分为 2^32 / 2^12 = 2^20个内存块 <br />内存块号的范围应该是 0 ~2^20 -1 <br />内存块号至少要用 20 bit 来表示 <br />至少要用3B来表示块号（3*8=24bit）<br /><a name="G4wdP"></a></p><h4 id="每个页表项占多少字节"><a class="markdownIt-Anchor" href="#每个页表项占多少字节"></a> 每个页表项占多少字节</h4><p>页表项连续存放，因此页号 可以是隐含的，不占存储空 间（类比数组）<br />由于页号是隐含的，因此每个页表项占3B，存储整个页表至少需要 3*(n+1)B<br />注意：页表记录的只是内存块号，而不 是内存块的起始地址！ <br />J 号内存块的起始地址 = J *内存块大小<br /><a name="Gr4v3"></a></p><h4 id="如何实现地址的转换"><a class="markdownIt-Anchor" href="#如何实现地址的转换"></a> 如何实现地址的转换</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599652533919-60f9fc8d-3a3e-4509-bb48-0852af4dc768.png#align=left&amp;display=inline&amp;height=293&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=404&amp;originWidth=707&amp;size=88235&amp;status=done&amp;style=none&amp;width=512" alt="image.png" /><br />特点：虽然进程的各个页面是离散存放的，但是页面内部是连续存放的 <br />如果要访问逻辑地址 A，则</p><ul><li>确定逻辑地址A 对应的“页号”P</li><li>找到P号页面在内存中的起始地址（需要查页表）</li><li>确定逻辑地址A 的“页内偏移量”W</li></ul><p>逻辑地址A 对应的物理地址 = P号页面在内存中的起始地址+页内偏移量W<br /><a name="MuWZV"></a></p><h4 id="如何确定一个逻辑地址对应-的页号-页内偏移量"><a class="markdownIt-Anchor" href="#如何确定一个逻辑地址对应-的页号-页内偏移量"></a> 如何确定一个逻辑地址对应 的页号、页内偏移量</h4><p>在某计算机系统中，页面大小是50B。某进程逻辑地址空间大小为200B，则逻辑地址 110 对应 的页号、页内偏移量是多少？<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599652726890-ce8e0ba7-c13e-43b9-9884-3f36065bb240.png#align=left&amp;display=inline&amp;height=200&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=305&amp;originWidth=865&amp;size=108625&amp;status=done&amp;style=none&amp;width=568" alt="image.png" /><br />在计算机内部，地址是用二进制表示的， 如果页面大小 刚好是 2 的整数幂，则计 算机硬件可以很快速的把逻辑地址拆分 成（页号，页内偏移量）。<br />结论：如果每个页面 大小为 2^K B，用二进 制数表示逻辑地址， 则末尾 K 位即为页内 偏移量，其余部分就 是页号。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599652829184-fff882fa-159e-4be6-b476-9368b0efc6ae.png#align=left&amp;display=inline&amp;height=216&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=331&amp;originWidth=704&amp;size=187673&amp;status=done&amp;style=none&amp;width=459" alt="image.png" /><br />根据页号可以查询页表，而页表中记录的 只是内存块号，而不是内存块的起始地址！ J 号内存块的起始地址 = J *内存块大小<br />结论：如果页面大小刚好是2 的整数幂，则只需把页表中记 录的物理块号拼接上页内偏移 量就能得到对应的物理地址<br /><a name="Q8mzh"></a></p><h4 id="为何页面大小要取2的整数幂"><a class="markdownIt-Anchor" href="#为何页面大小要取2的整数幂"></a> 为何页面大小要取2的整数幂</h4><p>逻辑地址的拆分更加迅速——如果每个页面大小为 2KB，用二进制数表示逻辑地址，则末尾 K 位 即为页内偏移量，其余部分就是页号。因此，如果让每个页面的大小为 2 的整数幂，计算机硬件就 可以很方便地得出一个逻辑地址对应的页号和页内偏移量，而无需进行除法运算，从而提升了运行 速度。 <br />物理地址的计算更加迅速——根据逻辑地址得到页号，根据页号查询页表从而找到页面存放的内 存块号，将二进制表示的内存块号和页内偏移量拼接起来，就可以得到最终的物理地址。<br /><a name="aNvrD"></a></p><h3 id="逻辑地址结构"><a class="markdownIt-Anchor" href="#逻辑地址结构"></a> 逻辑地址结构</h3><p>分页存储管理的逻辑地址结构如下所示：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599652949756-5014cb5e-4423-4adc-93dd-0ccd5c5c8d54.png#align=left&amp;display=inline&amp;height=41&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=65&amp;originWidth=629&amp;size=9819&amp;status=done&amp;style=none&amp;width=399" alt="image.png" /><br />地址结构包含两个部分：前一部分为页号，后一部分为页内偏移量 W。在上图所示的例子中，地址 长度为 32 位，其中 0~11位 为“页内偏移量”，或称“页内地址” ；12~31 位为“页号”。<br />页面大小 ↔页内偏移量位数-&gt;逻辑地址结构。<br /><a name="puq68"></a></p><h2 id="基本地址变换机构"><a class="markdownIt-Anchor" href="#基本地址变换机构"></a> 基本地址变换机构</h2><p>基本地址变换机构可以借助进程的页表将逻辑转换为逻辑地址。<br />通常会在系统中设置一个页表寄存器（PTR），存放页表在内存中的起始地址F和页表长度M。进程为执行时，页表的初始地址和页表长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把他们放到页表寄存器中。<br />注意，页面大小是2的整数幂。<br />设置页面大小为L，逻辑地址A到物理地址E的变换过程如下：</p><ol><li>计算页号P和页内偏移量W（如果用十进制数计算则，P=A/L，W=A%L，但是在计算及实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快的得到二进制表示的页号）</li><li>比较页号P和页表长度M，若P&gt;=M，则产生越界中断，否则继续执行（注意：页号是从0开始的，而也表长度是，因此P=M也会发生越界）</li><li>页表中的页号P对应的页表项地址=页表起始地址F+页号P*页表项长度，取出该页表项内容b，即为内存块号。（注意区分页表项长度、页表长度、页面大小的区别。页表长度是指这个页表中总共有几个页表项，即总共有几个页。页表项长度是指每个页表项占多大的存储空间，页面大小事只一个页面占多大的存储空间）<br /><a name="XmUw7"></a></li></ol><h3 id="页表项进一步分析"><a class="markdownIt-Anchor" href="#页表项进一步分析"></a> 页表项进一步分析</h3><p>每个页表项长度是相同的，页号是“隐含”的。<br />假设某系统内存大小为4GB，页面大小为4KB，内存总共会被分为2<sup>32/2</sup>12=20<sup>20个内存块，因此内存块号的范围应该是0~20</sup>20-1因此至少要20个二进制位才能表示这么多的的内存块号，因此至少要3个字节才够（每个字节8个二进制位，3个字节共24个二进制位）<br />各页表项会按顺序连续存放在内存中，如果该也表在内存中存放的起始地址是X，则M号页对应的页表项是存放在内存地址为X+3<em>M。<br />一个页面为4KB，则每个页框可以存放4096/3=1365个页表项，但是这个页框会剩余4096%3=1B页内存片。因此，1365号页表项存放的地址为X+3</em>1365+1。如果每个页表项占4字节，则每个页框刚好可以存放1024个页表项。<br /><a name="lsQSH"></a></p><h2 id="具有快表的地址变换机构"><a class="markdownIt-Anchor" href="#具有快表的地址变换机构"></a> 具有快表的地址变换机构</h2><p><a name="RjqYD"></a></p><h3 id="什么是快表tlb"><a class="markdownIt-Anchor" href="#什么是快表tlb"></a> 什么是快表（TLB）</h3><p>快表，又称联想寄存器（TLB， translation lookaside buffer），是一种访问速度比内存快很多的高速缓存（不是内存），用来存放最近访问的页表项的副本，可以加速地址变换的速度。 与此对应，内存中的页表常称为慢表。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599701517877-7af931b5-bd10-4fc8-80d1-c589b6a5e033.png#align=left&amp;display=inline&amp;height=294&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=355&amp;originWidth=391&amp;size=42028&amp;status=done&amp;style=none&amp;width=324" alt="image.png" /><br /><a name="YmhsR"></a></p><h4 id="快表数据读取流程"><a class="markdownIt-Anchor" href="#快表数据读取流程"></a> 快表数据读取流程</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599701736068-7d527c29-524b-458b-a0a7-a192107b99a2.png#align=left&amp;display=inline&amp;height=351&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=442&amp;originWidth=775&amp;size=145987&amp;status=done&amp;style=none&amp;width=616" alt="image.png" /><br /><a name="m2sxT"></a></p><h4 id="引入快表的地址变换过程"><a class="markdownIt-Anchor" href="#引入快表的地址变换过程"></a> 引入快表的地址变换过程</h4><ul><li>CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</li><li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块 号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。</li><li>如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要两次访存（注意：在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）</li></ul><p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。 因为局部性原理，一般来说快表的命中率可以达到 90% 以上。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599702290494-9327c477-0f8c-49eb-a179-2fd1584ff497.png#align=left&amp;display=inline&amp;height=161&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=224&amp;originWidth=788&amp;size=49859&amp;status=done&amp;style=none&amp;width=565" alt="image.png" /><br /><a name="FtQMh"></a></p><h4 id="tlb存储内容"><a class="markdownIt-Anchor" href="#tlb存储内容"></a> TLB存储内容</h4><p>TLB的价格昂贵，显然无法存下整个页表，因此要选择淘汰 一些页表 项——置换算法。<br /><a name="Aopt3"></a></p><h3 id="局部性原理"><a class="markdownIt-Anchor" href="#局部性原理"></a> 局部性原理</h3><p>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环） <br />空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）<br />每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599702532994-b71163cf-e7a3-4821-aa11-040b55b71083.png#align=left&amp;display=inline&amp;height=114&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=148&amp;originWidth=425&amp;size=29464&amp;status=done&amp;style=none&amp;width=328" alt="image.png" /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599702544061-7788599c-28c3-4912-9325-153bb85ce1ba.png#align=left&amp;display=inline&amp;height=231&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=348&amp;originWidth=223&amp;size=19117&amp;status=done&amp;style=none&amp;width=148" alt="image.png" /><br /><a name="7sj1w"></a></p><h2 id="两级页表"><a class="markdownIt-Anchor" href="#两级页表"></a> 两级页表</h2><p><a name="0KIjr"></a></p><h3 id="单级页表存在的问题"><a class="markdownIt-Anchor" href="#单级页表存在的问题"></a> 单级页表存在的问题</h3><p>某计算机系统按字节寻址，支持 32 位的逻辑地址，采用分页存储管理，页面大小为4KB，页表项长度为 4B。 <br />4KB = 2^12B，因此页内地址要用12位表示，剩余 20 位表示页号。 因此，该系统中用户进程最多有 220 页。相应的，一个进程的页表中，最多会 有 220 = 1M = 1,048,576 个页表项，所以一个页表最大需要 220 * 4B = 222 B，共 需要 222/212 = 210个页框存储该页表。 （需要专门给进程分配 210 = 1024 个连续的页 框来存放它的页表）<br />根据页号查询页表的方法：K 号页对应的页表项存放位置 = 页表始址 + K *4 要在所有的页表项都连续存放的基础上才能用这种方法找到页表项。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599703156865-a7b9a455-96ae-4735-baf6-a343e8b79676.png#align=left&amp;display=inline&amp;height=322&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=445&amp;originWidth=875&amp;size=133615&amp;status=done&amp;style=none&amp;width=633" alt="image.png" /><br /><a name="Jd5Cc"></a></p><h4 id="问题汇总"><a class="markdownIt-Anchor" href="#问题汇总"></a> 问题汇总</h4><ol><li>页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。</li><li>没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</li></ol><p>解决问题1可以把页表再分页并离散存储，然后再建立一张页表记录页表各个部分的存放位置，称为页目录表，或称外层页表，或称顶层页表。<br />解决问题2可以在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599704651632-e42b54d0-0df5-4b25-b961-455a3f008329.png#align=left&amp;display=inline&amp;height=218&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=266&amp;originWidth=436&amp;size=43516&amp;status=done&amp;style=none&amp;width=358" alt="image.png" /><br /><a name="nPAl0"></a></p><h2 id="两级页表的原理-地址结构"><a class="markdownIt-Anchor" href="#两级页表的原理-地址结构"></a> 两级页表的原理、地址结构</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599703242947-afe934df-d30b-43bc-9fa5-6375626cf471.png#align=left&amp;display=inline&amp;height=364&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=500&amp;originWidth=879&amp;size=118216&amp;status=done&amp;style=none&amp;width=640" alt="image.png" /></p><ol><li>按照地址结构将逻辑地址拆分成三部分</li><li>从PCB 中读出页目录表始址，再根据一级页号查页目录 表，找到下一级页表在内存中的存放位置</li><li>根据二级页号查二级页表，找到最终想访问的内存块号</li><li>结合页内偏移量得到物理地址<br /><a name="d4Vum"></a></li></ol><h3 id="注意细节"><a class="markdownIt-Anchor" href="#注意细节"></a> 注意细节</h3><p>若分为两级页表后，页表依然很长，则可以采用更多级页表，一般来说各级页表的大小不能超过一个页面。<br />两级页表的访存次数分析（假设没有快表机构）</p><ul><li>第一次访存：访问内存中的页目录表</li><li>第二次访存：访问内存中的二级页表</li><li>第三次访存：访问目标内存单元<br /><a name="AUW27"></a></li></ul><h2 id="基本分段存储管理方式"><a class="markdownIt-Anchor" href="#基本分段存储管理方式"></a> 基本分段存储管理方式</h2><p><a name="8PqtG"></a></p><h3 id="什么是分段"><a class="markdownIt-Anchor" href="#什么是分段"></a> 什么是分段</h3><p>进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址 <br />内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599704869004-dd0e9a0c-467e-4c2e-9fbe-b5d7519110e6.png#align=left&amp;display=inline&amp;height=259&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=347&amp;originWidth=843&amp;size=125091&amp;status=done&amp;style=none&amp;width=630" alt="image.png" /><br />分段系统的逻辑地址结构由段号（段名）和段内地址（段内偏移量）所组成。如：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599705002241-8cd629f0-201e-4fa3-b0b0-6956f829b70c.png#align=left&amp;display=inline&amp;height=50&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=77&amp;originWidth=643&amp;size=9156&amp;status=done&amp;style=none&amp;width=420" alt="image.png" /><br />段号的位数决定了每个进程最多可以分几个段，段内地址位数决定了每个段的最大长度是多少。<br />在上述例子中，若系统是按字节寻址的，则段号占16位，因此在该系统中，每个进程最多有 216 = 64K 个段，段内地址占 16位，因此每个段的最大长度是 216 = 64KB。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599705726679-910d256e-031f-4313-a8ef-0fda5e19724b.png#align=left&amp;display=inline&amp;height=112&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=176&amp;originWidth=602&amp;size=64824&amp;status=done&amp;style=none&amp;width=384" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599705751613-7a2af8c1-8946-48db-b8fb-4014a2e542b4.png#align=left&amp;display=inline&amp;height=304&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=371&amp;originWidth=287&amp;size=31875&amp;status=done&amp;style=none&amp;width=235" alt="image.png" /><br /><br /><br />每个段对应一个段表项，其中记录了该段在内存中的起始位置（又称 “基址”）和段的长度。 <br />各个段表项的长度是相同的。例如：某系统按字节寻址，采用分段存 储管理，逻辑地址结构为（段号16位, 段内地址16位），因此用16位 即可表示最大段长。物理内存大小为4GB（可用32位表示整个物理内 存地址空间）。因此，可以让每个段表项占 16+32 = 48位，即6B。由 于段表项长度相同，因此段号可以是隐含的，不占存储空间。若段表 存放的起始地址为 M，则 K号段对应的段表项存放的地址为 M + K*6<br /><a name="X52mX"></a></p><h3 id="执行流程"><a class="markdownIt-Anchor" href="#执行流程"></a> 执行流程</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599705891658-b73c2305-ad2a-44a9-92f0-8e6fc70e4848.png#align=left&amp;display=inline&amp;height=385&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=521&amp;originWidth=930&amp;size=205626&amp;status=done&amp;style=none&amp;width=687" alt="image.png" /><br /><a name="1m6xb"></a></p><h3 id="分段-分页管理的对比"><a class="markdownIt-Anchor" href="#分段-分页管理的对比"></a> 分段、分页管理的对比</h3><p>页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管 理上的需要，完全是系统行为，对用户是不可见的。 <br />段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻 辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。 <br />页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。 <br />分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。 <br />分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599706639309-1a6bc759-051e-4e5c-96b0-10034da6fa6b.png#align=left&amp;display=inline&amp;height=171&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=247&amp;originWidth=874&amp;size=65155&amp;status=done&amp;style=none&amp;width=606" alt="image.png" /><br />分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的（比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据 不一致）<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599706703595-6f3f7787-9adb-464e-95d7-650af4be7299.png#align=left&amp;display=inline&amp;height=304&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=359&amp;originWidth=831&amp;size=119224&amp;status=done&amp;style=none&amp;width=703" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599706751173-0e66edd3-849d-45e2-bfe3-d96285b60931.png#align=left&amp;display=inline&amp;height=332&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=399&amp;originWidth=844&amp;size=164238&amp;status=done&amp;style=none&amp;width=703" alt="image.png" /><br /><br /><br />访问一个逻辑地址需要几次访存<br />分页（单级页表）：第一次访存——查内存中的页表，第二次访存——访问目标内存单元。总共两次访存 <br />分段：第一次访存——查内存中的段表，第二次访存——访问目标内存单元。总共两次访存与分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表项放到快表中，这样可以 少一次访问，加快地址变换速度。<br /><a name="iEn0n"></a></p><h2 id="段页式管理方式"><a class="markdownIt-Anchor" href="#段页式管理方式"></a> 段页式管理方式</h2><p>分页分段优缺点如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599707114990-a382f1a9-e3d6-410f-a34a-814e8ce1e6dc.png#align=left&amp;display=inline&amp;height=186&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=248&amp;originWidth=773&amp;size=97499&amp;status=done&amp;style=none&amp;width=580" alt="image.png" /><br />分段+分页=段页式管理：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599707377362-83bdbbee-f736-4d9e-861a-23818b25f9dc.png#align=left&amp;display=inline&amp;height=341&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=413&amp;originWidth=789&amp;size=112957&amp;status=done&amp;style=none&amp;width=651" alt="image.png" /><br /></p><p><a name="i1F03"></a></p><h3 id="逻辑地址结构-2"><a class="markdownIt-Anchor" href="#逻辑地址结构-2"></a> 逻辑地址结构</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599707588960-e1ac574b-b624-4dc7-bcff-7c608b071c00.png#align=left&amp;display=inline&amp;height=70&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=98&amp;originWidth=608&amp;size=26238&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599707597683-bf643c47-b67d-48bb-903d-08b5d9b9f469.png#align=left&amp;display=inline&amp;height=70&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=102&amp;originWidth=632&amp;size=31943&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br />分段是对用户可见的，程序员编程时需要显式的给出段号、段内地址。而降各段分页，分页是对用户不可兼得。系统会分局段内地址自动划分页号和页内偏移量。<br />因此段页式管理的地址结构是二维的。<br />段号的位数决定了每个进程最多可以分为几段，位号的椰树决定了每个段最大有多少页，页内偏移量决定了页面的大小、内存块大小。<br /><a name="8JnpP"></a></p><h3 id="执行流程-2"><a class="markdownIt-Anchor" href="#执行流程-2"></a> 执行流程</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599708180878-92fb2831-b561-426a-ab55-07cfb1154809.png#align=left&amp;display=inline&amp;height=378&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=540&amp;originWidth=896&amp;size=218221&amp;status=done&amp;style=none&amp;width=628" alt="image.png" /><br /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统之内存&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#操作系统之内存&quot;&gt;&lt;/a&gt; 操作系统之内存&lt;/h1&gt;
&lt;p&gt;&lt;a name=&quot;Wsdw3&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt</summary>
      
    
    
    
    <category term="操作系统" scheme="https://jie-blog.icu/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://jie-blog.icu/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
