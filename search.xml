<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>datasource包</title>
      <link href="/posts/mybatis-datasource/"/>
      <url>/posts/mybatis-datasource/</url>
      
        <content type="html"><![CDATA[<h1 id="datasource包"><a class="markdownIt-Anchor" href="#datasource包"></a> datasource包</h1><p>通过dataSource包Mybatis将完成数据源的获取、数据连接的建立等工作为操作语句打好基础。<br /><a name="tJzvq"></a></p><h1 id="基础知识铺垫"><a class="markdownIt-Anchor" href="#基础知识铺垫"></a> 基础知识铺垫</h1><p>在分析datasource包周期还需要有一些基础知识要铺垫一下。<br /><a name="ygYRa"></a></p><h2 id="javasql和javaxsql"><a class="markdownIt-Anchor" href="#javasql和javaxsql"></a> java.sql和javax.sql</h2><p>这两个包共同为Java提供了强大的JDBC能力。<br /><a name="HuBTY"></a></p><h3 id="javasql"><a class="markdownIt-Anchor" href="#javasql"></a> java.sql</h3><p>基于该包实现了SQL语句传递给数据库、从数据库以表格形式读写数据等功能。<br />java.sql提供了一个Driver接口作为数据库驱动的接口。不同的数据库厂商只需根据自身的数据库特点开发相应的Driver实现并通过DriverManager进行注册就可以使用了。<br />除此之外，java.sql还为数据库连接、SQL语句、结果集等提供了众多的类。通常完成一次数据库操作的流程如下所示：</p><ol><li>建立DriverManger对象</li><li>从DriverManger对象中获取Connection对象。</li><li>从Connection对象中获取Statement对象。</li><li>将SQL语句交给Statement对象执行，并返回结果，通常放到ResultSet中。<br /><a name="cDzN1"></a></li></ol><h3 id="javaxsql"><a class="markdownIt-Anchor" href="#javaxsql"></a> javax.sql</h3><p>该类包扩展了JDBC核心API的功能，提供了服务端的支持。<br />使用javax.sql扩展后建议使用DataSource来获取Connection对象，而不是直接获取DriverManger。<br /><a name="Rq2ur"></a></p><h2 id="drivermanger"><a class="markdownIt-Anchor" href="#drivermanger"></a> DriverManger</h2><p>它是JDBC驱动程序管理器，可以管理一组JDBC驱动程序。<br />当调用getConnection方法时，DriverManger会尝试在已加载的驱动程序中找出合适的一个，并用找出的驱动程序建立一个面向指定数据库的连接，最后将建立的连接返回。<br />其内部主要有如下几个方法：</p><ul><li>void registerDriver：向DriverManger中注册给定的驱动程序。</li><li>void deregisterDriver：从DriverManger中删除给定的驱动程序。</li><li>Driver getDriver：查找能匹配给定URL路径的驱动程序。</li><li>Enumeration getDrivers：获取当前调用者可以访问的所有已加载的JDBC驱动程序。</li><li>Connection getConnection：建立给定数据库的连接。<br /><a name="2x8wz"></a></li></ul><h2 id="datasource"><a class="markdownIt-Anchor" href="#datasource"></a> DataSource</h2><p>DataSource代表了一个实际的数据源，其功能是作为工厂提供数据源连接。<br />DataSource仅仅是一个接口，不同的数据库可以对其提供多种实现，常见实现有如下几种：</p><ul><li>基本实现：生成基本的到数据库的连接对象Connection。</li><li>连接池实现：生成的Connection对象能够自动加到连接池。</li><li>分布式事务实现：生成的Connection对象可以参与分布式事务。</li></ul><p>DataSource的具体实现中最终也是基于DriverManager获得的Connection，因此可以认为DataSource只是DriverManger的进一步封装。<br /><a name="huAiY"></a></p><h2 id="connection"><a class="markdownIt-Anchor" href="#connection"></a> Connection</h2><p>该类中的方法主要是用来完成Statement对象的获取、Connection属性的设置等功能。<br />同时，Connection中存在事务管理的方法。通过调用这些事务管理方法可以控制数据库完成相应的事务操作。<br /><a name="1OeJx"></a></p><h2 id="statement"><a class="markdownIt-Anchor" href="#statement"></a> Statement</h2><p>通常Statement对象会返回一个结果集对象ResultSet。其内部方法主要完成执行SQL语句、获取SQL语句执行结果等功能。<br /><a name="ckpCp"></a></p><h1 id="数据源工厂接口"><a class="markdownIt-Anchor" href="#数据源工厂接口"></a> 数据源工厂接口</h1><p>datasource包中DataSourceFactory作为工厂的接口，javax.sql包中DataSource作为所有工厂的接口。其类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602484058259-a51506a0-4247-4d20-89f4-ed8adbc01a0f.png#align=left&amp;display=inline&amp;height=308&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=615&amp;originWidth=1374&amp;size=1342308&amp;status=done&amp;style=none&amp;width=687" alt="image.png" /><br />既然是工厂方法模式就要有具体工厂实现，在XMLConfigBuilder的dataSourceElement方法中找到了生成具体工厂的过程，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DataSourceFactory <span class="title">dataSourceElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过Type判断数据源类型，例如ROOLED、UNPOOLED</span></span><br><span class="line">    String type = context.getStringAttribute(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取datasource下的property属性</span></span><br><span class="line">    Properties props = context.getChildrenAsProperties();</span><br><span class="line">    <span class="comment">// 根据type值找到对应的DataSourceFactory实现</span></span><br><span class="line">    DataSourceFactory factory = (DataSourceFactory) resolveClass(type).newInstance();</span><br><span class="line">    <span class="comment">// 设置相应的属性</span></span><br><span class="line">    factory.setProperties(props);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Environment declaration requires a DataSourceFactory.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="yM1Wq"></a></p><h1 id="jndi数据源工厂"><a class="markdownIt-Anchor" href="#jndi数据源工厂"></a> JNDI数据源工厂</h1><p>datasource的jndi子包提供了一个JNDI数据源工厂JndiDataSourceFactory，首先先要了解一下JNDI的概念。<br /><a name="0ZiRf"></a></p><h2 id="jndi数据源"><a class="markdownIt-Anchor" href="#jndi数据源"></a> JNDI数据源</h2><p>JNDI是Java命名和目录接口，它能够为Java应用程序提供命名和目录访问的接口，也可以将其理解为一种命名规范。在使用该规范为资源命名并将资源放入环境中后，可以通过命名从环境中查找对应的资源。<br />数据源作为一种资源就可以使用JNDI命名后放入到环境中，这就是JNDI数据源。之后只需要通过名称信息就可以查找出来。<br /><a name="1xHzT"></a></p><h2 id="工厂实现"><a class="markdownIt-Anchor" href="#工厂实现"></a> 工厂实现</h2><p>该数据源工厂的getDataSource方法只负责将成员变量中的DataSource对象返回，从环境中找到指定的DataSource操作是在setProperties中实现的，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 初始上下文环境</span></span><br><span class="line">    InitialContext initCtx;</span><br><span class="line">    <span class="comment">// 获取配置信息，根据配置信息初始化环境</span></span><br><span class="line">    Properties env = getEnvProperties(properties);</span><br><span class="line">    <span class="keyword">if</span> (env == <span class="keyword">null</span>) &#123;</span><br><span class="line">      initCtx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      initCtx = <span class="keyword">new</span> InitialContext(env);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// 从配置信息中获取数据源信息</span></span><br><span class="line">    <span class="keyword">if</span> (properties.containsKey(INITIAL_CONTEXT)</span><br><span class="line">        &amp;&amp; properties.containsKey(DATA_SOURCE)) &#123;</span><br><span class="line">      <span class="comment">// 定位到initial_context给出的起始环境</span></span><br><span class="line">      Context ctx = (Context) initCtx.lookup(properties.getProperty(INITIAL_CONTEXT));</span><br><span class="line">      <span class="comment">// 从起始环境找到指定的数据源</span></span><br><span class="line">      dataSource = (DataSource) ctx.lookup(properties.getProperty(DATA_SOURCE));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (properties.containsKey(DATA_SOURCE)) &#123;</span><br><span class="line">      <span class="comment">// 从整个环境中找到指定数据源</span></span><br><span class="line">      dataSource = (DataSource) initCtx.lookup(properties.getProperty(DATA_SOURCE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> DataSourceException(<span class="string">&quot;There was an error configuring JndiDataSourceTransactionPool. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，从本质上讲，JndiDataSourceFactory不是在生产数据源，而是负责查找数据源。<br /><a name="SLRty"></a></p><h1 id="非池化数据源及工厂"><a class="markdownIt-Anchor" href="#非池化数据源及工厂"></a> 非池化数据源及工厂</h1><p>datasource的unpooled子包提供了非池化的数据源工厂即非池化的数据源。<br /><a name="lyN2U"></a></p><h2 id="非池化数据源工厂"><a class="markdownIt-Anchor" href="#非池化数据源工厂"></a> 非池化数据源工厂</h2><p>该类直接在自身的构造方法中创建了数据源对象并保存在了自身的成员变量中。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSourceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.dataSource = <span class="keyword">new</span> UnpooledDataSource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该工厂的setProperties方法负责为工厂的数据源设置属性，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 驱动的属性</span></span><br><span class="line">  Properties driverProperties = <span class="keyword">new</span> Properties();</span><br><span class="line">  <span class="comment">// 生成一个包含DataSource的元对象</span></span><br><span class="line">  MetaObject metaDataSource = SystemMetaObject.forObject(dataSource);</span><br><span class="line">  <span class="comment">// 设置属性</span></span><br><span class="line">  <span class="keyword">for</span> (Object key : properties.keySet()) &#123;</span><br><span class="line">    String propertyName = (String) key;</span><br><span class="line">    <span class="comment">// 如果是以driver.开头的匹配信息</span></span><br><span class="line">    <span class="keyword">if</span> (propertyName.startsWith(DRIVER_PROPERTY_PREFIX)) &#123;</span><br><span class="line">      <span class="comment">// 记录配置信息</span></span><br><span class="line">      String value = properties.getProperty(propertyName);</span><br><span class="line">      driverProperties.setProperty(propertyName.substring(DRIVER_PROPERTY_PREFIX_LENGTH), value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (metaDataSource.hasSetter(propertyName)) &#123;</span><br><span class="line">      <span class="comment">// 通过反射为DataSource设置其他属性</span></span><br><span class="line">      String value = (String) properties.get(propertyName);</span><br><span class="line">      Object convertedValue = convertValue(metaDataSource, propertyName, value);</span><br><span class="line">      metaDataSource.setValue(propertyName, convertedValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> DataSourceException(<span class="string">&quot;Unknown DataSource property: &quot;</span> + propertyName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (driverProperties.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 将以driver.开头的配置信息放入到DataSource的driverProperies属性中</span></span><br><span class="line">    metaDataSource.setValue(<span class="string">&quot;driverProperties&quot;</span>, driverProperties);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="0oRO1"></a></p><h2 id="非池化数据源"><a class="markdownIt-Anchor" href="#非池化数据源"></a> 非池化数据源</h2><p>非池化数据源是最简单的数据源，其只需要在每次请求链接时打开连接，在每次连接结束时关闭连接即可。<br />其内部属性和配置信息一一对应，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 驱动加载器</span></span><br><span class="line"><span class="keyword">private</span> ClassLoader driverClassLoader;</span><br><span class="line"><span class="comment">// 启动配置信息</span></span><br><span class="line"><span class="keyword">private</span> Properties driverProperties;</span><br><span class="line"><span class="comment">// 已经注册的所有驱动</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Driver&gt; registeredDrivers = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 数据库驱动</span></span><br><span class="line"><span class="keyword">private</span> String driver;</span><br><span class="line"><span class="comment">// 数据源地址</span></span><br><span class="line"><span class="keyword">private</span> String url;</span><br><span class="line"><span class="comment">// 数据源用户名</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="comment">// 数据源密码</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="comment">// 是否自动提交</span></span><br><span class="line"><span class="keyword">private</span> Boolean autoCommit;</span><br><span class="line"><span class="comment">// 默认事务隔离级别</span></span><br><span class="line"><span class="keyword">private</span> Integer defaultTransactionIsolationLevel;</span><br><span class="line"><span class="comment">// 最长等待时间，发出请求后最长等待该时间后如果数据库还没有回应则认为失败</span></span><br><span class="line"><span class="keyword">private</span> Integer defaultNetworkTimeout;</span><br></pre></td></tr></table></figure><p>数据源的最重要的功能就是给出数据库连接对象Connection，该功能由doGetConnection提供，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Connection <span class="title">doGetConnection</span><span class="params">(Properties properties)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化驱动</span></span><br><span class="line">  initializeDriver();</span><br><span class="line">  <span class="comment">// 通过DriverManger获取连接</span></span><br><span class="line">  Connection connection = DriverManager.getConnection(url, properties);</span><br><span class="line">  <span class="comment">// 配置连接</span></span><br><span class="line">  configureConnection(connection);</span><br><span class="line">  <span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，Connection对象是由DriverManager提供的。此前，还调用了initializeDriver来初始化驱动，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initializeDriver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 如果所需的驱动尚未注册到registeredDrivers</span></span><br><span class="line">  <span class="keyword">if</span> (!registeredDrivers.containsKey(driver)) &#123;</span><br><span class="line">    Class&lt;?&gt; driverType;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 如果存在驱动类加载器</span></span><br><span class="line">      <span class="keyword">if</span> (driverClassLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 优先使用驱动类加载器加载驱动类</span></span><br><span class="line">        driverType = Class.forName(driver, <span class="keyword">true</span>, driverClassLoader);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用Resources中的加载器加载驱动</span></span><br><span class="line">        driverType = Resources.classForName(driver);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 实例化驱动</span></span><br><span class="line">      Driver driverInstance = (Driver)driverType.newInstance();</span><br><span class="line">      <span class="comment">// 向DriverManager中注册驱动代理</span></span><br><span class="line">      DriverManager.registerDriver(<span class="keyword">new</span> DriverProxy(driverInstance));</span><br><span class="line">      <span class="comment">// 注册到registeredDrivers表示驱动已经被加载</span></span><br><span class="line">      registeredDrivers.put(driver, driverInstance);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">&quot;Error setting driver on UnpooledDataSource. Cause: &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="A0cty"></a></p><h1 id="池化数据源"><a class="markdownIt-Anchor" href="#池化数据源"></a> 池化数据源</h1><p>在连接池中总保留一定数量的数据库连接以备使用，可以在需要的时候取出，不需要的时候放回，这样就减少了连接的创建和销毁工作，从而提高了整体的效率。<br />之前分析得出非池化的数据源UnpooledDataSource获取DataSource时，实际上就是在UnPooledDataSource中的DriverManger对象给出的。因此，这些连接Connection对象不属于任何一个连接池。<br />关于PooledDataSourceFactory，其内部仅仅重写了UnpooledDataSource构造方法而已，比较简单，这里就不做分析直接开始分析数据源了。<br /><a name="9n1Ig"></a></p><h2 id="池化数据源属性"><a class="markdownIt-Anchor" href="#池化数据源属性"></a> 池化数据源属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PoolState state = <span class="keyword">new</span> PoolState(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 持有一个UnpooledDataSource对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> UnpooledDataSource dataSource;</span><br><span class="line"><span class="comment">// 和连接池设置有关的配置项</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumActiveConnections = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumIdleConnections = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumCheckoutTime = <span class="number">20000</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolTimeToWait = <span class="number">20000</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumLocalBadConnectionTolerance = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">protected</span> String poolPingQuery = <span class="string">&quot;NO PING QUERY SET&quot;</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> poolPingEnabled;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> poolPingConnectionsNotUsedFor;</span><br><span class="line"><span class="comment">// 存储池子中的连接编码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> expectedConnectionTypeCode;</span><br></pre></td></tr></table></figure><p>以下将对其中重要的属性进行一一分析。<br /><a name="EmQ82"></a></p><h3 id="state"><a class="markdownIt-Anchor" href="#state"></a> State</h3><p>state是一个PoolState对象，其内部存储了所有数据库连接及状态信息。数据库连接池大小的设置需要根据业务场景判断。因此，对连接池的运行数据进行统计是很有必要的。<br />PooledDataSource没有直接使用列表而是使用PoolState对象来存储所有的数据库连接，就是为了统计连接池运行数据的需要。<br /><a name="vR0I5"></a></p><h4 id="poolstate"><a class="markdownIt-Anchor" href="#poolstate"></a> PoolState</h4><p>该类的属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 池化数据源</span></span><br><span class="line"><span class="keyword">protected</span> PooledDataSource dataSource;</span><br><span class="line"><span class="comment">// 空闲的连接</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> List&lt;PooledConnection&gt; idleConnections = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 活动的连接</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> List&lt;PooledConnection&gt; activeConnections = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 连接被取出的次数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> requestCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 取出请求花费时间的累计值。从准备取出请求到结束的时间为取出请求花费的时间</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> accumulatedRequestTime = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 累计被检出的时间</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> accumulatedCheckoutTime = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 声明过期的连接数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> claimedOverdueConnectionCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 过期的连接数的总检出时长</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> accumulatedCheckoutTimeOfOverdueConnections = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 总等待时长</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> accumulatedWaitTime = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 等待的轮次</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> hadToWaitCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 坏连接的数目</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> badConnectionCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><a name="wWnKG"></a></p><h3 id="datasource-2"><a class="markdownIt-Anchor" href="#datasource-2"></a> dataSource</h3><p>当池化的数据源在连接池中的连接不够时也需要创建新的连接，而属性dataSource是一个UnpooledDataSource对象，在需要创建新的连接时由该属性给出。<br /><a name="a2j9f"></a></p><h3 id="expectedconnectiontypecode"><a class="markdownIt-Anchor" href="#expectedconnectiontypecode"></a> expectedConnectionTypeCode</h3><p>一个数据源连接池必须确保池中的每个连接都是等价的，这样才能保证每次从连接池取出链接不会存在差异性。expectedConnectionTypeCode存储的就是该数据源的类型编码。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">assembleConnectionTypeCode</span><span class="params">(String url, String username, String password)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="string">&quot;&quot;</span> + url + username + password).hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该值在创建新的PooledDataSource时生成，然后会赋值给每一个从该对象的连接池取出的PooledConnection。当connection归还给连接池时会校验该值从而保证换回来的对象属于该池。<br /><a name="uLYoC"></a></p><h2 id="池化链接的给出与收回"><a class="markdownIt-Anchor" href="#池化链接的给出与收回"></a> 池化链接的给出与收回</h2><p><a name="pCnZI"></a></p><h3 id="给出池化连接"><a class="markdownIt-Anchor" href="#给出池化连接"></a> 给出池化连接</h3><p>该部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PooledConnection <span class="title">popConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span> countedWait = <span class="keyword">false</span>;</span><br><span class="line">   PooledConnection conn = <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">// 用于统计取出链接花费的时间点</span></span><br><span class="line">   <span class="keyword">long</span> t = System.currentTimeMillis();</span><br><span class="line">   <span class="keyword">int</span> localBadConnectionCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">// 给state加同步锁</span></span><br><span class="line">     <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">       <span class="comment">// 池中存在空闲连接</span></span><br><span class="line">       <span class="keyword">if</span> (!state.idleConnections.isEmpty()) &#123;</span><br><span class="line">         <span class="comment">// 左移操作，取出第一个连接</span></span><br><span class="line">         conn = state.idleConnections.remove(<span class="number">0</span>);</span><br><span class="line">         <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">           log.debug(<span class="string">&quot;Checked out connection &quot;</span> + conn.getRealHashCode() + <span class="string">&quot; from pool.&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">// 池中没有空余连接</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 池中还有空余位置</span></span><br><span class="line">         <span class="keyword">if</span> (state.activeConnections.size() &lt; poolMaximumActiveConnections) &#123;</span><br><span class="line">           <span class="comment">// 创建新连接</span></span><br><span class="line">           conn = <span class="keyword">new</span> PooledConnection(dataSource.getConnection(), <span class="keyword">this</span>);</span><br><span class="line">           <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">             log.debug(<span class="string">&quot;Created connection &quot;</span> + conn.getRealHashCode() + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="comment">// 连接池已满，不能创建新的连接</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 找到借出去最久的连接</span></span><br><span class="line">           PooledConnection oldestActiveConnection = state.activeConnections.get(<span class="number">0</span>);</span><br><span class="line">           <span class="comment">// 查看已经借出了多久</span></span><br><span class="line">           <span class="keyword">long</span> longestCheckoutTime = oldestActiveConnection.getCheckoutTime();</span><br><span class="line">           <span class="comment">// 如果已经超市</span></span><br><span class="line">           <span class="keyword">if</span> (longestCheckoutTime &gt; poolMaximumCheckoutTime) &#123;</span><br><span class="line">             <span class="comment">// 声明该链接超时未还</span></span><br><span class="line">             state.claimedOverdueConnectionCount++;</span><br><span class="line">             state.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;</span><br><span class="line">             state.accumulatedCheckoutTime += longestCheckoutTime;</span><br><span class="line">             <span class="comment">// 因超时而除名</span></span><br><span class="line">             state.activeConnections.remove(oldestActiveConnection);</span><br><span class="line">             <span class="comment">// 如果超时不还的连接没有设置自动提交事务</span></span><br><span class="line">             <span class="keyword">if</span> (!oldestActiveConnection.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">// 尝试替它回滚</span></span><br><span class="line">                 oldestActiveConnection.getRealConnection().rollback();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                 <span class="comment">// 如果回滚时报仅仅记录不抛出异常</span></span><br><span class="line">                 log.debug(<span class="string">&quot;Bad connection. Could not roll back&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 创建一个连接替代超时不还连接的位置</span></span><br><span class="line">             conn = <span class="keyword">new</span> PooledConnection(oldestActiveConnection.getRealConnection(), <span class="keyword">this</span>);</span><br><span class="line">             conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp());</span><br><span class="line">             conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp());</span><br><span class="line">             oldestActiveConnection.invalidate();</span><br><span class="line">             <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">               log.debug(<span class="string">&quot;Claimed overdue connection &quot;</span> + conn.getRealHashCode() + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">          <span class="comment">// 借出最久单位逾期</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 继续等待</span></span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (!countedWait) &#123;</span><br><span class="line">                 <span class="comment">// 记录发生等待的次数，某次请求等待多伦也算作只发生了一次等待</span></span><br><span class="line">                 state.hadToWaitCount++;</span><br><span class="line">                 countedWait = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                 log.debug(<span class="string">&quot;Waiting as long as &quot;</span> + poolTimeToWait + <span class="string">&quot; milliseconds for connection.&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">long</span> wt = System.currentTimeMillis();</span><br><span class="line">               <span class="comment">// 沉睡一段时间再试，防止一直占有计算资源</span></span><br><span class="line">               state.wait(poolTimeToWait);</span><br><span class="line">               state.accumulatedWaitTime += System.currentTimeMillis() - wt;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 取得了连接</span></span><br><span class="line">       <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 判断连接是否可用，如果可用</span></span><br><span class="line">         <span class="keyword">if</span> (conn.isValid()) &#123;</span><br><span class="line">           <span class="comment">// 该链接没有设置自动回滚</span></span><br><span class="line">           <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">             <span class="comment">// 回滚未提交操作</span></span><br><span class="line">             conn.getRealConnection().rollback();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 每个借出去的连接都打上数据源的连接类型编码，以便在归还时确保正确</span></span><br><span class="line">           conn.setConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password));</span><br><span class="line">           <span class="comment">// 数据记录操作  </span></span><br><span class="line">           conn.setCheckoutTimestamp(System.currentTimeMillis());</span><br><span class="line">           conn.setLastUsedTimestamp(System.currentTimeMillis());</span><br><span class="line">           state.activeConnections.add(conn);</span><br><span class="line">           state.requestCount++;</span><br><span class="line">           state.accumulatedRequestTime += System.currentTimeMillis() - t;</span><br><span class="line">           <span class="comment">// 连接不可用</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">             log.debug(<span class="string">&quot;A bad connection (&quot;</span> + conn.getRealHashCode() + <span class="string">&quot;) was returned from the pool, getting another connection.&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           state.badConnectionCount++;</span><br><span class="line">           localBadConnectionCount++;</span><br><span class="line">           <span class="comment">// 直接删除</span></span><br><span class="line">           conn = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">// 如果没有一个连接可用，说明连不上数据库</span></span><br><span class="line">           <span class="keyword">if</span> (localBadConnectionCount &gt; (poolMaximumIdleConnections + poolMaximumLocalBadConnectionTolerance)) &#123;</span><br><span class="line">             <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">               log.debug(<span class="string">&quot;PooledDataSource: Could not get a good connection to the database.&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">&quot;PooledDataSource: Could not get a good connection to the database.&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果到这里还没找到连接，则会循环此操作，继续尝试取出连接</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">       log.debug(<span class="string">&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> conn;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><a name="cfJ6I"></a></p><h3 id="取出池化连接"><a class="markdownIt-Anchor" href="#取出池化连接"></a> 取出池化连接</h3><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pushConnection</span><span class="params">(PooledConnection conn)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">    <span class="comment">// 将该链接从活跃连接中删除</span></span><br><span class="line">    state.activeConnections.remove(conn);</span><br><span class="line">    <span class="comment">// 当前连接可用</span></span><br><span class="line">    <span class="keyword">if</span> (conn.isValid()) &#123;</span><br><span class="line">      <span class="comment">// 判断连接池未满且该链接确实属于该连接池  </span></span><br><span class="line">      <span class="keyword">if</span> (state.idleConnections.size() &lt; poolMaximumIdleConnections &amp;&amp; conn.getConnectionTypeCode() == expectedConnectionTypeCode) &#123;</span><br><span class="line">        state.accumulatedCheckoutTime += conn.getCheckoutTime();</span><br><span class="line">        <span class="comment">// 如果链接没有设置自动提交</span></span><br><span class="line">        <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">          <span class="comment">// 将未完成的操作回滚  </span></span><br><span class="line">          conn.getRealConnection().rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新整理连接</span></span><br><span class="line">        PooledConnection newConn = <span class="keyword">new</span> PooledConnection(conn.getRealConnection(), <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 将连接放入空闲池</span></span><br><span class="line">        state.idleConnections.add(newConn);</span><br><span class="line">        newConn.setCreatedTimestamp(conn.getCreatedTimestamp());</span><br><span class="line">        newConn.setLastUsedTimestamp(conn.getLastUsedTimestamp());</span><br><span class="line">        <span class="comment">// 连接未校验，以便取出时重新校验</span></span><br><span class="line">        conn.invalidate();</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">          log.debug(<span class="string">&quot;Returned connection &quot;</span> + newConn.getRealHashCode() + <span class="string">&quot; to pool.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        state.notifyAll();</span><br><span class="line">      <span class="comment">// 连接池已满或者该链接不属于该连接池</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        state.accumulatedCheckoutTime += conn.getCheckoutTime();</span><br><span class="line">        <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">          conn.getRealConnection().rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接关闭连接，而不是将其放入到连接池中</span></span><br><span class="line">        conn.getRealConnection().close();</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">          log.debug(<span class="string">&quot;Closed connection &quot;</span> + conn.getRealHashCode() + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        conn.invalidate();</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 当前连接不可用</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;A bad connection (&quot;</span> + conn.getRealHashCode() + <span class="string">&quot;) attempted to return to the pool, discarding connection.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      state.badConnectionCount++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="FKd7T"></a></p><h3 id="池化数据源中链接的等价性"><a class="markdownIt-Anchor" href="#池化数据源中链接的等价性"></a> 池化数据源中链接的等价性</h3><p>一个数据源的连接池必须保证池中的每个链接都是等价的，PooledDataSource通过存储在expectedConnectionTypeCode中的数据源连接类型编码保证这一点。PooledDataSource在每次给出链接时会给链接写入编码，在收回连接时会校验编码。这就避免了非本池连接放入该池。   <br />如果在使用连接时更改了dirver、url等属性也不会造成非本池连接放入该池的结果。因为修改这些属性的时候必定会调用其setter方法，以setDriver为例，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDriver</span><span class="params">(String driver)</span> </span>&#123;</span><br><span class="line">  dataSource.setDriver(driver);</span><br><span class="line">  forceCloseAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在set以后都调用了forceCloseAll方法来将所有的活动和空闲连接全部关闭，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forceCloseAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 增加同步锁</span></span><br><span class="line">  <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">    <span class="comment">// 重新计算和更新连接类型代码</span></span><br><span class="line">    expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword());</span><br><span class="line">    <span class="comment">// 依次循环所有的活动链接</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = state.activeConnections.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        PooledConnection conn = state.activeConnections.remove(i - <span class="number">1</span>);</span><br><span class="line">        conn.invalidate();</span><br><span class="line"></span><br><span class="line">        Connection realConn = conn.getRealConnection();</span><br><span class="line">        <span class="keyword">if</span> (!realConn.getAutoCommit()) &#123;</span><br><span class="line">          realConn.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        realConn.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依次关闭所有的空闲连接  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = state.idleConnections.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        PooledConnection conn = state.idleConnections.remove(i - <span class="number">1</span>);</span><br><span class="line">        conn.invalidate();</span><br><span class="line"></span><br><span class="line">        Connection realConn = conn.getRealConnection();</span><br><span class="line">        <span class="keyword">if</span> (!realConn.getAutoCommit()) &#123;</span><br><span class="line">          realConn.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        realConn.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;PooledDataSource forcefully closed/removed all connections.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种机制保证了池化数据源的链接始终等价的。<br /><a name="XJgus"></a></p><h2 id="池化连接"><a class="markdownIt-Anchor" href="#池化连接"></a> 池化连接</h2><p>关闭一个池化连接时，不应该真正的关闭掉，而是应该将自己放回连接池。正因为如此，PooledDataSource获得的数据库连接不能是普通的Connection类而是PooledConnection类。这类事普通Connection类的代理类。其最终的一个重要工作就是修改Connection的close方法行为。<br />PooledConnection类继承了InvocationHandler接口实现了动态代理类，其invoke源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">// 获取方法名</span></span><br><span class="line">  String methodName = method.getName();</span><br><span class="line">  <span class="keyword">if</span> (CLOSE.hashCode() == methodName.hashCode() &amp;&amp; CLOSE.equals(methodName)) &#123;</span><br><span class="line">    <span class="comment">// 把Connection返回给连接池</span></span><br><span class="line">    dataSource.pushConnection(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 检查连接是否可用</span></span><br><span class="line">    <span class="keyword">if</span> (!Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="comment">// issue #579 toString() should never fail</span></span><br><span class="line">      <span class="comment">// throw an SQLException instead of a Runtime</span></span><br><span class="line">      checkConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用真正的连接去执行</span></span><br><span class="line">    <span class="keyword">return</span> method.invoke(realConnection, args);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
          <category> 配置解析包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>scripting包</title>
      <link href="/posts/mybatis-scripting/"/>
      <url>/posts/mybatis-scripting/</url>
      
        <content type="html"><![CDATA[<h1 id="scripting包"><a class="markdownIt-Anchor" href="#scripting包"></a> scripting包</h1><p>mapper中的SQL语句支持使用非常灵活的SQL语句组建方式，比如可以在组建语句时使用foreach、where、if等标签。但是，无论使用哪种方式，最终还是会被解析成为最基本的SQL语句才能被数据库接受，这个解析过程主要由scripting包完成。<br /><a name="Wf20I"></a></p><h1 id="语言驱动接口及语言驱动注册表"><a class="markdownIt-Anchor" href="#语言驱动接口及语言驱动注册表"></a> 语言驱动接口及语言驱动注册表</h1><p><a name="MjFF3"></a></p><h2 id="languagedriver"><a class="markdownIt-Anchor" href="#languagedriver"></a> LanguageDriver</h2><p>LanguageDriver为语言驱动类的接口。该接口内部一共定义了三个方法，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LanguageDriver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建参数处理器，参数处理器能够将实参传给JDBC statement</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> mappedStatement 完整的数据库操作节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> parameterObject 参数对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> boundSql 数据库操作语句转化的BoundSql对象.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 参数处理器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">ParameterHandler <span class="title">createParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建SqlSource对象（基于映射文件方式）。该方法在Mybatis启动阶段读取映射接口或映射文件时被调用</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> configuration 配置信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> script 映射文件中的数据库操作节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> parameterType 参数类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> SqlSource 对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, XNode script, Class&lt;?&gt; parameterType)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建SqlSource对象（基于注解的方式）。该方式在Mybatis启动阶段读取映射接口或映射文件时被调用</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> configuration 配置信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> script 注解中的SQL字符串</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> parameterType 参数类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> SqlSource 对象 准确地说是DynamicSqlSource和RowSqlSource中的一中</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, String script, Class&lt;?&gt; parameterType)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LanguageDriver接口默认有两个实现，分别是RawLanguageDriver和XMLLanguageDriver，其中RawLanguageDriver是XMLLanguageDriver的子类。<br />RawLanguageDriver的所有方法其实都是XMLLanguageDriver完成的。并且在XMLLanguageDriver类完成操作后通过checkIsNotDynamic方法校验SqlSource必须为RowSqlSource类型。因此说RawLanguageDriver实际上是通过checkIsNotDynamic方法对XMLLanguageDriver类的裁剪，使得自身仅仅支持RowSqlSource类型的SqlSource。这种自身功能是父类功能子集的模型是一种先繁再简的方法。<br />此外，Mybatis还允许用户自己给出LanguageDriver的实现类，通过配置文件中的defaultScriptingLanguage实行将其指定为默认的脚本驱动。<br /><a name="ILV7A"></a></p><h2 id="languagedriverregistry"><a class="markdownIt-Anchor" href="#languagedriverregistry"></a> LanguageDriverRegistry</h2><p>LanguageDriverRegistry作为语言驱动的注册表管理所有的语言驱动，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有的语言驱动类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;? extends LanguageDriver&gt;, LanguageDriver&gt; LANGUAGE_DRIVER_MAP = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 默认的语言驱动类</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;? extends LanguageDriver&gt; defaultDriverClass;</span><br></pre></td></tr></table></figure><p>该类内部主要包括注册驱动、选取驱动。<br /><a name="dVsCk"></a></p><h1 id="sql节点树组建"><a class="markdownIt-Anchor" href="#sql节点树组建"></a> SQL节点树组建</h1><p>众多SQL节点组成的就是一棵树，首先要做的就是将XML中的信息读取出来，然后在内存中将XML树组建为一个SQL节点树。SQL节点树的组建就是由XMLScriptBuilder类负责的。<br />该类内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前要处理的XML节点  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> XNode context;</span><br><span class="line"><span class="comment">// 当前节点是否为动态节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isDynamic;</span><br><span class="line"><span class="comment">// 输入参数的类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; parameterType;</span><br><span class="line"><span class="comment">// 节点类型和对应的处理器组成的Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, NodeHandler&gt; nodeHandlerMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>在该类的内部定义了一个内部接口NodeHandler，该接口主要负责将节点拼装到节点数中。其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">NodeHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 该方法将当前节点拼装到节点数中</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleNode</span><span class="params">(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个SQL节点都对应了一个NodeHandler实现类，NodeHandler接口与其实现类的类图如下图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602289550226-bbe5ed50-bdda-4587-8460-16be900103dd.png#align=left&amp;display=inline&amp;height=244&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=488&amp;originWidth=1123&amp;size=925441&amp;status=done&amp;style=none&amp;width=561.5" alt="image.png" /><br />SQL节点与NodeHandler的对应关系由nodeHandlerMap所存储。<br />以IfHandler为例来分析XML信息如何组建成SQL节点树，IfHandler源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">IfHandler</span> <span class="keyword">implements</span> <span class="title">NodeHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">IfHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Prevent Synthetic Access</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNode</span><span class="params">(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解析该节点的下级节点</span></span><br><span class="line">    MixedSqlNode mixedSqlNode = parseDynamicTags(nodeToHandle);</span><br><span class="line">    <span class="comment">// 获取该节点的test节点</span></span><br><span class="line">    String test = nodeToHandle.getStringAttribute(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建一个IfSqlNode</span></span><br><span class="line">    IfSqlNode ifSqlNode = <span class="keyword">new</span> IfSqlNode(mixedSqlNode, test);</span><br><span class="line">    <span class="comment">// 将创建的IfSqlNode存放到SQL树中</span></span><br><span class="line">    targetContents.add(ifSqlNode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，组件SQL节点树的过程是一个深度优先遍历的过程。在下级节点处理完毕后，提取了XML中的信息组建成IfSqlNode对象，然后将IfSqlNode对象放入到了SQL节点数中。<br />从根节点组建方法的入口方法是parseScriptNode，目的是为了解析节点生成SqlSource对象，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parseScriptNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 解析节点得到MixedSqlNode</span></span><br><span class="line">  MixedSqlNode rootSqlNode = parseDynamicTags(context);</span><br><span class="line">  SqlSource sqlSource;</span><br><span class="line">  <span class="comment">// 根据是否有动态，创建对应的SqlSource</span></span><br><span class="line">  <span class="keyword">if</span> (isDynamic) &#123;</span><br><span class="line">    sqlSource = <span class="keyword">new</span> DynamicSqlSource(configuration, rootSqlNode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sqlSource = <span class="keyword">new</span> RawSqlSource(configuration, rootSqlNode, parameterType);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sqlSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其主要操作在parseDynamicTags完成，即把对象解析为节点树，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> MixedSqlNode <span class="title">parseDynamicTags</span><span class="params">(XNode node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// XNode拆分出的SqlNode列表</span></span><br><span class="line">  List&lt;SqlNode&gt; contents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 输入XNode的子XNode</span></span><br><span class="line">  NodeList children = node.getNode().getChildNodes();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">    <span class="comment">// 循环遍历每一个XNode</span></span><br><span class="line">    XNode child = node.newXNode(children.item(i));</span><br><span class="line">    <span class="comment">// CDTATASection类型或者是Test类型的XNode节点</span></span><br><span class="line">    <span class="keyword">if</span> (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) &#123;</span><br><span class="line">      <span class="comment">// 获取XNode的信息</span></span><br><span class="line">      String data = child.getStringBody(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      TextSqlNode textSqlNode = <span class="keyword">new</span> TextSqlNode(data);</span><br><span class="line">      <span class="comment">// 只要有一个TestSqlNode对象是动态的，那么整个MixedSqlNode就是动态的</span></span><br><span class="line">      <span class="keyword">if</span> (textSqlNode.isDynamic()) &#123;</span><br><span class="line">        contents.add(textSqlNode);</span><br><span class="line">        isDynamic = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        contents.add(<span class="keyword">new</span> StaticTextSqlNode(data));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 子XNode也是Node类型</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getNode().getNodeType() == Node.ELEMENT_NODE) &#123; <span class="comment">// issue #628</span></span><br><span class="line">      String nodeName = child.getNode().getNodeName();</span><br><span class="line">      <span class="comment">// 找到对应的处理器</span></span><br><span class="line">      NodeHandler handler = nodeHandlerMap.get(nodeName);</span><br><span class="line">      <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Unknown element &lt;&quot;</span> + nodeName + <span class="string">&quot;&gt; in SQL statement.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 用处理器节点处理</span></span><br><span class="line">      handler.handleNode(child, contents);</span><br><span class="line">      isDynamic = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个混合节点，其实就是一个SQL节点树</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MixedSqlNode(contents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parseDynamicTags会逐步分析XML文件中的节点并使用对应的NodeHandler实现来处理该节点，最终将所有的节点整合到一个MixedSqlNode对象中。MixedSqlNode对象就是SQL节点树。<br />在整合节点树的过程中，只要存在一个动态节点，那么该SQL树就会被认作动态的，动态的SQL节点树将用来创建DynamicSqlSource对象，否则就创建RawSqlSource。<br /><a name="mQHfY"></a></p><h1 id="sql节点树的解析"><a class="markdownIt-Anchor" href="#sql节点树的解析"></a> SQL节点树的解析</h1><p>对创建好的SQL节点数的解析主要是在scripting包的xmltags子包中进行展开。<br /><a name="uMgGN"></a></p><h2 id="ognl"><a class="markdownIt-Anchor" href="#ognl"></a> OGNL</h2><p>在分析源码之前，首先要了解一下OGNL。<br />OGNL（对象导航语言）是一种强大的表达式语言（EL）。通过它能够完成从集合中选取对象、读写对象的属性、调用对象和类的方法、表达式求值与判断等工作。<br />OGNL有Java工具包，只要引用它就可以在Java中使用OGNL的功能，OGNL主要有三个概念：</p><ul><li>表达式（expression）：是一个带有语法含义的字符串，是整个OGNL的核心内容，通过表达式来确定需要进行的OGNL操作。</li><li>根对象（root）：可以理解为OGNL的被操作对象。表达式中表示的操作就是针对根对象展开的。</li><li>上下文（context）：整个OGNL处理的上下文环境，该环境是Map对象。在进行OGNL处理之前，可以传入一个初始化过得上下文环境。<br /><a name="MFVMQ"></a></li></ul><h2 id="xmltags中的ognl"><a class="markdownIt-Anchor" href="#xmltags中的ognl"></a> xmltags中的OGNL</h2><p>为了更好地完成OGNL的解析工作，xmltags中还设置了三个相关的类，分别是：OgnlCache、OgnlClassResolver、OgnlMemberAccess。<br /><a name="JayZh"></a></p><h3 id="ognlclassresolver"><a class="markdownIt-Anchor" href="#ognlclassresolver"></a> OgnlClassResolver</h3><p>该类是OGNL定义的一个类，OGNL可以通过该类进行类的读取，即将类名转化为一个类。<br />OgnlClassResolver继承自DefaultClassResolver，并覆盖了其toClassForName方法，这样就可以通过Resources来读取类了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OgnlClassResolver</span> <span class="keyword">extends</span> <span class="title">DefaultClassResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Class <span class="title">toClassForName</span><span class="params">(String className)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Resources.classForName(className);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="UQ8Qq"></a></p><h3 id="ognlmemberaccess"><a class="markdownIt-Anchor" href="#ognlmemberaccess"></a> OgnlMemberAccess</h3><p>MemberAccess是OGNL提供的一个钩子接口，OGNL借助这个接口为访问对象的属性做好准备。<br />OgnlMemberAccess实现了MemberAccess接口，并基于反射修改了对象的访问性功能，这样OGNL便可以基于这些功能为访问对象的属性做好准备。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OgnlMemberAccess</span> <span class="keyword">implements</span> <span class="title">MemberAccess</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当前环境下，通过反射是否能够修改对象属性的可访问性</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> canControlMemberAccessible;</span><br><span class="line"></span><br><span class="line">  OgnlMemberAccess() &#123;</span><br><span class="line">    <span class="keyword">this</span>.canControlMemberAccessible = Reflector.canControlMemberAccessible();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置属性的可访问性</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">setup</span><span class="params">(Map context, Object target, Member member, String propertyName)</span> </span>&#123;</span><br><span class="line">    Object result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果允许修改属性的可访问性</span></span><br><span class="line">    <span class="keyword">if</span> (isAccessible(context, target, member, propertyName)) &#123;</span><br><span class="line">      AccessibleObject accessible = (AccessibleObject) member;</span><br><span class="line">      <span class="comment">// 如果属性原本不可访问</span></span><br><span class="line">      <span class="keyword">if</span> (!accessible.isAccessible()) &#123;</span><br><span class="line">        result = Boolean.FALSE;</span><br><span class="line">        <span class="comment">// 将属性修改为可访问</span></span><br><span class="line">        accessible.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将属性的可访问性恢复到指定状态</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restore</span><span class="params">(Map context, Object target, Member member, String propertyName,</span></span></span><br><span class="line"><span class="function"><span class="params">      Object state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ((AccessibleObject) member).setAccessible((Boolean) state);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断对象属性是否可访问</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccessible</span><span class="params">(Map context, Object target, Member member, String propertyName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> canControlMemberAccessible;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="Cwk3y"></a></p><h3 id="ognlcache"><a class="markdownIt-Anchor" href="#ognlcache"></a> OgnlCache</h3><p>为了提升OGNL的运行效率，Mybatis还提供了该缓存类，其内部源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OgnlCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> OgnlMemberAccess MEMBER_ACCESS = <span class="keyword">new</span> OgnlMemberAccess();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> OgnlClassResolver CLASS_RESOLVER = <span class="keyword">new</span> OgnlClassResolver();</span><br><span class="line">  <span class="comment">// 缓存解析后的OGNL表达式，提高效率</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; expressionCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">OgnlCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Prevent Instantiation of Static Class</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 读取表达式结果</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getValue</span><span class="params">(String expression, Object root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建默认的上下文</span></span><br><span class="line">      Map context = Ognl.createDefaultContext(root, MEMBER_ACCESS, CLASS_RESOLVER, <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">// 依次传入表达式树、上下文、根，从而获得表达式的结果</span></span><br><span class="line">      <span class="keyword">return</span> Ognl.getValue(parseExpression(expression), context, root);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OgnlException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error evaluating expression &#x27;&quot;</span> + expression + <span class="string">&quot;&#x27;. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 解析表达式，得到解析后的表达式树</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">parseExpression</span><span class="params">(String expression)</span> <span class="keyword">throws</span> OgnlException </span>&#123;</span><br><span class="line">    <span class="comment">// 先从缓存中获取</span></span><br><span class="line">    Object node = expressionCache.get(expression);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 直接解析，放入缓存</span></span><br><span class="line">      node = Ognl.parseExpression(expression);</span><br><span class="line">      expressionCache.put(expression, node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="bLd3f"></a></p><h2 id="表达式求值"><a class="markdownIt-Anchor" href="#表达式求值"></a> 表达式求值</h2><p>Mybatis没有将OGNL暴露给各个SQL节点使用，而是进一步的易用封装，得到了ExpressionEvaluator类，即表达式求值器，该类内部一共有两个方法，一个是evaluateBoolean一个是evaluateIterable。<br /><a name="B2R01"></a></p><h3 id="evaluateboolean"><a class="markdownIt-Anchor" href="#evaluateboolean"></a> evaluateBoolean</h3><p>该方法能够根据结果为判断语句求值（<if test="name!=xx">），其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">evaluateBoolean</span><span class="params">(String expression, Object parameterObject)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取表达式</span></span><br><span class="line">  Object value = OgnlCache.getValue(expression, parameterObject);</span><br><span class="line">  <span class="comment">// 如果是Boolean类型</span></span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">    <span class="keyword">return</span> (Boolean) value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是数字形式</span></span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Number) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(String.valueOf(value)).compareTo(BigDecimal.ZERO) != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="pMRpz"></a></p><h3 id="evaluateiterable"><a class="markdownIt-Anchor" href="#evaluateiterable"></a> evaluateIterable</h3><p>该方法能够为迭代形式的表达式求值，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterable&lt;?&gt; evaluateIterable(String expression, Object parameterObject) &#123;</span><br><span class="line">  <span class="comment">// 获取表达式结果</span></span><br><span class="line">  Object value = OgnlCache.getValue(expression, parameterObject);</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;The expression &#x27;&quot;</span> + expression + <span class="string">&quot;&#x27; evaluated to a null value.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 结果是Iterable类型</span></span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Iterable) &#123;</span><br><span class="line">    <span class="keyword">return</span> (Iterable&lt;?&gt;) value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 结果是Array</span></span><br><span class="line">  <span class="keyword">if</span> (value.getClass().isArray()) &#123;</span><br><span class="line">    <span class="comment">// 如果Array是原始的调用asList会抛出异常，因此要手动转为ArrayList</span></span><br><span class="line">    <span class="keyword">int</span> size = Array.getLength(value);</span><br><span class="line">    List&lt;Object&gt; answer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      Object o = Array.get(value, i);</span><br><span class="line">      answer.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果结果为Map</span></span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">    <span class="keyword">return</span> ((Map) value).entrySet();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error evaluating expression &#x27;&quot;</span> + expression + <span class="string">&quot;&#x27;.  Return value (&quot;</span> + value + <span class="string">&quot;) was not iterable.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="WM3QQ"></a></p><h2 id="动态上下文"><a class="markdownIt-Anchor" href="#动态上下文"></a> 动态上下文</h2><p>在SQL节点树解析时，需要不断保存已完成的SQL片段。在进行SQL节点树的解析时也需要一些参数和环境信息为解析的依据。以上两个功能都由DynamicContext提供。其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上下文环境</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ContextMap bindings;</span><br><span class="line"><span class="comment">// 用于拼装SQL语句片段的SpringJoiner</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StringJoiner sqlBuilder = <span class="keyword">new</span> StringJoiner(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">// 解析时的唯一编号，防止解析混乱</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> uniqueNumber = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>ContextMap是DynamicContext的内部类，是HashMap的子类。在进行数据查询的时候会先从ContextMap中查询，如果查询失败会从参数对象属性中查询，因此在编写SQL语句时可以直接引用参数对象的的属性。<br />DynamicContext类的构造方法中有上下文环境初始化的主要逻辑，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DynamicContext</span><span class="params">(Configuration configuration, Object parameterObject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parameterObject != <span class="keyword">null</span> &amp;&amp; !(parameterObject <span class="keyword">instanceof</span> Map)) &#123;</span><br><span class="line">    <span class="comment">// 获得参数对象的元对象</span></span><br><span class="line">    MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">    <span class="comment">// 判断参数对象本身是否有对应的类型处理器</span></span><br><span class="line">    <span class="keyword">boolean</span> existsTypeHandler = configuration.getTypeHandlerRegistry().hasTypeHandler(parameterObject.getClass());</span><br><span class="line">    <span class="comment">// 放入上下文信息</span></span><br><span class="line">    bindings = <span class="keyword">new</span> ContextMap(metaObject, existsTypeHandler);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 上下文信息为空</span></span><br><span class="line">    bindings = <span class="keyword">new</span> ContextMap(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把参数对象放入上下文信息</span></span><br><span class="line">  bindings.put(PARAMETER_OBJECT_KEY, parameterObject);</span><br><span class="line">  <span class="comment">// 把数据库id放入上下文信息</span></span><br><span class="line">  bindings.put(DATABASE_ID_KEY, configuration.getDatabaseId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，bingdings属性中存储了以下信息：</p><ul><li>数据库id。因此在编写SQL语句时可以直接使用DATABASE_ID_KEY变量引用数据库id的值。</li><li>参数对象。在编写SQL语句时可以直接使用PARAMETER_OBJECT_KEY变量来引用整个参数对象。</li><li>参数对象的元数据。基于参数对象元数据可以方便的引用参数对象的属性值，因此，编写SQL语句时可以直接引用参数对象的属性。<br /><a name="BLXZm"></a></li></ul><h2 id="sql节点及其解析"><a class="markdownIt-Anchor" href="#sql节点及其解析"></a> SQL节点及其解析</h2><p>Mybatis会将动态节点解析后才交给数据库执行，这些节点在Mybatis中都会被认为SqlNode。<br />SqlNode是一个接口，其内部只定义了一个apply方法，该方法负责完成节点自身的解析，并将解析结果合并到输入参数提供的上下文环境中。该接口的类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602295821126-63be2991-78e6-46c0-8e34-f5d10fb7cd42.png#align=left&amp;display=inline&amp;height=304&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=608&amp;originWidth=1115&amp;size=743466&amp;status=done&amp;style=none&amp;width=557.5" alt="image.png" /><br />接下来以典型的IfSqlSource、ForEachSqlSource、TextSqlNode为例对SqlNode接口的实现类进行介绍。<br /><a name="rvTby"></a></p><h3 id="ifsqlsource"><a class="markdownIt-Anchor" href="#ifsqlsource"></a> IfSqlSource</h3><p>该类的目标是if标签，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表达式求值器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExpressionEvaluator evaluator;</span><br><span class="line"><span class="comment">// if判断时的测试条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String test;</span><br><span class="line"><span class="comment">// 如果if成立，要被拼接的SQL片段信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlNode contents;</span><br></pre></td></tr></table></figure><p>apply方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断if条件是否成立</span></span><br><span class="line">  <span class="keyword">if</span> (evaluator.evaluateBoolean(test, context.getBindings())) &#123;</span><br><span class="line">    <span class="comment">// contents拼接到context</span></span><br><span class="line">    contents.apply(context);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="95RzH"></a></p><h3 id="foreachsqlnode"><a class="markdownIt-Anchor" href="#foreachsqlnode"></a> ForEachSqlNode</h3><p>ForEachSqlNode节点对应了foreach标签，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表达式求值器 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExpressionEvaluator evaluator;</span><br><span class="line"><span class="comment">// conllection属性的值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String collectionExpression;</span><br><span class="line"><span class="comment">// 节点内的内容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlNode contents;</span><br><span class="line"><span class="comment">// 左侧插入的字符串</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String open;</span><br><span class="line"><span class="comment">// 右侧插入的字符串</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String close;</span><br><span class="line"><span class="comment">// 元素分隔符</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String separator;</span><br><span class="line"><span class="comment">// 元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String item;</span><br><span class="line"><span class="comment">// 元素编号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String index;</span><br><span class="line"><span class="comment">// 配置信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br></pre></td></tr></table></figure><p>apply实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取上下文信息</span></span><br><span class="line">  Map&lt;String, Object&gt; bindings = context.getBindings();</span><br><span class="line">  <span class="comment">// 交给表达式求值器解析表达式从而获取迭代器</span></span><br><span class="line">  <span class="keyword">final</span> Iterable&lt;?&gt; iterable = evaluator.evaluateIterable(collectionExpression, bindings);</span><br><span class="line">  <span class="comment">// 没有可迭代的元素</span></span><br><span class="line">  <span class="keyword">if</span> (!iterable.iterator().hasNext()) &#123;</span><br><span class="line">    <span class="comment">// 不需要拼接信息直接返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">boolean</span> first = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">// 添加open字符串</span></span><br><span class="line">  applyOpen(context);</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (Object o : iterable) &#123;</span><br><span class="line">    DynamicContext oldContext = context;</span><br><span class="line">    <span class="comment">// 第一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (first || separator == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 添加元素</span></span><br><span class="line">      context = <span class="keyword">new</span> PrefixedContext(context, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 添加间隔符</span></span><br><span class="line">      context = <span class="keyword">new</span> PrefixedContext(context, separator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> uniqueNumber = context.getUniqueNumber();</span><br><span class="line">    <span class="comment">// Issue #709</span></span><br><span class="line">    <span class="comment">// 迭代的对象是map</span></span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      <span class="comment">// 迭代对象放入上下文环境</span></span><br><span class="line">      Map.Entry&lt;Object, Object&gt; mapEntry = (Map.Entry&lt;Object, Object&gt;) o;</span><br><span class="line">      applyIndex(context, mapEntry.getKey(), uniqueNumber);</span><br><span class="line">      applyItem(context, mapEntry.getValue(), uniqueNumber);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 将被迭代对象放入上下文环境</span></span><br><span class="line">      applyIndex(context, i, uniqueNumber);</span><br><span class="line">      applyItem(context, o, uniqueNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据上下文环境等信息构建内容</span></span><br><span class="line">    contents.apply(<span class="keyword">new</span> FilteredDynamicContext(configuration, context, index, item, uniqueNumber));</span><br><span class="line">    <span class="keyword">if</span> (first) &#123;</span><br><span class="line">      first = !((PrefixedContext) context).isPrefixApplied();</span><br><span class="line">    &#125;</span><br><span class="line">    context = oldContext;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加close字符串</span></span><br><span class="line">  applyClose(context);</span><br><span class="line">  <span class="comment">// 清理此次操作对环境的影响</span></span><br><span class="line">  context.getBindings().remove(item);</span><br><span class="line">  context.getBindings().remove(index);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，其主要流程是解析被迭代元素获得的迭代对象，然后迭代对象的信息添加到上下文中，根据上下文信息拼接字符串。字符串拼接完成后，对此次操作产生的临时变量清除。<br /><a name="vJJl8"></a></p><h3 id="textsqlnode"><a class="markdownIt-Anchor" href="#textsqlnode"></a> TextSqlNode</h3><p>该标签对应了SQL语句的字符串节点。字符串节点应用广泛，TextSqlNode能替换掉其中的“<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 142: …c0a46e47b54.png#̲align=left&amp;disp…'>{}”占位符。&lt;br /&gt;该类内部类图如下：&lt;br /&gt;![image.png](https://cdn.nlark.com/yuque/0/2020/png/485026/1602297072525-c1dd57e6-87ab-4b64-ada5-6c0a46e47b54.png#align=left&amp;display=inline&amp;height=246&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=492&amp;originWidth=1092&amp;size=771788&amp;status=done&amp;style=none&amp;width=546)&lt;br /&gt;TokenHandler接口会和通用占位符解析器GenericTokenParser配合使用，GenericTokenParser解析到匹配的占位符时会将占位符中的内容交给TokenHandler对象的handleToken方法处理。在TextSqlNode对象中占位符就是“</span>{}”符号，该对象会将SQL语句交给其两个内部类分别处理：</p><ul><li>BindingTokenParser：该对象的handleToken方法会取出占位符中的变量，然后使用该变量作为键去上下文环境中寻找对应的值然后替换占位符。</li><li>DynamicCheckerTokenParser：该对象的handleToken方法会置位成员属性isDynamic，因此该对象可以记录是否自身读到过占位符。</li></ul><p>TextSqlNode的apply方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建通用占位符解析器</span></span><br><span class="line">  GenericTokenParser parser = createParser(<span class="keyword">new</span> BindingTokenParser(context, injectionFilter));</span><br><span class="line">  <span class="comment">// 替换掉$&#123;&#125;</span></span><br><span class="line">  context.appendSql(parser.parse(text));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> GenericTokenParser <span class="title">createParser</span><span class="params">(TokenHandler handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> GenericTokenParser(<span class="string">&quot;$&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于TextSqlNode而言，如果内部含有${}那就是动态的，否则就不是动态的。<br /><a name="7j58t"></a></p><h1 id="sqlsource总结"><a class="markdownIt-Anchor" href="#sqlsource总结"></a> SqlSource总结</h1><p>语言驱动类的主要工作就是生成SqlSource，在语言驱动接口LanguageDriver的三个方法中，有两个方法是用来生成SqlSource的。而SqlSource子类的转化工作也是主要在scripting包中完成的。<br />SqlSource的子类的区别：</p><ul><li>DynamicSqlSource：动态Sql语句。所谓动态SQL语句是指含有动态SQL节点或者含有“${}”占位符。</li><li>RawSqlSource：原生SQL语句。指非动态语句，语句中可能含有“#{}”占位符，但不含有动态的SQL节点与“${}”占位符。</li><li>StaticSqlSource：静态语句。语句中可能含有“?”，可以直接交给数据库执行。</li><li>ProviderSqlSource：上面几种都是通过XML文件获取SQL语句，而P它是通过注解映射的形式获取的SQL语句。<br /><a name="lE8Jv"></a></li></ul><h2 id="sqlsource的生成"><a class="markdownIt-Anchor" href="#sqlsource的生成"></a> SqlSource的生成</h2><p><a name="Xap9B"></a></p><h3 id="解析映射文件生成sqlsource"><a class="markdownIt-Anchor" href="#解析映射文件生成sqlsource"></a> 解析映射文件生成SqlSource</h3><p>LanguageDiriver的下述方法用来解析配置文件中的节点信息，从而获取SqlSource对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, XNode script, Class&lt;?&gt; parameterType)</span></span>;</span><br></pre></td></tr></table></figure><p>其实现在XMLLanguageDriver中，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, XNode script, Class&lt;?&gt; parameterType)</span> </span>&#123;</span><br><span class="line">  XMLScriptBuilder builder = <span class="keyword">new</span> XMLScriptBuilder(configuration, script, parameterType);</span><br><span class="line">  <span class="keyword">return</span> builder.parseScriptNode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parseScriptNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MixedSqlNode rootSqlNode = parseDynamicTags(context);</span><br><span class="line">  SqlSource sqlSource;</span><br><span class="line">  <span class="keyword">if</span> (isDynamic) &#123;</span><br><span class="line">    sqlSource = <span class="keyword">new</span> DynamicSqlSource(configuration, rootSqlNode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sqlSource = <span class="keyword">new</span> RawSqlSource(configuration, rootSqlNode, parameterType);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sqlSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，解析映射文件生成的SqlSource不是DynamicSqlSource就是RawSqlSource。<br /><a name="VYEmq"></a></p><h3 id="解析注解信息生成sqlsource"><a class="markdownIt-Anchor" href="#解析注解信息生成sqlsource"></a> 解析注解信息生成SqlSource</h3><p>ProviderSqlSource通过调用LanguageDriver中的下述接口方法来生成SqlSource接口子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, String script, Class&lt;?&gt; parameterType)</span></span>;</span><br></pre></td></tr></table></figure><p>其是现在XMLLanguageDriver中，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, String script, Class&lt;?&gt; parameterType)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果注解是以&lt;script&gt;开头</span></span><br><span class="line">  <span class="keyword">if</span> (script.startsWith(<span class="string">&quot;&lt;script&gt;&quot;</span>)) &#123;</span><br><span class="line">    XPathParser parser = <span class="keyword">new</span> XPathParser(script, <span class="keyword">false</span>, configuration.getVariables(), <span class="keyword">new</span> XMLMapperEntityResolver());</span><br><span class="line">    <span class="keyword">return</span> createSqlSource(configuration, parser.evalNode(<span class="string">&quot;/script&quot;</span>), parameterType);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果注解中的内容不以&lt;script&gt;开头</span></span><br><span class="line">    script = PropertyParser.parse(script, configuration.getVariables());</span><br><span class="line">    TextSqlNode textSqlNode = <span class="keyword">new</span> TextSqlNode(script);</span><br><span class="line">    <span class="keyword">if</span> (textSqlNode.isDynamic()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DynamicSqlSource(configuration, textSqlNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RawSqlSource(configuration, script, parameterType);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果以<script>开头的SQL语句将使用和映射文件相同的解析方式，从而生成DynamicSqlSource或者RawSqlSource。<br />如果不以<script>开头则直接生成DynamicSqlSource或者RawSqlSource。<br />对象转化图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602386804982-42427fa6-cd4e-4a24-b1cc-588c075e0b78.png#align=left&amp;display=inline&amp;height=455&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=455&amp;originWidth=824&amp;size=601302&amp;status=done&amp;style=none&amp;width=824" alt="image.png" /><br /><a name="rrzvq"></a></p><h2 id="dynamicsqlsource的转化"><a class="markdownIt-Anchor" href="#dynamicsqlsource的转化"></a> DynamicSqlSource的转化</h2><p>DynamicSqlSource类在scripting的xmltags子包中，无论是DynamicSqlSource还是RawSqlSource最终都会转化为StaticSqlSource，然后才能给出一个BoundSql对象。<br />DynamicSqlSource的getBoundSql源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;.</span><br><span class="line">  <span class="comment">// 创建DynamicSqlSource的辅助类，用来记录DynamicSqlSource解析出来的SQL片段信息</span></span><br><span class="line">  DynamicContext context = <span class="keyword">new</span> DynamicContext(configuration, parameterObject);</span><br><span class="line">  <span class="comment">// 这里会从根节点开始，对节点逐层调用apply方法，此后所有的动态节点和“$&#123;&#125;”都会被替换</span></span><br><span class="line">  rootSqlNode.apply(context);</span><br><span class="line">  <span class="comment">// 处理占位符、汇总参数信息</span></span><br><span class="line">  SqlSourceBuilder sqlSourceParser = <span class="keyword">new</span> SqlSourceBuilder(configuration);</span><br><span class="line">  Class&lt;?&gt; parameterType = parameterObject == <span class="keyword">null</span> ? Object.class : parameterObject.getClass();</span><br><span class="line">  <span class="comment">// 处理“#&#123;&#125;”为?，最终圣城StaticSqlSource对象                                                   </span></span><br><span class="line">  SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());</span><br><span class="line">  BoundSql boundSql = sqlSource.getBoundSql(parameterObject);</span><br><span class="line">  <span class="comment">// getBindings的信息放入到boundSql的metaParameters中保存                                                 </span></span><br><span class="line">  context.getBindings().forEach(boundSql::setAdditionalParameter);</span><br><span class="line">  <span class="keyword">return</span> boundSql;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中parse方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parse</span><span class="params">(String originalSql, Class&lt;?&gt; parameterType, Map&lt;String, Object&gt; additionalParameters)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 完成#&#123;&#125;处理的处理器  </span></span><br><span class="line">  ParameterMappingTokenHandler handler = <span class="keyword">new</span> ParameterMappingTokenHandler(configuration, parameterType, additionalParameters);</span><br><span class="line">  <span class="comment">// 通用占位符解析器，用来进行占位符替换  </span></span><br><span class="line">  GenericTokenParser parser = <span class="keyword">new</span> GenericTokenParser(<span class="string">&quot;#&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>, handler);</span><br><span class="line">  <span class="comment">// 将#&#123;&#125;替换为?</span></span><br><span class="line">  String sql = parser.parse(originalSql);</span><br><span class="line">  <span class="comment">// 生成StaticSqlSource并返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> StaticSqlSource(configuration, sql, handler.getParameterMappings());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="A1TQ1"></a></p><h2 id="rawsqlsource的转化"><a class="markdownIt-Anchor" href="#rawsqlsource的转化"></a> RawSqlSource的转化</h2><p>RawSqlSource比DynamicSqlSource简单，它不包含动态节点和${}，因此其在构造方法中就完成了到StaticSqlSource的转化，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RawSqlSource</span><span class="params">(Configuration configuration, String sql, Class&lt;?&gt; parameterType)</span> </span>&#123;</span><br><span class="line">  SqlSourceBuilder sqlSourceParser = <span class="keyword">new</span> SqlSourceBuilder(configuration);</span><br><span class="line">  Class&lt;?&gt; clazz = parameterType == <span class="keyword">null</span> ? Object.class : parameterType;</span><br><span class="line">  <span class="comment">// 处理RawSqlSOurce中的#&#123;&#125;占位符</span></span><br><span class="line">  sqlSource = sqlSourceParser.parse(sql, clazz, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getBoundSql方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 由StaticSqlSource对象返回</span></span><br><span class="line">  <span class="keyword">return</span> sqlSource.getBoundSql(parameterObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="SS2ll"></a></p><h2 id="sqlsource接口实现类总结"><a class="markdownIt-Anchor" href="#sqlsource接口实现类总结"></a> SqlSource接口实现类总结</h2><p>SqlSource实现了的转化图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602387869042-782cd122-28ec-4e15-8d02-3f908636f2e0.png#align=left&amp;display=inline&amp;height=364&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=364&amp;originWidth=1186&amp;size=854514&amp;status=done&amp;style=none&amp;width=1186" alt="image.png" /><br />不管经历了怎样的过程，最终SqlSource接口定义的getBoundSql都是由StaticSqlSource对象来完成的。</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
          <category> 配置解析包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mapping包</title>
      <link href="/posts/mybatis-mapping/"/>
      <url>/posts/mybatis-mapping/</url>
      
        <content type="html"><![CDATA[<h1 id="mapping包"><a class="markdownIt-Anchor" href="#mapping包"></a> mapping包</h1><p>mapping中定义了众多的解析实体类。mapping包主要有以下功能：</p><ul><li>SQL语句处理功能。</li><li>输出结果处理功能。</li><li>输入参数处理功能。</li><li>多数据库种类处理功能。</li><li>其他功能。<br /><a name="e7nfx"></a></li></ul><h1 id="sql语句处理功能"><a class="markdownIt-Anchor" href="#sql语句处理功能"></a> SQL语句处理功能</h1><p>与SQL处理语句功能相关的类有三个，分别是MappedStatement、SqlSource和BoundSql。<br />其中，MappedStatement表示的是数据库操作节点（select、update、delete和insert）内的所有内容。SqlSource是数据库操作标签中包含的SQL语句。BoundSql是SqlSource的进一步处理产物。三者关系图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602126804963-c1fe5389-2d84-4cdb-a5c0-706f5e788b35.png#align=left&amp;display=inline&amp;height=124&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=249&amp;originWidth=1402&amp;size=498735&amp;status=done&amp;style=none&amp;width=701" alt="image.png" /><br /><a name="lk7FI"></a></p><h2 id="mappedstatement"><a class="markdownIt-Anchor" href="#mappedstatement"></a> MappedStatement</h2><p>这是一个典型的解析实体类，该类的属性和数据库操作标签十分相似。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602126921123-0983655e-b19b-4cd9-8cb6-dc236bca90af.png#align=left&amp;display=inline&amp;height=375&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=749&amp;originWidth=449&amp;size=156937&amp;status=done&amp;style=none&amp;width=224.5" alt="image.png" /><br />这里就不做过多的扩展了。<br /><a name="U1Hpb"></a></p><h2 id="sqlsource"><a class="markdownIt-Anchor" href="#sqlsource"></a> SqlSource</h2><p>SqlSource本身是一个接口，该接口只定义了一个返回BoundSql对象的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlSource</span> </span>&#123;</span><br><span class="line">  <span class="function">BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602127086507-90185b29-a121-4a20-8e7c-7847070a53df.png#align=left&amp;display=inline&amp;height=155&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=309&amp;originWidth=1258&amp;size=577094&amp;status=done&amp;style=none&amp;width=629" alt="image.png" /><br />四种实现类的区别如下：</p><ul><li>DynamicSqlSource：动态SQL语句。即SQL中含有动态SQL节点（如“if”）或者含有占位符（${}）。</li><li>RawSqlSource：原生的SQL语句。指非动态语句，语句中可能含有“#{}”占位符，但是不含动态SQL节点或者“${}”。</li><li>StaticSqlSource：静态语句。语句中可能含有“？”，直接可以交给数据库执行。</li><li>ProviderSqlSource：上面几种都是XML获取的SQL语句，而ProviderSqlSource是通过注解映射形式取得的SQL语句。</li></ul><p>DynamicSqlSource和RawSqlSource都会被处理成StaticSqlSource，然后通过StaticSqlSource的getBoundSql得到BoundSql对象。<br /><a name="WauoH"></a></p><h2 id="boundsql"><a class="markdownIt-Anchor" href="#boundsql"></a> BoundSql</h2><p>BoundSql是参数绑定完成后的SQL语句，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能含有&quot;?&quot;占位符的SQL语句</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String sql;</span><br><span class="line"><span class="comment">// 参数映射列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;ParameterMapping&gt; parameterMappings;</span><br><span class="line"><span class="comment">// 实参对象本身</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object parameterObject;</span><br><span class="line"><span class="comment">// 实参</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; additionalParameters;</span><br><span class="line"><span class="comment">// additionalParameters的包装对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MetaObject metaParameters;</span><br></pre></td></tr></table></figure><p>BoundSql是SQL语句的一个重要的中间产物，它既存储了转化结束的SQL信息，又包含了实参信息和一些附加的环境信息。<br /><a name="nrIcM"></a></p><h1 id="输出结果处理功能"><a class="markdownIt-Anchor" href="#输出结果处理功能"></a> 输出结果处理功能</h1><p>resultMap是一个十分强大的功能，它支持输出结果的组装、判断、懒加载等。<br />其在解析的时候设计的类包括：ResultMap、ResultMapping、Duscriminator，他们都是解析实体类，对应关系如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602127934737-76278523-dfff-4257-a21f-4acd9b343bb1.png#align=left&amp;display=inline&amp;height=148&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=295&amp;originWidth=1118&amp;size=522140&amp;status=done&amp;style=none&amp;width=559" alt="image.png" /><br /><a name="QOspf"></a></p><h2 id="resultmap"><a class="markdownIt-Anchor" href="#resultmap"></a> ResultMap</h2><p>该类和resultMap节点对应的信息高度一致，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局配置信息</span></span><br><span class="line"><span class="keyword">private</span> Configuration configuration;</span><br><span class="line"><span class="comment">// resultMap的编号</span></span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"><span class="comment">// 最终输出结果对应的Java类</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; type;</span><br><span class="line"><span class="comment">// XML中的&lt;result&gt;列表，即ResultMapping列表</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ResultMapping&gt; resultMappings;</span><br><span class="line"><span class="comment">// XML中的&lt;id&gt;和&lt;idArg&gt;</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ResultMapping&gt; idResultMappings;</span><br><span class="line"><span class="comment">// XML中的&lt;constructor&gt;</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ResultMapping&gt; constructorResultMappings;</span><br><span class="line"><span class="comment">// XML中的非&lt;constructor&gt;相关的属性列表</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ResultMapping&gt; propertyResultMappings;</span><br><span class="line"><span class="comment">// 所有参与映射的数据库中字段的集合</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; mappedColumns;</span><br><span class="line"><span class="comment">// 所有参与映射的Java对象属性集合</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; mappedProperties;</span><br><span class="line"><span class="comment">// 鉴别器</span></span><br><span class="line"><span class="keyword">private</span> Discriminator discriminator;</span><br><span class="line"><span class="comment">// 是否存在嵌套映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasNestedResultMaps;</span><br><span class="line"><span class="comment">// 是否存在嵌套查询</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasNestedQueries;</span><br><span class="line"><span class="comment">// 是否启动自动映射</span></span><br><span class="line"><span class="keyword">private</span> Boolean autoMapping;</span><br></pre></td></tr></table></figure><p>在resultMap中，属性被分为了两类：构造方法和非构造方法中的属性。非构造方法中的属性又被分为了两类：id属性和非id属性。根据这两个分类方式就产生了如下四个属性：</p><ul><li>resultMappings：所有的属性</li><li>idResultMappings：所有的id属性</li><li>constructorResultMappings：所有构造方法中的属性</li><li>propertyResultMappings：所有非构造方法中的属性<br /><a name="fOffb"></a></li></ul><h2 id="resultmapping"><a class="markdownIt-Anchor" href="#resultmapping"></a> ResultMapping</h2><p>上述涉及到的idArg、id、result等标签都对应着一个ResultMapping对象，该类内部结构如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602128431586-baf0e1c0-b9cf-4c3b-b788-564d0d79b560.png#align=left&amp;display=inline&amp;height=274&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=548&amp;originWidth=445&amp;size=111856&amp;status=done&amp;style=none&amp;width=222.5" alt="image.png" /><br />该类由于属性较多，因此创建ResultMapping对象会非常复杂，为了改善这个过程，ResultMapping使用了建造者模式。并且它的建造者模式直接放在了类的内部作为内部静态类出现。内部静态类中的方法调用不需要创建类的对象，而它却可以生成类的对象。<br />这种实现方法提升了类的内聚性，可以借鉴这种实现。<br /><a name="bngoH"></a></p><h2 id="discriminator"><a class="markdownIt-Anchor" href="#discriminator"></a> Discriminator</h2><p>Discriminator是resultMap内部的鉴别器，就像程序中的选择语句一样，它使得数据库查询结果能够根据某些条件的不同而进行不同的映射。<br />该类内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储条件判断行信息</span></span><br><span class="line"><span class="keyword">private</span> ResultMapping resultMapping;</span><br><span class="line"><span class="comment">// 存储选择项的信息，键为value的值，值为resultMap的值</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, String&gt; discriminatorMap;</span><br></pre></td></tr></table></figure><p>在DefaultResultSetHandler的resolveDiscriminatedResultMap方法中有该类属性生效的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultMap <span class="title">resolveDiscriminatedResultMap</span><span class="params">(ResultSet rs, ResultMap resultMap, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 已经处理过得鉴别器  </span></span><br><span class="line">  Set&lt;String&gt; pastDiscriminators = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  Discriminator discriminator = resultMap.getDiscriminator();</span><br><span class="line">  <span class="keyword">while</span> (discriminator != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 求解条件判断的结果，这个结果值就是鉴别器鉴别的依据</span></span><br><span class="line">    <span class="keyword">final</span> Object value = getDiscriminatorValue(rs, discriminator, columnPrefix);</span><br><span class="line">    <span class="comment">// 根据真实值判断属于哪个分支</span></span><br><span class="line">    <span class="keyword">final</span> String discriminatedMapId = discriminator.getMapIdFor(String.valueOf(value));</span><br><span class="line">    <span class="comment">// 从接下来的case里找到这个分支</span></span><br><span class="line">    <span class="keyword">if</span> (configuration.hasResultMap(discriminatedMapId)) &#123;</span><br><span class="line">      <span class="comment">// 找出指定的resultMap</span></span><br><span class="line">      resultMap = configuration.getResultMap(discriminatedMapId);</span><br><span class="line">      <span class="comment">// 继续分析下一层</span></span><br><span class="line">      Discriminator lastDiscriminator = discriminator;</span><br><span class="line">      <span class="comment">// 查看本resultMap内是否还有鉴别器</span></span><br><span class="line">      discriminator = resultMap.getDiscriminator();</span><br><span class="line">      <span class="comment">// 判别器出现了环</span></span><br><span class="line">      <span class="keyword">if</span> (discriminator == lastDiscriminator || !pastDiscriminators.add(discriminatedMapId)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resultMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求解鉴别器的条件判断结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getDiscriminatorValue</span><span class="params">(ResultSet rs, Discriminator discriminator, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ResultMapping resultMapping = discriminator.getResultMapping();</span><br><span class="line">  <span class="keyword">final</span> TypeHandler&lt;?&gt; typeHandler = resultMapping.getTypeHandler();</span><br><span class="line">  <span class="keyword">return</span> typeHandler.getResult(rs, prependPrefix(resultMapping.getColumn(), columnPrefix));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="15bMa"></a></p><h1 id="输入参数处理功能"><a class="markdownIt-Anchor" href="#输入参数处理功能"></a> 输入参数处理功能</h1><p>输入参数处理功能设计的两个类关系图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602129369295-91fd796c-bf99-4ae4-bc57-d34e4763768e.png#align=left&amp;display=inline&amp;height=81&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=161&amp;originWidth=1173&amp;size=264140&amp;status=done&amp;style=none&amp;width=586.5" alt="image.png" /><br />这两个类与RestMap和ResultMapping十分类似，并且在现在编译中已经弱化了parameterMap标签（建议使用内联参数），因此在这里就不做过多的分析了。<br /><a name="hcUdR"></a></p><h1 id="多数据库种类处理功能"><a class="markdownIt-Anchor" href="#多数据库种类处理功能"></a> 多数据库种类处理功能</h1><p>Mybatis支持多种数据库。在使用多种数据库前，需要先在配置文件中列举出要使用的数据库类型，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;databaseIdProvider type=<span class="string">&quot;DB_VENDOR&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;MySQL&quot;</span> value=<span class="string">&quot;mysql&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;SQL Server&quot;</span> value=<span class="string">&quot;sqlserver&quot;</span> /&gt;</span><br><span class="line">&lt;/databaseIdProvider&gt;</span><br></pre></td></tr></table></figure><p>然后在SQL语句上书写databaseId，如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectByAge&quot;</span> resultMap=<span class="string">&quot;userMap&quot;</span> databaseId=<span class="string">&quot;sqlserver&quot;</span>&gt;</span><br><span class="line">    SELECT * FROM `user` WHERE `age` = #&#123;age&#125; TOP 5</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">&quot;selectByAge&quot;</span> resultMap=<span class="string">&quot;userMap&quot;</span> databaseId=<span class="string">&quot;mysql&quot;</span>&gt;</span><br><span class="line">    SELECT * FROM `user` WHERE `age` = #&#123;age&#125; LIMIT 5</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>多种数据库支持的实现由DatabaseIdProvider接口负责，它有一个VendorDatabaseIdProvider实现类和一个即将废除的DefaultDatabaseIdProvider的子类。<br /><a name="RniON"></a></p><h2 id="vendordatabaseidprovider"><a class="markdownIt-Anchor" href="#vendordatabaseidprovider"></a> VendorDatabaseIdProvider</h2><p>VendorDatabaseIdProvider中的两个重要方法均继承自DatabaseIdProvider接口，分别是setProperties和getDatabaseId。<br /><a name="eoCcQ"></a></p><h3 id="setproperties"><a class="markdownIt-Anchor" href="#setproperties"></a> setProperties</h3><p>setProperties方法是用来将Mybatis配置文件中设置在databaseIdProvider节点中的信息写入到VendorDatabaseIdProvider对象中。<br /><a name="3hOCF"></a></p><h3 id="getdatabaseid"><a class="markdownIt-Anchor" href="#getdatabaseid"></a> getDatabaseId</h3><p>getDatabaseId方法是用来给出当前传入的DataSource对应的databaseId。主要逻辑位于getDatabaseName中，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getDatabaseName</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 获取当前连接的数据库名</span></span><br><span class="line">  String productName = getDatabaseProductName(dataSource);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.properties != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果设置了properties的值，则将获取的数据库名称作为模糊的key，映射为对应的value</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; property : properties.entrySet()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (productName.contains((String) property.getKey())) &#123;</span><br><span class="line">        <span class="keyword">return</span> (String) property.getValue();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// no match, return null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> productName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，他一共做了两个工作：</p><ul><li>获取当前数据源的类型。</li><li>将数据源类型映射为databaseIdProvider中设置的别名。<br /><a name="ETqAY"></a></li></ul><h1 id="其他功能"><a class="markdownIt-Anchor" href="#其他功能"></a> 其他功能</h1><p>mapping包中还有两个重要的类：Envirment和CacheBuiler。<br /><a name="QCzrd"></a></p><h2 id="environment"><a class="markdownIt-Anchor" href="#environment"></a> Environment</h2><p>Environment也是一个解析实体类，它对应着environments节点，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line"><span class="comment">// 事务工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TransactionFactory transactionFactory;</span><br><span class="line"><span class="comment">// 数据源信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DataSource dataSource;</span><br></pre></td></tr></table></figure><p><a name="StyrD"></a></p><h2 id="cachebuilder"><a class="markdownIt-Anchor" href="#cachebuilder"></a> CacheBuilder</h2><p>CacheBuilder是缓存建造者，他负责完成缓存对象的创建，具体的实现将在后续分析。<br /><a name="iTE1p"></a></p><h2 id="其他枚举类"><a class="markdownIt-Anchor" href="#其他枚举类"></a> 其他枚举类</h2><p>mapping中还存在着其他的一些枚举类，作用分别如下：</p><ul><li>FetchType：延迟加载设置</li><li>ParameterType：参数类型，指输入参数、输出参数等。</li><li>ResultFlag：返回结果中属性的特殊标志，表示是否为id属性、是否为构造器属性。</li><li>ResultSetType：结果集支持的访问方式。</li><li>SqlCommandType：SQL类型，指增删改查等。</li><li>StatementType：SQL语句类型，指是否为预编译语句，是否为存储过程等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
          <category> 配置解析包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>builder包</title>
      <link href="/posts/mybatis-builder/"/>
      <url>/posts/mybatis-builder/</url>
      
        <content type="html"><![CDATA[<h1 id="builder包"><a class="markdownIt-Anchor" href="#builder包"></a> builder包</h1><p>build包是一个按照类型划分出来的包，包中含有很多建造者类。虽然这个包是一个按照类型方式划分的包，但是该包也完成了如下两个比较完整的功能：</p><ul><li>解析XML配置文件和映射文件，这部分在功能xml子包中。</li><li>解析注解形式的Mapper声明，这部分功能在annotation子包中。<br /><a name="2JNa8"></a></li></ul><h1 id="建造者模式"><a class="markdownIt-Anchor" href="#建造者模式"></a> 建造者模式</h1><p>在仔细分析该包前首先要回忆一下建造者模式。<br />使用建造者模式对象建造的细节均交给了建造者来完成，调用者只需掌控总体流程即可，而不需要过多的关注建造对象的细节。<br />基于建造者创建的对象有以下几个优点：</p><ul><li>可以一次也可以分次设置被建造对象的属性。</li><li>调用者只需调用建造者的主要流程而不需要关心建造者的细节。</li><li>可以方便的修改建造者的行为来建造出不同的对象。</li></ul><p>建造者的实现有两种方法：</p><ul><li>属性设置方法。这类方法一般有多个，可以接受不同类型的参数来设置建造者的属性。</li><li>目标对象生成方法。这类方法一般只有一个，根据目前建造者的属性创建出一个目标对象。<br /><a name="IQfCQ"></a></li></ul><h2 id="建造者基类与工具类"><a class="markdownIt-Anchor" href="#建造者基类与工具类"></a> 建造者基类与工具类</h2><p>builder包中BaseBuilder是所有建造者的子类，其类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602034919258-c4700aa1-ab51-4647-ad59-84f70ebd37b5.png#align=left&amp;display=inline&amp;height=299&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=598&amp;originWidth=1157&amp;size=1077520&amp;status=done&amp;style=none&amp;width=578.5" alt="image.png" /><br />BaseBuilder更像一个工具类，为继承他的制造者提供了很多实用的方法：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602034997465-a81d025b-3fb2-4430-9336-92f2ce61e3c7.png#align=left&amp;display=inline&amp;height=229&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=458&amp;originWidth=511&amp;size=114178&amp;status=done&amp;style=none&amp;width=255.5" alt="image.png" /><br />BaseBuilder提供的工具方法大致分为如下几个类型：</p><ul><li>*ValueOf：类型转化函数，负责将输入参数转化为指定的类型，并支持默认值设置。</li><li>resolve*：字符串转枚举类型函数，根据字符串找出指定的枚举类型并返回。</li><li>createInstance：根据类型别名创建类型实例。</li><li>resolveTypeHandler：根据类型处理器别名返回类型处理器实例。</li></ul><p>也有一些类不需要BaseBuilder提供的方法，因此没有继承自它。<br />还有一些不是建造者模式也继承自该类，以MapperBuilderAssistant为例，它本身不是建造者类而是一个建造者辅助类，但是也继承自BaseBuilder。<br /><a name="WH1lA"></a></p><h3 id="mapperbuilderassistant"><a class="markdownIt-Anchor" href="#mapperbuilderassistant"></a> MapperBuilderAssistant</h3><p>Mybatis内部有很多设置项，比如命名空间、缓存共享、结果映射等等。最终这些设置将解析成不同的类，而MapperBuilderAssistant就是这些解析类的辅助类。其内部有很多辅助方法，如Mapper命名空间的设置、缓存的创建、鉴别器的创建等等。<br /><a name="laWXi"></a></p><h1 id="sqlsourcebuilder与staticsqlsource"><a class="markdownIt-Anchor" href="#sqlsourcebuilder与staticsqlsource"></a> SqlSourceBuilder与StaticSqlSource</h1><p>SqlSourceBuillder是一个建造者类，与它的名字不同，它并不能用来创建所有的SqlSource对象，而是只能通过parse方法生产出一个StaticSqlSource方法。<br />换句话说，SqlSourceBuillder类能够将DynamicSqlSource中的“#{}”替换掉，从而将其转化为StaticSqlSource。因此，把SqlSourceBuillder称作一个解析器或者转化器更为合适。在许多引用SqlSourceBuillder对象的地方都将对象的变量名定为“sqlSourceParser”。<br />其parse源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parse</span><span class="params">(String originalSql, Class&lt;?&gt; parameterType, Map&lt;String, Object&gt; additionalParameters)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 用来完成#&#123;&#125;处理的处理器  </span></span><br><span class="line">  ParameterMappingTokenHandler handler = <span class="keyword">new</span> ParameterMappingTokenHandler(configuration, parameterType, additionalParameters);</span><br><span class="line">  <span class="comment">// 通用的占位符解析器，用来进行占位符替换  </span></span><br><span class="line">  GenericTokenParser parser = <span class="keyword">new</span> GenericTokenParser(<span class="string">&quot;#&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>, handler);</span><br><span class="line">  <span class="comment">// 将#&#123;&#125;替换为?的SQL语句</span></span><br><span class="line">  String sql = parser.parse(originalSql);</span><br><span class="line">  <span class="comment">// 生成一个StaticSqlSource对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> StaticSqlSource(configuration, sql, handler.getParameterMappings());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="6PNJ5"></a></p><h2 id="staticsqlsource"><a class="markdownIt-Anchor" href="#staticsqlsource"></a> StaticSqlSource</h2><p>StaticSqlSource是SqlSource的一个子类，期内部的SQL语句已经不存在‘${}’或‘#{}’，而只存在？。其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只剩?的SQL语句  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String sql;</span><br><span class="line"><span class="comment">// SQL语句对应的参数列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;ParameterMapping&gt; parameterMappings;</span><br><span class="line"><span class="comment">// 配置信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br></pre></td></tr></table></figure><p>StaticSqlSource最重要的功能就是返回一个BoundSql对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> BoundSql(configuration, sql, parameterMappings, parameterObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BoundSql将在未来进行详细分析。<br /><a name="tmZ5S"></a></p><h1 id="caserefresolver和resultmapresolver"><a class="markdownIt-Anchor" href="#caserefresolver和resultmapresolver"></a> CaseRefResolver和ResultMapResolver</h1><p>这两个类都是某些类的解析器类，属性中包含被解析类相关的属性，同时还包含一个解析器（Mybatis把被解析对象命名为A，整合后的自解析类命名为AResolver）。<br /><a name="HIgT8"></a></p><h2 id="caserefresovler"><a class="markdownIt-Anchor" href="#caserefresovler"></a> CaseRefResovler</h2><p>Mybatis支持多个namespace之间共享缓存。CaseRefResolver就是用来处理多个命名空间共享缓存问题的，他自身有两个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mapper建造者辅助类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MapperBuilderAssistant assistant;</span><br><span class="line"><span class="comment">// 被应用的namespace，即使用cacheRef的Namespace缓存空间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String cacheRefNamespace;</span><br></pre></td></tr></table></figure><p>借助于MapperBuilderAssiant的useCacheRef方法，CaseRefResolver可以解析缓存共享问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Cache <span class="title">useCacheRef</span><span class="params">(String namespace)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (namespace == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;cache-ref element requires a namespace attribute.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    unresolvedCacheRef = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 获取namespace的缓存</span></span><br><span class="line">    Cache cache = configuration.getCache(namespace);</span><br><span class="line">    <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteElementException(<span class="string">&quot;No cache for namespace &#x27;&quot;</span> + namespace + <span class="string">&quot;&#x27; could be found.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 替换本地缓存，从而实现缓存共享</span></span><br><span class="line">    currentCache = cache;</span><br><span class="line">    unresolvedCacheRef = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteElementException(<span class="string">&quot;No cache for namespace &#x27;&quot;</span> + namespace + <span class="string">&quot;&#x27; could be found.&quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="PLejX"></a></p><h2 id="resultmapresovler"><a class="markdownIt-Anchor" href="#resultmapresovler"></a> ResultMapResovler</h2><p>Mybatis的resultMap标签支持继承，如下列代码所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id=<span class="string">&quot;girlUserMap&quot;</span> type=<span class="string">&quot;Girl&quot;</span> extends=<span class="string">&quot;userMap&quot;</span>&gt;</span><br><span class="line">    &lt;result property=<span class="string">&quot;email&quot;</span> column=<span class="string">&quot;email&quot;</span>/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;resultMap id=<span class="string">&quot;userMap&quot;</span> type=<span class="string">&quot;User&quot;</span> autoMapping=<span class="string">&quot;false&quot;</span>&gt;</span><br><span class="line">    &lt;id property=<span class="string">&quot;id&quot;</span> column=<span class="string">&quot;id&quot;</span> javaType=<span class="string">&quot;Integer&quot;</span> jdbcType=<span class="string">&quot;INTEGER&quot;</span></span><br><span class="line">        typeHandler=<span class="string">&quot;org.apache.ibatis.type.IntegerTypeHandler&quot;</span>/&gt;</span><br><span class="line">    &lt;result property=<span class="string">&quot;name&quot;</span> column=<span class="string">&quot;name&quot;</span>/&gt;</span><br><span class="line">    &lt;discriminator javaType=<span class="string">&quot;int&quot;</span> column=<span class="string">&quot;sex&quot;</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">case</span> value=<span class="string">&quot;0&quot;</span> resultMap=<span class="string">&quot;boyUserMap&quot;</span>/&gt;</span><br><span class="line">        &lt;<span class="keyword">case</span> value=<span class="string">&quot;1&quot;</span> resultMap=<span class="string">&quot;girlUserMap&quot;</span>/&gt;</span><br><span class="line">    &lt;/discriminator&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><p>其继承关系可以由ResultMapResovler所处理，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mapper建造者辅助类  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MapperBuilderAssistant assistant;</span><br><span class="line"><span class="comment">// ResultMap的id</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line"><span class="comment">// ResultMap的type属性，即目标对象类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line"><span class="comment">// ResultMap的extends属性，即继承属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String extend;</span><br><span class="line"><span class="comment">// ResultMap的Discriminator节点，即鉴别器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Discriminator discriminator;</span><br><span class="line"><span class="comment">// ResultMap中的属性映射列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;ResultMapping&gt; resultMappings;</span><br><span class="line"><span class="comment">// ResultMap的autoMapping属性，即是否开启自动映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Boolean autoMapping;</span><br></pre></td></tr></table></figure><p>借助MapperBuilderAssiant的addResultMap方法，ResultMapResovler完成了继承关系解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> ResultMap <span class="title">addResultMap</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     String id,</span></span></span><br><span class="line"><span class="function"><span class="params">     Class&lt;?&gt; type,</span></span></span><br><span class="line"><span class="function"><span class="params">     String extend,</span></span></span><br><span class="line"><span class="function"><span class="params">     Discriminator discriminator,</span></span></span><br><span class="line"><span class="function"><span class="params">     List&lt;ResultMapping&gt; resultMappings,</span></span></span><br><span class="line"><span class="function"><span class="params">     Boolean autoMapping)</span> </span>&#123;</span><br><span class="line">   id = applyCurrentNamespace(id, <span class="keyword">false</span>);</span><br><span class="line">   extend = applyCurrentNamespace(extend, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 解析ResultMap继承关系</span></span><br><span class="line">   <span class="comment">// 如果存在ResultMap的继承</span></span><br><span class="line">   <span class="keyword">if</span> (extend != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (!configuration.hasResultMap(extend)) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteElementException(<span class="string">&quot;Could not find a parent resultmap with id &#x27;&quot;</span> + extend + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 获取父级的ResultMap</span></span><br><span class="line">     ResultMap resultMap = configuration.getResultMap(extend);</span><br><span class="line">     <span class="comment">// 获取父级的属性映射</span></span><br><span class="line">     List&lt;ResultMapping&gt; extendedResultMappings = <span class="keyword">new</span> ArrayList&lt;&gt;(resultMap.getResultMappings());</span><br><span class="line">     <span class="comment">// 删除当前ResultMap已有的父级属性映射</span></span><br><span class="line">     extendedResultMappings.removeAll(resultMappings);</span><br><span class="line">     <span class="comment">// 如果ResultMap设有构造器，则移除父级构造器</span></span><br><span class="line">     <span class="keyword">boolean</span> declaresConstructor = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">for</span> (ResultMapping resultMapping : resultMappings) &#123;</span><br><span class="line">       <span class="keyword">if</span> (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">         declaresConstructor = <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (declaresConstructor) &#123;</span><br><span class="line">       extendedResultMappings.removeIf(resultMapping -&gt; resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 最终从父级继承而来的所有属性映射</span></span><br><span class="line">     resultMappings.addAll(extendedResultMappings);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 创建当前的ResultMap</span></span><br><span class="line">   ResultMap resultMap = <span class="keyword">new</span> ResultMap.Builder(configuration, id, type, resultMappings, autoMapping)</span><br><span class="line">       .discriminator(discriminator)</span><br><span class="line">       .build();</span><br><span class="line">   <span class="comment">// 将当前的ResultMap加入到configuration</span></span><br><span class="line">   configuration.addResultMap(resultMap);</span><br><span class="line">   <span class="keyword">return</span> resultMap;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><a name="mEf1o"></a></p><h1 id="parameterexpression类"><a class="markdownIt-Anchor" href="#parameterexpression类"></a> ParameterExpression类</h1><p>该类是一个属性解析器，用来将描述的字符串解析为键值对的形式。ParameterExpression继承自HashMap，内部能以键值对的形式保存最后的解析结果。<br />注意：对于没有属性声明的属性会以默认名称expression的形式出现。<br /><a name="Daltb"></a></p><h1 id="xml文件解析"><a class="markdownIt-Anchor" href="#xml文件解析"></a> XML文件解析</h1><p>Mybatis的XML文件都会被解析成对应的类，builder的xml包就负责完成这种工作。<br />Mybatis的配置文件和映射文件的节点很多，这些节点的解析是由xml子包中的五个解析器来配合完成的。范围如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602038458012-d9e972f9-c984-4d30-877d-fae496622b57.png#align=left&amp;display=inline&amp;height=481&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=627&amp;originWidth=808&amp;size=736922&amp;status=done&amp;style=none&amp;width=620" alt="image.png" /><br /><a name="mzE6P"></a></p><h2 id="xml文件声明解析"><a class="markdownIt-Anchor" href="#xml文件声明解析"></a> XML文件声明解析</h2><p>在DOCTYE声明中可以表明当前XML文件引用的地址，在EntityResolver接口中存在一个resolveEntity方法，可以通过实现这个方法自定义给出DTD文件流的方式，而不是只能从互联网下载。<br />XMLMapperEntityResolver就继承自该接口，其内部实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InputSource <span class="title">resolveEntity</span><span class="params">(String publicId, String systemId)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (systemId != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">// 将systemId转换为小写</span></span><br><span class="line">      String lowerCaseSystemId = systemId.toLowerCase(Locale.ENGLISH);</span><br><span class="line">      <span class="comment">// 通过判断说明是配置文档</span></span><br><span class="line">      <span class="keyword">if</span> (lowerCaseSystemId.contains(MYBATIS_CONFIG_SYSTEM) || lowerCaseSystemId.contains(IBATIS_CONFIG_SYSTEM)) &#123;</span><br><span class="line">        <span class="comment">// 把本地配置文档的DTD文件返回  </span></span><br><span class="line">        <span class="keyword">return</span> getInputSource(MYBATIS_CONFIG_DTD, publicId, systemId);</span><br><span class="line">      <span class="comment">// 通过判断说明是映射文档</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lowerCaseSystemId.contains(MYBATIS_MAPPER_SYSTEM) || lowerCaseSystemId.contains(IBATIS_MAPPER_SYSTEM)) &#123;</span><br><span class="line">        <span class="keyword">return</span> getInputSource(MYBATIS_MAPPER_DTD, publicId, systemId);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SAXException(e.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="priUa"></a></p><h2 id="配置文件解析"><a class="markdownIt-Anchor" href="#配置文件解析"></a> 配置文件解析</h2><p>配置文件解析是由XMLConfigBuilder完成的，同时该类还会建造出一个Configuration对象，其入口方法就是parse方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 不允许重复解析</span></span><br><span class="line">  <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Each XMLConfigBuilder can only be used once.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  parsed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">// 从根节点开始解析</span></span><br><span class="line">  parseConfiguration(parser.evalNode(<span class="string">&quot;/configuration&quot;</span>));</span><br><span class="line">  <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parseConfiguration：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 解析信息放入Configuration</span></span><br><span class="line">    <span class="comment">// 首先解析properties，以保证在解析其他节点时就可以生效</span></span><br><span class="line">    propertiesElement(root.evalNode(<span class="string">&quot;properties&quot;</span>));</span><br><span class="line">    Properties settings = settingsAsProperties(root.evalNode(<span class="string">&quot;settings&quot;</span>));</span><br><span class="line">    loadCustomVfs(settings);</span><br><span class="line">    loadCustomLogImpl(settings);</span><br><span class="line">    typeAliasesElement(root.evalNode(<span class="string">&quot;typeAliases&quot;</span>));</span><br><span class="line">    pluginElement(root.evalNode(<span class="string">&quot;plugins&quot;</span>));</span><br><span class="line">    objectFactoryElement(root.evalNode(<span class="string">&quot;objectFactory&quot;</span>));</span><br><span class="line">    objectWrapperFactoryElement(root.evalNode(<span class="string">&quot;objectWrapperFactory&quot;</span>));</span><br><span class="line">    reflectorFactoryElement(root.evalNode(<span class="string">&quot;reflectorFactory&quot;</span>));</span><br><span class="line">    settingsElement(settings);</span><br><span class="line">    <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">    environmentsElement(root.evalNode(<span class="string">&quot;environments&quot;</span>));</span><br><span class="line">    databaseIdProviderElement(root.evalNode(<span class="string">&quot;databaseIdProvider&quot;</span>));</span><br><span class="line">    typeHandlerElement(root.evalNode(<span class="string">&quot;typeHandlers&quot;</span>));</span><br><span class="line">    mapperElement(root.evalNode(<span class="string">&quot;mappers&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的调用一样是嵌套调用，这里以mapper为例继续解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理子节点，即mapper节点或package节点</span></span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="comment">// 是否为package</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">        <span class="comment">// 取出包路径</span></span><br><span class="line">        String mapperPackage = child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">// 全部存入mappers</span></span><br><span class="line">        configuration.addMappers(mapperPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// resource url mapperClass只有一个生效</span></span><br><span class="line">        String v = child.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">        String url = child.getStringAttribute(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        String mapperClass = child.getStringAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(resource);</span><br><span class="line">          <span class="comment">// 获取文件输入流</span></span><br><span class="line">          InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">          <span class="comment">// 使用XMLMapperBuilder解析映射文件</span></span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(url);</span><br><span class="line">          <span class="comment">// 获得网络输入流</span></span><br><span class="line">          InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">          <span class="comment">// 使用XMLMapperBuilder解析映射文件</span></span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 获取映射接口</span></span><br><span class="line">          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">          configuration.addMapper(mapperInterface);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XMLConfigBuilder在Mybatis中起到了引导的作用，正是从其parse方法开始引发了配置的解析。<br /><a name="ojvIG"></a></p><h2 id="数据库语句解析"><a class="markdownIt-Anchor" href="#数据库语句解析"></a> 数据库语句解析</h2><p>映射文件的解析由XMLMapperBuilder来负责，其parse方法为入口方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 判断是否重复解析</span></span><br><span class="line">   <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">     <span class="comment">// 处理mapper节点</span></span><br><span class="line">     configurationElement(parser.evalNode(<span class="string">&quot;/mapper&quot;</span>));</span><br><span class="line">     <span class="comment">// 加入已解析的列表，防止重复解析</span></span><br><span class="line">     configuration.addLoadedResource(resource);</span><br><span class="line">     <span class="comment">// 将mapper注册给Configuration</span></span><br><span class="line">     bindMapperForNamespace();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 分别处理失败的resultMap、cache-ref、SQL</span></span><br><span class="line">   parsePendingResultMaps();</span><br><span class="line">   parsePendingCacheRefs();</span><br><span class="line">   parsePendingStatements();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>处理mapper结点的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 读取当前配置文件的命名空间</span></span><br><span class="line">    String namespace = context.getStringAttribute(<span class="string">&quot;namespace&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (namespace == <span class="keyword">null</span> || namespace.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Mapper&#x27;s namespace cannot be empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">    <span class="comment">// 映射文件中其他配置节点的解析</span></span><br><span class="line">    cacheRefElement(context.evalNode(<span class="string">&quot;cache-ref&quot;</span>));</span><br><span class="line">    cacheElement(context.evalNode(<span class="string">&quot;cache&quot;</span>));</span><br><span class="line">    parameterMapElement(context.evalNodes(<span class="string">&quot;/mapper/parameterMap&quot;</span>));</span><br><span class="line">    resultMapElements(context.evalNodes(<span class="string">&quot;/mapper/resultMap&quot;</span>));</span><br><span class="line">    sqlElement(context.evalNodes(<span class="string">&quot;/mapper/sql&quot;</span>));</span><br><span class="line">    <span class="comment">// 处理各种数据库操作语句</span></span><br><span class="line">    buildStatementFromContext(context.evalNodes(<span class="string">&quot;select|insert|update|delete&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error parsing Mapper XML. The XML location is &#x27;&quot;</span> + resource + <span class="string">&quot;&#x27;. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类的parse方法在结尾有三个parsePending方法来处理解析过程中的暂时错误。<br />解析上下文读取文件时，可能会读取到一个节点是其还没有被定义，这种时候有两种解决方法：</p><ul><li>第一轮只读入所有结点但不处理依赖，在第二轮再处理依赖关系。Spring初始化时就用的这种方案。</li><li>如果为被定义就设为暂时性的错误，显然Mybatis默认采用这种方案。<br /><a name="O6ETX"></a></li></ul><h2 id="statement解析"><a class="markdownIt-Anchor" href="#statement解析"></a> Statement解析</h2><p>数据库的操作节点解析由XMLStatementBuilder的parseStatementNode方法完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseStatementNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取当前节点的id与databaseId</span></span><br><span class="line">   String id = context.getStringAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">   String databaseId = context.getStringAttribute(<span class="string">&quot;databaseId&quot;</span>);</span><br><span class="line"><span class="comment">// 验证id与databaseId是否匹配。Mybatis允许多种数据库配置，有些语句只能针对特定数据库生效</span></span><br><span class="line">   <span class="keyword">if</span> (!databaseIdMatchesCurrent(id, databaseId, <span class="keyword">this</span>.requiredDatabaseId)) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 获取节点名</span></span><br><span class="line">   String nodeName = context.getNode().getNodeName();</span><br><span class="line">   <span class="comment">// 读取和判断语句类型</span></span><br><span class="line">   SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">   <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">   <span class="keyword">boolean</span> flushCache = context.getBooleanAttribute(<span class="string">&quot;flushCache&quot;</span>, !isSelect);</span><br><span class="line">   <span class="keyword">boolean</span> useCache = context.getBooleanAttribute(<span class="string">&quot;useCache&quot;</span>, isSelect);</span><br><span class="line">   <span class="keyword">boolean</span> resultOrdered = context.getBooleanAttribute(<span class="string">&quot;resultOrdered&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理语句的include节点</span></span><br><span class="line">   XMLIncludeTransformer includeParser = <span class="keyword">new</span> XMLIncludeTransformer(configuration, builderAssistant);</span><br><span class="line">   includeParser.applyIncludes(context.getNode());</span><br><span class="line"><span class="comment">// 获取参数类型</span></span><br><span class="line">   String parameterType = context.getStringAttribute(<span class="string">&quot;parameterType&quot;</span>);</span><br><span class="line">   Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);</span><br><span class="line"><span class="comment">// 获取语句类型</span></span><br><span class="line">   String lang = context.getStringAttribute(<span class="string">&quot;lang&quot;</span>);</span><br><span class="line">   LanguageDriver langDriver = getLanguageDriver(lang);</span><br><span class="line"><span class="comment">// 处理SelectKey节点，这里会将KeyGenerator加入到Configuration.keyGenerators中</span></span><br><span class="line">   processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 所有的selectKey和include已经被解析并删除完毕，开始SQL解析</span></span><br><span class="line">   KeyGenerator keyGenerator;</span><br><span class="line">   String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">   keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="keyword">true</span>);</span><br><span class="line">   <span class="comment">// 判断是否已经有解析好的KeyGenerator</span></span><br><span class="line">   <span class="keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">     keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 全局或者本语句只要一启动自动key生成就会使用key生成</span></span><br><span class="line">     keyGenerator = context.getBooleanAttribute(<span class="string">&quot;useGeneratedKeys&quot;</span>,</span><br><span class="line">         configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">         ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 读取各个配置属性</span></span><br><span class="line">   SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line">   StatementType statementType = StatementType.valueOf(context.getStringAttribute(<span class="string">&quot;statementType&quot;</span>, StatementType.PREPARED.toString()));</span><br><span class="line">   Integer fetchSize = context.getIntAttribute(<span class="string">&quot;fetchSize&quot;</span>);</span><br><span class="line">   Integer timeout = context.getIntAttribute(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">   String parameterMap = context.getStringAttribute(<span class="string">&quot;parameterMap&quot;</span>);</span><br><span class="line">   String resultType = context.getStringAttribute(<span class="string">&quot;resultType&quot;</span>);</span><br><span class="line">   Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">   String resultMap = context.getStringAttribute(<span class="string">&quot;resultMap&quot;</span>);</span><br><span class="line">   String resultSetType = context.getStringAttribute(<span class="string">&quot;resultSetType&quot;</span>);</span><br><span class="line">   ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);</span><br><span class="line">   <span class="keyword">if</span> (resultSetTypeEnum == <span class="keyword">null</span>) &#123;</span><br><span class="line">     resultSetTypeEnum = configuration.getDefaultResultSetType();</span><br><span class="line">   &#125;</span><br><span class="line">   String keyProperty = context.getStringAttribute(<span class="string">&quot;keyProperty&quot;</span>);</span><br><span class="line">   String keyColumn = context.getStringAttribute(<span class="string">&quot;keyColumn&quot;</span>);</span><br><span class="line">   String resultSets = context.getStringAttribute(<span class="string">&quot;resultSets&quot;</span>);</span><br><span class="line"><span class="comment">// 在MapperBuilderAssistant帮助下创建MappedStatement对象并写入Configuration</span></span><br><span class="line">   builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">       fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">       resultSetTypeEnum, flushCache, useCache, resultOrdered,</span><br><span class="line">       keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="ZUVk0"></a></p><h2 id="引用解析"><a class="markdownIt-Anchor" href="#引用解析"></a> 引用解析</h2><p>Mybatis支持在数据库操作语句中编写引用语句片段。<br />在之前statement解析中也可以看到include节点是由XMLIncludeTransformer来负责的，他可以将include中的include节点替换为被引用的SQL片段。其applyInclude（Node）方法时解析include结点的入口方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyIncludes</span><span class="params">(Node source, <span class="keyword">final</span> Properties variablesContext, <span class="keyword">boolean</span> included)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (source.getNodeName().equals(<span class="string">&quot;include&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 找出被应用的节点</span></span><br><span class="line">    Node toInclude = findSqlFragment(getStringAttribute(source, <span class="string">&quot;refid&quot;</span>), variablesContext);</span><br><span class="line">    Properties toIncludeContext = getVariablesContext(source, variablesContext);</span><br><span class="line">    <span class="comment">// 递归处理被引用节点中的include节点</span></span><br><span class="line">    applyIncludes(toInclude, toIncludeContext, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (toInclude.getOwnerDocument() != source.getOwnerDocument()) &#123;</span><br><span class="line">      toInclude = source.getOwnerDocument().importNode(toInclude, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完成include节点的替换</span></span><br><span class="line">    source.getParentNode().replaceChild(toInclude, source);</span><br><span class="line">    <span class="keyword">while</span> (toInclude.hasChildNodes()) &#123;</span><br><span class="line">      toInclude.getParentNode().insertBefore(toInclude.getFirstChild(), toInclude);</span><br><span class="line">    &#125;</span><br><span class="line">    toInclude.getParentNode().removeChild(toInclude);</span><br><span class="line">   <span class="comment">// 元素节点</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">    <span class="keyword">if</span> (included &amp;&amp; !variablesContext.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// 用属性替换变量</span></span><br><span class="line">      NamedNodeMap attributes = source.getAttributes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; attributes.getLength(); i++) &#123;</span><br><span class="line">        Node attr = attributes.item(i);</span><br><span class="line">        attr.setNodeValue(PropertyParser.parse(attr.getNodeValue(), variablesContext));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环到下层节点递归处理的下层的include节点</span></span><br><span class="line">    NodeList children = source.getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">      applyIncludes(children.item(i), variablesContext, included);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (included &amp;&amp; source.getNodeType() == Node.TEXT_NODE</span><br><span class="line">      <span class="comment">// 文本节点</span></span><br><span class="line">      &amp;&amp; !variablesContext.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// 用属性值来替代变量</span></span><br><span class="line">    source.setNodeValue(PropertyParser.parse(source.getNodeValue(), variablesContext));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="e3QAH"></a></p><h3 id="解析过程示意图"><a class="markdownIt-Anchor" href="#解析过程示意图"></a> 解析过程示意图：</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1602041595938-b2808eab-bcf7-4d37-bb5f-294e45545484.png#align=left&amp;display=inline&amp;height=211&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=275&amp;originWidth=692&amp;size=234735&amp;status=done&amp;style=none&amp;width=530" alt="image.png" /><br /><a name="MWkYB"></a></p><h1 id="注解映射解析"><a class="markdownIt-Anchor" href="#注解映射解析"></a> 注解映射解析</h1><p>Mybatis也支持使用注解来配置映射，builder包中的annocation子包就可以用来完成这种形式的映射解析。<br /><a name="unVX5"></a></p><h2 id="解析触发"><a class="markdownIt-Anchor" href="#解析触发"></a> 解析触发</h2><p>注解解析是从MapperAnnotationBuilder中的parse方法开始的。<br />该类在触发方法之前就已经在静态代码块中完成了一些初始化工作了，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  SQL_ANNOTATION_TYPES.add(Select.class);</span><br><span class="line">  SQL_ANNOTATION_TYPES.add(Insert.class);</span><br><span class="line">  SQL_ANNOTATION_TYPES.add(Update.class);</span><br><span class="line">  SQL_ANNOTATION_TYPES.add(Delete.class);</span><br><span class="line"></span><br><span class="line">  SQL_PROVIDER_ANNOTATION_TYPES.add(SelectProvider.class);</span><br><span class="line">  SQL_PROVIDER_ANNOTATION_TYPES.add(InsertProvider.class);</span><br><span class="line">  SQL_PROVIDER_ANNOTATION_TYPES.add(UpdateProvider.class);</span><br><span class="line">  SQL_PROVIDER_ANNOTATION_TYPES.add(DeleteProvider.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SQL_ANNOTATION_TYPES中放入了四种直接注解，SQL_PROVIDER_ANNOTATION_TYPES中放入了四种间接注解。<br />在mappers中标注出dao层接口以后就会触发MapperAnnotationBuilder的parse方法开始解析工作。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String resource = type.toString();</span><br><span class="line">  <span class="comment">// 防止重复分析</span></span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    <span class="comment">// 寻找类名对应的resources路径下是否有xml配置，如果有则解析。这样就可以两种模式双管齐下。</span></span><br><span class="line">    loadXmlResource();</span><br><span class="line">    <span class="comment">// 记录资源路径</span></span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    <span class="comment">// 设置命名空间</span></span><br><span class="line">    assistant.setCurrentNamespace(type.getName());</span><br><span class="line">    <span class="comment">// 处理缓存</span></span><br><span class="line">    parseCache();</span><br><span class="line">    parseCacheRef();</span><br><span class="line">    Method[] methods = type.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 排除桥接方法</span></span><br><span class="line">        <span class="keyword">if</span> (!method.isBridge()) &#123;</span><br><span class="line">          <span class="comment">// 解析方法</span></span><br><span class="line">          parseStatement(method);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">        <span class="comment">// 暂存解析异常</span></span><br><span class="line">        configuration.addIncompleteMethod(<span class="keyword">new</span> MethodResolver(<span class="keyword">this</span>, method));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  parsePendingMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>桥接方法是为了匹配泛型类型擦除而由编译器自动引入的，并非用户编写的，所以需要排除。<br />注意：在解析接口方法时可能会遇到一些尚未读取的其他信息，如尚未解析的ResultMap、命名空间信息等。这时会将该方法放入到Configuration类中的incompleteMethods属性中，在最后再次处理。在再次处理时，用到了MethodResolver对象，该对象通过调用parseStatement方法对解析失败的接口方法进行再一次解析。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parseStatement</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 通过子方法获取参数类型</span></span><br><span class="line">  Class&lt;?&gt; parameterTypeClass = getParameterType(method);</span><br><span class="line">  <span class="comment">// 获取方法的脚本语言驱动</span></span><br><span class="line">  LanguageDriver languageDriver = getLanguageDriver(method);</span><br><span class="line">  <span class="comment">// 通过注解获取SqlSource</span></span><br><span class="line">  SqlSource sqlSource = getSqlSourceFromAnnotations(method, parameterTypeClass, languageDriver);</span><br><span class="line">  <span class="keyword">if</span> (sqlSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取方法上可能存在的配置信息，配置信息由@Options注解指定</span></span><br><span class="line">    Options options = method.getAnnotation(Options.class);</span><br><span class="line">    <span class="keyword">final</span> String mappedStatementId = type.getName() + <span class="string">&quot;.&quot;</span> + method.getName();</span><br><span class="line"> <span class="comment">// 用默认值初始化各项设置，省略具体代码。</span></span><br><span class="line">    <span class="comment">// 处理主键自动生成的问题，省略具体代码</span></span><br><span class="line">    <span class="comment">// 如果存在@Options注解，则根据其中的配置信息重新配置，省略具体代码</span></span><br><span class="line">    <span class="comment">// 返回结果ResultMap处理，省略具体代码</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 将获取的映射信息存入configuration</span></span><br><span class="line">    assistant.addMappedStatement(</span><br><span class="line">        <span class="comment">// 省略代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最关键的方法就是getSqlSourceFromAnnotations，通过该方法获取了SqlSource对象，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSource <span class="title">getSqlSourceFromAnnotations</span><span class="params">(Method method, Class&lt;?&gt; parameterType, LanguageDriver languageDriver)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历寻找是否有直接注解</span></span><br><span class="line">    Class&lt;? extends Annotation&gt; sqlAnnotationType = getSqlAnnotationType(method);</span><br><span class="line">    <span class="comment">// 遍历寻找是否有间接注解</span></span><br><span class="line">    Class&lt;? extends Annotation&gt; sqlProviderAnnotationType = getSqlProviderAnnotationType(method);</span><br><span class="line">    <span class="keyword">if</span> (sqlAnnotationType != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sqlProviderAnnotationType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 两类注解不可同时使用</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;You cannot supply both a static SQL and SqlProvider to method named &quot;</span> + method.getName());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 含有直接注解的</span></span><br><span class="line">      Annotation sqlAnnotation = method.getAnnotation(sqlAnnotationType);</span><br><span class="line">      <span class="comment">// 取出value值</span></span><br><span class="line">      <span class="keyword">final</span> String[] strings = (String[]) sqlAnnotation.getClass().getMethod(<span class="string">&quot;value&quot;</span>).invoke(sqlAnnotation);</span><br><span class="line">      <span class="comment">// 基于字符串构建SqlSource</span></span><br><span class="line">      <span class="keyword">return</span> buildSqlSourceFromStrings(strings, parameterType, languageDriver);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sqlProviderAnnotationType != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 含有间接注解的</span></span><br><span class="line">      Annotation sqlProviderAnnotation = method.getAnnotation(sqlProviderAnnotationType);</span><br><span class="line">      <span class="comment">// 根据对应的方法获取SqlSource</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ProviderSqlSource(assistant.getConfiguration(), sqlProviderAnnotation, type, method);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Could not find value method on SQL annotation.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="77H4A"></a></p><h3 id="直接注解"><a class="markdownIt-Anchor" href="#直接注解"></a> 直接注解</h3><p>上述方法中直接注解映射由buildSqlSourceFromStrings负责生成，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSource <span class="title">buildSqlSourceFromStrings</span><span class="params">(String[] strings, Class&lt;?&gt; parameterTypeClass, LanguageDriver languageDriver)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> StringBuilder sql = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">  <span class="keyword">for</span> (String fragment : strings) &#123;</span><br><span class="line">    sql.append(fragment);</span><br><span class="line">    sql.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> languageDriver.createSqlSource(configuration, sql.toString().trim(), parameterTypeClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作很简单，就是直接将SQL语句的字符串拼接交给languageDriver进行处理并返回。<br /><a name="uwopA"></a></p><h2 id="间接注解"><a class="markdownIt-Anchor" href="#间接注解"></a> 间接注解</h2><p>在分析间接注解前首先要分析ProviderContext和ProviderMethodDriver两个类。<br /><a name="dmxZq"></a></p><h3 id="providercontext"><a class="markdownIt-Anchor" href="#providercontext"></a> ProviderContext</h3><p>该类的功能就是将以下三个属性整合为一个整体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供映射信息类 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; mapperType;</span><br><span class="line"><span class="comment">// 提供映射信息的方法，该方法属于mapperType类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Method mapperMethod;</span><br><span class="line"><span class="comment">// 数据库编号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String databaseId;</span><br></pre></td></tr></table></figure><p><a name="grMCT"></a></p><h3 id="providermethodresolver"><a class="markdownIt-Anchor" href="#providermethodresolver"></a> ProviderMethodResolver</h3><p>该接口默认方法是resoveMethod，其作用是从@*Provider注解的type属性所指向的类中挑出method属性中所指定的方法。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Method <span class="title">resolveMethod</span><span class="params">(ProviderContext context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 找出同名方法</span></span><br><span class="line">  List&lt;Method&gt; sameNameMethods = Arrays.stream(getClass().getMethods())</span><br><span class="line">      .filter(m -&gt; m.getName().equals(context.getMapperMethod().getName()))</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">  <span class="comment">// 如果没有找到，则抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (sameNameMethods.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Cannot resolve the provider method because &#x27;&quot;</span></span><br><span class="line">        + context.getMapperMethod().getName() + <span class="string">&quot;&#x27; not found in SqlProvider &#x27;&quot;</span> + getClass().getName() + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据返回类型再次判断，返回类型必须是CharSequence及其子类</span></span><br><span class="line">  List&lt;Method&gt; targetMethods = sameNameMethods.stream()</span><br><span class="line">      .filter(m -&gt; CharSequence.class.isAssignableFrom(m.getReturnType()))</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">  <span class="keyword">if</span> (targetMethods.size() == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 若唯一则返回该方法</span></span><br><span class="line">    <span class="keyword">return</span> targetMethods.get(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (targetMethods.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Cannot resolve the provider method because &#x27;&quot;</span></span><br><span class="line">        + context.getMapperMethod().getName() + <span class="string">&quot;&#x27; does not return the CharSequence or its subclass in SqlProvider &#x27;&quot;</span></span><br><span class="line">        + getClass().getName() + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Cannot resolve the provider method because &#x27;&quot;</span></span><br><span class="line">        + context.getMapperMethod().getName() + <span class="string">&quot;&#x27; is found multiple in SqlProvider &#x27;&quot;</span> + getClass().getName() + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要分为两个步骤：</p><ol><li>找到符合方法名的所有方法。</li><li>根据方法返回值进一步校验。<br /><a name="ymVAL"></a></li></ol><h3 id="providersqlsource"><a class="markdownIt-Anchor" href="#providersqlsource"></a> ProviderSqlSource</h3><p>该类内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Configuration对象  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line"><span class="comment">// *Provider注解上type属性所指的类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; providerType;</span><br><span class="line"><span class="comment">// 语言驱动</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LanguageDriver languageDriver;</span><br><span class="line"><span class="comment">// 含有注解的接口方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Method mapperMethod;</span><br><span class="line"><span class="comment">// *Provider注解上，method属性所指的方法</span></span><br><span class="line"><span class="keyword">private</span> Method providerMethod;</span><br><span class="line"><span class="comment">// 给定SQL语句的方法对应的参数</span></span><br><span class="line"><span class="keyword">private</span> String[] providerMethodArgumentNames;</span><br><span class="line"><span class="comment">// 给定SQL语句的方法对应的参数类型</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt;[] providerMethodParameterTypes;</span><br><span class="line"><span class="comment">// ProviderContext对象</span></span><br><span class="line"><span class="keyword">private</span> ProviderContext providerContext;</span><br><span class="line"><span class="comment">// ProviderContext对象</span></span><br><span class="line"><span class="keyword">private</span> Integer providerContextIndex;</span><br></pre></td></tr></table></figure><p>该类作为SqlSource接口的子类，实现了getBoundSql方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取sqlSource对象</span></span><br><span class="line">  SqlSource sqlSource = createSqlSource(parameterObject);</span><br><span class="line">  <span class="comment">// 从SqlSource中获取BoundSql对象</span></span><br><span class="line">  <span class="keyword">return</span> sqlSource.getBoundSql(parameterObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createSqlSource方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSource <span class="title">createSqlSource</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// SQL字符串信息存储</span></span><br><span class="line">    String sql;</span><br><span class="line">    <span class="comment">// 如果是map类型</span></span><br><span class="line">    <span class="keyword">if</span> (parameterObject <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">      <span class="keyword">int</span> bindParameterCount = providerMethodParameterTypes.length - (providerContext == <span class="keyword">null</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (bindParameterCount == <span class="number">1</span> &amp;&amp;</span><br><span class="line">        (providerMethodParameterTypes[Integer.valueOf(<span class="number">0</span>).equals(providerContextIndex) ? <span class="number">1</span> : <span class="number">0</span>].isAssignableFrom(parameterObject.getClass()))) &#123;</span><br><span class="line">        <span class="comment">// 调用*Provider注解的type类中的method方法，从而获取SQL字符串</span></span><br><span class="line">        sql = invokeProviderMethod(extractProviderMethodArguments(parameterObject));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Map&lt;String, Object&gt; params = (Map&lt;String, Object&gt;) parameterObject;</span><br><span class="line">        <span class="comment">// 调用*Provider注解的type类中的method方法，从而获得SQL字符串  </span></span><br><span class="line">        sql = invokeProviderMethod(extractProviderMethodArguments(params, providerMethodArgumentNames));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (providerMethodParameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 无需参数</span></span><br><span class="line">      sql = invokeProviderMethod();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (providerMethodParameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (providerContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 只有一个参数</span></span><br><span class="line">        sql = invokeProviderMethod(parameterObject);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 参数为providerContext</span></span><br><span class="line">        sql = invokeProviderMethod(providerContext);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (providerMethodParameterTypes.length == <span class="number">2</span>) &#123;</span><br><span class="line">      sql = invokeProviderMethod(extractProviderMethodArguments(parameterObject));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Cannot invoke SqlProvider method &#x27;&quot;</span> + providerMethod</span><br><span class="line">        + <span class="string">&quot;&#x27; with specify parameter &#x27;&quot;</span> + (parameterObject == <span class="keyword">null</span> ? <span class="keyword">null</span> : parameterObject.getClass())</span><br><span class="line">        + <span class="string">&quot;&#x27; because SqlProvider method arguments for &#x27;&quot;</span> + mapperMethod + <span class="string">&quot;&#x27; is an invalid combination.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt; parameterType = parameterObject == <span class="keyword">null</span> ? Object.class : parameterObject.getClass();</span><br><span class="line">    <span class="keyword">return</span> languageDriver.createSqlSource(configuration, sql, parameterType);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (BuilderException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error invoking SqlProvider method &#x27;&quot;</span> + providerMethod</span><br><span class="line">        + <span class="string">&quot;&#x27; with specify parameter &#x27;&quot;</span> + (parameterObject == <span class="keyword">null</span> ? <span class="keyword">null</span> : parameterObject.getClass()) + <span class="string">&quot;&#x27;.  Cause: &quot;</span> + extractRootCause(e), e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法可以概括为三步：</p><ul><li>调用*Provider注解的type类中的method方法，从而获得SQL字符串。</li><li>向languageDriver的createSqlSource方法传入SQL字符串等参数生成一个SqlSource对象。</li><li>调用SqlSource的getBoundSql方法，获得BoundSql对象。</li></ul>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
          <category> 配置解析包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>binding包</title>
      <link href="/posts/mybatis-binding/"/>
      <url>/posts/mybatis-binding/</url>
      
        <content type="html"><![CDATA[<h1 id="binding包"><a class="markdownIt-Anchor" href="#binding包"></a> binding包</h1><p>binding包主要负责处理Java方法与SQL语句之间绑定关系。<br />binding包主要有以下两个功能：</p><ul><li>维护映射接口中抽象方法与数据库操作节点之间的映射关系。</li><li>为映射接口中的抽象方法接入相应的数据库操作。<br /><a name="4DnUf"></a></li></ul><h1 id="数据库接入操作"><a class="markdownIt-Anchor" href="#数据库接入操作"></a> 数据库接入操作</h1><p>binding包是基于映射的动态代理实现的，该包内与接入数据库相关的类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601946515109-39ebd2b0-853d-4912-b054-e96cc74268fe.png#align=left&amp;display=inline&amp;height=358&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=715&amp;originWidth=1129&amp;size=1152659&amp;status=done&amp;style=none&amp;width=564.5" alt="image.png" /><br /><a name="w0LHb"></a></p><h2 id="mappermethod"><a class="markdownIt-Anchor" href="#mappermethod"></a> MapperMethod</h2><p>首先要做的就是要把数据库操作节点转换为一个方法。MapperMethod对象就表示数据库操作转化后的方法。每个MapperMethod对象都对应一个数据库操作节点，调用MapperMethod的execute方法就可以触发节点中的SQL语句操作数据库。<br /><a name="G2IIP"></a></p><h3 id="内部类"><a class="markdownIt-Anchor" href="#内部类"></a> 内部类</h3><p>MapperMethod类中有两个重要的属性，分别对应着两个内部类，即SqlCommand和MethodSignature。<br />还有一个重要的ParamMap属性来作为取值使用。<br /><a name="t2kzl"></a></p><h4 id="methodsignature"><a class="markdownIt-Anchor" href="#methodsignature"></a> MethodSignature</h4><p>该类指代一个具体方法的签名（细节），其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值是否是集合    </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsMany;</span><br><span class="line"><span class="comment">// 返回值是否是map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsMap;</span><br><span class="line"><span class="comment">// 返回值是否为空</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsVoid;</span><br><span class="line"><span class="comment">// 返回值类型是否是Cursor</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsCursor;</span><br><span class="line"><span class="comment">// 返回值类型是否是Optional</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsOptional;</span><br><span class="line"><span class="comment">// 该方法的返回值类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; returnType;</span><br><span class="line"><span class="comment">// 如果返回值类型是map 则在这里记录key</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String mapKey;</span><br><span class="line"><span class="comment">// resultHandle参数的位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Integer resultHandlerIndex;</span><br><span class="line"><span class="comment">// rowBounds参数的位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Integer rowBoundsIndex;</span><br><span class="line"><span class="comment">// 参数名称解析器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ParamNameResolver paramNameResolver;</span><br></pre></td></tr></table></figure><p><a name="z2YEm"></a></p><h4 id="sqlcommand"><a class="markdownIt-Anchor" href="#sqlcommand"></a> SqlCommand</h4><p>该类是指代一个SQL语句，内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SQL语句的名称   </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"><span class="comment">// SQL语句的种类，包含增、删、改、查、清缓存和未知</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlCommandType type;</span><br></pre></td></tr></table></figure><p>SqlCommand会根据传入参数完成对name和type的赋值。resolveMappedStatement字方法会根据接口找到对应的MappedStatement，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> MappedStatement <span class="title">resolveMappedStatement</span><span class="params">(Class&lt;?&gt; mapperInterface, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;?&gt; declaringClass, Configuration configuration)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数据库操作语句编号是：接口名.方法名</span></span><br><span class="line">    String statementId = mapperInterface.getName() + <span class="string">&quot;.&quot;</span> + methodName;</span><br><span class="line">    <span class="comment">// configuration保存了解析后的所有操作语句，所以在这里判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (configuration.hasStatement(statementId)) &#123;</span><br><span class="line">      <span class="comment">// 找到语句并返回</span></span><br><span class="line">      <span class="keyword">return</span> configuration.getMappedStatement(statementId);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mapperInterface.equals(declaringClass)) &#123;</span><br><span class="line">      <span class="comment">// 递归到头了都没找到，返回空值</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向上寻找直到找到接口（递归调用）</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; superInterface : mapperInterface.getInterfaces()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (declaringClass.isAssignableFrom(superInterface)) &#123;</span><br><span class="line">        MappedStatement ms = resolveMappedStatement(superInterface, methodName,</span><br><span class="line">            declaringClass, configuration);</span><br><span class="line">        <span class="keyword">if</span> (ms != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> ms;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="YzfJ8"></a></p><h3 id="总结分析"><a class="markdownIt-Anchor" href="#总结分析"></a> 总结分析</h3><p>显然MapperMethod类将一个数据库操作语句和Java语句绑定在了一起，其MethodSignature属性保存了这个方法的详细信息，SqlCommand对象持有这个方法对应的SQL语句，如下图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601948351931-e618b729-205e-42fc-89a2-f6ea1fda9ad0.png#align=left&amp;display=inline&amp;height=137&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=274&amp;originWidth=1121&amp;size=456941&amp;status=done&amp;style=none&amp;width=560.5" alt="image.png" /><br /><a name="lUEmO"></a></p><h3 id="parammap"><a class="markdownIt-Anchor" href="#parammap"></a> ParamMap</h3><p>该类是HashMap的子类，但是它比HashMap要严格：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">super</span>.containsKey(key)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Parameter &#x27;&quot;</span> + key + <span class="string">&quot;&#x27; not found. Available parameters are &quot;</span> + keySet());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获取值时，如果不存在直接抛出异常。<br /><a name="X2drJ"></a></p><h3 id="execute"><a class="markdownIt-Anchor" href="#execute"></a> execute</h3><p>只要触发了MapperMethod的execute方法就可以触发具体的数据库操作，于是数据库就被转化成了具体的方法。exectue源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">   Object result;</span><br><span class="line"><span class="comment">// 根据SQL语句不同执行不同的操作</span></span><br><span class="line">   <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">     <span class="comment">// 如果是插入语句</span></span><br><span class="line">     <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">       <span class="comment">// 调整参数和实参顺序</span></span><br><span class="line">       Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">       <span class="comment">// 执行并返回</span></span><br><span class="line">       result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果是更新语句</span></span><br><span class="line">     <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">       Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">       result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果是删除语句</span></span><br><span class="line">     <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">       Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">       result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果是查询语句</span></span><br><span class="line">     <span class="keyword">case</span> SELECT:</span><br><span class="line">       <span class="comment">// 方法返回值是void，但是方法有结果</span></span><br><span class="line">       <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">         <span class="comment">// 使用结果处理器执行查询</span></span><br><span class="line">         executeWithResultHandler(sqlSession, args);</span><br><span class="line">         result = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 方法返回值是集合</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">         result = executeForMany(sqlSession, args);</span><br><span class="line">       <span class="comment">// 方法返回值是map</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">         result = executeForMap(sqlSession, args);</span><br><span class="line">       <span class="comment">// 方法返回值是Cursor</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">         result = executeForCursor(sqlSession, args);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 单条结果查询</span></span><br><span class="line">         Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">         result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">         <span class="comment">// 查询结果为null或者返回值类型不匹配，返回值是Optional</span></span><br><span class="line">         <span class="keyword">if</span> (method.returnsOptional()</span><br><span class="line">             &amp;&amp; (result == <span class="keyword">null</span> || !method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">           result = Optional.ofNullable(result);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     <span class="comment">// 如果是刷新语句</span></span><br><span class="line">     <span class="keyword">case</span> FLUSH:</span><br><span class="line">       result = sqlSession.flushStatements();</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Unknown execution method for: &quot;</span> + command.getName());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 查询结果为空，但返回值为基本类型且不为空</span></span><br><span class="line">   <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Mapper method &#x27;&quot;</span> + command.getName()</span><br><span class="line">         + <span class="string">&quot; attempted to return null from a method with a primitive return type (&quot;</span> + method.getReturnType() + <span class="string">&quot;).&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><a name="qPA1A"></a></p><h2 id="mapperproxy"><a class="markdownIt-Anchor" href="#mapperproxy"></a> MapperProxy</h2><p>在MapperMethod方法把数据库操作转换成了一个方法，这里又要通过MapperProxy来将数据库操作方法接入映射接口的抽象方法中，即可以使用动态代理来调用MapperMethod的方法实现mapper文件中定义的方法的功能。<br />MapperProxy是基于动态代理针对接口映射方法调用转接成了对MapperMethod对象execute方法的调用从而实现了接口调用数据库操作的功能。<br />MapperProxy继承自InvocationHandler，是个标准的动态代理的类。当实例替代被代理对象后，对被代理对象的方法调用会被转接到MapperProxy的invoke方法上，invoke方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否继承自object</span></span><br><span class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="comment">// 直接执行原有方法</span></span><br><span class="line">      <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">    <span class="comment">// 判断是否是默认方法</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.isDefault()) &#123;</span><br><span class="line">     <span class="comment">// 执行默认方法</span></span><br><span class="line">      <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 找到对应的MapperMethod对象</span></span><br><span class="line">  <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">  <span class="comment">// 调用excute方法</span></span><br><span class="line">  <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="XocJR"></a></p><h2 id="mapperproxyfactory"><a class="markdownIt-Anchor" href="#mapperproxyfactory"></a> MapperProxyFactory</h2><p>该类的实现比较简单，就是MapperProxy的生产工厂，newInstance方法会生成一个MapperProxy对象。<br /><a name="JS5IX"></a></p><h1 id="抽象方法与数据库操作节点的关联"><a class="markdownIt-Anchor" href="#抽象方法与数据库操作节点的关联"></a> 抽象方法与数据库操作节点的关联</h1><p>前面的操作已经将与各数据库操作转换成了一个方法，甚至是一个动态代理乃至一个生产工厂，并将这个方法接入一个映射接口的抽象方法中。<br />Mapper文件如此之多，因此要在确定关联关系是个很重要的事情，Mybatis分两步完成了该任务：<br /><a name="ltuUv"></a></p><h2 id="绑定接口和映射文件"><a class="markdownIt-Anchor" href="#绑定接口和映射文件"></a> 绑定接口和映射文件</h2><p>将映射接口与MapperProxyFactory关联起来，这种关联关系是在MapperRegistry中的knowMappers属性中维护的，其属性定义：<code>private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap&lt;&gt;();</code><br />因为MapperProxyFactory的构造方法只接受一个接口类型，且不允许修改，因此MapperProxyFactory和映射接口的对应是唯一的，同样MapperProxyFactory和MapperProxy也是一一对应的，因此knowMappers间接对应了唯一的MapperProxy。<br />MapperRegistry的getMapper方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 找出指定映射接口的映射工厂</span></span><br><span class="line">  <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">  <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is not known to the MapperRegistry.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 通过mapperProxyFactory返回对应的处理器实例</span></span><br><span class="line">    <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样映射文件就和接口就通过返回的代理对象绑定了起来。<br /><a name="adtHd"></a></p><h2 id="绑定抽象方法"><a class="markdownIt-Anchor" href="#绑定抽象方法"></a> 绑定抽象方法</h2><p>现在范围已经缩减到了映射接口和MapperProxy的关系映射，接下来由MapperProxy中的MethodCache属性维护接口抽象方法和MapperMethod的映射。其属性定义如下：<code>private final Map&lt;Method, MapperMethod&gt; methodCache;</code><br />在cachedMapperMethod方法中完成了赋值操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> methodCache.computeIfAbsent(method, k -&gt; <span class="keyword">new</span> MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="aaoJk"></a></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>经过了上述两个步骤形成了下图的结构：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601951581210-b79f8609-55ae-43f2-bef5-a4fd24141d6f.png#align=left&amp;display=inline&amp;height=304&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=608&amp;originWidth=1214&amp;size=1164326&amp;status=done&amp;style=none&amp;width=607" alt="image.png" /><br />代理关系建立完成后，只要调用映射接口中的方法都会被MapperProxy截获，而MapperProxy会创建或选取合适的MapperMethod对象，并触发execute方法完成数据库操作。因而，抽象方法的调用变成了数据库操作。<br /><a name="eMsVp"></a></p><h1 id="数据库操作的总结"><a class="markdownIt-Anchor" href="#数据库操作的总结"></a> 数据库操作的总结</h1><p><a name="OCqE5"></a></p><h2 id="初始化阶段"><a class="markdownIt-Anchor" href="#初始化阶段"></a> 初始化阶段</h2><p>对各个映射文件解析时，各个数据库操作的节点信息会被记录到Configuration对象的mappedStatements属性中。该属性结构是一种StrictMap，键值为SQL语句的namespace.语句id，值为数据库操作节点信息。<br />Mybatis还会根据扫描的所有映射接口，根据映射接口创建与之关联的MapperProxyFactory，两者关联关系由MapperRegistry维护。当调用getMapper方法时，MapperProxyFactory会生产出一个MapperProxy对象作为映射接口代理。<br /><a name="DNIQ1"></a></p><h2 id="读写阶段"><a class="markdownIt-Anchor" href="#读写阶段"></a> 读写阶段</h2><p>当接口方法被调用时会被MapperProxy所劫持，触发内部的invoke方法，从而创建MapperMethod对象。<br />在创建MapperMethod的过程中，MapperMethod中的sqlCommond子类的构造方法会去Configuration对象的mappedStatements属性中获取当前映射接口名、其他的SQL语句信息。<br />之后execute方法会被触发来执行数据库操作。<br /><a name="X35TD"></a></p><h1 id="spring整合"><a class="markdownIt-Anchor" href="#spring整合"></a> Spring整合</h1><p>在Spring的application.xml中配置mapper文件所在的位置后，Spring在启动阶段会对指定路径进行扫描。对于扫描到的映射接口，mybatis-spring会将其当做MapperFactoryBean对象注册到Spring的Bean列表中。而MapperFactoryBean可以给出映射接口的代理类。这样就可以实现自动注入的功能。<br />springboot同理，知识增加了负责完成自动配置工作的mybatis-spring-boot-autoconfigure项目而已。</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
          <category> 配置解析包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>配置解析概述</title>
      <link href="/posts/mybatis-title/"/>
      <url>/posts/mybatis-title/</url>
      
        <content type="html"><![CDATA[<h1 id="配置解析概述"><a class="markdownIt-Anchor" href="#配置解析概述"></a> 配置解析概述</h1><p>Mybatis的配置解析依赖两个文件进行：</p><ul><li>配置文件，里面包含了Mybatis的基本信息，该文件只有一个。</li><li>映射文件，这里面设置了Java对象和数据库属性之间的映射关系、数据库操作语句等。该文件可以有多个。</li></ul><p>Mybatis首先要完成以上两类文件的解析，并根据解析的信息设置好Mybatis的运行环境以备使用。<br />所谓的解析过程就是将配置信息提取、转化，最终在Java对象中保存的过程。</p><hr /><p>按照上述思路，从类的角度分析，可以将配置解析相关的类分为以下两种：</p><ul><li>解析类（含接口）：提供配置的解析功能，完成配置信息的提取、转化。</li><li>解析实体类（含接口）：提供配置保存功能。该类在结构上与配置信息有对应的关系。配置信息最终会保存到解析实体类的属性中。</li></ul><p>注意：这种划分不是绝对的，因为存在一个二者皆是的。<br /></p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
          <category> 配置解析包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>parsing包</title>
      <link href="/posts/mybatis-parsing/"/>
      <url>/posts/mybatis-parsing/</url>
      
        <content type="html"><![CDATA[<h1 id="parsing包"><a class="markdownIt-Anchor" href="#parsing包"></a> parsing包</h1><p>Mybatis的parsing包就是用来解析XML文件的包，要了解该包前，要先回顾一下以下基础知识。<br /><a name="VawTP"></a></p><h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1><p><a name="CLYI0"></a></p><h2 id="xml文件"><a class="markdownIt-Anchor" href="#xml文件"></a> XML文件</h2><p>扩展标记语言（XML）是一种标记语言。标记语言即指计算机所能理解的信息符号，通过标记可以实现软件开发者与计算机之间的信息沟通。<br />XML可扩展的一个重要表现就是XML文档的结构是可以自由定义的。XML的节点包括元素节点、属性节点、文本节点、文档节点等。定义的XML文档可以用DTD，也可以用XML Schema。<br /><a name="c8zEb"></a></p><h2 id="xpath"><a class="markdownIt-Anchor" href="#xpath"></a> XPath</h2><p>XML表述的是一种树状结构，而XPath（XML路径语言）作为一种小型的查询语言能够根据XML结构树在树上寻找节点。<br />解析样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String resource = <span class="string">&quot;info.xml&quot;</span>;</span><br><span class="line">            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">            DocumentBuilder db = dbf.newDocumentBuilder();</span><br><span class="line">            Document doc = db.parse(Thread.currentThread().getContextClassLoader().getResourceAsStream(resource));</span><br><span class="line">            XPathFactory factory = XPathFactory.newInstance();</span><br><span class="line">            XPath xpath = factory.newXPath();</span><br><span class="line">            XPathExpression compile = xpath.compile(<span class="string">&quot;/members/user[id=1]&quot;</span>);</span><br><span class="line">            System.out.println(compile.evaluate(doc));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="s8sls"></a></p><h1 id="xml解析"><a class="markdownIt-Anchor" href="#xml解析"></a> XML解析</h1><p>Mybatis的配置文件与映射文件均是XML文件，因此解析并读取XML文档的内容是Mybatis展开后续工作的基础。<br />XPathParser和XNode类是两个最为关键的类，其主要关系如下图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601866214309-2172d457-bd4b-4692-a083-85a164bb8b5d.png#align=left&amp;display=inline&amp;height=188&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=375&amp;originWidth=1055&amp;size=491882&amp;status=done&amp;style=none&amp;width=527.5" alt="image.png" /><br /><a name="CUkwH"></a></p><h2 id="xpathparser"><a class="markdownIt-Anchor" href="#xpathparser"></a> XpathParser</h2><p>XpathParser内部封装了XPath类的对象，因此XpathParser具有解析XML的能力，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要解析的XML文档  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Document document;</span><br><span class="line"><span class="comment">// 是否开启验证</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> validation;</span><br><span class="line"><span class="comment">// 声明寻找DTD文件的方法，本地寻找还是网络下载</span></span><br><span class="line"><span class="keyword">private</span> EntityResolver entityResolver;</span><br><span class="line"><span class="comment">// Mybatis配置文件的Properties节点</span></span><br><span class="line"><span class="keyword">private</span> Properties variables;</span><br><span class="line"><span class="comment">// XPath工具</span></span><br><span class="line"><span class="keyword">private</span> XPath xpath;</span><br></pre></td></tr></table></figure><p>该类内部有很多重载的构造，他们均是传入参数并且初始化document属性的此外。此外，其还提供大量的eval*方法，这些方法最后都调用了evaluate方法，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">evaluate</span><span class="params">(String expression, Object root, QName returnType)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> xpath.evaluate(expression, root, returnType);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error evaluating XPath.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，这里调用的是xpath的方法，因此，整个XPathParser类的本质是对XPath的封装和调用。<br /><a name="807Iu"></a></p><h2 id="xnode"><a class="markdownIt-Anchor" href="#xnode"></a> XNode</h2><p>同理，可以把XNode看作是Node类的包装类。其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XML的一个节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node node;</span><br><span class="line"><span class="comment">// 节点名</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"><span class="comment">// 节点体</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String body;</span><br><span class="line"><span class="comment">// 节点属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Properties attributes;</span><br><span class="line"><span class="comment">// Mybatis Properties信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Properties variables;</span><br><span class="line"><span class="comment">// XML解析器XPathParser</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> XPathParser xpathParser;</span><br></pre></td></tr></table></figure><p>XNode里封装了XPathParser对象。显然，XNode封装了自身的解析器，在一个类中封装自身的解析器是一种常见的做法，如此一来他便获得了解析自身的能力，从而减少了对外部的依赖，具有内聚性。<br /><a name="8tsij"></a></p><h2 id="变量替换"><a class="markdownIt-Anchor" href="#变量替换"></a> 变量替换</h2><p>XPathParser类中还有一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">evalString</span><span class="params">(Object root, String expression)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 解析出来的字符结果</span></span><br><span class="line">  String result = (String) evaluate(expression, root, XPathConstants.STRING);</span><br><span class="line">  <span class="comment">// 对字符中的属性进行处理</span></span><br><span class="line">  result = PropertyParser.parse(result, variables);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PropertyParser.parse方法对解析出来的结果进行了进一步的处理。<br />PropertyParser是属性解析器，其类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601868758405-fa3a10f2-5e25-4ded-8476-f4920fc1e362.png#align=left&amp;display=inline&amp;height=292&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=584&amp;originWidth=868&amp;size=663796&amp;status=done&amp;style=none&amp;width=434" alt="image.png" /><br /><a name="yFB0h"></a></p><h3 id="generictokenparser"><a class="markdownIt-Anchor" href="#generictokenparser"></a> GenericTokenParser</h3><p>GenericTokenParser是通用的占位符解析器，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 占位符起始标志</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String openToken;</span><br><span class="line"><span class="comment">// 占位符结束标志</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String closeToken;</span><br><span class="line"><span class="comment">// 占位符处理器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TokenHandler handler;</span><br></pre></td></tr></table></figure><p>其内部仅有的方法时parse方法，其主要完成的是占位符的定位工作，然后替换工作交给TokenHandler来处理。<br />此外，GenericTokenParser提供的占位符定位功能应用十分广泛，不仅仅局限在XML解析中，SQL语句中的“#{}”或“${}”也离不开该类的解析。<br /><a name="sqcfP"></a></p><h3 id="tokenhandler"><a class="markdownIt-Anchor" href="#tokenhandler"></a> TokenHandler</h3><p>PropertyParser内部类VariableTokenHandler就实现了该接口，其属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入的属性变量，是HashTable的子类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Properties variables;</span><br><span class="line"><span class="comment">// 是否启用默认值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> enableDefaultValue;</span><br><span class="line"><span class="comment">// 如果启用默认值则表示键和默认值之间的分隔符</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String defaultValueSeparator;</span><br></pre></td></tr></table></figure><p>向handleToken方法中传入参数后，该方法会以输入参数为键尝试从variables中获取值并返回，这个键值寻找的过程中还支持默认值，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">handleToken</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (variables != <span class="keyword">null</span>) &#123;</span><br><span class="line">      String key = content;</span><br><span class="line">      <span class="comment">// 如果启动默认值，则设置默认值</span></span><br><span class="line">      <span class="keyword">if</span> (enableDefaultValue) &#123;</span><br><span class="line">        <span class="comment">// 找出键与默认值分隔符的位置</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> separatorIndex = content.indexOf(defaultValueSeparator);</span><br><span class="line">        String defaultValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (separatorIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 分隔符以前是键</span></span><br><span class="line">          key = content.substring(<span class="number">0</span>, separatorIndex);</span><br><span class="line">          <span class="comment">// 分隔符以后是默认值</span></span><br><span class="line">          defaultValue = content.substring(separatorIndex + defaultValueSeparator.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (defaultValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 非默认值方式寻值</span></span><br><span class="line">          <span class="keyword">return</span> variables.getProperty(key, defaultValue);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (variables.containsKey(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> variables.getProperty(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果variables为空，原样返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;$&#123;&quot;</span> + content + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到parse方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parse</span><span class="params">(String string, Properties variables)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 负责替换字符串的类</span></span><br><span class="line">  VariableTokenHandler handler = <span class="keyword">new</span> VariableTokenHandler(variables);</span><br><span class="line">  <span class="comment">// 创建通用占位符的类</span></span><br><span class="line">  GenericTokenParser parser = <span class="keyword">new</span> GenericTokenParser(<span class="string">&quot;$&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>, handler);</span><br><span class="line">  <span class="comment">// 开展解析，即替换占位符中的值</span></span><br><span class="line">  <span class="keyword">return</span> parser.parse(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样只要XML中使用“${}”包围一个变量名，该变量名就会被解析替换成properties节点中对应的值。<br />s</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
          <category> 基础功能包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>logging包</title>
      <link href="/posts/mybatis-logging/"/>
      <url>/posts/mybatis-logging/</url>
      
        <content type="html"><![CDATA[<h1 id="logging包"><a class="markdownIt-Anchor" href="#logging包"></a> logging包</h1><p>logging包负责完成Mybatis操作中的日志记录工作。<br /><a name="CCKd0"></a></p><h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1><p><a name="FjPog"></a></p><h2 id="适配器模式"><a class="markdownIt-Anchor" href="#适配器模式"></a> 适配器模式</h2><p>适配器模式是一种结构性模式，基于该模式设计的类能够在两个或者多个不兼容的类之间起到沟通桥梁的作用。<br />适配器模式能够使得原本不兼容的类可以一起工作。通常情况下，如果目标类是可以修改的，则不需要使用适配器模式进行干预了，直接修改目标类即可。但如果目标类是不可修改的（例如目标类由外部提供，或者目标类被众多其他类依赖必须保持不变），那么就可以使用适配器模式。<br /><a name="C4OCm"></a></p><h2 id="日志框架与日志级别"><a class="markdownIt-Anchor" href="#日志框架与日志级别"></a> 日志框架与日志级别</h2><p>日志框架是一种在目标对象发生变化时将相关信息记录进日志文件框架。这样，当目标对象出现问题或需要检查目标对象变动历史时，日志框架记录的日志文件便可以提供翔实的资料。<br />常见日志等级划分如下：</p><ul><li>Fatal：致命等级的日志，指发生了严重的会导致应用程序退出的事件。</li><li>Error：错误等级的日志，指发生了错误，但是不影响系统运行。</li><li>Warn：警告等级的日志，指发生了异常没可能是潜在的错误。</li><li>Info：信息登记的日志，指一些在颗粒度级别上需要强调的应用程序运行信息。</li><li>Debug：调试等级日志，指一些颗粒对于程序调试有帮助的信息。</li><li>Trace：跟踪等级的日志，指一些包含程序运行调试过程的信息。</li></ul><p>很多日志框架都可以定义日志的级别，也可以根据日志等级进行输出，防止大量的日志信息混杂在一起。<br /><a name="wOB2d"></a></p><h2 id="基于反射的动态代理"><a class="markdownIt-Anchor" href="#基于反射的动态代理"></a> 基于反射的动态代理</h2><p>之前回顾过静态代理，这里回顾一下基于反射的动态代理。<br />动态代理灵活性很多，它在代码运行时动态的为一个对象增加代理，并且能为代理对象动态的增加方法。<br />具体实现方法详见后续的源码分析。<br /><a name="FJEpx"></a></p><h1 id="log接口"><a class="markdownIt-Anchor" href="#log接口"></a> Log接口</h1><p>logger包中最核心的就是Log接口，其有11个实现类分布在logging包的不同子包中。<br />Log接口中定义了如下几个抽象方法：<br /><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601807799081-eea08218-79c5-4357-8c0b-f2df6d38409d.png#align=left&amp;display=inline&amp;height=114&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=228&amp;originWidth=370&amp;size=38052&amp;status=done&amp;style=none&amp;width=185" alt="image.png" /></strong><br />其含义分别是：</p><ul><li>error：打印Error级别的日志。</li><li>warn：打印Warn级别日志。</li><li>debug：打印Debug级别日志。</li><li>trace：打印Trace级别的日志。</li><li>isDebugEnable：判断打印Debug级别日志的功能是否开启。</li><li>isTraceEnable：判断打印Trace级别日志的功能是否开启。<br /><a name="nz0kq"></a></li></ul><h1 id="log接口的实现类"><a class="markdownIt-Anchor" href="#log接口的实现类"></a> Log接口的实现类</h1><p>Log接口的实现类一共有11个，这里就不进行逐一详细的分析。<br />NoLoggingImpl：望文生义，其内部没有什么具体的实现，只是一种Log接口的实现罢了。<br />StdOutImpl：其方法也没什么特别，只是对error级别的日志进行err级别的打印罢了。<br />Slf4jLocationAwareLoggerImpl和Sl4jLoggerImpl类只是Slf4jImpl的装饰器。<br />Log4jAbstractLoggerImpl和Log4j2LoggerImpl类是Log4j2Impl的装饰器。<br />这样 就剩下了五个实现类。接下来以JakartaCommonsLoggingImpl类的为例来分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JakartaCommonsLoggingImpl</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">ibatis</span>.<span class="title">logging</span>.<span class="title">Log</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Log log;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JakartaCommonsLoggingImpl</span><span class="params">(String clazz)</span> </span>&#123;</span><br><span class="line">    log = LogFactory.getLog(clazz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isDebugEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isTraceEnabled();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略其他源码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JakartaCommonsLoggingImpl是一个典型的对象适配器，其内部持有一个org.apache.ibatis.logging.Log对象，然后所有方法都将操作委托给了该对象。<br /><a name="3ni1T"></a></p><h1 id="logfactory"><a class="markdownIt-Anchor" href="#logfactory"></a> LogFactory</h1><p>该类就是一个制造实现类的工厂，最终，该工厂会给出一个可用的Log实现类，有它来完成日志打印的工作。<br />Log接口的实现类都是对象适配器，最终的实际工作都要委托给被适配的目标对象来完成。LogFactory的主要工作就是尝试生成各个目标对象。该功能是通过如下静态代码块实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  tryImplementation(LogFactory::useSlf4jLogging);</span><br><span class="line">  tryImplementation(LogFactory::useCommonsLogging);</span><br><span class="line">  tryImplementation(LogFactory::useLog4J2Logging);</span><br><span class="line">  tryImplementation(LogFactory::useLog4JLogging);</span><br><span class="line">  tryImplementation(LogFactory::useJdkLogging);</span><br><span class="line">  tryImplementation(LogFactory::useNoLogging);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tryImplementation</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (logConstructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      runnable.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="comment">// ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用runnable.run方法不会触发不会触发多线程，因此这里的多个tryImplementation是依次执行的，而这里的useNoLogging就是他的保底实现类，即不输出任何日志。<br />跟随断点来到了setImplementation方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setImplementation</span><span class="params">(Class&lt;? extends Log&gt; implClass)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 当前日志实现类的构造方法</span></span><br><span class="line">    Constructor&lt;? extends Log&gt; candidate = implClass.getConstructor(String.class);</span><br><span class="line">    <span class="comment">// 尝试生成日志实现类的实例</span></span><br><span class="line">    Log log = candidate.newInstance(LogFactory.class.getName());</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;Logging initialized using &#x27;&quot;</span> + implClass + <span class="string">&quot;&#x27; adapter.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果运行到这里，说明没有异常发生，则实例化日志实现类成功</span></span><br><span class="line">    logConstructor = candidate;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> LogException(<span class="string">&quot;Error setting Log implementation.  Cause: &quot;</span> + t, t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当外部调用getLog方法时，便可以由logConstructor创建一个Log类的实例。.<br /><a name="p9hgu"></a></p><h1 id="jdbc日志打印"><a class="markdownIt-Anchor" href="#jdbc日志打印"></a> JDBC日志打印</h1><p>jdbc子包基于代理模式，让Mybatis能够将JDBC的操作日志打印出来。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601811138309-d5a08dd6-effe-4ce2-938b-1784c8a9bcbe.png#align=left&amp;display=inline&amp;height=169&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=337&amp;originWidth=1195&amp;size=600702&amp;status=done&amp;style=none&amp;width=597.5" alt="image.png" /><br />BaseJdbcLogger各个子类使用动态代理（继承InvactionHandler接口）来实现日志的打印。<br />以下以ConnectionLogger为例进行的invoke方法进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获得方法来源，如果方法继承来自Object类，则直接交给目标对象执行</span></span><br><span class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, params);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;prepareStatement&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDebugEnabled()) &#123;</span><br><span class="line">        <span class="comment">// 输出方法中的参数信息</span></span><br><span class="line">        debug(<span class="string">&quot; Preparing: &quot;</span> + removeBreakingWhitespace((String) params[<span class="number">0</span>]), <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 交由目标对象执行</span></span><br><span class="line">      PreparedStatement stmt = (PreparedStatement) method.invoke(connection, params);</span><br><span class="line">      <span class="comment">// 返回一个PreparedStatementLogger对象，代理PreparedStatement完成日志打印</span></span><br><span class="line">      stmt = PreparedStatementLogger.newInstance(stmt, statementLog, queryStack);</span><br><span class="line">      <span class="keyword">return</span> stmt;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;prepareCall&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDebugEnabled()) &#123;</span><br><span class="line">        debug(<span class="string">&quot; Preparing: &quot;</span> + removeBreakingWhitespace((String) params[<span class="number">0</span>]), <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 交由目标对象执行</span></span><br><span class="line">      PreparedStatement stmt = (PreparedStatement) method.invoke(connection, params);</span><br><span class="line">      <span class="comment">// 返回一个PreparedStatementLogger对象，代理PreparedStatement完成日志打印</span></span><br><span class="line">      stmt = PreparedStatementLogger.newInstance(stmt, statementLog, queryStack);</span><br><span class="line">      <span class="keyword">return</span> stmt;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;createStatement&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">      <span class="comment">// 交由目标对象执行</span></span><br><span class="line">      Statement stmt = (Statement) method.invoke(connection, params);</span><br><span class="line">      <span class="comment">// 返回一个StatementLogger对象，代理Statement完成日志打印</span></span><br><span class="line">      stmt = StatementLogger.newInstance(stmt, statementLog, queryStack);</span><br><span class="line">      <span class="keyword">return</span> stmt;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 其他方法</span></span><br><span class="line">      <span class="keyword">return</span> method.invoke(connection, params);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
          <category> 基础功能包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>I/O包</title>
      <link href="/posts/mybatis-i_o/"/>
      <url>/posts/mybatis-i_o/</url>
      
        <content type="html"><![CDATA[<h1 id="io包"><a class="markdownIt-Anchor" href="#io包"></a> I/O包</h1><p>顾名思义，I/O包即输入输出包，负责完成对Mybatis的输入输出相关的操作。<br />在Mybatis中，与磁盘文件的交互主要是对xml配置文件的读写。因此，I/O包中主要提供对磁盘文件读操作的支持。此外，I/O包还提供对内存中类文件（class文件）的操作。<br /><a name="Zlflf"></a></p><h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1><p>要想细致分析I/O包，要对以下知识点留有概念。<br /><a name="YdFbS"></a></p><h2 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h2><p>使用单例模式的类提供的一个方法得到该类的对象就可以保证该类的对象是唯一的。<br /><a name="aBTVC"></a></p><h2 id="代理模式"><a class="markdownIt-Anchor" href="#代理模式"></a> 代理模式</h2><p>代理模式是指建立某一个对象的代理对象，并且由代理对象控制对原对象的引用。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601706025779-12f34328-cbee-460b-af68-af3e764f17a2.png#align=left&amp;display=inline&amp;height=352&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=352&amp;originWidth=839&amp;size=400691&amp;status=done&amp;style=none&amp;width=839" alt="image.png" /><br />代理类能够实现很多功能：</p><ul><li>隔离功能：能够建立一个目标对象的代理对象。从而防止外部对目标对象的访问。可以在代理对象中增加身份验证等功能，从而实现对目标对象的安全防护。</li><li>扩展功能：对一个目标对象建立代理对象后，可以在代理对象中增加更多的扩展功能。</li><li>直接替换：对一个目标对象建立代理对象后，可以直接使用代理对象完全替换目标对象，由代理对象实现全部的功能。<br /><a name="Y5NxH"></a></li></ul><h3 id="静态代理"><a class="markdownIt-Anchor" href="#静态代理"></a> 静态代理</h3><p>所谓静态，是指代理对象和被代理对象在程序中是确定的，不会在程序运行过程中发生变化。<br /><a name="GzGiG"></a></p><h3 id="动态代理"><a class="markdownIt-Anchor" href="#动态代理"></a> 动态代理</h3><p>静态代理的特点就是其局限性，这样的代理方法十分不灵活，动态代理就可以完美的解决这一问题。<br /><a name="MRCtQ"></a></p><h2 id="vfs"><a class="markdownIt-Anchor" href="#vfs"></a> VFS</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601706043407-f2b5b78a-e0fe-4982-a0ac-097c2edfa1b9.png#align=left&amp;display=inline&amp;height=546&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=546&amp;originWidth=938&amp;size=769135&amp;status=done&amp;style=none&amp;width=938" alt="image.png" /><br />磁盘文件系统可以分为很多种，如：FAT、VFAT、NFS、NTFS等。不同的文件系统操作不同，VFS作为一个虚拟的文件系统，将各个磁盘文件系统的差异屏蔽起来，提供了统一的操作。在操作磁盘文件时，软件程序只需要和VFS沟通即可。<br /><a name="0aK5T"></a></p><h1 id="vfs的实现类"><a class="markdownIt-Anchor" href="#vfs的实现类"></a> VFS的实现类</h1><p>Mybatis的io包中的VFS的作用是从应用服务器中寻找和读取资源文件。IO包中VFS相关类主要有三个：VFS、DefaultVFS、JBoss6VFS。<br />DefaultVFS和JBoss6VFS是VFS的两个实现类，在确定了具体实现类之后，外部只需调用VFS中的方法就可以完成外部文件读取的操作。<br /><a name="pStL4"></a></p><h2 id="vfs分析"><a class="markdownIt-Anchor" href="#vfs分析"></a> VFS分析</h2><p>VFS的内部核心属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储内置的VFS实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] IMPLEMENTATIONS = &#123; JBoss6VFS.class, DefaultVFS.class &#125;;</span><br><span class="line"><span class="comment">// 存储用户自定的VFS实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Class&lt;? extends VFS&gt;&gt; USER_IMPLEMENTATIONS = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>观察其内部接口可知，VFS有一个VFSHolder内部类，其使用了单例模式的方法定义了VFS的实现类。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最终生成的VFS对象    </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> VFS INSTANCE = createVFS();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> VFS <span class="title">createVFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// VFS实现类列表</span></span><br><span class="line">      List&lt;Class&lt;? extends VFS&gt;&gt; impls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="comment">// 先添加用户自定义的实现类，因此用户自定义实现类的优先级最高</span></span><br><span class="line">      impls.addAll(USER_IMPLEMENTATIONS);</span><br><span class="line">      impls.addAll(Arrays.asList((Class&lt;? extends VFS&gt;[]) IMPLEMENTATIONS));</span><br><span class="line"></span><br><span class="line">      VFS vfs = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 依次生成实现类实例，找出第一个可用实例并返回</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; vfs == <span class="keyword">null</span> || !vfs.isValid(); i++) &#123;</span><br><span class="line">        Class&lt;? extends VFS&gt; impl = impls.get(i);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 生成一个实现类对象</span></span><br><span class="line">          vfs = impl.newInstance();</span><br><span class="line">          <span class="comment">// 判断对象是否可用</span></span><br><span class="line">          <span class="keyword">if</span> (vfs == <span class="keyword">null</span> || !vfs.isValid()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">              log.debug(<span class="string">&quot;VFS implementation &quot;</span> + impl.getName() +</span><br><span class="line">                  <span class="string">&quot; is not valid in this environment.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">          log.error(<span class="string">&quot;Failed to instantiate &quot;</span> + impl, e);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Using VFS adapter &quot;</span> + vfs.getClass().getName());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> vfs;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><a name="l9axx"></a></p><h2 id="defaultvfs"><a class="markdownIt-Anchor" href="#defaultvfs"></a> DefaultVFS</h2><p>该类是VFS的默认实现类之一，其isVaild返回的值恒为true，因此，VFS最终生成的对象至少会为DefaultVFS实例。除此之外，其内部还有如下几个方法：</p><ul><li>list：列出指定url下符合条件的资源名称。</li><li>listResources：列出给定Jar包中符合条件的资源名称。</li><li>findJarForResource：找出指定路径上的jar包中符合条件的资源名称。</li><li>getPackagePath：将jar包名称转换为路径。</li><li>isJar：判断指定路径上是否为jar包。<br /><a name="jXfL0"></a></li></ul><h2 id="jboss6vfs"><a class="markdownIt-Anchor" href="#jboss6vfs"></a> JBoss6VFS</h2><p>JBoss6VFS是借鉴JBoss6设计的一套VFS实现类。其主要存在两个内部类：</p><ul><li>Virsual6VFS：仿照JBoss中VirsualFile设计的一个功能子集。</li><li>VFS：仿照JBoss中VFS类设计的一个功能子集。</li></ul><p>经过源码分析发现，这两个类的方法都没实现具体的操作，而是通过invoke调用JBoss的相关方法。因此可以认为其内部类都是代理类，只负责完成将相关操作传给被代理类工作。至于确定被代理类是否存在的工作，在initialize方法中完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  initialize();</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (valid == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 假设可用</span></span><br><span class="line">    valid = Boolean.TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L校验所需的类是否存在，不存在变为不可用</span></span><br><span class="line">    VFS.VFS = checkNotNull(getClass(<span class="string">&quot;org.jboss.vfs.VFS&quot;</span>));</span><br><span class="line">    VirtualFile.VirtualFile = checkNotNull(getClass(<span class="string">&quot;org.jboss.vfs.VirtualFile&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检验所需的方法是否存在，不存在便不可用</span></span><br><span class="line">    VFS.getChild = checkNotNull(getMethod(VFS.VFS, <span class="string">&quot;getChild&quot;</span>, URL.class));</span><br><span class="line">    VirtualFile.getChildrenRecursively = checkNotNull(getMethod(VirtualFile.VirtualFile,</span><br><span class="line">        <span class="string">&quot;getChildrenRecursively&quot;</span>));</span><br><span class="line">    VirtualFile.getPathNameRelativeTo = checkNotNull(getMethod(VirtualFile.VirtualFile,</span><br><span class="line">        <span class="string">&quot;getPathNameRelativeTo&quot;</span>, VirtualFile.VirtualFile));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断上述方法的返回值是否达到预期，否则不可用</span></span><br><span class="line">    checkReturnType(VFS.getChild, VirtualFile.VirtualFile);</span><br><span class="line">    checkReturnType(VirtualFile.getChildrenRecursively, List.class);</span><br><span class="line">    checkReturnType(VirtualFile.getPathNameRelativeTo, String.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="xE7I5"></a></p><h1 id="类文件的加载"><a class="markdownIt-Anchor" href="#类文件的加载"></a> 类文件的加载</h1><p>除了读取普通文件外，有时还需要读取类文件，并加载成一个类。<br />把类文件加载成类需要类加载器的支持，ClassLoaderWrapper类中封装了五种加载器，而Resources类又对ClassLoaderWrapper进行了简单的封装，下列将会详细分析ClassLoaderWrapper。<br />五种加载器在getClassLoaders方法中进行了定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader[] getClassLoaders(ClassLoader classLoader) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ClassLoader[]&#123;</span><br><span class="line">      <span class="comment">// 作为参数传入的类加载器，可能为null</span></span><br><span class="line">      classLoader,</span><br><span class="line">      <span class="comment">// 系统默认的类加载器，如果没设置可以为null</span></span><br><span class="line">      defaultClassLoader,</span><br><span class="line">      <span class="comment">// 当前线程的线程上下文中的类加载器</span></span><br><span class="line">      Thread.currentThread().getContextClassLoader(),</span><br><span class="line">      <span class="comment">// 当前对象的类加载器</span></span><br><span class="line">      getClass().getClassLoader(),</span><br><span class="line">      <span class="comment">// 系统类加载器，在ClassLoaderWrapper构造函数中设置</span></span><br><span class="line">      systemClassLoader&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述五种类加载器优先级由高到低进行排序，在方法classForName根据类名找出指定类的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> Class&lt;?&gt; classForName(String name, ClassLoader[] classLoader) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"><span class="comment">// 对上述五种加载器进行尝试</span></span><br><span class="line">   <span class="keyword">for</span> (ClassLoader cl : classLoader) &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">null</span> != cl) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 使用当前类加载器尝试是否能够成功</span></span><br><span class="line">         Class&lt;?&gt; c = Class.forName(name, <span class="keyword">true</span>, cl);</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">null</span> != c) &#123;</span><br><span class="line">           <span class="comment">// 只要能找到目标则返回结果</span></span><br><span class="line">           <span class="keyword">return</span> c;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">         <span class="comment">// 忽略这个异常，在下面所有加载器未找到时统一抛出</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;Cannot find class: &quot;</span> + name);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><a name="05Nhw"></a></p><h1 id="resolverutil类"><a class="markdownIt-Anchor" href="#resolverutil类"></a> ResolverUtil类</h1><p>该类是一个工具类，其主要完成的是对类的筛选，这些条件可以是：</p><ul><li>是否是某个接口或类的子类</li><li>是否具有某个注解</li></ul><p>ResolverUtil设置了一个内部接口Test，该接口是一个筛选器，内部类中有一个抽象方法matches来判断指定类是否满足筛选条件。该工具类内部类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601708320241-dde058a0-da42-46f5-a990-07b18cc30b16.png#align=left&amp;display=inline&amp;height=401&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=401&amp;originWidth=1094&amp;size=624104&amp;status=done&amp;style=none&amp;width=1094" alt="image.png" /><br />如上图所示，其内部的两个实现类都重写了matches方法：</p><ul><li>IsA类中的matches方法可以判断目标类是否实现了某个接口或者继承了某个类。</li><li>AnnotatedWith的matches方法可以判断目标类是否具有某个注解。</li></ul><p>上述校验的类会放入到工具类的matches属性里。这样一来，读取某个路径上的类文件是，可以借助该工具类进行筛选，其内部的find方法支持筛选出指定路径下符合条件的类文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResolverUtil&lt;T&gt; <span class="title">find</span><span class="params">(Test test, String packageName)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获得起始包路径</span></span><br><span class="line">  String path = getPackagePath(packageName);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 找出包内的各个文件</span></span><br><span class="line">    List&lt;String&gt; children = VFS.getInstance().list(path);</span><br><span class="line">    <span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">      <span class="comment">// 判断后缀</span></span><br><span class="line">      <span class="keyword">if</span> (child.endsWith(<span class="string">&quot;.class&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 判断是否符合条件（Test可以是IsA或者AnnotatedWith）</span></span><br><span class="line">        addIfMatching(test, child);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;Could not read package: &quot;</span> + packageName, ioe);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addIfMatching方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addIfMatching</span><span class="params">(Test test, String fqn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 转化为外部名称</span></span><br><span class="line">    String externalName = fqn.substring(<span class="number">0</span>, fqn.indexOf(<span class="string">&#x27;.&#x27;</span>)).replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="comment">// 获取类加载器</span></span><br><span class="line">    ClassLoader loader = getClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;Checking to see if class &quot;</span> + externalName + <span class="string">&quot; matches criteria [&quot;</span> + test + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// 加载类文件</span></span><br><span class="line">    Class&lt;?&gt; type = loader.loadClass(externalName);</span><br><span class="line">    <span class="keyword">if</span> (test.matches(type)) &#123;</span><br><span class="line">      <span class="comment">// 添加到matches属性中</span></span><br><span class="line">      matches.add((Class&lt;T&gt;) type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;Could not examine class &#x27;&quot;</span> + fqn + <span class="string">&quot;&#x27;&quot;</span> + <span class="string">&quot; due to a &quot;</span> +</span><br><span class="line">        t.getClass().getName() + <span class="string">&quot; with message: &quot;</span> + t.getMessage());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
          <category> 基础功能包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>type包</title>
      <link href="/posts/mybatis-type/"/>
      <url>/posts/mybatis-type/</url>
      
        <content type="html"><![CDATA[<h1 id="type包"><a class="markdownIt-Anchor" href="#type包"></a> type包</h1><p>type包里有55个类，为了不头大，这里先进行简单的分类，方便进一步的分析。</p><ul><li>类型处理器<ul><li>TypeHandler：类型处理器接口。</li><li>BaseTypeHandler：类型处理器的基础实现。</li><li>TypeReference：类型参考器。</li><li>*TypeHandler：43个类型处理器。</li></ul></li><li>类型注册表：<ul><li>SimpleTypeRegistry：基本类型注册表，内部使用Set维护了所有Java基本数据类型的集合。</li><li>TypeAliasRegistry：类型别名注册表，内部使用HashMap维护了所有的类型的别名和类型关系映射。</li><li>TypeHandlerRegistry：类型处理器注册表，内部维护了所有类型与对应类型处理器的映射关系。</li></ul></li><li>注解类：<ul><li>Alias：使用该注解可以给类设置别名，设置后，别名和类型的映射关系便存入TypeAliasTypes中。</li><li>MappedJdbcTypes：想要使用自己的处理器来处理某些JDBC类型时，只需创建BaseTypeHandler的子类然后加上该注解声明其要处理的JDBC类型即可。</li><li>MappedTypes：想要使用自己的处理器处理某些Java类型时，只需创建BaseTypeHandler的子类然后加上该注解，然后声明要处理的Java类型即可。</li></ul></li><li>异常类：<ul><li>TypeException：表示类型处理相关的异常。</li></ul></li><li>枚举类：<ul><li>JdbcType：在Enum中定义了所有的JDBC类型。<br /><a name="DdBtH"></a></li></ul></li></ul><h1 id="模板模式"><a class="markdownIt-Anchor" href="#模板模式"></a> 模板模式</h1><p>分析处理器前要先了解一下模板模式。<br />在模板模式中，需要使用一个抽象类定义一套整体的步骤（即模板），而抽象类的子类则完成每个步骤的具体实现。<br /><a name="G2CfO"></a></p><h1 id="类型处理器"><a class="markdownIt-Anchor" href="#类型处理器"></a> 类型处理器</h1><p><a name="J9SFk"></a></p><h2 id="basetypehandler"><a class="markdownIt-Anchor" href="#basetypehandler"></a> BaseTypeHandler</h2><p>作为一个ORM框架，对象关系映射中的数据类型映射也就十分重要，不同字段所需的读写方法各不相同，因此需要对不同类型的字段采取相应的处理方法。<br />在type包中，将每种类型对应的处理方法封装在了对应的类型处理器中。TypeHandler和BaseTypeHandler分别是类型处理器的接口和基类，其类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601634542762-145aaf65-3411-4031-a224-12051e27a51c.png#align=left&amp;display=inline&amp;height=500&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=500&amp;originWidth=1049&amp;size=614400&amp;status=done&amp;style=none&amp;width=1049" alt="image.png" /><br />这里的BaseTypeHandler就引用了模板模式的思想，以getResult方法为例，该方法完成了异常处理等统一的工作，而与具体类型相关的getNullableResult则通过抽象方法交给具体类型处理器实现。该方法的四种定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向 PreparedStatement对象中的指定变量位置写入一个不为null的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, T parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">// 从  ResultSet中按照字段名读出一个可能为null的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">// 从  ResultSet中按照字段编号读出一个可能为null的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">getNullableResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">// 从  CallableStatement中按照字段编号读出一个可能为null的数据  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">getNullableResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><p>因为抽象方法跟具体类型相关，因此存在泛型参数T。在每种类型处理器的实现中，都给出了泛型参数的值。<br /><a name="Dg6PO"></a></p><h2 id="typereference"><a class="markdownIt-Anchor" href="#typereference"></a> TypeReference</h2><p>所有类型处理器都是TypeHandler接口的实现，因此都可以通过TypeHandler来调用。但是TypeHandler的实现如此多，就需要一种参照书来查看当前的调用使用的是哪种目标类型。<br />Mybatis定义了一个TypeReference类，它能够判断出一个TypeHandler用来处理的目标类型。其判断方法很简单，就是取出TypeHandler实现类中的泛型参数T的类型而已，这个值的类型就是要处理的目标类型。其子类BaseTypeHandler通过传入泛型的值，从而递交给TypeReference来获取目标类型。<br />该功能由getSuperclassTypeParameter实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">Type <span class="title">getSuperclassTypeParameter</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 获取clazz类带有泛型的直接父类</span></span><br><span class="line">   Type genericSuperclass = clazz.getGenericSuperclass();</span><br><span class="line">   <span class="keyword">if</span> (genericSuperclass <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">     <span class="comment">// try to climb up the hierarchy until meet something useful</span></span><br><span class="line">     <span class="keyword">if</span> (TypeReference.class != genericSuperclass) &#123;</span><br><span class="line">       <span class="comment">// 说明没有解析到足够上层，将clazz类的父类作为输入参数递归调用</span></span><br><span class="line">       <span class="keyword">return</span> getSuperclassTypeParameter(clazz.getSuperclass());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">&quot;&#x27;&quot;</span> + getClass() + <span class="string">&quot;&#x27; extends TypeReference but misses the type parameter. &quot;</span></span><br><span class="line">       + <span class="string">&quot;Remove the extension or add a type parameter to it.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 说明genericSuperclass是泛型，获取泛型的第一个参数</span></span><br><span class="line">   Type rawType = ((ParameterizedType) genericSuperclass).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">   <span class="comment">// TODO remove this when Reflector is fixed to return Types</span></span><br><span class="line">   <span class="comment">// 判断是否是参数化类型</span></span><br><span class="line">   <span class="keyword">if</span> (rawType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">     <span class="comment">// 获取参数化类型的实际类型</span></span><br><span class="line">     rawType = ((ParameterizedType) rawType).getRawType();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> rawType;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>该方法通过TypeReference的构造器中调用。<br /><a name="oNnJJ"></a></p><h1 id="类型注册表"><a class="markdownIt-Anchor" href="#类型注册表"></a> 类型注册表</h1><p>推断出目标类型以后，Mybatis还需要根据目标类型来找到相应的类型处理器，这个过程就需要各种类型注册表的帮助。<br />SimpleTypeRegistry是一个非常简单的注册表，其内部通过SIMPLE_TYPE_SET定义了很多基本类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Class&lt;?&gt;&gt; SIMPLE_TYPE_SET = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  SIMPLE_TYPE_SET.add(String.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Byte.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Short.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Character.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Integer.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Long.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Float.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Double.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Boolean.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Date.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(Class.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(BigInteger.class);</span><br><span class="line">  SIMPLE_TYPE_SET.add(BigDecimal.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TypeAliasRegistry是一个别名注册表，其内部使用typeAliases属性维护了类型和别名的对应关系。<br />TypeHandlerRegistry是这三个注册表中最核心也是最关键的一个，数据类型和相关处理器都是它来维护的。接下来要详细的分析一下这个类。<br /><a name="LjNW2"></a></p><h2 id="typehandlerregistry"><a class="markdownIt-Anchor" href="#typehandlerregistry"></a> TypeHandlerRegistry</h2><p>在分析之前，要明确Java类型参数和JDBC中的类型参数是一对多的关系，比如一个String会对应数据库的varchar、char。<br />其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDBC类型与对应类型处理器的映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;  jdbcTypeHandlerMap = <span class="keyword">new</span> EnumMap&lt;&gt;(JdbcType.class);</span><br><span class="line"><span class="comment">// Java类型与Map&lt;JdbcType,TypeHandler&lt;?&gt;&gt;的映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; typeHandlerMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 未知类型的处理器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TypeHandler&lt;Object&gt; unknownTypeHandler = <span class="keyword">new</span> UnknownTypeHandler(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 键与typeHandler.getClass()，值为typeHandler。里面存储了所有的类型处理器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt; allTypeHandlersMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 空的Map&lt;jdbcType,TypeHandler&lt;?&gt;&gt;，表示该Java类型没有对应的Map&lt;jdbcType,TypeHandler&lt;?&gt;&gt;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; NULL_TYPE_HANDLER_MAP = Collections.emptyMap();</span><br><span class="line"><span class="comment">// 默认的枚举类型处理器</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;? extends TypeHandler&gt; defaultEnumTypeHandler = EnumTypeHandler.class;</span><br></pre></td></tr></table></figure><p>其实际的获取处理器的方式就是两次映射的过程：</p><ul><li>根据传入的Java类型，调用getJdbcHandlerMap字方法寻找对应的jdbcTypeHandler后返回。</li><li>基于jdbcTypeHandlerMap，根据JDBC类型找到对应的TypeHandler。</li></ul><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">TypeHandler&lt;T&gt; <span class="title">getTypeHandler</span><span class="params">(Type type, JdbcType jdbcType)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否是单一的Java类型</span></span><br><span class="line">  <span class="keyword">if</span> (ParamMap.class.equals(type)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据Java类型找到对应的jdbcHandlerMap</span></span><br><span class="line">  Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; jdbcHandlerMap = getJdbcHandlerMap(type);</span><br><span class="line">  TypeHandler&lt;?&gt; handler = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (jdbcHandlerMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据JDBC类型找寻对应的处理器</span></span><br><span class="line">    handler = jdbcHandlerMap.get(jdbcType);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      handler = jdbcHandlerMap.get(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// #591</span></span><br><span class="line">      handler = pickSoleHandler(jdbcHandlerMap);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// type drives generics here</span></span><br><span class="line">  <span class="keyword">return</span> (TypeHandler&lt;T&gt;) handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
          <category> 基础功能包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>annocations包与lang包</title>
      <link href="/posts/mybatis-annocations&amp;lang/"/>
      <url>/posts/mybatis-annocations&amp;lang/</url>
      
        <content type="html"><![CDATA[<h1 id="annocations包与lang包"><a class="markdownIt-Anchor" href="#annocations包与lang包"></a> annocations包与lang包</h1><p>这两个包中存放的都是自定义的注解类，这里只分析其共性，就不一一进行分析了。<br /><a name="pwrG6"></a></p><h1 id="java的注解详解"><a class="markdownIt-Anchor" href="#java的注解详解"></a> Java的注解详解</h1><p>以随机一个注解为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.PARAMETER)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Param &#123;</span><br><span class="line">  <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，这个自定义的注解类还会包含很多其他的注解，这些注解其他注解的注解称为元注解。<br />元注解共有五个：@Target、@Retention、@Documented、@Interited、@Repeatable。其分别含义：<br /><a name="FlT6B"></a></p><h2 id="target"><a class="markdownIt-Anchor" href="#target"></a> @Target</h2><p>该注解是用来声明注解可以用在什么地方的，他的值需要从枚举类ElementType中选取，ElementType的枚举值如下：</p><ul><li>TYPE：类、接口、注释、枚举。</li><li>FIELD：字段。</li><li>METHOD：方法。</li><li>PARMETER：参数。</li><li>CONSTRUCTOR：构造方法。</li><li>LOCAL_VARIABLE：本地变量。</li><li>ANNOTATION_TYPE：注解。</li><li>PACKAGE：包。</li><li>TYPE_PARAMETER：参数类型。</li><li>TYPE_USER：类型使用。</li></ul><p>注：元属性也有Target、枚举值可以选择多个。<br /><a name="8fLTd"></a></p><h1 id="retention"><a class="markdownIt-Anchor" href="#retention"></a> @Retention</h1><p>该注解是用来声明注解的生命周期的，即表明注解会被保存到哪一个阶段。他的值需要从枚举类RetentionType中选取，其枚举值如下：</p><ul><li>SOURCE：保留到源码阶段。这一类注解一把留给编译器使用，在编译时会被擦除。</li><li>CLASS：保留到类文件阶段。这是默认的生命周期，JVM运行时不包含这类信息。</li><li>RUNTIME：保留到JVM运行阶段。<br /><a name="uAKak"></a></li></ul><h2 id="document"><a class="markdownIt-Anchor" href="#document"></a> @Document</h2><p>不需要设置具体的值，被注解的注解会在javadoc中生成。<br /><a name="kl0zk"></a></p><h2 id="inherited"><a class="markdownIt-Anchor" href="#inherited"></a> @Inherited</h2><p>不需要设置具体的值，被该注解的注解的注解可以被继承（不能从接口继承）。<br /><a name="VLWw3"></a></p><h2 id="repeatable"><a class="markdownIt-Anchor" href="#repeatable"></a> @Repeatable</h2><p>表示该注解可以重复在一个地方使用多次。<br /><a name="80JyB"></a></p><h1 id="param注解分析"><a class="markdownIt-Anchor" href="#param注解分析"></a> Param注解分析</h1><p>这里以Param注解为例来分析自定义注解类。<br />在调用dao层方法时加上@Param注解，便可以在Mapper中引用id所指代的变量。接下来将分析该功能是如何实现的。<br />随着调试来到ParamNameResolver的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ParamNameResolver</span><span class="params">(Configuration config, Method method)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取参数参数类型列表</span></span><br><span class="line">  <span class="keyword">final</span> Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line">  <span class="comment">// 准备用二维数组存取所有参数的注解</span></span><br><span class="line">  <span class="keyword">final</span> Annotation[][] paramAnnotations = method.getParameterAnnotations();</span><br><span class="line">  <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">int</span> paramCount = paramAnnotations.length;</span><br><span class="line">  <span class="comment">// 循环处理各个参数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> paramIndex = <span class="number">0</span>; paramIndex &lt; paramCount; paramIndex++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isSpecialParameter(paramTypes[paramIndex])) &#123;</span><br><span class="line">      <span class="comment">// 跳过特别的参数</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数名字</span></span><br><span class="line">    String name = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : paramAnnotations[paramIndex]) &#123;</span><br><span class="line">      <span class="comment">// 找到param注解</span></span><br><span class="line">      <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Param) &#123;</span><br><span class="line">        hasParamAnnotation = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 以param的值作为参数名</span></span><br><span class="line">        name = ((Param) annotation).value();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 否则保留参数</span></span><br><span class="line">      <span class="keyword">if</span> (config.isUseActualParamName()) &#123;</span><br><span class="line">        name = getActualParamName(method, paramIndex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// use the parameter index as the name (&quot;0&quot;, &quot;1&quot;, ...)</span></span><br><span class="line">        <span class="comment">// gcode issue #71</span></span><br><span class="line">        name = String.valueOf(map.size());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存入位置序号+名字</span></span><br><span class="line">    map.put(paramIndex, name);</span><br><span class="line">  &#125;</span><br><span class="line">  names = Collections.unmodifiableSortedMap(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
          <category> 基础功能包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>reflection包</title>
      <link href="/posts/mybatis-annocations&amp;lang/"/>
      <url>/posts/mybatis-annocations&amp;lang/</url>
      
        <content type="html"><![CDATA[<h1 id="reflection包"><a class="markdownIt-Anchor" href="#reflection包"></a> reflection包</h1><p><a name="vA04i"></a></p><h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1><p><a name="Pw5mh"></a></p><h2 id="装饰器模式"><a class="markdownIt-Anchor" href="#装饰器模式"></a> 装饰器模式</h2><p>装饰器模式又称包装模式，是一种结构型模式。在使用装饰器模式对包装类进行扩展后不会影响原有类。通常使用的场景是在一个核心基本类的基础上提供大量的装饰类，从而使核心基本类经过不同的装饰类修饰后获得不同的功能。此外，装饰器类还可以叠加使用，从而使一个基本类同时具有多个装饰类的功能。<br />装饰器模式归在本人的理解就是在一杯奶茶里加上波霸、芋圆、椰果后，这杯奶茶变成了一杯加料的“奶茶”。好比FileInputStream和InputStream的关系。<br /><a name="7LE5V"></a></p><h2 id="反射"><a class="markdownIt-Anchor" href="#反射"></a> 反射</h2><p>通过Java的反射能够在类的运行过程中知道这个类有哪些属性和方法。此外，还可以修改属性、调用方法、建立类的实例。例如平常进行的复制操作就可以利用反射书写一个适用于任何类的对象的赋值工作。<br />反射主要提供了以下几个功能：</p><ul><li>在运行时判断任意一个对象所属的类。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时修改任意一个对象的成员变量。</li><li>在运行时调用任意一个对象的方法。<br /><a name="lqoZy"></a></li></ul><h2 id="type接口及其子类"><a class="markdownIt-Anchor" href="#type接口及其子类"></a> Type接口及其子类</h2><p>在反射中经常会遇到一个位于java.lang.reflect包下的Type接口，该接口子类类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601365504161-8d341197-8b6a-42c1-ab12-762df6a6052a.png#align=left&amp;display=inline&amp;height=147&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=294&amp;originWidth=1262&amp;size=581414&amp;status=done&amp;style=none&amp;width=631" alt="image.png" /></p><ul><li>Class类：它代表运行的Java程序中的类和接口。</li><li>WildcardType接口：它代表通配符表达式。例如：“？”，“？ extends Number”。</li><li>TypeVariable接口：它代表参数化的类型，例如：“Map&lt;K，V&gt;”中的K，V。</li><li>ParameterizedType接口：它代表参数化的类型。例如：“Collection<String>”就是参数化类型。</li><li>GenericArrayType接口：它代表包含ParameterizedType或者TypeVariable元素的列表。<br /><a name="YSlQP"></a></li></ul><h1 id="对象工厂子包"><a class="markdownIt-Anchor" href="#对象工厂子包"></a> 对象工厂子包</h1><p>reflection包下的factory子包就是一个对象工厂子包，该对象常用来基于反射生产出各种对象，子包结构：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601365848909-95047bfd-6944-44cc-8aa4-b02c99110907.png#align=left&amp;display=inline&amp;height=68&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=109&amp;originWidth=316&amp;size=14545&amp;status=done&amp;style=none&amp;width=197" alt="image.png" /><br />观察ObjectFacory接口，有如下三个方法：</p><ul><li><code>void setProperties(Properties properties)</code>：设置工厂属性</li><li><code>&lt;T&gt; T create(Class&lt;T&gt; type)</code>：传入到下一个create</li><li><code>&lt;T&gt; T create(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</code>：传入目标类型、参数类型列表、参数值列表，根据相应的含参构造方法生成这个类型的实例。</li><li><code>&lt;T&gt; boolean isCollection(Class&lt;T&gt; type)</code>：判断传入的类型是否是一个集合类。</li></ul><p>DefaultObjectFactory类实现了该接口，其create最终返回的是instantiateClass方法生成的对象，其方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>  &lt;T&gt; <span class="function">T <span class="title">instantiateClass</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 构造方法对象</span></span><br><span class="line">    Constructor&lt;T&gt; constructor;</span><br><span class="line">    <span class="comment">// 判断是否不含参或者参数列表为null</span></span><br><span class="line">    <span class="keyword">if</span> (constructorArgTypes == <span class="keyword">null</span> || constructorArgs == <span class="keyword">null</span>) &#123;</span><br><span class="line">      constructor = type.getDeclaredConstructor();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 返回空构造函数生成对象</span></span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="comment">// 如果访问异常，判断构造函数访问属性可否修改</span></span><br><span class="line">        <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) &#123;</span><br><span class="line">          <span class="comment">// 修改构造函数访问属性</span></span><br><span class="line">          constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">          <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据输入参数类型找到对应的构造器</span></span><br><span class="line">    constructor = type.getDeclaredConstructor(constructorArgTypes.toArray(<span class="keyword">new</span> Class[constructorArgTypes.size()]));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 采用有参构造函数创建实例并返回</span></span><br><span class="line">      <span class="keyword">return</span> constructor.newInstance(constructorArgs.toArray(<span class="keyword">new</span> Object[constructorArgs.size()]));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) &#123;</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance(constructorArgs.toArray(<span class="keyword">new</span> Object[constructorArgs.size()]));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 收集所有参数类型</span></span><br><span class="line">    String argTypes = Optional.ofNullable(constructorArgTypes).orElseGet(Collections::emptyList)</span><br><span class="line">        .stream().map(Class::getSimpleName).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">    <span class="comment">// 收集所有参数</span></span><br><span class="line">    String argValues = Optional.ofNullable(constructorArgs).orElseGet(Collections::emptyList)</span><br><span class="line">        .stream().map(String::valueOf).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">&quot;Error instantiating &quot;</span> + type + <span class="string">&quot; with invalid types (&quot;</span> + argTypes + <span class="string">&quot;) or values (&quot;</span> + argValues + <span class="string">&quot;). Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外该实现类里还有一个resolveInterface方法，其作用是判断如果传入的类型是容器接口的话，返回相应的容器对象，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveInterface(Class&lt;?&gt; type) &#123;</span><br><span class="line">  Class&lt;?&gt; classToCreate;</span><br><span class="line">  <span class="keyword">if</span> (type == List.class || type == Collection.class || type == Iterable.class) &#123;</span><br><span class="line">    classToCreate = ArrayList.class;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Map.class) &#123;</span><br><span class="line">    classToCreate = HashMap.class;</span><br><span class="line">  &#125; else if (type == SortedSet.class) &#123; // issue #510 Collections Support</span><br><span class="line">    classToCreate = TreeSet.class;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Set.class) &#123;</span><br><span class="line">    classToCreate = HashSet.class;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    classToCreate = type;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> classToCreate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="duvQU"></a></p><h1 id="执行器子包"><a class="markdownIt-Anchor" href="#执行器子包"></a> 执行器子包</h1><p>reflection包下的invoker子包是执行器的子包，该子包中的类能够基于反射实现对象方法的调用和对象属性的读写，该包下的类图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601366988466-8ad4d0f5-6c8d-4f7a-b5c6-7dcff3ef3098.png#align=left&amp;display=inline&amp;height=182&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=364&amp;originWidth=1126&amp;size=630938&amp;status=done&amp;style=none&amp;width=563" alt="image.png" /><br />Invoker的三种实现分别用于处理环境如下：</p><ul><li>GetFieldInvoker：负责对象属性的读操作。</li><li>SetFiledInvoker：负责对象属性的写操作。</li><li>MethodInvoker：负责对象其他方法的操作。</li></ul><p>此外，Invoker接口中定义的两个抽象方法的功能分别是：</p><ul><li>invoker：执行方法，该方法负责完成对象方法的调用和对象属性的读写。在三个实现类中，分别是属性读写操作、属性赋值操作、方法触发操作。</li><li>getType：用来获取方法。它对于GetFieldInvoker、SetFiledInvoker的含义是获取目标属性类型，而MethodInvoker取略有不同，详见下文。<br /><a name="GCbzN"></a></li></ul><h2 id="methodinvoker的gettype"><a class="markdownIt-Anchor" href="#methodinvoker的gettype"></a> MethodInvoker的getType</h2><p>该类的getType源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getType() &#123;</span><br><span class="line">  <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅仅是返回一个type对象，其对象又是在其构造方法中定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MethodInvoker</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.method = method;</span><br><span class="line"><span class="comment">// 有且仅有一个参数时</span></span><br><span class="line">   <span class="keyword">if</span> (method.getParameterTypes().length == <span class="number">1</span>) &#123;</span><br><span class="line">     type = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     type = method.getReturnType();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当有且仅有一个参数时，type为输入参数的类型，否则type将为返回值类型。<br /><a name="ef7BF"></a></p><h2 id="invoke的实现"><a class="markdownIt-Anchor" href="#invoke的实现"></a> invoke的实现</h2><p>这里以GetFieldInvoker为示例，其实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object target, Object[] args)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 直接获取反射目标对象的值</span></span><br><span class="line">    <span class="keyword">return</span> field.get(target);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    <span class="comment">// 如果属性的访问性可以修改</span></span><br><span class="line">    <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) &#123;</span><br><span class="line">      <span class="comment">// 修改访问属性</span></span><br><span class="line">      field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">return</span> field.get(target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><a name="RkJTo"></a></p><h1 id="属性子包"><a class="markdownIt-Anchor" href="#属性子包"></a> 属性子包</h1><p>reflection包下的properties子包是属性的子包，该子包中的类用来完成与对象属性相关的操作，其包结构如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601367880256-db406b71-8690-4b05-8f40-46765dfc1c2d.png#align=left&amp;display=inline&amp;height=81&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=106&amp;originWidth=272&amp;size=14096&amp;status=done&amp;style=none&amp;width=208" alt="image.png" /><br /><a name="i1U8m"></a></p><h2 id="propertiescopier"><a class="markdownIt-Anchor" href="#propertiescopier"></a> PropertiesCopier</h2><p>其中，PropertiesCopier负责复制属性的值，该类中的唯一方法就是实现拷贝功能的方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyBeanProperties</span><span class="params">(Class&lt;?&gt; type, Object sourceBean, Object destinationBean)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 两个对象同属的类</span></span><br><span class="line">  Class&lt;?&gt; parent = type;</span><br><span class="line">  <span class="keyword">while</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取该类的全部属性</span></span><br><span class="line">    <span class="keyword">final</span> Field[] fields = parent.getDeclaredFields();</span><br><span class="line">    <span class="comment">// 遍历属性</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 调用set方法进行赋值</span></span><br><span class="line">          field.set(destinationBean, field.get(sourceBean));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">          <span class="comment">// 判断是否有属性访问权限</span></span><br><span class="line">          <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) &#123;</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            field.set(destinationBean, field.get(sourceBean));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// Nothing useful to do, will only fail on final fields, which will be ignored.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parent = parent.getSuperclass();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：该方法无法完成继承得来的属性的赋值，因为copyBeanProperties方法在赋值的时候不包含继承属性。<br /><a name="MY2un"></a></p><h2 id="propertynamer"><a class="markdownIt-Anchor" href="#propertynamer"></a> PropertyNamer</h2><p>该类用于提供属性名称相关的操作功能，其正常运行的前提下是对象的属性符合JavaBean命名规范。<br /><a name="x1caz"></a></p><h2 id="propertytokenizer"><a class="markdownIt-Anchor" href="#propertytokenizer"></a> PropertyTokenizer</h2><p>该类是一个属性标记器，当传入一个形如“student[sId].name”的字符串时，标记器会将其拆开放入到各个属性中。<br /><a name="81yad"></a></p><h1 id="对象包装器子包"><a class="markdownIt-Anchor" href="#对象包装器子包"></a> 对象包装器子包</h1><p>reflection包下的wrapper子包是对象包装器的子包，该子包中的类使用装饰器模式对各种类型的对象进行进一步封装，使其增加新的功能。包内类图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601448001468-5b168440-ce42-4f74-9f73-4a0eaea7ef81.png#align=left&amp;display=inline&amp;height=305&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=610&amp;originWidth=1107&amp;size=855226&amp;status=done&amp;style=none&amp;width=553.5" alt="image.png" /><br />其中DefaultObjectWrapperFactory是对象包装器工厂接口的实现，但是这个类中并没有任何功能。因此用户可以通过这个接口定义自己的工厂实现类。<br /><a name="pNTCp"></a></p><h2 id="beanwrapper"><a class="markdownIt-Anchor" href="#beanwrapper"></a> BeanWrapper</h2><p>ObjectWrapper接口是所有对象包装器的总接口，下面将以BeanWrapper为例介绍一下包装器的实现，但是此前要先了解一下MetaObject和MetaClass类：</p><ul><li>MetaObject：涵盖对象中更多细节信息和功能的一个类，又称元对象。</li><li>MetaClass：涵盖了类型中更多细节信息和功能的类，称为元类。</li></ul><p>BeanWrapper有三个重要的属性，其中metaObject属性是由父类BaseWrappper继承而来的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被包装对象的元对象（继承自父类BaseWrapper）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> MetaObject metaObject;</span><br><span class="line"><span class="comment">// 被包装的对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object object;</span><br><span class="line"><span class="comment">// 被包装对象所属类的元类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MetaClass metaClass;</span><br></pre></td></tr></table></figure><p>类中方法的解释：</p><ul><li>get：获得被包装对象某个属性的值。</li><li>set：设置被包装对象某个属性的值。</li><li>findProperty：找到对应属性的名称。</li><li>getGetterNames：获得所有的属性get方法的名字。</li><li>getSetterNames：获得所有的属性set方法的名字。</li><li>getSetterType：获得指定属性的set方法的类型。</li><li>getGetterType：获得指定属性的get方法的类型。</li><li>hasSetter：判断某个属性是否有对应的set方法。</li><li>hasGetter：判断某个属性是否有对应的get方法。</li><li>instantiatePropertyValue：实例化某个属性的值。</li></ul><p>因此，一个Bean经过BeanWrapper包装后就可以暴露出很多易用的方法，从而实现对属性、方法的一系列操作。<br /><a name="z8pZE"></a></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>类似于BeanWrapper，CollectionWrapper、MapWrapper也可以通过这样的包装使Collection和Map暴露出很多易用的方法。<br />BaseWrapper作为MapWrapper和BeanWrapper的父类，提供了两个有用的基础方法为set和get使用。<br /><a name="4u9Mv"></a></p><h1 id="父包类"><a class="markdownIt-Anchor" href="#父包类"></a> 父包类</h1><p><a name="BXLDN"></a></p><h2 id="反射核心类"><a class="markdownIt-Anchor" href="#反射核心类"></a> 反射核心类</h2><p>reflection包中最核心的类就是Reflector类。<br />Refection的相关类类图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601450359300-46397827-be8f-4554-96a2-58fed10099ae.png#align=left&amp;display=inline&amp;height=150&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=299&amp;originWidth=866&amp;size=390074&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br /><a name="jsJNi"></a></p><h3 id="reflection"><a class="markdownIt-Anchor" href="#reflection"></a> Reflection</h3><p>该类将一个类反射解析后会将该类的属性、方法等一一归类放到下述各个属性中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要被反射解析的类  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line"><span class="comment">// 能够读的属性列表，即有get方法的属性列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] readablePropertyNames;</span><br><span class="line"><span class="comment">// 能够写的属性列表，即有set方法的属性列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] writablePropertyNames;</span><br><span class="line"><span class="comment">// set方法映射表。键为属性名，值为set方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Invoker&gt; setMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// get方法映射表。键为属性名，值为get方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Invoker&gt; getMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// set方法输入类型。键为属性名，值为对应的该属性的set方法的类型（set方法第一个参数的类型）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; setTypes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// get方法输出类型。键为属性名，值为对应的该属性的get方法的类型（get方法返回值的类型）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; getTypes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="keyword">private</span> Constructor&lt;?&gt; defaultConstructor;</span><br><span class="line"><span class="comment">// 大小无关的属性映射表。键为属性全大写值，值为属性名。</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, String&gt; caseInsensitivePropertyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>Reflection类反射解析一个类的过程是由构造函数触发的，构造函数源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Reflector</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 要被反射解析的类</span></span><br><span class="line">  type = clazz;</span><br><span class="line">  <span class="comment">// 设置无参构造函数属性</span></span><br><span class="line">  addDefaultConstructor(clazz);</span><br><span class="line">  <span class="comment">// 解析所有的getter</span></span><br><span class="line">  addGetMethods(clazz);</span><br><span class="line">  <span class="comment">// 解析所有的setter</span></span><br><span class="line">  addSetMethods(clazz);</span><br><span class="line">  <span class="comment">// 解析所有的属性</span></span><br><span class="line">  addFields(clazz);</span><br><span class="line">  <span class="comment">// 设置可读参数</span></span><br><span class="line">  readablePropertyNames = getMethods.keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// 设置可写参数</span></span><br><span class="line">  writablePropertyNames = setMethods.keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// 将可读可写参数放入大小写无关的属性映射表</span></span><br><span class="line">  <span class="keyword">for</span> (String propName : readablePropertyNames) &#123;</span><br><span class="line">    caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (String propName : writablePropertyNames) &#123;</span><br><span class="line">    caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的几个方法实现较为基础，暂不做分析。<br /><a name="ReqH3"></a></p><h3 id="defaultreflectorfactory"><a class="markdownIt-Anchor" href="#defaultreflectorfactory"></a> DefaultReflectorFactory</h3><p>ReflectorFactory是Reflector的接口工厂，DefaultReflectorFactory是该接口的实现，于是将分析DefaultReflectorFactory类。<br />该类中只有一个业务相关的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Reflector <span class="title">findForClass</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否允许缓存</span></span><br><span class="line">  <span class="keyword">if</span> (classCacheEnabled) &#123;</span><br><span class="line">    <span class="comment">// synchronized (type) removed see issue #461</span></span><br><span class="line">    <span class="comment">// 生产输入参数Type的反射器对象并放入缓存</span></span><br><span class="line">    <span class="keyword">return</span> reflectorMap.computeIfAbsent(type, Reflector::<span class="keyword">new</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Reflector(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="2bgpx"></a></p><h2 id="反射包装类"><a class="markdownIt-Anchor" href="#反射包装类"></a> 反射包装类</h2><p>之前在wrapper涉及到的两个基础类：MetaClass和MetaObject这里将详细分析。<br /><a name="HoWcP"></a></p><h3 id="metaobject"><a class="markdownIt-Anchor" href="#metaobject"></a> MetaObject</h3><p>MetaObject被称为元对象，是一个针对普通Object对象的包装类，其属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object originalObject;</span><br><span class="line"><span class="comment">// 对象包装器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ObjectWrapper objectWrapper;</span><br><span class="line"><span class="comment">// 对象工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ObjectFactory objectFactory;</span><br><span class="line"><span class="comment">// 对象包装器工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ObjectWrapperFactory objectWrapperFactory;</span><br><span class="line"><span class="comment">// 反射工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReflectorFactory reflectorFactory;</span><br></pre></td></tr></table></figure><p>该类提供很多和objectWrapper一样的方法：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601452010427-e85d7658-a737-4b16-a09c-f1a3e3e49c2d.png#align=left&amp;display=inline&amp;height=164&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=327&amp;originWidth=495&amp;size=76636&amp;status=done&amp;style=none&amp;width=247.5" alt="image.png" /><br />并且在实现的时候调用了objectWrapper的响应方法。<br />然而在objectWrapper的实现中却调用了MetaClass对象的相应方法。<br /><a name="YUEZC"></a></p><h3 id="metaclass"><a class="markdownIt-Anchor" href="#metaclass"></a> MetaClass</h3><p>MetaClass被称为元类，它是针对类的进一步封装，内部集成了类可能使用的反射器和反射工厂。<br /><a name="0BB5j"></a></p><h3 id="systemmetaobject"><a class="markdownIt-Anchor" href="#systemmetaobject"></a> SystemMetaObject</h3><p>该类中限定了一些默认值，源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemMetaObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectFactory DEFAULT_OBJECT_FACTORY = <span class="keyword">new</span> DefaultObjectFactory();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectWrapperFactory DEFAULT_OBJECT_WRAPPER_FACTORY = <span class="keyword">new</span> DefaultObjectWrapperFactory();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MetaObject NULL_META_OBJECT = MetaObject.forObject(NullObject.class, DEFAULT_OBJECT_FACTORY, DEFAULT_OBJECT_WRAPPER_FACTORY, <span class="keyword">new</span> DefaultReflectorFactory());</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SystemMetaObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Prevent Instantiation of Static Class</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NullObject</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MetaObject <span class="title">forObject</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MetaObject.forObject(object, DEFAULT_OBJECT_FACTORY, DEFAULT_OBJECT_WRAPPER_FACTORY, <span class="keyword">new</span> DefaultReflectorFactory());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中forObject方法只能使用默认MetaObject工厂。<br /><a name="dqzQN"></a></p><h2 id="异常拆包类"><a class="markdownIt-Anchor" href="#异常拆包类"></a> 异常拆包类</h2><p>该类的设计比较有趣，ExcepetionUtil是一个异常工具类，他提供了一个拆包异常的工具方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Throwable <span class="title">unwrapThrowable</span><span class="params">(Throwable wrapped)</span> </span>&#123;</span><br><span class="line">  Throwable unwrapped = wrapped;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (unwrapped <span class="keyword">instanceof</span> InvocationTargetException) &#123;</span><br><span class="line">      <span class="comment">// 拆包获得内部异常</span></span><br><span class="line">      unwrapped = ((InvocationTargetException) unwrapped).getTargetException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unwrapped <span class="keyword">instanceof</span> UndeclaredThrowableException) &#123;</span><br><span class="line">      <span class="comment">// 拆包获得内部异常</span></span><br><span class="line">      unwrapped = ((UndeclaredThrowableException) unwrapped).getUndeclaredThrowable();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> unwrapped;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类将InvocationTargetException和UndeclaredThrowableException两个异常进行拆包来得到真正的异常类。<br />这里InvocationTargetException属于必检异常，UndeclaredThrowableException属于免检异常，他们都不属于Mybatis，来自java.lang.reflect包。<br />反射过程中抛出的异常是无法确定是哪种异常，因此通常都会以Throwable抛出。Throwable又可以分为必检型和免检型，因此就要交给这两个异常分别处理：<br /><a name="jlTRv"></a></p><h3 id="invocationtargetexception"><a class="markdownIt-Anchor" href="#invocationtargetexception"></a> InvocationTargetException</h3><p>反射操作的目标方法中出现异常时都会统一的包装成一个必检异常InvocationTargetException，在InvocationTargetException内部的target保存了原始的异常。<br />内部核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationTargetException</span> <span class="keyword">extends</span> <span class="title">ReflectiveOperationException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4085088731926701167L</span>;</span><br><span class="line">    <span class="keyword">private</span> Throwable target;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvocationTargetException</span><span class="params">(Throwable target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((Throwable)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Throwable <span class="title">getTargetException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="1fPcs"></a></p><h3 id="undeclaredthrowableexception"><a class="markdownIt-Anchor" href="#undeclaredthrowableexception"></a> UndeclaredThrowableException</h3><p>在代码实现的时候，如果子类想要抛出必检异常，那么父类必定要声明过这个必检异常。同样的，如果代理类和被代理类实现了共同的接口，则代理类方法中抛出的必检异常必须是在共同接口声明过的。<br />可是当代理类想抛出异常时，其共同的接口或父类并没有声明该必检异常，那又该如何处理。<br />答案就是将这个必检异常包装成免检异常UndeclaredThrowableException，所以说UndeclaredThrowableException并不代表着真实的免检异常，其内部也可能包裹着必检异常InvocationTargetException。<br /><a name="IU6N3"></a></p><h3 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3><p>经过分析UndeclaredThrowableException和InvocationTargetException后可以了解为什么要在ExceptionUtil中会有一个while(true)，因为只有这样才能把这两个包装类拆包拆出真正的异常。<br /><a name="aBJJp"></a></p><h2 id="参数名解析器"><a class="markdownIt-Anchor" href="#参数名解析器"></a> 参数名解析器</h2><p>ParamNameResolver是一个参数名解析器，用来按顺序列出方法中的虚参，并对实参进行命名标注。<br />其内部参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法输入参数的参数次序表，键为参数次序，值为参数名称或者参数@Param注解的值  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; names;</span><br><span class="line"><span class="comment">// 该方法输入参数中是否含有@Param</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasParamAnnotation;</span><br></pre></td></tr></table></figure><p>其主要方法有ParamNameResolver构造函数和getNamedParams方法，暂不做解析。<br /><a name="Y7kWy"></a></p><h2 id="泛型解析器"><a class="markdownIt-Anchor" href="#泛型解析器"></a> 泛型解析器</h2><p><a name="0O0EW"></a></p><h3 id="解析器作用"><a class="markdownIt-Anchor" href="#解析器作用"></a> 解析器作用</h3><p>TypeParameterResolver是一个泛型参数解析器，下面用一段简单的代码演示其功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用TypeParameterResolver分析User类中getInfo方法输出结果的具体类型</span></span><br><span class="line">            Type type1 = TypeParameterResolver.resolveReturnType(User.class.getMethod(&quot;getInfo&quot;), User.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;User类中getInfo方法的输出结果类型 :\n&quot;</span> + type1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用TypeParameterResolver分析Student类中getInfo方法输出结果的具体类型</span></span><br><span class="line">            Type type2 = TypeParameterResolver.resolveReturnType(User.class.getMethod(&quot;getInfo&quot;), Student.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;Student类中getInfo方法的输出结果类型 :\n&quot;</span> + type2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601454537014-490989df-40ce-40e3-bbc8-0e9ba5ed4f9a.png#align=left&amp;display=inline&amp;height=92&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=183&amp;originWidth=1027&amp;size=193417&amp;status=done&amp;style=none&amp;width=513.5" alt="image.png" /><br />显然，其作用就是帮助Mybatis解析出属性返回值、输入参数的泛型的具体类型。<br /><a name="autgF"></a></p><h3 id="解析器原理分析"><a class="markdownIt-Anchor" href="#解析器原理分析"></a> 解析器原理分析</h3><p>其对外提供了三个方法：</p><ul><li>resolveFieldType：解析属性的泛型</li><li>resolveReturnType：解析方法的返回值泛型</li><li>resolveParamTypes：解析方法输入参数的泛型</li></ul><p>这三个方法实现方法大致相同，先选择一个最难的resolveParamTypes进行解析。<br />其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Type[] resolveParamTypes(Method method, Type srcType) &#123;</span><br><span class="line">  <span class="comment">// 取出方法所有的参数</span></span><br><span class="line">  Type[] paramTypes = method.getGenericParameterTypes();</span><br><span class="line">  <span class="comment">// 定义目标方法的类或接口</span></span><br><span class="line">  Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line">  <span class="comment">// 创建解析结果的集合</span></span><br><span class="line">  Type[] result = <span class="keyword">new</span> Type[paramTypes.length];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paramTypes.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 对输入的每个参数调用resolveType方法解析结果</span></span><br><span class="line">    result[i] = resolveType(paramTypes[i], srcType, declaringClass);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resolveType需要传入三个参数：</p><ul><li>Type type：指要分析的字段或者参数的类型。这里要分析的是getInfo的输出参数，即List<T>。</li><li>Type srcType：指要分析的字段或者参数所属的类。这里要分析的是Student类中的getInfo方法，故所属的类是Student</li><li>Class_&lt;<em>?</em>&gt; _declaringClass：指要分析的字段或者参数的类。getInfo方法在User类中被定义，故这里是User类。</li></ul><p>其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Type <span class="title">resolveType</span><span class="params">(Type type, Type srcType, Class&lt;?&gt; declaringClass)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是类型变量，如Map&lt;K,V&gt;的 K，V</span></span><br><span class="line">  <span class="keyword">if</span> (type <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">    <span class="keyword">return</span> resolveTypeVar((TypeVariable&lt;?&gt;) type, srcType, declaringClass);</span><br><span class="line">  <span class="comment">// 如果是参数化类型，如Collection&lt;String&gt;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">    <span class="keyword">return</span> resolveParameterizedType((ParameterizedType) type, srcType, declaringClass);</span><br><span class="line">  <span class="comment">// 如果是包含ParameterizedType或者TypeVariable元素的列表</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type <span class="keyword">instanceof</span> GenericArrayType) &#123;</span><br><span class="line">    <span class="keyword">return</span> resolveGenericArrayType((GenericArrayType) type, srcType, declaringClass);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，resolveType会根据不同的参数类型调用不同的子方法处理。<br />追随端点来到相应的resolveParameterizedType方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ParameterizedType <span class="title">resolveParameterizedType</span><span class="params">(ParameterizedType parameterizedType, Type srcType, Class&lt;?&gt; declaringClass)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取变量的原始类型，本次为List</span></span><br><span class="line">  Class&lt;?&gt; rawType = (Class&lt;?&gt;) parameterizedType.getRawType();</span><br><span class="line">  <span class="comment">// 获取类型参数，本例只有一个T</span></span><br><span class="line">  Type[] typeArgs = parameterizedType.getActualTypeArguments();</span><br><span class="line">  <span class="comment">// 类型参数的实际类型</span></span><br><span class="line">  Type[] args = <span class="keyword">new</span> Type[typeArgs.length];</span><br><span class="line">  <span class="comment">// 依次处理每一个类型参数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; typeArgs.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 类型参数是类型变量，本次符合</span></span><br><span class="line">    <span class="keyword">if</span> (typeArgs[i] <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">      args[i] = resolveTypeVar((TypeVariable&lt;?&gt;) typeArgs[i], srcType, declaringClass);</span><br><span class="line">    <span class="comment">// 类型参数是参数化类型，例如List&lt;List&lt;T&gt;&gt;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeArgs[i] <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">      args[i] = resolveParameterizedType((ParameterizedType) typeArgs[i], srcType, declaringClass);</span><br><span class="line">    <span class="comment">// 类型参数是通配符泛型，例如&lt;? extends XXX&gt;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeArgs[i] <span class="keyword">instanceof</span> WildcardType) &#123;</span><br><span class="line">      args[i] = resolveWildcardType((WildcardType) typeArgs[i], srcType, declaringClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 类型参数时确定类型，例如 Conllection&lt;String&gt;</span></span><br><span class="line">      args[i] = typeArgs[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ParameterizedTypeImpl(rawType, <span class="keyword">null</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟踪resolveTypeVar：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Type <span class="title">resolveTypeVar</span><span class="params">(TypeVariable&lt;?&gt; typeVar, Type srcType, Class&lt;?&gt; declaringClass)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 解析出来的类型参数结果</span></span><br><span class="line">   Type result;</span><br><span class="line">   Class&lt;?&gt; clazz;</span><br><span class="line">   <span class="comment">// 该类型参数是一个Class，本例符合</span></span><br><span class="line">   <span class="keyword">if</span> (srcType <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">     clazz = (Class&lt;?&gt;) srcType;</span><br><span class="line">   <span class="comment">// 该类型属于参数化类型</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (srcType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">     ParameterizedType parameterizedType = (ParameterizedType) srcType;</span><br><span class="line">     <span class="comment">// 获取参数化类型的原始类型</span></span><br><span class="line">     clazz = (Class&lt;?&gt;) parameterizedType.getRawType();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;The 2nd arg must be Class or ParameterizedType, but was: &quot;</span> + srcType.getClass());</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 变量所属的类和定义变量的类一致。本例中T属于Student定义属于User</span></span><br><span class="line">   <span class="keyword">if</span> (clazz == declaringClass) &#123;</span><br><span class="line">     <span class="comment">// 确定边界上限（边界类型，本次Number）</span></span><br><span class="line">     Type[] bounds = typeVar.getBounds();</span><br><span class="line">     <span class="keyword">if</span> (bounds.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> bounds[<span class="number">0</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> Object.class;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 获取所属类的父类</span></span><br><span class="line">   Type superclass = clazz.getGenericSuperclass();</span><br><span class="line">   <span class="comment">// 扫描父类，确定边界（边界类型，本次Number）</span></span><br><span class="line">   result = scanSuperTypes(typeVar, srcType, declaringClass, clazz, superclass);</span><br><span class="line">   <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 获取变量所属类的接口</span></span><br><span class="line">   Type[] superInterfaces = clazz.getGenericInterfaces();</span><br><span class="line">   <span class="comment">// 遍历父接口确定边界</span></span><br><span class="line">   <span class="keyword">for</span> (Type superInterface : superInterfaces) &#123;</span><br><span class="line">     result = scanSuperTypes(typeVar, srcType, declaringClass, clazz, superInterface);</span><br><span class="line">     <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> Object.class;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>此外还有resolveTypeVar和resolveGenericArrayType方法。<br />方法就是resolveParameterizedType的简化版。<br />resolveGenericArrayType源码解析如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Type <span class="title">resolveGenericArrayType</span><span class="params">(GenericArrayType genericArrayType, Type srcType, Class&lt;?&gt; declaringClass)</span> </span>&#123;</span><br><span class="line">  Type componentType = genericArrayType.getGenericComponentType();</span><br><span class="line">  Type resolvedComponentType = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 元素类型是类的变量，例如T[]</span></span><br><span class="line">  <span class="keyword">if</span> (componentType <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">    resolvedComponentType = resolveTypeVar((TypeVariable&lt;?&gt;) componentType, srcType, declaringClass);</span><br><span class="line">  <span class="comment">// 元素类型是泛型列表，例如T[][]</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (componentType <span class="keyword">instanceof</span> GenericArrayType) &#123;</span><br><span class="line">    resolvedComponentType = resolveGenericArrayType((GenericArrayType) componentType, srcType, declaringClass);</span><br><span class="line">  <span class="comment">// 元素类型是参数化类型，例如Collection&lt;T&gt;[]</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (componentType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">    resolvedComponentType = resolveParameterizedType((ParameterizedType) componentType, srcType, declaringClass);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是Class类</span></span><br><span class="line">  <span class="keyword">if</span> (resolvedComponentType <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">    <span class="keyword">return</span> Array.newInstance((Class&lt;?&gt;) resolvedComponentType, <span class="number">0</span>).getClass();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GenericArrayTypeImpl(resolvedComponentType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
          <category> 基础功能包 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>exceptions包</title>
      <link href="/posts/mybatis-exceptions/"/>
      <url>/posts/mybatis-exceptions/</url>
      
        <content type="html"><![CDATA[<h1 id="exceptions包"><a class="markdownIt-Anchor" href="#exceptions包"></a> exceptions包</h1><p>exceptions为Mybatis定义了绝大多数异常类的父类，同时也提供了异常类的生产工厂。<br /><a name="c7D3m"></a></p><h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1><p>了解excepetions包之前首先要对如下几个内容有所了解。<br /><a name="rAvLz"></a></p><h2 id="java的异常"><a class="markdownIt-Anchor" href="#java的异常"></a> Java的异常</h2><p>Java的异常类都是以Throwable为父类，Throwable又派生出了Error和Exception两大子类：</p><ul><li>Error及其子类代表着JVM异常。这类异常发生时无法通过程序来矫正，最可靠的方法就是停止JVM的运行。因此这类异常属于免检异常。</li><li>Excepetion及其子类代表程序运行中发生了意料之外的事情，这些异常可以被Java的异常处理机制所处理。Exception又可以分为两类：<ul><li>RuntimeException及其子类：这类异常是程序设计的错误，通过修复程序才可以避免，如数组越界、数值异常等。因此这类异常也属于免检异常。</li><li>非RuntimeException及其子类：这类异常通常由外部因素所导致的，是不可预知和避免的，如IO异常、类型寻找异常等。因此，这类异常属于必检异常。</li></ul></li></ul><p>注：免检异常即不需要对这类异常做强制检查。必检异常即在表写程序时要用try、catch进行包围的。<br /><a name="LRUTt"></a></p><h2 id="序列化和反序列化"><a class="markdownIt-Anchor" href="#序列化和反序列化"></a> 序列化和反序列化</h2><p>序列化是把对象转换为字节序列的过程。反序列化是把字节序列恢复成对象的过程。<br />对象序列化通常有两个目的：</p><ul><li>将对象转换为字节后保存到存储介质中，即为了对象的持久化。</li><li>将对象转换为字节后在网络上传输，即为了传输对象。</li></ul><p>在实现序列化时通常都是实现Serializabale接口即可，实现即表明这个类的对象是可序列化的，而不需要任何额外操作。（当然，还有其他方法）<br />在反序列化时，涉及到了一个serialVersionUID的字段，该字段叫做序列化版本控制字段。如果对象自己序列中的该字段与当前类不同，则反序列化失败且抛出版本不一致异常（InvaidClassException），反之则成功。<br />注意：如果没有显式的定义serialVersionUID属性，系统则会自动的生成一个serialVersionUID，当类的类名、类及属性修饰符、接口及接口顺序、属性、构造函数等相关内容任何一项发生改变serialVersionUID都会发生变化。<br />因此，通常手动定义一个serialVersionUID，这样便可以：</p><ul><li>希望版本间兼容时保持serialVersionUID不变。</li><li>希望不兼容时serialVersionUID改变。<br /><a name="p7SfU"></a></li></ul><h1 id="exception类"><a class="markdownIt-Anchor" href="#exception类"></a> Exception类</h1><p>在exceptions包中有三个异常类和一个工厂类：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601360526991-3191f2b9-ec1b-450f-95b3-d7f201fd0994.png#align=left&amp;display=inline&amp;height=62&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=123&amp;originWidth=331&amp;size=19204&amp;status=done&amp;style=none&amp;width=165.5" alt="image.png" /><br />但是实际的Mybatis的异常图谱远不止这三个异常类，如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601360626312-37fab0c6-dc6a-4192-ab1e-902b34975900.png#align=left&amp;display=inline&amp;height=266&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=531&amp;originWidth=1173&amp;size=926070&amp;status=done&amp;style=none&amp;width=586.5" alt="image.png" /><br />注意：IbatisException是PersistenceException的父类，而其他的异常类却都继承自PersistenceEception，于是IbatisException被架空了，因此IbatisException类上有了一个大大的@Deprecated。<br />此外，在所有Exception的类中的定义都十分简单，基本上都是由一个serialVersionUID字段和四种构造方法组成的，因此也不做过多分析了。<br /><a name="AWz9d"></a></p><h1 id="exceptionfactory类"><a class="markdownIt-Anchor" href="#exceptionfactory类"></a> ExceptionFactory类</h1><p>该类是负责生产Exception的工厂，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ExceptionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Prevent Instantiation</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RuntimeException <span class="title">wrapException</span><span class="params">(String message, Exception e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PersistenceException(ErrorContext.instance().message(message).cause(e).toString(), e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wrapException方法负责执行主要的逻辑，ErrorContext将在后续进行分析。</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
          <category> 基础功能包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis之基础概念</title>
      <link href="/posts/mybatis-title/"/>
      <url>/posts/mybatis-title/</url>
      
        <content type="html"><![CDATA[<h1 id="mybatis之基础概念"><a class="markdownIt-Anchor" href="#mybatis之基础概念"></a> Mybatis之基础概念</h1><p><a name="GPKvu"></a></p><h1 id="orm框架的引入"><a class="markdownIt-Anchor" href="#orm框架的引入"></a> ORM框架的引入</h1><p>传统的JDBC的代码是复杂且冗余的，因此就引入了ORM的思想来简化面向对象的开发和实现关系型数据库的持久化方案。其中，Mybatis就是一个优秀的ORM框架。<br />ORM多是将Java对象和数据库表直接关联起来（类似于Spring Data JPA），而Mybatis则是将Java方法与SQL语句关联起来，除此之外，Mybatis还提供了一种映射机制，将SQL语句的参数或结果与对象关联起来。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601097939314-71d8e6d3-5853-4df5-8cdb-eae14f066349.png#align=left&amp;display=inline&amp;height=156&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=193&amp;originWidth=648&amp;size=193912&amp;status=done&amp;style=none&amp;width=524" alt="image.png" /><br />如图，在调用方法时可以给方法传递对象作为SQL语句的参数，而SQL语句的执行结果也会被映射成对象后返回。这样，读写过程就成了一个传统的面向对象的过程。<br /><a name="XHFJx"></a></p><h2 id="mybatis的功能"><a class="markdownIt-Anchor" href="#mybatis的功能"></a> Mybatis的功能</h2><p>经过以前的项目积累，现在结合ORM总结一下Mybatis的核心功能：</p><ul><li>将包含if等标签的复杂数据库操作语句解析成纯粹的SQL语句。</li><li>将数据库操作节点和映射接口中的抽象方法进行绑定，在抽象方法被调用时执行数据库操作。</li><li>将输入参数对象转化为数据库操作语句的参数。</li><li>将数据库操作语句的返回结果转换为对象。<br /><a name="9KVjd"></a></li></ul><h1 id="使用mybatis"><a class="markdownIt-Anchor" href="#使用mybatis"></a> 使用Mybatis</h1><p>配置Mybatis有三种方式：</p><ol><li>纯代码配置：配置信息和业务耦合在一起，很少使用。</li><li>基于XML配置：经常使用。</li><li>外部框架配置：类似于Spring、Spring Boot这类框架提供了与Mybatis对接的相关组件，可以在其配置文件中直接配置Mybatis。切记：接口方法上一定要加上@Mapper注解。<br /><a name="ofHqy"></a></li></ol><h2 id="配置参数"><a class="markdownIt-Anchor" href="#配置参数"></a> 配置参数</h2><p>Mybatis的配置文件通常会被命名为mybatis-config.xml，其根节点为configuration，根节点包含的一级节点如下：</p><ul><li>properties：属性信息，相当于Mybatis的局部变量。</li><li>settings：设置信息，通过这个来对Mybatis的功能进行调整。</li><li>typeAliases：类型别名，在这里可以为类型设置一些简短的名字。</li><li>typeHandlers：类型处理器，在这里可以为不同的类型设置相应的处理器。</li><li>objectFactory：对象工厂，在这里可以指定Mybatis创建新对象时使用的工厂。</li><li>objectWrapperFactory：对象包装工厂，在这里可以指定Mybatis使用的对象包装器工厂。</li><li>reflectorFacotry：反射器工厂，在这里可以设置反射器工厂。</li><li>plugins：插件，在这里可以为Mybatis配置插件，从而修改或扩展Mybatis的行为。</li><li>environments：环境，这里可以配置Mybatis运行的环境信息。</li><li>databaseIdProvider：数据库编号，在这里可以为不同的数据库配置不同的编号，这样可以对不同类型的数据库设置不同数据库操作语句。</li><li>mappers：映射文件，在这里可以设置映射文件或映射接口文件地址。</li></ul><p>注意，配置文件的节点顺序必须按照上述所示！<br /><a name="Jg2b3"></a></p><h2 id="映射文件"><a class="markdownIt-Anchor" href="#映射文件"></a> 映射文件</h2><p>映射文件的根节点为mapper，在mapper节点下可以包含的节点及其含义如下：</p><ul><li>cache：缓存，通过它可以对命名空间进行缓存配置。</li><li>cache-ref：缓存引用，通过它可以引用其他命名空间的缓存作为当前命名空间的缓存。</li><li>resultMap：结果映射，通过它来配置如何将SQL查询结果映射为对象。</li><li>parameterMap：参数映射，通过它可以配置如何将参数映射为SQL参数。注意：该节点已被废除，建议直接使用内联参数。</li><li>sql：SQL语句片段，通过它来设置可以被复用的语句片段。</li><li>insert：插入语句。</li><li>update：更新语句。</li><li>delete：删除语句。</li><li>select：查询语句。<br /><a name="eC5C7"></a></li></ul><h2 id="映射接口文件"><a class="markdownIt-Anchor" href="#映射接口文件"></a> 映射接口文件</h2><p>映射接口文件中可以定义一些抽象方法，这些抽象方法有两种方式可以实现映射且执行SQL语句：</p><ul><li>抽象方法与对应的映射文件的数据库操作节点相对应。</li><li>通过注释声明自身的数据库操作语句。</li></ul><p>其中，当整个接口文件中均为类抽象方法时，该接口文件可以没有对应的映射文件。<br /><a name="3IiaQ"></a></p><h1 id="mybatis运行过程初探"><a class="markdownIt-Anchor" href="#mybatis运行过程初探"></a> Mybatis运行过程初探</h1><p>现有一段可以运行的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一阶段：MyBatis的初始化阶段</span></span><br><span class="line">        String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="comment">// 得到配置文件的输入流</span></span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到SqlSessionFactory</span></span><br><span class="line">        SqlSessionFactory sqlSessionFactory =</span><br><span class="line">                <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二阶段：数据读写阶段</span></span><br><span class="line">        <span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">            <span class="comment">// 找到接口对应的实现</span></span><br><span class="line">            UserMapper userMapper = session.getMapper(UserMapper.class);</span><br><span class="line">            <span class="comment">// 组建查询参数</span></span><br><span class="line">            User userParam = <span class="keyword">new</span> User();</span><br><span class="line">            userParam.setSchoolName(<span class="string">&quot;Sunny School&quot;</span>);</span><br><span class="line">            <span class="comment">// 调用接口展开数据库操作</span></span><br><span class="line">            List&lt;User&gt; userList =  userMapper.queryUserBySchoolName(userParam);</span><br><span class="line">            <span class="comment">// 打印查询结果</span></span><br><span class="line">            <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;name : &quot;</span> + user.getName() + <span class="string">&quot; ;  email : &quot;</span> + user.getEmail());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，其可以分为两个阶段：</p><ol><li>Mybatis初始化阶段，在这个阶段完成Mybatis环境的准备工作，这个工作只在Mybatis的启动时运行一次。</li><li>数据读写阶段，该阶段由数据读写操作触发，将根据要求完成具体的增删改查等数据库操作。</li></ol><p>以下将按照这个两个阶段划分逐步探究。<br /><a name="w9934"></a></p><h2 id="初始化阶段"><a class="markdownIt-Anchor" href="#初始化阶段"></a> 初始化阶段</h2><p><a name="oVDYs"></a></p><h3 id="静态代码块执行"><a class="markdownIt-Anchor" href="#静态代码块执行"></a> 静态代码块执行</h3><p>既然是详细分析，那就要从第一行来看：<br /><code>public static void main(String[] args)</code><br />注意关键字static，这个关键字把整个方法声明成了一个静态代码块。<br />类的初始化就是把Class文件加载到JVM的过程，这一过程会经过如图所示的几个步骤：<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/485026/1601289600816-a46f78e2-458b-40b6-be75-1e39f593addd.jpeg?x-oss-process=image/auto-orient,1#align=left&amp;display=inline&amp;height=289&amp;margin=%5Bobject%20Object%5D&amp;name=QQ%E5%9B%BE%E7%89%8720200928183903.jpg&amp;originHeight=289&amp;originWidth=1515&amp;size=56487&amp;status=done&amp;style=none&amp;width=1515" alt="QQ图片20200928183903.jpg" /><br />静态代码块会在类加载过程中的初始化阶段执行，且只执行一次，一个类可以有多个静态代码块，他们会按照顺序执行。<br /><a name="o1krW"></a></p><h3 id="获取inputstream"><a class="markdownIt-Anchor" href="#获取inputstream"></a> 获取InputStream</h3><p>进入静态代码块后即将执行的语句就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="comment">// 得到配置文件的输入流</span></span><br><span class="line">InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>追随getResourceAsStream方法得到源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InputStream <span class="title">getResourceAsStream</span><span class="params">(String resource, ClassLoader[] classLoader)</span> </span>&#123;</span><br><span class="line">    ClassLoader[] var3 = classLoader;</span><br><span class="line">    <span class="keyword">int</span> var4 = classLoader.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">        ClassLoader cl = var3[var5];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != cl) &#123;</span><br><span class="line">            InputStream returnValue = cl.getResourceAsStream(resource);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == returnValue) &#123;</span><br><span class="line">                returnValue = cl.getResourceAsStream(<span class="string">&quot;/&quot;</span> + resource);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != returnValue) &#123;</span><br><span class="line">                <span class="keyword">return</span> returnValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里除了资源路径名称resource以外，还有一组额外的参数ClassLoader。ClassLoader叫做类加载器，是负责加载类的对象。一般情况下，类加载器会将给定类的二进制名称转换为文件名，然后从文件系统中读取该名称的类文件。<br />如代码所示，如果找不到会添加上“/”继续查找，成功后会将指定文件的输入流返回。<br /><a name="Iu3ad"></a></p><h3 id="配置信息读取"><a class="markdownIt-Anchor" href="#配置信息读取"></a> 配置信息读取</h3><p>获取完输入流就要执行以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory =</span><br><span class="line">              <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure><p>这一步首先创建了SqlSessionFactory的对象，然后调用了build方法。<br />追随build方法得到以下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">    SqlSessionFactory var5;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">        var5 = <span class="keyword">this</span>.build(parser.parse());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var14) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error building SqlSession.&quot;</span>, var14);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var13) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最核心的代码是第4、5行。<br />这两句代码实现了如下两个步骤：</p><ul><li>生成了一个XMLConfigBuilder对象，并调用器parse方法返回一个Configuration对象。</li><li>调用SqlSessionFactoryBuilder自身的build方法并返回一个SqlSessionFactory对象。</li></ul><p>这里再猜拆分这两个步骤进行分析。<br /><a name="jLB4S"></a></p><h4 id="parse"><a class="markdownIt-Anchor" href="#parse"></a> parse</h4><p>追随其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parsed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Each XMLConfigBuilder can only be used once.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.parsed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.parseConfiguration(<span class="keyword">this</span>.parser.evalNode(<span class="string">&quot;/configuration&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.configuration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里出现了“/configuration”关键字，其中“configuration”为mybatis-config.xml的根节点，因此这里是解析整个配置文件的入口，parseConfiguration是解析配置文件的方法，将返回的结果填入到configuration中并返回。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.propertiesElement(root.evalNode(<span class="string">&quot;properties&quot;</span>));</span><br><span class="line">        Properties settings = <span class="keyword">this</span>.settingsAsProperties(root.evalNode(<span class="string">&quot;settings&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.loadCustomVfs(settings);</span><br><span class="line">        <span class="keyword">this</span>.loadCustomLogImpl(settings);</span><br><span class="line">        <span class="keyword">this</span>.typeAliasesElement(root.evalNode(<span class="string">&quot;typeAliases&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.pluginElement(root.evalNode(<span class="string">&quot;plugins&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.objectFactoryElement(root.evalNode(<span class="string">&quot;objectFactory&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.objectWrapperFactoryElement(root.evalNode(<span class="string">&quot;objectWrapperFactory&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.reflectorFactoryElement(root.evalNode(<span class="string">&quot;reflectorFactory&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.settingsElement(settings);</span><br><span class="line">        <span class="keyword">this</span>.environmentsElement(root.evalNode(<span class="string">&quot;environments&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.databaseIdProviderElement(root.evalNode(<span class="string">&quot;databaseIdProvider&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.typeHandlerElement(root.evalNode(<span class="string">&quot;typeHandlers&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.mapperElement(root.evalNode(<span class="string">&quot;mappers&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + var3, var3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="p4gh3"></a></p><h4 id="build"><a class="markdownIt-Anchor" href="#build"></a> build</h4><p>build方法接受了Configuration参数并返回了一个SqlSessionFacory的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：DefaultSqlSessionFactory 是SqlSessionFacory的实现类。<br /><a name="YNU7q"></a></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>总结初始化阶段，其主要完成了如下几个工作：</p><ul><li>根据配置文件的位置获取相应的输入流。</li><li>从配置文件的根节点开始，逐层解析配置文件，也包括映射文件，解析过程中不断将解析结果放入configuration中。</li><li>将configuration对象传入DefaultSqlSessionFactory并返回，获取一个SqlSessionFactory对象。<br /><a name="3jOO2"></a></li></ul><h2 id="数据库读写阶段"><a class="markdownIt-Anchor" href="#数据库读写阶段"></a> 数据库读写阶段</h2><p><a name="nB9L4"></a></p><h3 id="获得sqlsession"><a class="markdownIt-Anchor" href="#获得sqlsession"></a> 获得SqlSession</h3><p>结束初始化工作后，执行读写操作的第一步就是获取SqlSession对象，其语句如下：<br /><code>SqlSession session = sqlSessionFactory.openSession()</code><br />追如openSession方法得到源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    DefaultSqlSession var8;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Environment environment = <span class="keyword">this</span>.configuration.getEnvironment();</span><br><span class="line">        TransactionFactory transactionFactory = <span class="keyword">this</span>.getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">        tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">        Executor executor = <span class="keyword">this</span>.configuration.newExecutor(tx, execType);</span><br><span class="line">        var8 = <span class="keyword">new</span> DefaultSqlSession(<span class="keyword">this</span>.configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var12) &#123;</span><br><span class="line">        <span class="keyword">this</span>.closeTransaction(tx);</span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error opening session.  Cause: &quot;</span> + var12, var12);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> var8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中生成了一系列对象：Environment、TransactionFactory、Transaction、Executor，并将他们传递给DefaultSqlSession的构造方法生成DefaultSqlSession对象并返回。在DefaultSqlSession类中可以看到他提供的查询、增加、更新、删除、回滚、提交等方法。<br /><a name="Ig561"></a></p><h3 id="映射接口和映射文件绑定"><a class="markdownIt-Anchor" href="#映射接口和映射文件绑定"></a> 映射接口和映射文件绑定</h3><p>获取到了SqlSession的对象后，即将执行：<br /><code>UserMapper userMapper = session.getMapper(UserMapper.class);</code><br />进入到getMapper方法，得到源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory)<span class="keyword">this</span>.knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is not known to the MapperRegistry.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + var5, var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法通过映射接口信息从所有已经解析的映射文件中找到了对应的映射文件，然后根据这个映射文件组建并返回了接口的一个实现对象。这个实现对象通过mapperProxyFactory.newInstance(sqlSession)的语句返回，追随newInstance方法得到源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy(sqlSession, <span class="keyword">this</span>.mapperInterface, <span class="keyword">this</span>.methodCache);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，返回的是一个动态代理对象。<br /><a name="5gbkD"></a></p><h3 id="映射接口注入实现"><a class="markdownIt-Anchor" href="#映射接口注入实现"></a> 映射接口注入实现</h3><p>获得userMapper的动态代理对象后，就要执行下列语句：<br /><code>List&lt;User&gt; userList = userMapper.queryUserBySchoolName(userParam);</code><br />在这里，要真正的执行SQL语句。<br />既然调用动态代理对象的方法，那么就要回到MapperProxy的invoke方法中查看接口方法调用过程。（被代理对象的方法会被代理对象的方法拦截）<br />追溯invoke方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (method.isDefault()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.invokeDefaultMethod(proxy, method, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(var5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MapperMethod mapperMethod = <span class="keyword">this</span>.cachedMapperMethod(method);</span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(<span class="keyword">this</span>.sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据调试追踪到execute方法，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    Object param;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="keyword">this</span>.command.getType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> INSERT:</span><br><span class="line">        param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = <span class="keyword">this</span>.rowCountResult(sqlSession.insert(<span class="keyword">this</span>.command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> UPDATE:</span><br><span class="line">        param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = <span class="keyword">this</span>.rowCountResult(sqlSession.update(<span class="keyword">this</span>.command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DELETE:</span><br><span class="line">        param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = <span class="keyword">this</span>.rowCountResult(sqlSession.delete(<span class="keyword">this</span>.command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SELECT:</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.method.returnsVoid() &amp;&amp; <span class="keyword">this</span>.method.hasResultHandler()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.executeWithResultHandler(sqlSession, args);</span><br><span class="line">            result = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.method.returnsMany()) &#123;</span><br><span class="line">            result = <span class="keyword">this</span>.executeForMany(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.method.returnsMap()) &#123;</span><br><span class="line">            result = <span class="keyword">this</span>.executeForMap(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.method.returnsCursor()) &#123;</span><br><span class="line">            result = <span class="keyword">this</span>.executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</span><br><span class="line">            result = sqlSession.selectOne(<span class="keyword">this</span>.command.getName(), param);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.method.returnsOptional() &amp;&amp; (result == <span class="keyword">null</span> || !<span class="keyword">this</span>.method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">                result = Optional.ofNullable(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FLUSH:</span><br><span class="line">        result = sqlSession.flushStatements();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Unknown execution method for: &quot;</span> + <span class="keyword">this</span>.command.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.method.getReturnType().isPrimitive() &amp;&amp; !<span class="keyword">this</span>.method.returnsVoid()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Mapper method &#x27;&quot;</span> + <span class="keyword">this</span>.command.getName() + <span class="string">&quot; attempted to return null from a method with a primitive return type (&quot;</span> + <span class="keyword">this</span>.method.getReturnType() + <span class="string">&quot;).&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里根据不同的处理方法选择不同的语句，这里以select为例进入到了SELECT的语句块中，根据返回类型，这里将要执行<code>result = this.executeForMany(sqlSession, args);</code>方法，追入得到源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">executeForMany</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</span><br><span class="line">    List result;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.method.hasRowBounds()) &#123;</span><br><span class="line">        RowBounds rowBounds = <span class="keyword">this</span>.method.extractRowBounds(args);</span><br><span class="line">        result = sqlSession.selectList(<span class="keyword">this</span>.command.getName(), param, rowBounds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = sqlSession.selectList(<span class="keyword">this</span>.command.getName(), param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.method.getReturnType().isAssignableFrom(result.getClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.method.getReturnType().isArray() ? <span class="keyword">this</span>.convertToArray(result) : <span class="keyword">this</span>.convertToDeclaredCollection(sqlSession.getConfiguration(), result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里实现了映射接口注入实现的过程，对接口的抽象方法的调用转变成了数据库的调用过程。<br /><a name="m69km"></a></p><h3 id="sql查找的实现"><a class="markdownIt-Anchor" href="#sql查找的实现"></a> SQL查找的实现</h3><p>以查找为例，这里深入探究其执行过程。<br />根据端点追寻其执行到<code>result = sqlSession.selectList(this.command.getName(), param);</code>语句，获得selectList源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">    List var5;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MappedStatement ms = <span class="keyword">this</span>.configuration.getMappedStatement(statement);</span><br><span class="line">        var5 = <span class="keyword">this</span>.executor.query(ms, <span class="keyword">this</span>.wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error querying database.  Cause: &quot;</span> + var9, var9);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的MappedStatement对象对应了设置的一个数据库操作节点，其主要定义了数据库操作语句、输入/输出参数等操作信息。这里通过statement（SQL语句）将要执行的MappedStatement对象从configuration中获取出来。<br />紧接着将要执行query语句来实现具体的查询操作。<br />注意，这里有两个query的实现类：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601294695203-d739b09d-daca-4534-ba37-f63f6cb69f4d.png#align=left&amp;display=inline&amp;height=56&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=112&amp;originWidth=667&amp;size=15746&amp;status=done&amp;style=none&amp;width=333.5" alt="image.png" /><br />根据调试，先进入到了CachingExecutor的实现方法中。<br />获得实现方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">    CacheKey key = <span class="keyword">this</span>.createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中BoundSql负责将复杂的标签类似于if、where转换为普通的SQL语句。CacheKey是本次查询操作计算出来的缓存键。<br />继续跟踪query语句得到源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.flushCacheIfRequired(ms);</span><br><span class="line">        <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.ensureNoOutParams(ms, boundSql);</span><br><span class="line">            List&lt;E&gt; list = (List)<span class="keyword">this</span>.tcm.getObject(cache, key);</span><br><span class="line">            <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">                list = <span class="keyword">this</span>.delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">                <span class="keyword">this</span>.tcm.putObject(cache, key, list);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里先判断缓存是否命中，如果命中则直接从缓存中拿取数据结果。否则，将调用delegate的query语句。<br />这里假设没有命中，继续进行调试。发现现在进入到了BaseExecutor的query实现方法中。<br />获得其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.closed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.clearLocalCache();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List list;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ++<span class="keyword">this</span>.queryStack;</span><br><span class="line">            list = resultHandler == <span class="keyword">null</span> ? (List)<span class="keyword">this</span>.localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                list = <span class="keyword">this</span>.queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            --<span class="keyword">this</span>.queryStack;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">            Iterator var8 = <span class="keyword">this</span>.deferredLoads.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var8.hasNext()) &#123;</span><br><span class="line">                BaseExecutor.DeferredLoad deferredLoad = (BaseExecutor.DeferredLoad)var8.next();</span><br><span class="line">                deferredLoad.load();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.deferredLoads.clear();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">                <span class="keyword">this</span>.clearLocalCache();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里逻辑比较复杂，根据调试执行到语句：<code>list = this.queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</code>中，获得源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.localCache.putObject(key, ExecutionPlaceholder.EXECUTION_PLACEHOLDER);</span><br><span class="line"></span><br><span class="line">    List list;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        list = <span class="keyword">this</span>.doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.localCache.removeObject(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.localCache.putObject(key, list);</span><br><span class="line">    <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">        <span class="keyword">this</span>.localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，这里先在缓存中放入了一个占位符，然后执行了doQuery方法查询到结果后将缓存中的数据替换为了真的结果集。<br />根据调试获得doQuery源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    List var9;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Configuration configuration = ms.getConfiguration();</span><br><span class="line">        StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>.wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        stmt = <span class="keyword">this</span>.prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">        var9 = handler.query(stmt, resultHandler);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法生成了Statement的对象stmt，这个Statement并非Mybatis的类，而是java.sql的类，Statement能执行静态的SQL语句并返回结果。继续追踪query语句得到源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    PreparedStatement ps = (PreparedStatement)statement;</span><br><span class="line">    ps.execute();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将Statement转换成了PreparedStatement类，然后执行了execute方法来进行数据库查询。这里的操作与JDBC操作一致。查询过后将PreparedStatement的对象传入到handleResultSets方法中从而完成了整个查找的过程。<br />此时，数据库中已经出现了SQL的查询语句：<br /><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601296041530-eafc98c9-32f5-4611-9148-ef2eac2db67b.png#align=left&amp;display=inline&amp;height=64&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=128&amp;originWidth=1202&amp;size=155994&amp;status=done&amp;style=none&amp;width=601" alt="image.png" /></strong><br /><a name="f7Y3A"></a></p><h4 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h4><p>查询过程涉及的步骤较多，这里进行流程的梳理：</p><ul><li>查询前先查询Mybatis的缓存，如果缓存未命中的话才进行查询，并且将查询后将结果存入到Mybatis的缓存中。</li><li>SQL语句经过了层层转化，依次经过了MappedStatement对象、Statement对象、PreparedStatement对象以后再执行基本的JDBC的操作。</li><li>查询后将结果交给ResultHandler对象处理。<br /><a name="8wBe0"></a></li></ul><h3 id="结果集的处理"><a class="markdownIt-Anchor" href="#结果集的处理"></a> 结果集的处理</h3><p>继续追踪<code>return this.resultSetHandler.handleResultSets(ps);</code>语句得到源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().activity(<span class="string">&quot;handling results&quot;</span>).object(<span class="keyword">this</span>.mappedStatement.getId());</span><br><span class="line">    List&lt;Object&gt; multipleResults = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">int</span> resultSetCount = <span class="number">0</span>;</span><br><span class="line">    ResultSetWrapper rsw = <span class="keyword">this</span>.getFirstResultSet(stmt);</span><br><span class="line">    List&lt;ResultMap&gt; resultMaps = <span class="keyword">this</span>.mappedStatement.getResultMaps();</span><br><span class="line">    <span class="keyword">int</span> resultMapCount = resultMaps.size();</span><br><span class="line">    <span class="keyword">this</span>.validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(rsw != <span class="keyword">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">        ResultMap resultMap = (ResultMap)resultMaps.get(resultSetCount);</span><br><span class="line">        <span class="keyword">this</span>.handleResultSet(rsw, resultMap, multipleResults, (ResultMapping)<span class="keyword">null</span>);</span><br><span class="line">        rsw = <span class="keyword">this</span>.getNextResultSet(stmt);</span><br><span class="line">        <span class="keyword">this</span>.cleanUpAfterHandlingResultSet();</span><br><span class="line">        ++resultSetCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] resultSets = <span class="keyword">this</span>.mappedStatement.getResultSets();</span><br><span class="line">    <span class="keyword">if</span> (resultSets != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(rsw != <span class="keyword">null</span> &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</span><br><span class="line">            ResultMapping parentMapping = (ResultMapping)<span class="keyword">this</span>.nextResultMaps.get(resultSets[resultSetCount]);</span><br><span class="line">            <span class="keyword">if</span> (parentMapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">                String nestedResultMapId = parentMapping.getNestedResultMapId();</span><br><span class="line">                ResultMap resultMap = <span class="keyword">this</span>.configuration.getResultMap(nestedResultMapId);</span><br><span class="line">                <span class="keyword">this</span>.handleResultSet(rsw, resultMap, (List)<span class="keyword">null</span>, parentMapping);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rsw = <span class="keyword">this</span>.getNextResultSet(stmt);</span><br><span class="line">            <span class="keyword">this</span>.cleanUpAfterHandlingResultSet();</span><br><span class="line">            ++resultSetCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.collapseSingleResultList(multipleResults);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法将查询出来的结果遍历后放入到multipleResults中并返回，其中multipleResults就是最终想要拿到的List<User>。<br />根据调试绘制出调用链路图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601296641320-b0592228-f64c-47e9-beff-88d78c777d92.png#align=left&amp;display=inline&amp;height=392&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=784&amp;originWidth=1166&amp;size=997528&amp;status=done&amp;style=none&amp;width=583" alt="image.png" /><br />其中三个重要方法如下：</p><ul><li>createResultObject：该方法创建了输出结果对象，即User。</li><li>applyAutomaticMappings：在自动属性映射功能开启情况下，将数据赋值给输出结果对象。</li><li>applyPropertyMappings：按照用户的映射设置，将数据赋值给输出结果对象。<br /><a name="zqWeY"></a></li></ul><h2 id="运行过程总结"><a class="markdownIt-Anchor" href="#运行过程总结"></a> 运行过程总结</h2><p>梳理完执行流程，这里进行一下Mybatis工作概述：</p><ul><li>建立数据库的SqlSession。</li><li>查找当前映射接口中的抽象方法对应数据库操作节点，根据节点生成接口代理类对象（实现）。</li><li>接口的实现拦截对映射接口中抽象方法的调用，并将其转换成数据查询操作。</li><li>对数据库操作节点中的数据库操作语句进行多次处理，最终得到标准的SQL语句。</li><li>尝试从缓存查找结果，如果找到则返回，找不到则继续从数据库中查找。</li><li>从数据库中查询结果。</li><li>处理结果集<ul><li>建立输出对象</li><li>根据输出结果对输出对象赋值。</li></ul></li><li>在缓存中存储查询结果。</li><li>返回查询结果。</li></ul><p>显然，数据库操作是相当耗时的，因此开发中要尽量减少对数据库的操作。<br /><a name="LcX17"></a></p><h1 id="mybatis的源码结构概述"><a class="markdownIt-Anchor" href="#mybatis的源码结构概述"></a> Mybatis的源码结构概述</h1><p>在开始分析Mybatis包之前，首先要知道Mybatis的包如何划分。其划分标准如下：</p><ul><li>按照类型划分，例如将所有接口类型放入一个包。这种分类方式从类型上看更为清晰，但是会导致一个功能的多个类分散到不同的包中，不利于模块化开发。</li><li>按照功能方式划分，例如将所有与加/解密有关的类放入一个包。这种分类方式下，同一个功能的类内聚性高，便于模块化开发，但是也会导致同一包内的类型混乱。</li></ul><p>Mybatis按照类型划分出了exceptions、annotations等包，按照功能划分出了基础功能包、配置解析包、核心操作包。<br />Mybatis包结构如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601297882858-2a28fea0-a867-4e7d-8b48-94f486a80e14.png#align=left&amp;display=inline&amp;height=286&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=572&amp;originWidth=244&amp;size=54153&amp;status=done&amp;style=none&amp;width=122" alt="image.png" /><br />按照包功能划分三大类：</p><ul><li>基础功能包：提供外围基础功能，如文件读取、反射等。该类包的特点就是相对独立，与业务耦合小。</li><li>配置解析包：完成配置解析、存储等工作。该类包主要在系统初始化阶段运行。</li><li>核心操作包：这些包完成数据库的操作。在工作过程中，其可能会依赖基础功能包提供的基础功能和配置解析包提供的配置信息。该类包一般在数据库操作阶段运行。</li></ul><p>划分如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601298118046-f9f00e1d-3b4a-4516-a5b2-9f60c606ab9b.png#align=left&amp;display=inline&amp;height=334&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=667&amp;originWidth=248&amp;size=187071&amp;status=done&amp;style=none&amp;width=124" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1601298179631-2fe38c26-eeb7-432b-b83f-4b3226be9aeb.png#align=left&amp;display=inline&amp;height=362&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=724&amp;originWidth=957&amp;size=722888&amp;status=done&amp;style=none&amp;width=478.5" alt="image.png" /></p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hashMap 核心与原理分析</title>
      <link href="/posts/hashmap/"/>
      <url>/posts/hashmap/</url>
      
        <content type="html"><![CDATA[<p><a name="KYF8R"></a></p><h1 id="实现概述"><a class="markdownIt-Anchor" href="#实现概述"></a> 实现概述</h1><p>首先明确HashMap是数组+链表+红黑树的形式存储的。<br />存储数据的数组的类型是内部Node类，在resize方法可以找到：<code>new HashMap.Node[newCap];</code><br />在添加元素是首先会计算key的hash值，并根据hash值找数组对应的下标：<code>p = tab[i = n - 1 &amp; hash]</code><br />如果该位置目前并没有元素，则直接将该元素放入数组中：<br /><code>tab[i] = this.newNode(hash, key, value, (HashMap.Node)null)</code><br />如果该位置有元素，则把新的元素加入到链表中：<br /><code>((HashMap.Node)e).value = value;</code><br />当元素的长度超过阈值时，链表则会转换为红黑树（转换为红黑树还需要满足其他的条件，链表长度达到阈值只是其中的一个条件）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount &gt;= <span class="number">7</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.treeifyBin(tab, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法是为了减少哈希的碰撞概率，最极端的情况就是，当所有的元素都具有相同的哈希值，那么HashMap会退化为一个链表，查找时间也从O(1)上升到O(N)。实现了红黑树后使用哈希值作为树的分支变量，如果两个哈希值不等，但指向同一个桶的话，较大的那个会插入到右子树里。如果哈希值相等，HashMap希望key值最好是实现了Comparable接口的，这样它可以按照顺序来进行插入。<br /><a name="nqo7k"></a></p><h1 id="加载阶段源码分析"><a class="markdownIt-Anchor" href="#加载阶段源码分析"></a> 加载阶段源码分析</h1><p><a name="tEq1K"></a></p><h2 id="类的定义及属性"><a class="markdownIt-Anchor" href="#类的定义及属性"></a> 类的定义及属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1073741824</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75F</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">transient</span> HashMap.Node&lt;K, V&gt;[] table;</span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Entry&lt;K, V&gt;&gt; entrySet;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p>HashMap继承自AbstractMap，实现了Map、Cloneable、Serializable接口。</p><ul><li>Table数组的初始化长度是DEFAULT_INITIAL_CAPACITY（16）</li><li>Table数组最大长度MAXIMUM_CAPACITY（1073741824）</li><li>默认的加载因子是DEFAULT_LOAD_FACTOR（0.75）（即当HashMap存储的元素超过初始值与加载因子的乘积时HashMap会进行扩容，即默认超过16*0.75=12时会进行扩容）</li><li>当链表长度超过TREEIFY_THRESHOLD（8）时会转化为红黑树</li><li>当红黑树resize时发现长度小于UNTREEIFY_THRESHOLD（6）时转换回链表</li><li>当Table数组的长度超过了MIN_TREEIFY_CAPACITY（64）才会进行树化（为了防止前期阶段频繁扩容和树化过程冲突）<br /><a name="7XXmp"></a></li></ul><h2 id="node内部类"><a class="markdownIt-Anchor" href="#node内部类"></a> Node内部类</h2><p>其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    HashMap.Node&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法略</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// setter、getter略</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Entry) &#123;</span><br><span class="line">                Entry&lt;?, ?&gt; e = (Entry)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(<span class="keyword">this</span>.key, e.getKey()) &amp;&amp; Objects.equals(<span class="keyword">this</span>.value, e.getValue())) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，这是一个单向链表。HashMap中用一个数组table来存储这个单向链表，每⼀个键值对组成了⼀个Entry实体。<br /><a name="qvqn5"></a></p><h3 id="链表数组作用"><a class="markdownIt-Anchor" href="#链表数组作用"></a> 链表+数组作用</h3><p>由于数组的值是限制死的，在对key值进行散列取到下标以后，放入到数组中时，难免出现两个key值不同，但是却放入到下标相同的数组格子中，此时就可以使用链表来对其进行链式的存放，形成样式如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1603088089108-229ccb63-9329-48e7-a3ea-0bc57259a002.png#align=left&amp;display=inline&amp;height=102&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=151&amp;originWidth=589&amp;size=28790&amp;status=done&amp;style=none&amp;width=397" alt="image.png" /><br /><a name="fXmoN"></a></p><h4 id="为什么不用arraylist代替数组"><a class="markdownIt-Anchor" href="#为什么不用arraylist代替数组"></a> 为什么不用ArrayList代替数组</h4><p>原因很简单，因为数组的自由度高，可让HashMap任由摆布。<br /><a name="wWG1z"></a></p><h2 id="hashmap构造方法"><a class="markdownIt-Anchor" href="#hashmap构造方法"></a> HashMap构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法类型一</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (initialCapacity &gt; <span class="number">1073741824</span>) &#123;</span><br><span class="line">                initialCapacity = <span class="number">1073741824</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (loadFactor &gt; <span class="number">0.0F</span> &amp;&amp; !Float.isNaN(loadFactor)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">                <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 构造方法类型二</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, <span class="number">0.75F</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 构造方法类型三</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = <span class="number">0.75F</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 构造方法类型四</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = <span class="number">0.75F</span>;</span><br><span class="line">        <span class="keyword">this</span>.putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这几个方法主要完成了加载因子的赋值和容器大小的限定，之所以限定容器大小是因为HashMap的容量始终都是2的次幂，所以当我们传入一个指定的容量时，还会调用一个tableSizeFor(int cap)方法来计算容量的大小。<br /><a name="1cxSr"></a></p><h1 id="放入取出源码分析"><a class="markdownIt-Anchor" href="#放入取出源码分析"></a> 放入/取出源码分析</h1><p><a name="QmFkQ"></a></p><h2 id="放入"><a class="markdownIt-Anchor" href="#放入"></a> 放入</h2><p>putVal源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">     HashMap.Node[] tab;</span><br><span class="line">     <span class="keyword">int</span> n;</span><br><span class="line">     <span class="comment">// 数组为空时进行扩容，显然，resize的第一次运行是在这里开始的</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = <span class="keyword">this</span>.table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">         n = (tab = <span class="keyword">this</span>.resize()).length;</span><br><span class="line">     &#125;</span><br><span class="line">     Object p;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="comment">// 当数组当前对象为空时直接创建一个新的节点放入</span></span><br><span class="line">     <span class="keyword">if</span> ((p = tab[i = n - <span class="number">1</span> &amp; hash]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">         tab[i] = <span class="keyword">this</span>.newNode(hash, key, value, (HashMap.Node)<span class="keyword">null</span>);</span><br><span class="line">     <span class="comment">// 如果当前位置非空，产生哈希冲突</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         Object e;</span><br><span class="line">         Object k;</span><br><span class="line">         <span class="comment">// key也完全相等</span></span><br><span class="line">         <span class="keyword">if</span> (((HashMap.Node)p).hash == hash &amp;&amp; ((k = ((HashMap.Node)p).key) == key || key != <span class="keyword">null</span> &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">             e = p;</span><br><span class="line">         <span class="comment">// 判断当前是否是红黑树</span></span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> HashMap.TreeNode) &#123;</span><br><span class="line">             e = ((HashMap.TreeNode)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                 <span class="comment">// 遍历到链表尾部把当前值加进去</span></span><br><span class="line">                 <span class="keyword">if</span> ((e = ((HashMap.Node)p).next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     ((HashMap.Node)p).next = <span class="keyword">this</span>.newNode(hash, key, value, (HashMap.Node)<span class="keyword">null</span>);</span><br><span class="line">                     <span class="comment">// 如果达到阈值则进入treeifyBin方法判断64的阈值，如果没达到则只进行扩容</span></span><br><span class="line">                     <span class="comment">// 如果table容量达到64的阈值，则将该单向链表转化为红黑树</span></span><br><span class="line">                     <span class="keyword">if</span> (binCount &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">                         <span class="keyword">this</span>.treeifyBin(tab, hash);</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line"><span class="comment">// 如果key值重复</span></span><br><span class="line">                 <span class="keyword">if</span> (((HashMap.Node)e).hash == hash &amp;&amp; ((k = ((HashMap.Node)e).key) == key || key != <span class="keyword">null</span> &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 p = e;</span><br><span class="line">                 ++binCount;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">// 如果key相同则覆盖value，并返回value</span></span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">             V oldValue = ((HashMap.Node)e).value;</span><br><span class="line">             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 ((HashMap.Node)e).value = value;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">this</span>.afterNodeAccess((HashMap.Node)e);</span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ++<span class="keyword">this</span>.modCount;</span><br><span class="line">     <span class="comment">// 数组扩容检测</span></span><br><span class="line">     <span class="keyword">if</span> (++<span class="keyword">this</span>.size &gt; <span class="keyword">this</span>.threshold) &#123;</span><br><span class="line">         <span class="keyword">this</span>.resize();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">this</span>.afterNodeInsertion(evict);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><a name="TsfWv"></a></p><h3 id="put总结"><a class="markdownIt-Anchor" href="#put总结"></a> put总结</h3><p>以上一共经历了如下几个关键步骤：</p><ul><li>对key的hashCode做哈希运算，计算出index脚标。</li><li>判断是否碰撞？如果未碰撞则直接生成链表放入数组</li><li>如果碰撞，比较key是否存在，如果不存在加入到之前的链表的next的位置</li><li>如果不存在则替换value返回oldvalue</li><li>判断链表是否过长，如果是就判断数组是否达到64的阈值，如果达到了则转换为红黑树。</li><li>如果没达到则resize。</li></ul><p><a name="JIpkU"></a></p><h2 id="获取"><a class="markdownIt-Anchor" href="#获取"></a> 获取</h2><p>getNode源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap.<span class="function">Node&lt;K, V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    HashMap.Node[] tab;</span><br><span class="line">    HashMap.Node first;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// 判断table数组不为空，找到第一个插入的node</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = <span class="keyword">this</span>.table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (first = tab[n - <span class="number">1</span> &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">// 判断第一个是不是想要的节点</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; ((k = first.key) == key || key != <span class="keyword">null</span> &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap.Node e;</span><br><span class="line">        <span class="comment">// 第二个节点不为空</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是红黑树存储</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> HashMap.TreeNode) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((HashMap.TreeNode)first).getTreeNode(hash, key);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 遍历链表</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key != <span class="keyword">null</span> &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span>((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>get的过程和put可以对比来看，其会先获取可以的hash值，并计算得到此key在数组中的位置，如果first节点不是需要获取的key，则往下遍历，直到找到需要获取的键值，并返回对应的value即可。<br /><a name="mjoyu"></a></p><h1 id="扩容机制"><a class="markdownIt-Anchor" href="#扩容机制"></a> 扩容机制</h1><p>当HashMap中的元素越来越多的时候，因为数组的长度是固定的，所以产生哈希冲突的几率也就越来越大。为了减小哈希冲突的几率，同时也是为了提高查询效率，就需要对HashMap适当的进行扩容。扩容不是达到数字7就开始扩容，或者产生哈希冲突就开始扩容，而是需要满足一定条件才开始扩容，比如：</p><ul><li>达到table.length * loadFactory时。</li><li>多次碰撞后达到链表阈值8且table小于64时。</li><li>等等</li></ul><p>总之，扩容是个耗时的操作，扩容后的大小一般为之前的两倍。resize源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap.Node&lt;K, V&gt;[] resize() &#123;</span><br><span class="line">       <span class="comment">// 存储旧table</span></span><br><span class="line">       HashMap.Node&lt;K, V&gt;[] oldTab = <span class="keyword">this</span>.table;</span><br><span class="line">       <span class="keyword">int</span> oldCap = oldTab == <span class="keyword">null</span> ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="keyword">int</span> oldThr = <span class="keyword">this</span>.threshold;</span><br><span class="line">       <span class="keyword">int</span> newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> newCap;</span><br><span class="line">       <span class="comment">// 旧数组不为空</span></span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果旧数组容量大于1073741824</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= <span class="number">1073741824</span>) &#123;</span><br><span class="line">               <span class="comment">// 将阈值扩大到Int MAX</span></span><br><span class="line">               <span class="keyword">this</span>.threshold = <span class="number">2147483647</span>;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">// 如果旧数组没有达到最大值，但是大鱼初始值</span></span><br><span class="line">           <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; <span class="number">1073741824</span> &amp;&amp; oldCap &gt;= <span class="number">16</span>) &#123;</span><br><span class="line">               <span class="comment">// 扩容两倍</span></span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       <span class="comment">// 阈值大于0</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 将hash表的长度设为阈值大小</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       <span class="comment">// 未初始化，table为空</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           newCap = <span class="number">16</span>;</span><br><span class="line">           newThr = <span class="number">12</span>;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">// 如果阈值等于0</span></span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 重新计算阈值</span></span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * <span class="keyword">this</span>.loadFactor;</span><br><span class="line">           newThr = newCap &lt; <span class="number">1073741824</span> &amp;&amp; ft &lt; <span class="number">1.07374182E9F</span> ? (<span class="keyword">int</span>)ft : <span class="number">2147483647</span>;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">// 存储阈值</span></span><br><span class="line">       <span class="keyword">this</span>.threshold = newThr;</span><br><span class="line">       <span class="comment">// 创建新数组</span></span><br><span class="line">       HashMap.Node&lt;K, V&gt;[] newTab = <span class="keyword">new</span> HashMap.Node[newCap];</span><br><span class="line">       <span class="comment">// 扩容替换</span></span><br><span class="line">       <span class="keyword">this</span>.table = newTab;</span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 遍历旧数组</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               HashMap.Node e;</span><br><span class="line">               <span class="comment">// 如果当前位置不为空</span></span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="comment">// 如果下个链表为空</span></span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">// 重新放置该链表位置</span></span><br><span class="line">                       newTab[e.hash &amp; newCap - <span class="number">1</span>] = e;</span><br><span class="line">                    <span class="comment">// 如果当前链表是红黑树</span></span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> HashMap.TreeNode) &#123;</span><br><span class="line">                       <span class="comment">// 把新的hash表也变为红黑树</span></span><br><span class="line">                       ((HashMap.TreeNode)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="comment">// 保留旧hash表中的链表</span></span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       HashMap.Node&lt;K, V&gt; loHead = <span class="keyword">null</span>;</span><br><span class="line">                       HashMap.Node&lt;K, V&gt; loTail = <span class="keyword">null</span>;</span><br><span class="line">                       HashMap.Node&lt;K, V&gt; hiHead = <span class="keyword">null</span>;</span><br><span class="line">                       HashMap.Node hiTail = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                       HashMap.Node next;</span><br><span class="line">                       <span class="comment">// 遍历当前Table的node，赋值给新的table</span></span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="comment">// 将节点分为两类，e.hash &amp; oldCap为0和e.hash &amp; oldCap为1</span></span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               &#125;</span><br><span class="line"></span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               &#125;</span><br><span class="line"></span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line"></span><br><span class="line">                           e = next;</span><br><span class="line">                       &#125; <span class="keyword">while</span>(next != <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 将为0的索引链放入到newTab[j]中</span></span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line"><span class="comment">// 将为1的索引链放入到newTab[j + oldCap]中</span></span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><a name="HGy1Y"></a></p><h1 id="包含算法"><a class="markdownIt-Anchor" href="#包含算法"></a> 包含算法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 零散知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之I/O设备</title>
      <link href="/posts/operating_system_input/output/"/>
      <url>/posts/operating_system_input/output/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统之io设备"><a class="markdownIt-Anchor" href="#操作系统之io设备"></a> 操作系统之I/O设备</h1><p><a name="R8WGO"></a></p><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>I/O就是输入输出，IO设备就是可以将数据输入到计算机或者接收计算机输出数据的外部设备，属于计算机的硬件部分。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599968367174-ce374900-829a-440a-b005-751be266ad40.png#align=left&amp;display=inline&amp;height=208&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=265&amp;originWidth=601&amp;size=142776&amp;status=done&amp;style=none&amp;width=471" alt="image.png" /><br />UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。<br /><a name="Pqlyz"></a></p><h2 id="io设备分类"><a class="markdownIt-Anchor" href="#io设备分类"></a> I/O设备分类</h2><p>I/O设备分类可以用三种分类方法，分别是按照使用特性分、按照传输速率分和按照信息交换的单位划分。<br /><a name="sy7UT"></a></p><h3 id="使用特性划分"><a class="markdownIt-Anchor" href="#使用特性划分"></a> 使用特性划分</h3><p>使用特性划分又可以分为人机交互类外部设备、存储设备和网络通信设备。<br />其中人机交互外部设备传输速率最慢，存储设备最快，网络通信设备适中。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599968632250-639b0214-2afa-47d2-afdb-215801e2c906.png#align=left&amp;display=inline&amp;height=175&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=249&amp;originWidth=758&amp;size=127098&amp;status=done&amp;style=none&amp;width=534" alt="image.png" /><br /><a name="jzEZA"></a></p><h3 id="按传输速率分"><a class="markdownIt-Anchor" href="#按传输速率分"></a> 按传输速率分</h3><p>按传输速率可以划分为低速、中速和高速设备。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599968697833-83e501eb-8aad-4c44-82d8-35c30922b2ee.png#align=left&amp;display=inline&amp;height=176&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=236&amp;originWidth=711&amp;size=97506&amp;status=done&amp;style=none&amp;width=529" alt="image.png" /><br /><a name="HuyHU"></a></p><h3 id="按信息交换单位分"><a class="markdownIt-Anchor" href="#按信息交换单位分"></a> 按信息交换单位分</h3><p>按信息交换单位可划分为块设备和字符设备。<br />其中块设备传输速率高，可寻址即对它可随机的读、写任一块。<br />字符设备传输速率较慢，不可寻址，在输入输出时常采用中断驱动方式。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599968831902-3dac54e2-824f-4267-8a8c-c2ff23bc3de6.png#align=left&amp;display=inline&amp;height=176&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=205&amp;originWidth=505&amp;size=64478&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br /><a name="usnYz"></a></p><h1 id="io控制器"><a class="markdownIt-Anchor" href="#io控制器"></a> I/O控制器</h1><p><a name="3UjyR"></a></p><h2 id="io控制器的组成"><a class="markdownIt-Anchor" href="#io控制器的组成"></a> I/O控制器的组成</h2><p>I/O设备由机械部件和电子部件组成。<br /><a name="WAuJP"></a></p><h3 id="机械部件"><a class="markdownIt-Anchor" href="#机械部件"></a> 机械部件</h3><p>I/O设备的机械部件主要用来执行具体的I/O操作。如常见的鼠标、键盘、LED显示屏、移动硬盘的磁臂、磁盘盘面等。<br />I/O设备的电子部件通常是一块插入主板扩充槽的印刷电路板。<br /><a name="hU5BX"></a></p><h3 id="电子部件"><a class="markdownIt-Anchor" href="#电子部件"></a> 电子部件</h3><p>CPU无法直接控制I/O设备的机械部件，因此还要有一个电子部件作为CPU和I/O设备机械部件之间的中介，用于实现CPU对设备的控制。这个部件就是I/O控制器，又称设备控制器。CPU可控制I/O控制器，又由I/O控制器来控制设备的机械部件。<br /><a name="U4Itp"></a></p><h2 id="io控制器的功能"><a class="markdownIt-Anchor" href="#io控制器的功能"></a> I/O控制器的功能</h2><p>其总共拥有如下四个功能：<br /><a name="LyVyY"></a></p><h3 id="接受和识别cpu发出的命令"><a class="markdownIt-Anchor" href="#接受和识别cpu发出的命令"></a> 接受和识别CPU发出的命令</h3><p>如CPU发来的read/wirte命令，I/O控制器会有相应的控制寄存器来存放命令和参数。<br /><a name="eNGL4"></a></p><h3 id="向cpu报告设备的状态"><a class="markdownIt-Anchor" href="#向cpu报告设备的状态"></a> 向CPU报告设备的状态</h3><p>I/O控制器中会有相应的状态寄存器用于记录I/O设备的当前状态，如：1表示空闲，0表示忙碌。<br /><a name="ej9OQ"></a></p><h3 id="数据交换"><a class="markdownIt-Anchor" href="#数据交换"></a> 数据交换</h3><p>I/O控制器中会设置相应的数据寄存器。输出时，数据寄存器用于暂存CPU发来的数据，之后再由控制器发送设备。输入时，数据寄存器用于暂存设备发来的数据，之后CPU从寄存器中取走数据。<br /><a name="F7o7e"></a></p><h3 id="地址识别"><a class="markdownIt-Anchor" href="#地址识别"></a> 地址识别</h3><p>类似于内存的地址，为了区分设备控制器中的各个寄存器，也许要给各个寄存器，也许要给各个寄存器设置一个特定的地址。I/O控制器通过CPU提供的地址来判断CPU要读写的是哪个寄存器。<br /><a name="lU3Kc"></a></p><h2 id="io控制器结构"><a class="markdownIt-Anchor" href="#io控制器结构"></a> I/O控制器结构</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599975121635-a454816f-d2e3-43c1-ba3a-ff9bb15f2bca.png#align=left&amp;display=inline&amp;height=305&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=432&amp;originWidth=734&amp;size=154862&amp;status=done&amp;style=none&amp;width=519" alt="image.png" /><br />注意：</p><ol><li>一个I/O控制器可能会对应多个设备。</li><li>数据寄存器、控制寄存器、状态寄存器可能有多个（如：每个控制器/状态寄存器对应一个具体的设备），且这些寄存器都要有对应的地址才方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为内存映像I/O。其他计算机采用I/O专用地址，即寄存器独立编址。<br /><a name="2FssT"></a></li></ol><h3 id="内存映像io和寄存器独立编址"><a class="markdownIt-Anchor" href="#内存映像io和寄存器独立编址"></a> 内存映像I/O和寄存器独立编址</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599975544113-b4559ee0-5a37-4bb4-85f2-29e720571d3a.png#align=left&amp;display=inline&amp;height=309&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=364&amp;originWidth=723&amp;size=129477&amp;status=done&amp;style=none&amp;width=613" alt="image.png" /><br /><a name="gHL5Q"></a></p><h1 id="io控制方式"><a class="markdownIt-Anchor" href="#io控制方式"></a> I/O控制方式</h1><p>I/O设备的数据读写有如下四种控制方式：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599975696963-f4925b66-f5d2-47a6-ad99-685e46f6f713.png#align=left&amp;display=inline&amp;height=136&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=271&amp;originWidth=226&amp;size=36116&amp;status=done&amp;style=none&amp;width=113" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599978106061-da85f714-6b79-4afd-a17f-cb1966b00922.png#align=left&amp;display=inline&amp;height=287&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=416&amp;originWidth=808&amp;size=210679&amp;status=done&amp;style=none&amp;width=557" alt="image.png" /><br /><a name="hoWfu"></a></p><h2 id="程序直接控制方式"><a class="markdownIt-Anchor" href="#程序直接控制方式"></a> 程序直接控制方式</h2><p>以读操作为例，其操作流程如下：</p><ol><li>CPU向控制器发出指令， 于是设备启动并且状态寄存器设为1.</li><li>轮询检查控制器的状态（即不断的执行程序的循环，若状态位一直是1，说明设备还没准备好要输入数据，因此CPU会不断的轮询检查）</li><li>输入设备准备好数据后将数据传送给控制器并报告自身状态。</li><li>控制器将数据放入数据寄存器中，并将状态改为0（已就绪）</li><li>CPU发现设备已经就绪，于是将数据寄存器中的内容读入到CPU的寄存器中，然后把CPU寄存器中的内容放入到内存。</li><li>如还要继续读出擦操作，CPU继续发出指令。</li></ol><p>程序代码：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599976036806-53554c79-0492-41fd-b4f8-d44c8690bf74.png#align=left&amp;display=inline&amp;height=243&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=340&amp;originWidth=422&amp;size=110283&amp;status=done&amp;style=none&amp;width=301" alt="image.png" /><br />流程图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599976108878-a1b5ab64-6092-48f3-935f-6dfded44f4a9.png#align=left&amp;display=inline&amp;height=436&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=452&amp;originWidth=361&amp;size=87531&amp;status=done&amp;style=none&amp;width=348" alt="image.png" /><br /><a name="d4o23"></a></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>该方法实现简单，加上实现循环检查的一系列指令即可（因此称为“程序直接控制方式”）<br />数据流向：<br />读操作（数据输入）：I/O设备-&gt;CPU-&gt;内存<br />写操作（数据输出）：内存-&gt;CPU-&gt;I/O设备<br />显然，每次读写都需要CPU的帮助<br />CPU干预很频繁，I/O操作开始之前、完成之后需要CPU介入，甚至在等待I/O完成过程中CPU还需要不断地轮询检查。每次读/写仅操作一个字。<br />因此，其缺点是CPU和I/O设备只能串行工作，CPU需要一直轮询检查，长期忙等，CPU利用率低。<br /><a name="Nmoyj"></a></p><h2 id="中断驱动方式"><a class="markdownIt-Anchor" href="#中断驱动方式"></a> 中断驱动方式</h2><p>引入中断机制，用于I/O设备速度慢，因此CPU发出读/写命令后可将等待I/O的进程阻塞，先切换到别的进程执行。当I/O完成后，控制器回向CPU发送一个中断信号，CPU检测到中断信号后会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。处理中断的过程中，CPU从I/O设备控制器读一个字的数据传送到CPU寄存器，在写入主存。接着，CPU恢复等待I/O的进程（或其他进程）的运行环境然后再执行。<br />注意：</p><ul><li>CPU会在每个指令周期的末尾检查中断</li><li>中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。显然，如果中断发生频率太高也会降低系统性能。</li></ul><p>流程图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599976855535-189473c7-b158-40ae-8073-a0888da39623.png#align=left&amp;display=inline&amp;height=327&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=413&amp;originWidth=294&amp;size=38172&amp;status=done&amp;style=none&amp;width=233" alt="image.png" /><br /><a name="8zZOs"></a></p><h3 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3><p>与程序直接控制方式相比，在中断驱动方式中，I/O控制器会通过中断信号主动报告I/O已完成，CPU不需要不断的轮询。CPU和I/O设备可以并行工作，CPU利用率显著提升。<br />每次I/O操作开始之前、完成之后需要CPU接入，等待I/O完成的过程中CPU可以切换到其他的进程执行。每次读/写一个字。<br />数据流向：<br />读操作（数据输入）：I/O设备-&gt;CPU-&gt;内存<br />写操作（数据输出）：内存-&gt;CPU-&gt;I/O设备<br />综上，其缺点为：每个字在I/O设备之间的传输都需要经过CPU，而频繁的中断处理会消耗比较多的CPU时间。<br /><a name="wGGr8"></a></p><h2 id="dma方式"><a class="markdownIt-Anchor" href="#dma方式"></a> DMA方式</h2><p>与中断驱动方式相比，DMA方式（Direct Memory Access，直接存储器存储，主要用于设备的I/O控制）有如下几个改进：</p><ul><li>数据传送单位是“块”</li><li>数据的流向是从设备直接放入内存或者从内存直接到设备。不再需要CPU中转。</li><li>仅在传送一个或多个数据块的开始或结束时才需要CPU的干预。</li></ul><p>流程图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599977296598-7e08c259-db46-4f10-be55-dfe0adfc6b84.png#align=left&amp;display=inline&amp;height=151&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=247&amp;originWidth=722&amp;size=100367&amp;status=done&amp;style=none&amp;width=440" alt="image.png" /><br /><a name="Okh5p"></a></p><h3 id="dma控制器"><a class="markdownIt-Anchor" href="#dma控制器"></a> DMA控制器</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599977354856-7129c428-4315-4a13-b2de-f3c4b625538d.png#align=left&amp;display=inline&amp;height=171&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=264&amp;originWidth=814&amp;size=43625&amp;status=done&amp;style=none&amp;width=527" alt="image.png" /><br />DR（Data Register 数据寄存器）：暂存从设备到内存或从内存到设备的数据。<br />MAR（Memory Address Register，内存地址寄存器）：在输入时，MAR表示数据应该放在内存的什么位置，输出时MAR表示要输出的数据放在内存中的什么位置。<br />DC（Data Counter 数据计数器）：表示剩余要读/写的字节数。<br />CR（Command Register，命令/状态寄存器）：用于存放CPU发来的I/O命令，或设备的状态信息。<br /><a name="SrPpa"></a></p><h3 id="总结-3"><a class="markdownIt-Anchor" href="#总结-3"></a> 总结</h3><p>数据以块为单位，CPU介入频率进一步降低。数据的传输不再需要经过CPU再写入内存，数据传输效率进一步增加。CPU和I/O设备的并行性得到提升。<br />但是其缺点是CPU每发出一个I/O指令，只能读/写一个或多个连续的数据块，如果要读/写多个和离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条I/O指令，进行多次中断处理才能完成。<br /><a name="NC4lY"></a></p><h2 id="通道控制方法"><a class="markdownIt-Anchor" href="#通道控制方法"></a> 通道控制方法</h2><p>通道是一种硬件，可以当作简化版的CPU，其可以识别并执行一系列的通道指令。<br />执行流程如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599977910044-22291a90-235f-41b8-86d2-ff0a12534620.png#align=left&amp;display=inline&amp;height=237&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=361&amp;originWidth=804&amp;size=128319&amp;status=done&amp;style=none&amp;width=527" alt="image.png" /><br /><a name="Jy5Yp"></a></p><h3 id="总结-4"><a class="markdownIt-Anchor" href="#总结-4"></a> 总结</h3><p>与CPU相比通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与CPU共享内存。<br />在这个环境下CPU、通道、I/O设备可以并行的工作，资源利用率高。<br />但是实现比较复杂，需要专门的通道硬件支持。<br /><a name="VnpzA"></a></p><h1 id="软件的层次结构"><a class="markdownIt-Anchor" href="#软件的层次结构"></a> 软件的层次结构</h1><p>软件的层次结构如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599978167148-2e9de087-8903-4f66-8854-3bf9c8f2154e.png#align=left&amp;display=inline&amp;height=225&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=449&amp;originWidth=941&amp;size=153318&amp;status=done&amp;style=none&amp;width=470.5" alt="image.png" />   <br />直接涉及到硬件具体细节、且与终端无关的操作肯定是在设备驱动层完成的，没有设计硬件的、对各种设备都需要进行的管理工作都是在设备独立性软件层进行的。<br /><a name="6DhFd"></a></p><h2 id="用户层软件"><a class="markdownIt-Anchor" href="#用户层软件"></a> 用户层软件</h2><p>用户层软件实现了与用户交互的接口，用户可以直接使用该层提供的、与I/O操作相关的库函数对设备进行操作。例如：printf(“hello, world!”);<br />用户层软件将用户请求翻译成格式化的I/O请求，并通过“系统调用”请求操作系统内核的服务。例如：printf(“hello, world!”); 会被翻译成等价的write系统调用，当然，用户层软件也会在系统调用是填入相应的参数。<br />Windiws操作系统向外提供的一系列系统调用由于操作系统调用的格式严格、使用麻烦，因此在用户层上封装了一系列更方便的库函数接口供用户使用。<br /><a name="80AXY"></a></p><h2 id="设备独立性软件"><a class="markdownIt-Anchor" href="#设备独立性软件"></a> 设备独立性软件</h2><p>设备独立性软件又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。<br />其主要功能：</p><ul><li>向上层提供统一的调用接口，如read/write系统调用。</li><li>设备的保护，其原理类似于文件保护。设备被看做是一种特殊的文件，不同用户对各个文件的访问权限是不一样的，同理对设备的访问权限也是不一样的。</li><li>差错处理。设备独立性软件需要对一些设备的错误进行处理。</li><li>设备的分配与回收。</li><li>数据缓冲区管理。可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异。</li><li>建立逻辑设备名到物理设备名的映射关系，根据设备类型选择调用相应的驱动。<ul><li>用户或用户层软件发出I/O操作相关系统调用的系统调用时，需要指明此次要操作的I/O设备的逻辑设备名，例如打印机1、打印机2等等。</li><li>设备独立性软件需要通过“逻辑设备表（LUT,Logical Unit Table）”来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序。<br /><a name="0ef5w"></a></li></ul></li></ul><h3 id="逻辑设备表"><a class="markdownIt-Anchor" href="#逻辑设备表"></a> 逻辑设备表</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599978967376-4b5d6029-3358-40af-a728-6c094189ee02.png#align=left&amp;display=inline&amp;height=160&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=240&amp;originWidth=609&amp;size=64990&amp;status=done&amp;style=none&amp;width=405" alt="image.png" /><br />操作系统可以采用两种方式管理逻辑设备表（LUT）<br />第一种方式是整个系统只设置一张LUT，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单个用户的操作系统。<br />第二种方式是为每个用户设置一张LUT，各个用户使用的逻辑设备名称可以重复，是用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。<br /><a name="4LXUP"></a></p><h4 id="为什么需要不同的驱动程序"><a class="markdownIt-Anchor" href="#为什么需要不同的驱动程序"></a> 为什么需要不同的驱动程序</h4><p>对比下述两张图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599979254681-83b4afcd-0b23-4c56-ac69-9f3913bcec38.png#align=left&amp;display=inline&amp;height=301&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=463&amp;originWidth=847&amp;size=96217&amp;status=done&amp;style=none&amp;width=550" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599979306493-5eb3a1bc-b0bd-4e0f-8149-503e02e89e3b.png#align=left&amp;display=inline&amp;height=306&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=472&amp;originWidth=843&amp;size=110130&amp;status=done&amp;style=none&amp;width=546" alt="image.png" /><br />不同设备的内部硬件特性可能也不同，这些特性只有厂家才知道，因此厂家必须提供与设备相对应的驱动程序，CPU执行驱动程序的指令序列来完成设备寄存器、检查设备状态等工作。<br /><a name="ydA1S"></a></p><h2 id="设备驱动程序"><a class="markdownIt-Anchor" href="#设备驱动程序"></a> 设备驱动程序</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599979663757-63020a2d-971b-441e-b6b7-a5b655529c9c.png#align=left&amp;display=inline&amp;height=480&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=960&amp;originWidth=1410&amp;size=169139&amp;status=done&amp;style=none&amp;width=705" alt="image.png" /><br />主要负责对硬件设备的具体控制，将上层发出的一系列命令（如：write、read等）转化为特定的设备了解的一系列操作，包括设置设备寄存器、检查设备状态等。<br />不同的I/O设备有着不同的硬件特性，具体细节只有厂家才知道，因此厂家要根据设备的硬件特性设计并提供相应的驱动程序。<br />注：驱动程序一般会以一个独立进程的方式存在。<br /><a name="8ivvI"></a></p><h2 id="中断处理程序"><a class="markdownIt-Anchor" href="#中断处理程序"></a> 中断处理程序</h2><p>当I/O任务完成时，I/O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。中断处理程序处理流程如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599979766704-d0c5bc97-71a4-4426-abb7-4b78d2d81b41.png#align=left&amp;display=inline&amp;height=210&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=242&amp;originWidth=363&amp;size=46814&amp;status=done&amp;style=none&amp;width=315" alt="image.png" /><br /><a name="yLcHd"></a></p><h2 id="流程演示"><a class="markdownIt-Anchor" href="#流程演示"></a> 流程演示</h2><ol><li>用户通过调用用户层软件提供的库函数发出I/O请求</li><li>用户层软件通过系统调用请求设备独立性软件层的服务</li><li>设备独立性软件层根据LUT调用设备对应的驱动程序</li><li>驱动程序向I/O控制器发出具体命令</li><li>等待I/O完成的进程应该被阻塞，因此需要进程切换，而进程切换必然需要终端操作。<br /><a name="Bawuk"></a></li></ol><h1 id="io核心子系统功能"><a class="markdownIt-Anchor" href="#io核心子系统功能"></a> I/O核心子系统功能</h1><p>设备独立性软件层、设备驱动程序层和中断处理程序层属于操作系统的内核部分，即I/O系统或称I/O核心子系统，因此I/O核心字系统要实现的功能就是中间三层要实现的功能。<br />其核心功能所在分区如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599980508664-a2fa5cca-2f25-45e9-a156-03f0287712c0.png#align=left&amp;display=inline&amp;height=213&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=426&amp;originWidth=959&amp;size=281991&amp;status=done&amp;style=none&amp;width=479.5" alt="image.png" /><br /><a name="ArKKs"></a></p><h2 id="假脱机技术spooling"><a class="markdownIt-Anchor" href="#假脱机技术spooling"></a> 假脱机技术（SPOOLing）</h2><p>需要请求磁盘设备的设备独立性软件的服务，因此一般来说假脱机技术是在用户层软件实现的，但是在新版教材中把假脱机技术归在了I/O核心子系统的功能。<br /><a name="h5psE"></a></p><h3 id="什么是脱机技术"><a class="markdownIt-Anchor" href="#什么是脱机技术"></a> 什么是脱机技术</h3><p>在手工阶段，主机直接从I/O设备获得数据，由于设备速度按慢，主机速度快。人机速度矛盾明显，主机要浪费很多时间来等待设备。<br />所以在批处理阶段引入了脱机输入/输出技术，通过外围机的控制，慢速输入设备的数据线被输入到更快速的磁带上，之后主机可以从快速的磁带上读入数据，从而减缓速度矛盾。另一方面，即使CPU在忙碌也可以提前将数据输入到磁带，即使慢速的输出设备正在忙碌也可以提前将数据输出到磁带。<br />因此，脱机即脱离主机控制进行输入/输出操作。<br /><a name="hazKE"></a></p><h3 id="什么是假脱机技术"><a class="markdownIt-Anchor" href="#什么是假脱机技术"></a> 什么是假脱机技术</h3><p>假脱机技术又称SPOOLing技术，是用软件的方式模拟脱机技术。SPOOLing系统的组成如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599981344173-6dfe5d4a-289a-45c7-bae6-f0fa73f1918d.png#align=left&amp;display=inline&amp;height=294&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=588&amp;originWidth=1160&amp;size=320535&amp;status=done&amp;style=none&amp;width=580" alt="image.png" /><br />在输入/出进程的控制下，输入/出缓冲区用于暂时从输入/出设备输入/出的数据，之后再转存到输入/出井中。<br />注意：输入缓冲区和输出缓冲区是在内存中的缓冲区。<br /><a name="eWmu4"></a></p><h4 id="输入井"><a class="markdownIt-Anchor" href="#输入井"></a> 输入井</h4><p>模拟脱机输入时的磁带，用于收容I/O设备输入的数据。<br /><a name="OnN3m"></a></p><h4 id="输出井"><a class="markdownIt-Anchor" href="#输出井"></a> 输出井</h4><p>模拟脱机输出时的磁带，用于收容用户进程输出的数据。<br /><a name="lP5fr"></a></p><h2 id="io调度"><a class="markdownIt-Anchor" href="#io调度"></a> I/O调度</h2><p>用某种算法确定一个好的顺序来处理各个I/O请求。<br />如：磁盘调度（先来先去服务算法、最短寻道优先算法、SCAN算法、C-SCAN算法、LOOK算法、C-LOOK算法）。当多个磁盘I/O请求到来时，用某种调度算法确定满足I/O请求的顺序。<br />同理，打印机等设备也可以用先来先服务算法、优先算法、短作业优先等算法来确定I/O调度顺序。<br /><a name="MMxxn"></a></p><h2 id="设备保护"><a class="markdownIt-Anchor" href="#设备保护"></a> 设备保护</h2><p>操作系统需要实现文件保护功能，不同的用户对各个文件有不同的访问权限，如：只读、读和写等。<br />在UNIX系统中，设备被看作是一种特殊的文件，每个设备也会有对应的FCB，当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此来实现设备保护功能。<br /><a name="qHbQd"></a></p><h2 id="设备的分配与回收"><a class="markdownIt-Anchor" href="#设备的分配与回收"></a> 设备的分配与回收</h2><p><a name="GoBub"></a></p><h3 id="分配时考虑的因素"><a class="markdownIt-Anchor" href="#分配时考虑的因素"></a> 分配时考虑的因素</h3><p>设备分配时应该考虑的因素有设备的固有属性、设备的分配算法、设备分配中的安全性。<br /><a name="N4nHV"></a></p><h4 id="设备的固有属性"><a class="markdownIt-Anchor" href="#设备的固有属性"></a> 设备的固有属性</h4><p>设备的固有属性可分为三种：独占设备、共享设备、虚拟设备。</p><ul><li>独占设备：一个时间段只能分配给一个进程（如打印机）</li><li>共享设备：可同时分配给多个进程使用（如磁盘），宏观上往往是宏观上同时共享使用设备，而微观上是交替使用。</li><li>虚拟设备：采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用。（如采用SPOOLing技术实现的共享打印机）<br /><a name="MNfOc"></a></li></ul><h4 id="设备的分配算法"><a class="markdownIt-Anchor" href="#设备的分配算法"></a> 设备的分配算法</h4><p>设备的分配算法可以使用先来先服务、优先级高者优先、短任务优先等算法。<br /><a name="2dFjj"></a></p><h4 id="设备分配中的安全性"><a class="markdownIt-Anchor" href="#设备分配中的安全性"></a> 设备分配中的安全性</h4><p>从进程运行的安全性考虑，设备分配有两种方法：<br />安全分配方式：<br />为进程分配一个设备后就将阻塞，本次I/O完成后才将进程唤醒。一个时段内每个进程只能使用一个设备。<br />优点：破坏了请求和保持条件，不会产生死锁。<br />缺点：对于一个进程来说，CPU和I/O设备只能串行工作。<br />不安全分配方式：<br />进程发出I/O请求后，系统为其分配I/O设备，进程可继续执行，之后还可以发出新的I/O请求，只有某个I/O请求得不到满足时才将进程阻塞。一个进程可以同时使用多个设备。<br />优点：进程的计算任务和I/O任务可以并行处理，让进程迅速推进。<br />缺点：可能会发生死锁。<br /><a name="Q93NE"></a></p><h3 id="静态分配和动态分配"><a class="markdownIt-Anchor" href="#静态分配和动态分配"></a> 静态分配和动态分配</h3><p>静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源。破坏了请求和保持条件，不会发生死锁。<br />动态分配：进程运行过程中动态申请设备资源。<br /><a name="ffRm6"></a></p><h3 id="设备分配管理中的数据结构"><a class="markdownIt-Anchor" href="#设备分配管理中的数据结构"></a> 设备分配管理中的数据结构</h3><p>设备、控制器、通道的关系如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599982511496-c13f5850-8f5b-42bb-a7f3-5b85fd36e4d5.png#align=left&amp;display=inline&amp;height=179&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=246&amp;originWidth=672&amp;size=50899&amp;status=done&amp;style=none&amp;width=489" alt="image.png" /><br />设备控制表（DTC）：系统为每个设备配置一张DTC，用于记录设备情况。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599982555247-9af146e5-9a56-45fb-9907-2e2a2fc0dd8b.png#align=left&amp;display=inline&amp;height=155&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=218&amp;originWidth=691&amp;size=110881&amp;status=done&amp;style=none&amp;width=491" alt="image.png" /><br />注：系统会根据阻塞原因不同将进程PCB挂到不同的阻塞队列。<br />控制器控制表（COCT）：每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作管理。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599982653577-b3aa74dd-de19-4f41-885d-24b82decd920.png#align=left&amp;display=inline&amp;height=131&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=186&amp;originWidth=726&amp;size=80066&amp;status=done&amp;style=none&amp;width=510" alt="image.png" /><br />通道控制表（CHCT）：每个通道都会对应一张CHCT，操作系统根据CHCT信息对通道进行操作和管理。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599982701722-772182f2-d403-456d-bf84-991a2f047319.png#align=left&amp;display=inline&amp;height=158&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=202&amp;originWidth=746&amp;size=80147&amp;status=done&amp;style=none&amp;width=584" alt="image.png" /><br />系统设备表（SDT）：记录了系统中全部设备的情况，每个设备都对应一个表目。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599982752025-4d464d24-1244-4590-9ed8-8aba6926c613.png#align=left&amp;display=inline&amp;height=134&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=199&amp;originWidth=643&amp;size=45176&amp;status=done&amp;style=none&amp;width=432" alt="image.png" /><br /><a name="yrBe6"></a></p><h3 id="设备分配的步骤"><a class="markdownIt-Anchor" href="#设备分配的步骤"></a> 设备分配的步骤</h3><ol><li>根据进程请求的设备名查找SDT（注：物理设备名是进程请求分配设备时提供的参数）</li><li>根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程。</li><li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li><li>根据COCT找到CHCT，若通道忙碌泽江金城PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</li></ol><p>只有设备、控制器、通道三者都分配成功时此设备分配才算成功，之后便可启动I/O设备进行数据传输。<br /><a name="RilLL"></a></p><h3 id="设备分配步骤的改进"><a class="markdownIt-Anchor" href="#设备分配步骤的改进"></a> 设备分配步骤的改进</h3><p>上述步骤有如下几个缺点：</p><ul><li>用户编程时必须使用物理设备名，底层细节对用户不透明，不方便编程。</li><li>若换了一个物理设备，则程序无法进行。</li><li>若程序进程请求的物理设备正在忙碌，则及时系统中还有同类型的设备，进程也必须阻塞等待。</li></ul><p>改进方法：建立逻辑设备名与物理设备名的映射机制，用户编程只需要提供逻辑设备名即可。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599983281112-3dfcdf0c-195a-43d5-8444-88788e74b463.png#align=left&amp;display=inline&amp;height=190&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=283&amp;originWidth=830&amp;size=71199&amp;status=done&amp;style=none&amp;width=557" alt="image.png" /><br />逻辑设备表（LUT）建立了逻辑设备名和物理设备名的映射关系。<br />某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在LUT增加相应表项。<br />如果之后用户进程再次通过相同的逻辑请求使用设备，则操作系统通过LUT表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序的入口地址。<br />LUT表设置问题：<br />整个系统只有一张LUT：各个用户所用的逻辑设备名不允许重复<br />每个用户一张LUT：不同的用户的设备名可以重复。<br /><a name="P50x3"></a></p><h1 id="缓冲区管理"><a class="markdownIt-Anchor" href="#缓冲区管理"></a> 缓冲区管理</h1><p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可以利用内存作为缓冲区。<br />使用硬件作为缓冲区的成本比较高，容量也比较小，一般仅用在对速度要求十分高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）<br />一般情况下，更多是利用内存作为缓存区，设备独立性软件的缓冲区管理就是要组织管理好这些缓冲区。<br /><a name="xBSuM"></a></p><h2 id="缓冲区的作用"><a class="markdownIt-Anchor" href="#缓冲区的作用"></a> 缓冲区的作用</h2><p>其主要作用如下：</p><ul><li>缓和CPU与I/O设备之间的速度不匹配的矛盾。</li><li>减少对CPU的中断频率，放宽对CPU中断响应时间的限制。</li><li>解决数据颗粒度不匹配的问题。例如，输出进程每次可以生成一块数据，但是I/O设备每次只能输出一个字符。</li><li>提高CPU与I/O设备之间的并行性。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599983956994-e5e90d79-902c-4ac2-b5a5-3b78a3b51075.png#align=left&amp;display=inline&amp;height=184&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=223&amp;originWidth=346&amp;size=34391&amp;status=done&amp;style=none&amp;width=285" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599983964724-adbe044a-89f2-44f7-8f61-bcfea2074c2d.png#align=left&amp;display=inline&amp;height=191&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=270&amp;originWidth=579&amp;size=63719&amp;status=done&amp;style=none&amp;width=410" alt="image.png" /><br /><a name="i4Rr8"></a></p><h2 id="单缓存"><a class="markdownIt-Anchor" href="#单缓存"></a> 单缓存</h2><p>假设某用户进程请求某种模块设备读入若干块的数据，若采用单缓存的策略，操作系统会在主存中为其分配一个缓冲区。<br />注意：当缓冲区数据非空时，不能往缓冲区中入数据，只能从缓冲区把数据传出，当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满后才能从缓冲区吧数据传出。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984283080-cab8e813-55e1-4892-ab45-f3a9949ed121.png#align=left&amp;display=inline&amp;height=259&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=319&amp;originWidth=530&amp;size=61674&amp;status=done&amp;style=none&amp;width=431" alt="image.png" /><br />时间表变化图：<br />T&gt;C<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984334973-1b68b2ce-ab38-47dc-a0cb-2760a868605f.png#align=left&amp;display=inline&amp;height=217&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=338&amp;originWidth=860&amp;size=103940&amp;status=done&amp;style=none&amp;width=552" alt="image.png" /><br />T&lt;C<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984373185-ffd3755b-0995-47b4-84df-da71e37fb0ed.png#align=left&amp;display=inline&amp;height=205&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=345&amp;originWidth=929&amp;size=110857&amp;status=done&amp;style=none&amp;width=553" alt="image.png" /><br />平均耗时：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984435223-30e9f13c-cc23-4943-aceb-e18782be60c3.png#align=left&amp;display=inline&amp;height=242&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=353&amp;originWidth=835&amp;size=88961&amp;status=done&amp;style=none&amp;width=572" alt="image.png" /><br /><a name="bXD7m"></a></p><h2 id="双缓冲"><a class="markdownIt-Anchor" href="#双缓冲"></a> 双缓冲</h2><p>假设某用户进程请求某种模块设备读入若干块的数据，若采用双缓存的策略，操作系统会在主存中为其分配两个缓冲区。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984548270-3e658a64-1fa1-4b20-b7b2-d09b0b5d7aef.png#align=left&amp;display=inline&amp;height=244&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=352&amp;originWidth=866&amp;size=80104&amp;status=done&amp;style=none&amp;width=601" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984575653-9a2552d3-befa-4991-8a39-0651285f3e4c.png#align=left&amp;display=inline&amp;height=216&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=332&amp;originWidth=785&amp;size=129225&amp;status=done&amp;style=none&amp;width=510" alt="image.png" /><br />显然，采用双缓冲策略处理一个数据块平均耗时为Max(T,C+M)<br /><a name="YAWfy"></a></p><h2 id="两种缓冲区在通信时的区别"><a class="markdownIt-Anchor" href="#两种缓冲区在通信时的区别"></a> 两种缓冲区在通信时的区别</h2><p>两台机器之间通信时，可以配置缓冲区用于数据的发送和接受。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984682990-63b7fcb0-bd41-47b2-bc80-12f28f1e2492.png#align=left&amp;display=inline&amp;height=168&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=271&amp;originWidth=697&amp;size=69199&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br />显然，若两个相互通信的机器只设置单缓冲区，在任一个时刻只能实现数据的单向传输。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984780846-d0cae697-dfd0-4607-803a-b30813005cd3.png#align=left&amp;display=inline&amp;height=223&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=282&amp;originWidth=515&amp;size=32175&amp;status=done&amp;style=none&amp;width=407" alt="image.png" /><br />若两个相互通信的机器设置双缓冲区，则同一时刻可以实现双向的数据传输。<br />注：管道通信中的管道其实就是缓冲区，要实现数据双向传输必须要设置两个管道。<br /><a name="p6wwR"></a></p><h2 id="循环缓冲区"><a class="markdownIt-Anchor" href="#循环缓冲区"></a> 循环缓冲区</h2><p>将多个大小相等的缓冲区链接成一个循环队列。<br />注：以下图示中，橙色未一充满数据的缓冲区，绿色表示空缓冲区。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984919280-8da997c8-9d60-40cd-9144-c82fcc0ead96.png#align=left&amp;display=inline&amp;height=211&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=306&amp;originWidth=564&amp;size=40321&amp;status=done&amp;style=none&amp;width=388" alt="image.png" /><br /><a name="UtQQt"></a></p><h2 id="缓冲池"><a class="markdownIt-Anchor" href="#缓冲池"></a> 缓冲池</h2><p>缓冲池由系统中公用的缓冲区组成，这些缓冲区按使用状况可划分为空缓冲队列、装满输入数据缓冲队列（输入队列）、装满输出数据的缓冲队列（输出队列）。<br />另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了两种工作缓冲区：用于收容输入数据的工作缓冲区（hin）、用于提取输入数据的工作缓冲区（sin）、用户收容输出数据的工作缓冲区（hout）、用于提取输出数据的工作缓冲区（sout）<br /><a name="ydiDs"></a></p><h3 id="执行步骤"><a class="markdownIt-Anchor" href="#执行步骤"></a> 执行步骤</h3><ul><li>输入进程请求输入数据<ul><li>从空缓冲队列中取出一块作为收容输入数据的工作缓冲区（hin），充满数据后将缓冲区挂到输入队列队尾。</li></ul></li><li>计算进程想要取得一块输入数据<ul><li>从输入队列中取得一块冲满输入数据的缓冲区作为“提取输入数据的工作缓冲区（sin）”。缓冲区读空后挂到空缓冲区队列。</li></ul></li><li>计算进程想要准备好的数据冲入缓冲区<ul><li>从空缓冲队列中取出一块作为“收容输出数据的工作缓冲区（hout）”。数据冲满后将缓冲区挂到输出队列队尾。</li></ul></li><li>输出进程请求输出数据<ul><li>从输出队列中取得一块充满输出数据的缓冲区作为“提取输出数据的工作缓冲区（sout）”。缓冲区读空后挂到空缓冲区队列。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之磁盘</title>
      <link href="/posts/operating_system_disk/"/>
      <url>/posts/operating_system_disk/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统之磁盘"><a class="markdownIt-Anchor" href="#操作系统之磁盘"></a> 操作系统之磁盘</h1><p><a name="rEcV0"></a></p><h1 id="磁盘的结构"><a class="markdownIt-Anchor" href="#磁盘的结构"></a> 磁盘的结构</h1><p>磁盘实际样子如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/485026/1599889988958-ed10375e-99f6-41f1-9aa7-c66e4ec2b6b8.jpeg#align=left&amp;display=inline&amp;height=283&amp;margin=%5Bobject%20Object%5D&amp;originHeight=283&amp;originWidth=400&amp;size=0&amp;status=done&amp;style=none&amp;width=400" alt="" /><br />磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据。<br />磁盘的圆盘盘面可以横向划分成一个个磁道，一个圈就是一个磁道。最内侧的磁道上扇区最小，因此数据密度最大。<br />每个磁道又被纵向划分成一个个扇区，每个扇区就是一个磁盘块，各个扇区存放的数据量相同。<br /><a name="4oDwH"></a></p><h2 id="如何写入读出数据"><a class="markdownIt-Anchor" href="#如何写入读出数据"></a> 如何写入/读出数据</h2><p>每个磁盘都拥有一个磁头，磁头移动到想要读/写的扇面所在的磁道后磁盘会转动，让目标扇区从磁头下面划过，最后完成对扇区的读/写操作。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599890553886-07d75711-beca-4cbf-b099-3b86cef4a5da.png#align=left&amp;display=inline&amp;height=285&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=305&amp;originWidth=317&amp;size=63129&amp;status=done&amp;style=none&amp;width=296" alt="image.png" /><br /><a name="9SgB5"></a></p><h2 id="盘面-柱面结构"><a class="markdownIt-Anchor" href="#盘面-柱面结构"></a> 盘面、柱面结构</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599890623778-46339110-9587-4f45-9a23-a1b275eaec2b.png#align=left&amp;display=inline&amp;height=323&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=468&amp;originWidth=627&amp;size=225297&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br /><a name="o0fAg"></a></p><h2 id="磁盘的物理地址"><a class="markdownIt-Anchor" href="#磁盘的物理地址"></a> 磁盘的物理地址</h2><p>磁盘的物理地址可以用（柱面号，盘面号，扇区号）来定位任意一个“磁盘块”。在“文件的物理结构”中所指代的文件数据存放在外存的块号可转换为（柱面号，盘面号，扇面号）的地址形式。<br />反之，也可以根据地质读取一个块：</p><ul><li>根据柱面号移动刺臂，让磁头指向指定的柱面。</li><li>激活指定盘面对应的磁头。</li><li>磁盘旋转的过程中，指定的磁区会从磁头下面划过，这样就完成了对指定扇区的读/写。<br /><a name="Kpj2f"></a></li></ul><h2 id="磁盘的分类"><a class="markdownIt-Anchor" href="#磁盘的分类"></a> 磁盘的分类</h2><p>磁盘按照磁头类型划分可以分为活动头磁盘和固定头磁盘，按照盘片分可以划分为可换盘磁盘和固定盘磁盘。<br />按照盘片分望文生义，暂不做解释。<br /><a name="VryLc"></a></p><h3 id="活动头磁盘"><a class="markdownIt-Anchor" href="#活动头磁盘"></a> 活动头磁盘</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599890967111-6a3844c7-ddb1-4cdc-8249-8966074fd076.png#align=left&amp;display=inline&amp;height=333&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=443&amp;originWidth=359&amp;size=163324&amp;status=done&amp;style=none&amp;width=270" alt="image.png" /><br /><a name="u93KE"></a></p><h3 id="固定头磁盘"><a class="markdownIt-Anchor" href="#固定头磁盘"></a> 固定头磁盘</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599890986014-80e55528-4e1e-4163-8f1f-2d1b208c8d03.png#align=left&amp;display=inline&amp;height=330&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=481&amp;originWidth=420&amp;size=165966&amp;status=done&amp;style=none&amp;width=288" alt="image.png" /><br /><a name="bElGf"></a></p><h1 id="磁盘调度算法"><a class="markdownIt-Anchor" href="#磁盘调度算法"></a> 磁盘调度算法</h1><p>在明确算法前，首先要了解如何计算一次磁盘读/写操作需要的时间。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599891211931-f2aad384-5647-4451-8eb2-c1cfcdf756dd.png#align=left&amp;display=inline&amp;height=228&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=336&amp;originWidth=350&amp;size=68409&amp;status=done&amp;style=none&amp;width=237" alt="image.png" /><br /><a name="yIvRE"></a></p><h2 id="耗时计算"><a class="markdownIt-Anchor" href="#耗时计算"></a> 耗时计算</h2><p>耗时计算拥有寻道时间、延迟时间、传输时间三个影响因素。<br />总的平均存取时间公式 Ta=Ts+1/2r+b/(rN)<br />其中，操作系统的磁盘调度算法会直接影响寻道时间。延迟时间和传输时间都与磁盘转速有关，且为线性相关。而转速是硬件的固有属性，因此操作系统无法优化延迟时间和传输时间。所以操作系统只能通过优化调度算法来优化寻道时间来减少耗时。<br /><a name="cdIRj"></a></p><h3 id="寻道时间"><a class="markdownIt-Anchor" href="#寻道时间"></a> 寻道时间</h3><p>寻道时间即在读/写数据前，将磁头移动到指定磁道所花费的时间。<br />寻道时间公式： Ts=s+m*n。<br />参数解释：</p><ul><li>启动磁头臂也是需要时间的，假设耗时为s</li><li>移动磁头也是需要一定时间的，假设磁头匀速转动，每跨越一个磁道耗时为m，总共需要跨越n条磁道。</li></ul><p>现在磁盘移动一个磁道大约耗时0.2s，磁盘启动时间大约为2ms。<br /><a name="iHQve"></a></p><h3 id="延迟时间"><a class="markdownIt-Anchor" href="#延迟时间"></a> 延迟时间</h3><p>延迟时间即通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为r（单位：转/秒，或转/分），则平均所需的延迟时间为TR=（1/2）*（1/r）=1/2r<br />参数解释：</p><ul><li>1/r就是转一圈需要的时间。找到目标扇区的平均需要转半圈因此再乘1/2。</li></ul><p>硬盘的典型转速为5400转/分，或7200转/分。<br /><a name="fdycd"></a></p><h3 id="传输时间"><a class="markdownIt-Anchor" href="#传输时间"></a> 传输时间</h3><p>传输时间即从磁盘读取或向磁盘写入数据所经历的时间。<br />传输时间公式：Tt=（1/r）*（b/N）=b/（rN）<br />参数解释：</p><ul><li>假设磁盘转速为r</li><li>此次读/写的字节数为b</li><li>每个磁道上的字节数为N</li><li>每个磁道要可存N字节的数据，因此b字节的数据需要b/N个磁道才能存储</li><li>读/写一个磁道所需的时间刚好又是转一圈所需要的时间1/r<br /><a name="CrDOI"></a></li></ul><h2 id="先来先去服务算法fcfs"><a class="markdownIt-Anchor" href="#先来先去服务算法fcfs"></a> 先来先去服务算法（FCFS）</h2><p>根据进程请求访问磁盘先后顺序进行调度。<br />假设磁头的初始位置为100号信道，有多个进程先后陆续的请求访问55、58、39、18、90、160、150、38、184号磁道。<br />按照FCFS的规则，按照请求到达的顺序，磁头需要一次移动到55、58、39、18、90、160、150、38、184号磁道。磁针运动轨迹如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599892624881-464008a7-4d87-4c8a-8d95-7f1d05c4e6e7.png#align=left&amp;display=inline&amp;height=106&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=187&amp;originWidth=762&amp;size=21860&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br />磁盘共移动了45+3+19+21+72+70+10+112+146+498个磁道。<br />响应一个请求平均需要移动498/9=55.3个磁道（平均寻道长度）<br />优点：公平，如果请求访问的磁道比较集中，算法性能还算良好。<br />缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间比较长。<br /><a name="9R8k7"></a></p><h2 id="最短寻找时间优先sstf"><a class="markdownIt-Anchor" href="#最短寻找时间优先sstf"></a> 最短寻找时间优先（SSTF）</h2><p>SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道地址最短，但是并不能保证总的寻道地址最短。（贪心算法的思想，只选当前最优，但未必是总体最优）<br />假设磁头的初始位置时100号磁道，有多个进程先后陆续的请求访问55、58、39、18、90、160、150、38、184号磁道。磁针运动轨迹如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599893481736-6d63e7c5-5112-4537-8b8c-afa8f82275ec.png#align=left&amp;display=inline&amp;height=90&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=139&amp;originWidth=666&amp;size=16795&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br />磁头总共移动了（100-18）+（184-18）=248个磁道<br />响应一个请求平均需要移动248/9=27.5个磁道（平均寻道长度）<br />优点：性能良好，平均寻道时间短。<br />缺点：可能产生“饥饿”现象（磁头在一个小区域来回移动，导致其他位置饥饿）<br /><a name="WobQw"></a></p><h2 id="扫描算法scan"><a class="markdownIt-Anchor" href="#扫描算法scan"></a> 扫描算法（SCAN）</h2><p>为了防止SSTF的饥饿产生，可以规定只有磁头移动到最外侧磁道时才能往内侧移动，移动到最内侧时才能往最外侧移动。这就是扫描算法的思想，其磁头移动的方式很像电梯，因此又称电梯算法。<br />假设某磁盘的磁道为0~200号，磁头的初始位置时100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续的请求访问55、58、39、18、90、160、150、38、184号磁道。磁针运动轨迹如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599893970828-a45ece52-9f78-4f2e-a538-3067747e707a.png#align=left&amp;display=inline&amp;height=94&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=143&amp;originWidth=806&amp;size=20385&amp;status=done&amp;style=none&amp;width=529" alt="image.png" /><br />磁头总共移动了（200-100）+（200-18）=282个磁道<br />响应一个请求平均需要移动282/9=31.3个磁道（平均寻找长度）<br />优点：性能良好，平均寻道时间比较短，不会产生饥饿。<br />缺点：</p><ul><li>只有到点了最边上的磁道才能够改变磁头的移动方向。事实上，处理了184号磁道的访问请求以后就不需要向右移动磁头了。</li><li>SCAN算法对于各个位置磁道的响应频率不平均（如：假设此时磁头正在往右移动，且刚处理过的90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离，而响应了184号磁道的请求后，很快又可以再次响应184号磁道请求了）<br /><a name="oJyM9"></a></li></ul><h2 id="look算法"><a class="markdownIt-Anchor" href="#look算法"></a> LOOK算法</h2><p>LOOK算法解决了SCAN算法只有到了最边上的磁道才能改变磁头移动方向的问题：如果磁头移动方向上已经没有别的请求就可以立即改变磁头移动方向。（边移动边观察，因此称作LOOK）<br />假设某磁盘的磁道为0~200号，磁头的初始位置时100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续的请求访问55、58、39、18、90、160、150、38184号磁道。磁针运动轨迹如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599894835528-bcbc28a3-445d-45ff-9f2a-cefe61cc8d3a.png#align=left&amp;display=inline&amp;height=103&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=149&amp;originWidth=845&amp;size=18728&amp;status=done&amp;style=none&amp;width=584" alt="image.png" /><br />磁针总共移动了（184-100）+（184-18）=250个磁道<br />响应一个请求平均需要移动250/9=27.5个磁道（平均寻道长度）<br />优点：比起SCAN算法，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短。<br /><a name="aTIh6"></a></p><h2 id="循环扫描算法c-scan"><a class="markdownIt-Anchor" href="#循环扫描算法c-scan"></a> 循环扫描算法（C-SCAN）</h2><p>SCAN算法对于各个位置磁道的响应频率不平均，而C-SCAN算法就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始段而不处理任何请求。<br />假设某磁盘的磁道为0~200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续的请求访问55、58、39、18、90、160、150、38、184号磁道。磁针运动轨迹如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599895200833-44e51f76-2747-4d10-aecc-54d64eef8c06.png#align=left&amp;display=inline&amp;height=149&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=211&amp;originWidth=899&amp;size=47830&amp;status=done&amp;style=none&amp;width=633" alt="image.png" /><br />磁头总共移动了（200-100）+（200-0）+（90-0）=390个磁道<br />响应一个请求平均需要移动390/9=43.3个磁道（平均寻道长度）<br />优点：比起SCAN，对于各个位置磁道的响应频率很平均。<br />缺点：只有到最边上的磁道才能改变磁头移动方向。事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了，并且，磁头返回时其实只需要返回18号磁道即可，不需要返回到最边远的磁道。另外，比起SCAN算法，平均寻道时间更长。<br /><a name="PrIR9"></a></p><h2 id="c-look调度算法"><a class="markdownIt-Anchor" href="#c-look调度算法"></a> C-LOOK调度算法</h2><p>C-SCAN的主要缺点是只有到达最边上的磁道时才能改变磁头移动的方向，并且磁头返回时不一定需要返回到最边缘的磁道上。C-LOOK算法就是为了解决这个问题。如果磁头移动的方向上已经没有磁道访问请求，这时就可以让磁头返回，并且磁头只需要返回到由此头访问请求的位置即可。<br />假设某磁盘的磁道为0~200号，磁头的初始位置为100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道。磁针运动轨迹如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599896035062-9974b184-cd52-4194-a1a0-ee25f2b68748.png#align=left&amp;display=inline&amp;height=119&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=179&amp;originWidth=899&amp;size=62149&amp;status=done&amp;style=none&amp;width=597" alt="image.png" /><br /><br /><br />磁头总共移动了（184-100）+（184-18）+（90-18）=322个磁道<br />响应一个请求平均需要移动322/9=35.8个磁道（平均寻道长度）<br />优点：比起C-SCAN算法，不需要每次都移动到最外侧或最内侧才能改变磁头方向，使寻道时间进一步缩短。<br /><a name="JihMs"></a></p><h1 id="减少延迟时间方法"><a class="markdownIt-Anchor" href="#减少延迟时间方法"></a> 减少延迟时间方法</h1><p>现有磁盘如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599896244398-d22a5ad1-2f90-4641-95b3-6332680d5552.png#align=left&amp;display=inline&amp;height=228&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=293&amp;originWidth=392&amp;size=63365&amp;status=done&amp;style=none&amp;width=305" alt="image.png" /><br />假设要连续读取橙色区域的2、3、4扇区。<br />磁头读取一块的内容（也就是一个扇区的内容）后，需要一小段时间处理，而盘片又在不停的旋转。<br />因此，如果2、3号扇区相邻着排列，则读完2号扇区后无法连续不断的读入3号扇区，必须等盘片继续旋转，3号扇区再次划过磁头才能完成扇区读入。<br />因此，磁头读入一个扇区数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区可能需要很长的延迟时间。<br /><a name="fR1u4"></a></p><h2 id="交替编号"><a class="markdownIt-Anchor" href="#交替编号"></a> 交替编号</h2><p>让逻辑上相邻的扇区在物理上有一定的时间间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599896937462-08b24e73-c097-4072-a7c5-a5033e2dc95e.png#align=left&amp;display=inline&amp;height=261&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=306&amp;originWidth=334&amp;size=60229&amp;status=done&amp;style=none&amp;width=285" alt="image.png" /><br /><a name="igw5S"></a></p><h2 id="地址结构设计"><a class="markdownIt-Anchor" href="#地址结构设计"></a> 地址结构设计</h2><p>关于为什么磁盘的物理地址是（柱面号，盘面号，扇区号）而不是（盘面号，柱面号，扇区号）：<br />假设某磁盘有8个柱面/磁道（假设最内侧柱面/磁道号为0），4个盘面，8个盘区，则可用3个二进制位表示柱面，2个二进制位表示盘面，3个二进制位表示扇面<br /><a name="js6Pm"></a></p><h3 id="盘面号柱面号扇区号"><a class="markdownIt-Anchor" href="#盘面号柱面号扇区号"></a> （盘面号，柱面号，扇区号）</h3><p>若物理地址的结构是（盘面号，柱面号，扇区号），且需要连续读取物理地址（00,000,000）<sub>（00,001,111）的扇区。（00,000,00）</sub>（00,000,111）转两圈可以读完，之后则需要再读取物理地址相邻的区域，即（00,001,000）~（00,001,111），需要启动磁头臂将磁头移动到下一个磁道。<br /><a name="QbJan"></a></p><h3 id="柱面号-盘面号-扇面号"><a class="markdownIt-Anchor" href="#柱面号-盘面号-扇面号"></a> （柱面号、盘面号、扇面号）</h3><p>若物理地址的结构是（柱面号、盘面号、扇面号），且需要连续读取物理地址（000,00,000）<sub>（000,01,111）的扇区。（000,00,000）</sub>（000,00,111）由盘面0的磁头读取数据之后再读取物理地址相邻的区域，即（000,01,000）~（000,01,111），由于柱面号/磁道号相同，只是盘面号不同，因此不需要移动磁头臂，只需要激活相邻盘面的磁头即可。<br /><a name="gwEFh"></a></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>综上所述，读取地址连续的磁盘块时，采用（柱面号、盘面号、扇面号）的地址结构可以减少磁头移动消耗的时间。<br /><a name="g9RU3"></a></p><h2 id="错位命名"><a class="markdownIt-Anchor" href="#错位命名"></a> 错位命名</h2><p><a name="cVb5A"></a></p><h3 id="不采用错位命名"><a class="markdownIt-Anchor" href="#不采用错位命名"></a> 不采用错位命名：</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599898080591-985d1ad9-494e-471c-85f2-450735d16a1e.png#align=left&amp;display=inline&amp;height=233&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=391&amp;originWidth=645&amp;size=134456&amp;status=done&amp;style=none&amp;width=385" alt="image.png" /><br />若相邻的盘面相对的位置相同处扇区编号相同，因为所有盘面都是连轴转的，因此会产生如下现象：<br />读取完磁盘块（000,00,111）之后，需要短暂的时间处理，而盘面又在不停的转动，因此当（000,01,000）第一次划过1号盘面的磁头下方时并不能读取数据，只能等待该扇区再次划过磁头。<br /><a name="TZQVy"></a></p><h3 id="错位命名后"><a class="markdownIt-Anchor" href="#错位命名后"></a> 错位命名后：</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599898312545-8f2ea97c-d4ab-472e-b5c3-a0998768c21b.png#align=left&amp;display=inline&amp;height=258&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=402&amp;originWidth=675&amp;size=136584&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br />由于采用了错位命名法，因此读取完磁盘块（000,00,111）之后还有一段时间处理，当（000,01,000）第一次划过1号盘面的磁头下方时就可以直接读取数据了，从而减少了延迟时间。<br /><a name="z7dQn"></a></p><h1 id="磁盘管理"><a class="markdownIt-Anchor" href="#磁盘管理"></a> 磁盘管理</h1><p><a name="ZQO0T"></a></p><h2 id="磁盘初始化"><a class="markdownIt-Anchor" href="#磁盘初始化"></a> 磁盘初始化</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599899024356-1b1fc37f-2fa6-4561-a013-0a45821ca811.png#align=left&amp;display=inline&amp;height=219&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=309&amp;originWidth=338&amp;size=52490&amp;status=done&amp;style=none&amp;width=240" alt="image.png" /><br />磁盘初始化有如下三个阶段：</p><ol><li>进行低级格式化（物理格式化），将磁盘的各个隧道划分为扇区，一个扇区通常可分为头、数据区域、尾三个部分。管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码（如奇偶校验、CRC循环冗余校验码等，校验码用于校验山区中的数据是否发生错误）</li><li>将磁盘分区，每个分区由若干柱面形成（即熟悉的C、D、E盘等）</li><li>进行逻辑格式化，创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、空闲分区表）<br /><a name="9CwzB"></a></li></ol><h2 id="引导块"><a class="markdownIt-Anchor" href="#引导块"></a> 引导块</h2><p>计算机开机时需要进行一些列初始化的工作，这些初始化工作是通过执行初始化程序（自举程序）完成的。<br />初始化程序可以放在ROM（只读存储器）中，但是ROM的数据在出厂时就已经写入了，并且以后不可以修改。ROM一般是出厂时就集成在主板上的。所以自举程序如果放在ROM中会很不方便。<br />为了解决上述问题，ROM只存放很小的“自举装入程序”，开启时计算机先运行“自举装入程序”，通过执行该程序就可以找到引导块并将完整的“自举程序”装入内存完成初始化、<br />而完整的自举程序会放在磁盘的启动块（即引导块/自动分区）上，启动块位磁盘的固定位置。拥有启动分区的磁盘称为启动磁盘或系统磁盘。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599899970244-376d03ae-b8c5-4c18-a26b-79a90120ac8e.png#align=left&amp;display=inline&amp;height=283&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=299&amp;originWidth=297&amp;size=54580&amp;status=done&amp;style=none&amp;width=281" alt="image.png" /><br /><a name="b9fJ7"></a></p><h2 id="坏块的管理"><a class="markdownIt-Anchor" href="#坏块的管理"></a> 坏块的管理</h2><p>坏掉、无法正常启动的扇区就是“坏块”，这属于硬件故障，操作系统是无法修复的，应该将坏块标记出来以免错误地使用到它。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599900092244-307ed40a-ed99-48ae-98cd-ae3fcfc69298.png#align=left&amp;display=inline&amp;height=255&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=296&amp;originWidth=299&amp;size=53452&amp;status=done&amp;style=none&amp;width=258" alt="image.png" /><br />对于简单的磁盘，可以再逻辑格式化时（建立文件系统时）对整个磁盘进行坏块检查，标明哪些扇区是坏扇区，比如：FAT表上注明。（在这种方式中，坏块对操作系统不透明）。<br />对于复杂的磁盘，磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表。<br />在磁盘出厂前进行低级格式化（物理格式化）时就将坏块链进行初始化。<br />会保留一些“备用扇区”用于替换坏块。这种方案称为扇区备用。且这种处理方式中，坏块对操作系统透明。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之文件系统</title>
      <link href="/posts/operating_system_file_system/"/>
      <url>/posts/operating_system_file_system/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统之文件系统"><a class="markdownIt-Anchor" href="#操作系统之文件系统"></a> 操作系统之文件系统</h1><p><a name="yYAyL"></a></p><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>文件——就是一组有意义的信息/数据集合。<br /><a name="PYlGN"></a></p><h2 id="文件属性"><a class="markdownIt-Anchor" href="#文件属性"></a> 文件属性</h2><ul><li>文件名：由创建文件的用户决定文件名，主要是为了方便用户找到文 件，同一目录下不允许有重名文件。</li><li>标识符：一个系统内的各文件标识 符唯一，对用户来说毫无可读性， 因此标识符只是操作系统用于区分 各个文件的一种内部名称。</li><li>类型：指明文件的类型</li><li>位置：文件存放的路径（让用户使用）、在外存中的地址（操作系统 使用，对用户不可见）</li><li>大小：指明文件大小</li><li>创建时间、上次修改时间</li><li>文件所有者信息</li><li>保护信息：对文件进行保护的访问控制信息<br /><a name="sgnOi"></a></li></ul><h2 id="文件组织形式"><a class="markdownIt-Anchor" href="#文件组织形式"></a> 文件组织形式</h2><p>无结构文件（如文本文件）——由一些二进制或字符流组成，又称“流式文件”<br />有结构文件（如数据库表）——由一组相似的记录组成，又称“记录式文件”<br /><a name="n2MY1"></a></p><h2 id="文件操作功能"><a class="markdownIt-Anchor" href="#文件操作功能"></a> 文件操作功能</h2><p>可用几个基本操作完成更复杂的操作，比如：“复制文件”： 先创建一个新的空文件，再把源文件读入内存，再将内存中的数据写到新文件中。<br /><a name="9bown"></a></p><h3 id="删除文件"><a class="markdownIt-Anchor" href="#删除文件"></a> 删除文件</h3><p>可以“删除文件”（点了“删除”之后， 图形化交互进程通过操作系统提供的 “删除文件”功能，即 delete 系统调用， 将文件数据从外存中删除）<br /><a name="FhswD"></a></p><h3 id="写文件"><a class="markdownIt-Anchor" href="#写文件"></a> 写文件</h3><p>可以“写文件”，将更改过的文件数据写回外存（在“记事本”应用程序中编辑文件内容，点击“保存”后， “记事本”应用程序通过操作系统提供 的“写文件”功能，即 write 系统调用， 将文件数据从内存写回外存）<br /><a name="0wWfA"></a></p><h3 id="读文件"><a class="markdownIt-Anchor" href="#读文件"></a> 读文件</h3><p>可以“读文件”，将文件数据读 内存，才能让CPU处理（双击后，“记事本”应用程序通过操作系统 提供的“读文件”功能，即 read 系 统调用，将文件数据从外存读入内存，并显示在屏幕上）<br /><a name="WtqpT"></a></p><h3 id="创建文件"><a class="markdownIt-Anchor" href="#创建文件"></a> 创建文件</h3><p>可以“创建文件”， （点击新建后，图形化交互进程在背后调 用了“create 系统调用”）<br /><a name="whzMl"></a></p><h3 id="打开文件"><a class="markdownIt-Anchor" href="#打开文件"></a> 打开文件</h3><p>读/写文件之前，需要“打开文件”<br /><a name="4HxXX"></a></p><h3 id="关闭文件"><a class="markdownIt-Anchor" href="#关闭文件"></a> 关闭文件</h3><p>读/写文件结束之后， 需要“关闭文件”<br /><a name="TWWBv"></a></p><h2 id="文件存储"><a class="markdownIt-Anchor" href="#文件存储"></a> 文件存储</h2><p>操作系统以“块”为单位为文件分配存储空间，因此即使一个文件大小只有10B，但它依然需要占用 1KB 的磁盘块。外存中的数据读入内存时同样以块为单位。<br />类似于内存分为一个个“内存块”，外存会分为一个个“块/磁盘块/物理 块”。每个磁盘块的大小是相等的，每块一般包含2的整数幂个地址（如 本例中，一块包含 210 个地址，即 1KB）。同样类似的是，文件的逻辑地址也可以分为（逻辑块号，块内地址），操作系统同样需要将逻辑地址转 换为外存的物理地址（物理块号，块内地址）的形式。块内地址的位数取 决于磁盘块的大小<br />与内存一样，外存也是由一个个存储单元组成的，每个存储单元可以 存储一定量的数据（如 1B）。每个 存储单元对应一个物理地址<br /><a name="mkRHl"></a></p><h2 id="文件管理功能"><a class="markdownIt-Anchor" href="#文件管理功能"></a> 文件管理功能</h2><p>文件共享：使多个用户可以共享使用一个文件<br />文件保护：如何保证不同的用户对文件有不同的操作权限<br /><a name="ljjXO"></a></p><h1 id="文件的逻辑结构"><a class="markdownIt-Anchor" href="#文件的逻辑结构"></a> 文件的逻辑结构</h1><p>所谓的“逻辑结构”，就是指在用户看来， 文件内部的数据应该是如何组织起来的。而 “物理结构”指的是在操作系统看来，文件的数据是如何存放在外存中的。<br />按文件是否有结构分类，可以分为无结构文件、有结构文件两种。 <br />根据有结构文件中的各 条记录在逻辑上如何组织，可以分为三类：顺序文件、索引文件、索引顺序文件。<br /><a name="uIfnX"></a></p><h2 id="按结构分"><a class="markdownIt-Anchor" href="#按结构分"></a> 按结构分</h2><p><a name="ENEQU"></a></p><h3 id="无结构文件"><a class="markdownIt-Anchor" href="#无结构文件"></a> 无结构文件</h3><p>无结构文件：文件内部的数据就是一系列二进制流或字符流组成。又称“流式文件”。如： Windows 操作系统中的 .txt 文件。<br />文件内部的数据其实就是一系列字符流，没有明显的结构特性。因此也不用探讨无结构文件的“逻辑结构”问题。<br /><a name="sW02f"></a></p><h3 id="有结构文件"><a class="markdownIt-Anchor" href="#有结构文件"></a> 有结构文件</h3><p>由一组相似的记录组成，又称“记录式文件”。每条记录又若干个数据项组成。如： 数据库表文件。一般来说，每条记录有一个数据项可作为关键字（作为识别不同记录的ID）。根据各条记录的长度（占用的 存储空间）是否相等，又可分为定长记录和可变长记录两种。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599826000748-1039a343-7e76-4ecd-9432-56a7fea55a56.png#align=left&amp;display=inline&amp;height=256&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=339&amp;originWidth=755&amp;size=192681&amp;status=done&amp;style=none&amp;width=571" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599826149433-bb0403f6-e99e-499c-82aa-740ec40dccf2.png#align=left&amp;display=inline&amp;height=266&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=310&amp;originWidth=435&amp;size=101725&amp;status=done&amp;style=none&amp;width=373" alt="image.png" /><br />这个有结构文件由可变长记录组成，由于各 个学生的特长存在很大区别，因此“特长” 这个数据项的长度不确定，这就导致了各条 记录的长度也不确定。当然，没有特长的学 生甚至可以去掉“特长”数据项。<br /><a name="OAr6n"></a></p><h2 id="按组织方式分"><a class="markdownIt-Anchor" href="#按组织方式分"></a> 按组织方式分</h2><p><a name="uvQ9g"></a></p><h3 id="顺序文件"><a class="markdownIt-Anchor" href="#顺序文件"></a> 顺序文件</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599826700883-18c2b9bd-ac4a-412f-83ea-fa56f7f0ed77.png#align=left&amp;display=inline&amp;height=84&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=139&amp;originWidth=661&amp;size=53855&amp;status=done&amp;style=none&amp;width=400" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599826495705-0eeef89e-8865-42a3-a690-c244f40d4d32.png#align=left&amp;display=inline&amp;height=124&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=179&amp;originWidth=794&amp;size=105315&amp;status=done&amp;style=none&amp;width=552" alt="image.png" /><br />文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。<br />定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取；若能再保证记录的顺序结构，则可实现快速检索 （即根据关键字快速找到对应记录）<br /><a name="WScKQ"></a></p><h4 id="顺序存储"><a class="markdownIt-Anchor" href="#顺序存储"></a> 顺序存储</h4><p>逻辑上相邻的记录 物理上也相邻（类似于顺序表）<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599826361798-f730b8f5-386e-4f6a-8ed7-a639f5a052a9.png#align=left&amp;display=inline&amp;height=32&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=44&amp;originWidth=310&amp;size=7548&amp;status=done&amp;style=none&amp;width=225" alt="image.png" /><br /><a name="4gLwF"></a></p><h4 id="链式存储"><a class="markdownIt-Anchor" href="#链式存储"></a> 链式存储</h4><p>逻辑上相邻 的记录物理上不一定相邻 （类似于链表）<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599826382338-43ba5d0b-6ade-4b22-891c-d088cbf90d26.png#align=left&amp;display=inline&amp;height=130&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=130&amp;originWidth=283&amp;size=10849&amp;status=done&amp;style=none&amp;width=283" alt="image.png" /><br /><a name="aW3qB"></a></p><h3 id="索引文件"><a class="markdownIt-Anchor" href="#索引文件"></a> 索引文件</h3><p>索引表本身是定长记录的顺序文件。因此可以快速找到第 i 个记录对应的索引项。 可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。 每当要增加/删除一个记录时，需要对索引表进行 修改。由于索引文件有很快的检索速度，因此主 要用于对信息处理的及时性要求比较高的场合。<br />另外，可以用不同的数据项建立多个索引表。如： 学生信息表中，可用关键字“学号”建立一张索 引表。也可用“姓名”建立一张索引表。这样就 可以根据“姓名”快速地检索文件了。<br /><a name="OhmvB"></a></p><h3 id="索引顺序文件"><a class="markdownIt-Anchor" href="#索引顺序文件"></a> 索引顺序文件</h3><p>索引文件每个记录对应一个索引表项，因此索引表可能会很大。 比如：文件的每个记录平均只占 8B，而每个索引表项占32个字节，那么索引 表都要比文件内容本身大4倍，这样对存储空间的利用率就太低了。<br />索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立 一张索引表，但不同的是：并不是每个记录对应一个索引表项，而是一组记录对应一个 索引表项<br />索引顺序文件的索引项也不需要按关键字顺序排列，这样可以极大地方便新表项的插入<br /><a name="sHCnW"></a></p><h4 id="检索效率分析"><a class="markdownIt-Anchor" href="#检索效率分析"></a> 检索效率分析</h4><p>若一个顺序文件有10000个记录，则根据关键字检索文件，只能从头开始顺序查找（这里指的并不是定长记录、顺序结构 的顺序文件），平均须查找 5000 个记录。 <br />若采用索引顺序文件结构，可把 10000 个记录分为 √10000 = 100 组，每组 100 个记录。则需要先顺序查找 索引表找到分组（共100个分组，因此索引表长度为 100，平均需要查 50 次），找到分组后，再在分组中 顺序查找记录（每个分组100 个记录，因此平均需要查 50 次）。可见，采用索引顺序文件结构后，平均查 找次数减少为 50+50 = 100 次。<br />若文件共有 10^6个记录，则可分为 1000 个分组，每个分组 1000 个记录。根据关键字检索一个记录 平均需要查找 500+500 = 1000 次。这个查找次数依然很多<br /><a name="X5Qeb"></a></p><h3 id="多级索引顺序文件"><a class="markdownIt-Anchor" href="#多级索引顺序文件"></a> 多级索引顺序文件</h3><p>为了进一步提高检索效率，可以为顺序文件建立多级索引表。例如，对于一个含 10^6个记录的文件，可先 为该文件建立一张低级索引表，每 100 个记录为一组，故低级索引表中共有 10000 个表项（即10000个定长 记录），再把这 10000 个定长记录分组，每组100个，为其建立顶级索引表，故顶级索引表中共有 100 个表项。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599827035523-19717f14-d0bf-4840-8ca0-fd4b7fb3038c.png#align=left&amp;display=inline&amp;height=249&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=338&amp;originWidth=858&amp;size=123521&amp;status=done&amp;style=none&amp;width=633" alt="image.png" /><br /><a name="gLArm"></a></p><h1 id="文件目录"><a class="markdownIt-Anchor" href="#文件目录"></a> 文件目录</h1><p>windows目录结构如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599832160265-5eaee9a3-084f-4f11-bda5-a81545c92583.png#align=left&amp;display=inline&amp;height=378&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=756&amp;originWidth=1200&amp;size=109914&amp;status=done&amp;style=none&amp;width=600" alt="image.png" /><br />这种结构的文件之间的组织结 构清晰，易于查找。编程时也可以很方便的用文件路径找到一个文件。<br />如： FILE *fp; fp=fopen(“F:\data\myfile.dat”); 用户可以轻松实现“按名存取”。<br /><a name="YEHAX"></a></p><h2 id="文件控制块"><a class="markdownIt-Anchor" href="#文件控制块"></a> 文件控制块</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599836889846-8bf15d90-d492-490b-8f38-edac0f9afdc1.png#align=left&amp;display=inline&amp;height=322&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=395&amp;originWidth=869&amp;size=223949&amp;status=done&amp;style=none&amp;width=708" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599839657564-0b1ad476-f4a2-45ec-9809-7a6e53034f78.png#align=left&amp;display=inline&amp;height=246&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=297&amp;originWidth=569&amp;size=76232&amp;status=done&amp;style=none&amp;width=472" alt="image.png" /><br />FCB 实现了文件名和文件之间的映射。使用户（用户程序）可以实现“按名存取”。<br />FCB 的有序集合称为“文件目录”，一个FCB就是一个文件目录项。 FCB 中包含了文件的基本信息（文件名、物理地址、逻辑结构、物理结构等），存取控制信息（是否可读/可写、禁止访问的用户名单等），使用信息（如文件的建立时间、修改时间等）。 最重要，最基本的还是 文件名、文件存放的物理地址。<br /><a name="rheDY"></a></p><h3 id="对目录常用的操作"><a class="markdownIt-Anchor" href="#对目录常用的操作"></a> 对目录常用的操作</h3><p>搜索：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项 <br />创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项<br />删除文件：当删除一个文件时，需要在目录中删除相应的目录项 <br />显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性 <br />修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项（如：文件重命名）<br /><a name="vn2NW"></a></p><h2 id="目录结构"><a class="markdownIt-Anchor" href="#目录结构"></a> 目录结构</h2><p><a name="iAGDt"></a></p><h3 id="单级目录结构"><a class="markdownIt-Anchor" href="#单级目录结构"></a> 单级目录结构</h3><p>早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项。单级目录实现了“按名存取”，但是不允许文件重名。 <br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599839899805-9130f735-8117-4062-a6c2-0b3e8385a3f7.png#align=left&amp;display=inline&amp;height=344&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=344&amp;originWidth=312&amp;size=38073&amp;status=done&amp;style=none&amp;width=312" alt="image.png" /><br />在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件 对应的目录项插入目录表中。 <br />显然，单级目录结构不适用于多用户操作系统。<br /><a name="img6o"></a></p><h3 id="两级目录结构"><a class="markdownIt-Anchor" href="#两级目录结构"></a> 两级目录结构</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599840346470-83950c43-d4d4-49ea-a281-8a1e1933f12f.png#align=left&amp;display=inline&amp;height=318&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=373&amp;originWidth=869&amp;size=162537&amp;status=done&amp;style=none&amp;width=742" alt="image.png" /><br />又称树形目录结构，早期的多用户操作系统，采用两级目录结构。分为主文件目录（MFD，Master File Directory）和用户文件目录（UFD，User Flie Directory）。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599840596104-c7142d0a-3fef-4015-9c5c-a17e5f3ab763.png#align=left&amp;display=inline&amp;height=158&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=244&amp;originWidth=792&amp;size=72734&amp;status=done&amp;style=none&amp;width=513" alt="image.png" /><br />用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串。各级目录之间 用“/”隔开。从根目录出发的路径称为绝对路径。 <br />例如：自拍.jpg 的绝对路径是 “/照片/2015-08/自拍.jpg” 系统根据绝对路径一层一层地找到下一级目录。刚开始从外存读入根目录的目录表；找到“照片”目录的 存放位置后，从外存读入对应的目录表；再找到“2015-08”目录的存放位置，再从外存读入对应目录表； <br />最后才找到文件“自拍.jpg”的存放位置。整个过程需要3次读磁盘I/O操作。 <br />很多时候，用户会连续访问同一目录内的多个文件（比如：接连查看“2015-08”目录内的多个照片文件）， 显然，每次都从根目录开始查找，是很低效的。因此可以设置一个“当前目录”。<br /><a name="MaeQM"></a></p><h4 id="当前目录"><a class="markdownIt-Anchor" href="#当前目录"></a> 当前目录</h4><p>例如，此时已经打开了“照片”的目录文件，也就是说，这张目录表已调入内存，那么可以把它设置为 “当前目录”。当用户想要访问某个文件时，可以使用从当前目录出发的“相对路径” 。 <br />在 Linux 中，“.”表示当前目录，因此如果“照片”是当前目录，则”自拍.jpg”的相对路径    为： “./2015-08/自拍.jpg”。从当前路径出发，只需要查询内存中的“照片”目录表，即可知道”2015-08”目录 表的存放位置，从外存调入该目录，即可知道“自拍.jpg”存放的位置了。<br />可见，引入“当前目录”和“相对路径”后，磁盘I/O的次数减少了。这就ᨀ升了访问文件的效率。<br />用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串。各级目录之间 用“/”隔开。从根目录出发的路径称为绝对路径。例如：自拍.jpg 的绝对路径是 “/照片/2015-08/自 拍.jpg” <br />每次都从根目录开始查找，是很低效的。因此可以设置一个“当前目录”。例如，此时已经打开了“照片” 的目录文件，也就是说，这张目录表已调入内存，那么可以把它设置为“当前目录”。当用户想要访问某 个文件时，可以使用从当前目录出发的“相对路径” 。 在 Linux 中，“.”表示当前目录，因此如果“照片”是当前目录，则”自拍.jpg”的相对路径为： “./2015-08/自拍.jpg”。<br />树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但 是，树形结构不便于实现文件的共享。为此，提出了“无环图目录结构”。<br /><a name="IYlxt"></a></p><h3 id="无环图目录结构"><a class="markdownIt-Anchor" href="#无环图目录结构"></a> 无环图目录结构</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599841753977-d91b6d18-d5a0-48a0-b46d-d7fc35e0e445.png#align=left&amp;display=inline&amp;height=220&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=302&amp;originWidth=861&amp;size=94833&amp;status=done&amp;style=none&amp;width=628" alt="image.png" /><br />可以用不同的文件名指向同一个文件，甚至可以指向同一个目录（共享同一目录下的所有内容）。 需要为每个共享结点设置一个共享计数器，用于记录此时有多少个地方在共享该结点。用户提出删除结 点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除共享结点。 只有共享计数器减为0时，才删除结点。 <br />注意：共享文件不同于复制文件。在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个 用户修改了文件数据，那么所有用户都可以看到文件数据的变化。<br /><a name="yPdJw"></a></p><h3 id="索引结点fcb的改进"><a class="markdownIt-Anchor" href="#索引结点fcb的改进"></a> 索引结点（FCB的改进）</h3><p>其实在查找各级目录的过程中 只需要用到“文件名”这个信 息，只有文件名匹配时，才需 要读出文件的其他信息。因此 可以考虑让目录表“瘦身”来 提升效率。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599841886489-25bd4c82-40d6-456e-b440-6445e9364f24.png#align=left&amp;display=inline&amp;height=156&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=205&amp;originWidth=506&amp;size=49959&amp;status=done&amp;style=none&amp;width=386" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599841929530-4fc756f9-a1bf-4900-8507-e34f8e3d9819.png#align=left&amp;display=inline&amp;height=143&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=206&amp;originWidth=532&amp;size=41272&amp;status=done&amp;style=none&amp;width=369" alt="image.png" /><br />假设一个FCB是64B，磁盘块的大 小为1KB，则每个盘块中只能存放 16个FCB。若一个文件目录中共有 640个目录项，则共需要占用 640/16 = 40 个盘块。因此按照某 文件名检索该目录，平均需要查 询320 个目录项，平均需要启动磁 盘20次（每次磁盘I/O读入一块）。<br />若使用索引结点机制，文件名占14B，索引结点指针站2B，则每 个盘块可存放64个目录项，那么按文件名检索目录平均只需要 读入 320/64 = 5 个磁盘块。显然，这将大大提升文件检索速度。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599842001580-8b83a93e-fc9b-4dab-87df-441455bd38ce.png#align=left&amp;display=inline&amp;height=163&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=221&amp;originWidth=519&amp;size=35388&amp;status=done&amp;style=none&amp;width=382" alt="image.png" /><br />当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括 文件在外存中的存放位置，根据“存放位置”即可找到文件。 <br />存放在外存中的索引结点称为“磁盘索引结点”，当索引结点放入内存后称为“内存索引结点”。 相比之下内存索引结点中需要增加一些信息，比如：文件是否被修改、此时有几个进程正在访问该文件 等。<br /><a name="sCZzl"></a></p><h1 id="文件的物理结构"><a class="markdownIt-Anchor" href="#文件的物理结构"></a> 文件的物理结构</h1><p>文件的物理结构即文件的分配方式，文件的分配方式又分为连续分配、链接分配和索引分配。<br />类似于内存分页，磁盘中的存储单元也会被分为一个个“块/磁盘块/物理块”。很多操作系统中，磁盘块的大小与内存块、页面的大小相同。内存与磁盘之间的数据交换（即 读/写操作、磁盘I/O）都是以 “块”为单位进行的。即每次读入一块，或每次写出一块。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599872068240-9d79eff4-100f-44b0-bacf-9e4eec562ad5.png#align=left&amp;display=inline&amp;height=260&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=369&amp;originWidth=708&amp;size=97204&amp;status=done&amp;style=none&amp;width=498" alt="image.png" /><br />在内存管理中，进程的逻辑地址空间被分为一个一个页面。同样的，在外存管理中，为了方便对文件数据的管理，文件的逻辑地 址空间也被分为了一个一个的文件“块”。 于是文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式。<br /><a name="fTAgH"></a></p><h2 id="连续分配"><a class="markdownIt-Anchor" href="#连续分配"></a> 连续分配</h2><p>连续分配方式要求每个文件在磁盘上占有一组连续的块。<br />用户给出要访问的逻辑块号，操作系统 找到该文件对应的目录项（FCB）… 物理块号 = 起始块号 + 逻辑块号 当然，还需要检查用户提供的逻辑块号 是否合法（逻辑块号 ≥长度就不合法）。可以直接算出逻辑块号对应的物理 块号，因此连续分配支持顺序访问和直接访问（即随机访问）<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599872280037-7913642b-cccc-4afc-ab72-12f6b2a64e63.png#align=left&amp;display=inline&amp;height=267&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=398&amp;originWidth=539&amp;size=74483&amp;status=done&amp;style=none&amp;width=362" alt="image.png" /><br />读取某个磁盘块时，需要移动磁头。访问的两个磁 盘块相隔越远，移动磁头所需时间就越长。因此，连续分配的文件在顺序读/写时速度最快。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599872372104-946bd88b-2cf8-41c1-8487-eba23b2a785b.png#align=left&amp;display=inline&amp;height=280&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=382&amp;originWidth=589&amp;size=66564&amp;status=done&amp;style=none&amp;width=432" alt="image.png" /><br />若此时文件A要拓展，需要再增加一个磁盘块（总共需要连续的4个磁盘块）。 由于采用连续结构，因此文件A占用的磁盘块必须是连续的。 因此只能将文件A全部“迁移”到绿色区域。 所以，物理上采用连续分配的文件不方便拓展。<br /><a name="XMfy0"></a></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599872475326-28e5236a-5775-4c9f-acce-e9fdd4c7e533.png#align=left&amp;display=inline&amp;height=246&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=346&amp;originWidth=510&amp;size=47788&amp;status=done&amp;style=none&amp;width=362" alt="image.png" /><br />物理上采用连续分配， 存储空间利用率低，会产生 难以利用的磁盘碎片 可以用紧凑来处理碎片，但 是需要耗费很大的时间代价。<br />优点：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快 <br />缺点：不方便文件拓展；存储空间利用率低，会产生磁盘碎片<br /><a name="go5cQ"></a></p><h2 id="链接分配"><a class="markdownIt-Anchor" href="#链接分配"></a> 链接分配</h2><p>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。其又分为隐式链接和显式链接两种。<br /><a name="auGlx"></a></p><h3 id="隐式链接"><a class="markdownIt-Anchor" href="#隐式链接"></a> 隐式链接</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599872682048-d0845a64-bf01-4eda-9fe5-a0838c9d9dd5.png#align=left&amp;display=inline&amp;height=306&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=436&amp;originWidth=490&amp;size=102502&amp;status=done&amp;style=none&amp;width=344" alt="image.png" /><br />用户给出要访问的逻辑块号 i，操作系统找到该文件对应的目录项（FCB），从目录项中找到起始块号（即0号块），将0号逻辑块读入内存，由此知道1号逻辑块存放的物理块号，于是读入1号逻辑块，再找到2号逻辑块的存放位置，以此类推。 因此，读入i号逻辑块，总共需要 i+1 次磁盘 I/O。<br />采用链式分配（隐式链接）方式的文件，只支持顺序访问，不支持随机访问，查 找效率低。另外，指向下一个盘块的指针也 需要耗费少量的存储空间。<br />若此时要拓展文件，则可以随便 找一个空闲磁盘块，挂到文件的 磁盘块链尾，并修改文件的FCB，因此采用隐式链接的链接分配方式，很方便文件拓展。 另外，所有的空闲磁盘块都可以被利用，不会有碎片问题， 外存利用率高。<br /><a name="thOYg"></a></p><h4 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h4><p>除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录 包括文件第一块的指针和最后一块的指针。<br />优点：很方便文件拓展，不会有碎片问题，外存利用率高。 <br />缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量 的存储空间。<br /><a name="d4Tgz"></a></p><h3 id="显式链接"><a class="markdownIt-Anchor" href="#显式链接"></a> 显式链接</h3><p>把用于链接文件各物理块的指针显式地存放在一张表中。即 文件分配表（FAT，File Allocation Table）。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599872943166-cab1f85e-3a83-4fd8-ba34-642f3ec3b1f6.png#align=left&amp;display=inline&amp;height=309&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=418&amp;originWidth=528&amp;size=64881&amp;status=done&amp;style=none&amp;width=390" alt="image.png" /><br /><br /><br />假设某个新创建的文件“aaa”依 次存放在磁盘块 2-&gt;5-&gt;0-&gt;1 <br />假设某个新创建的文件“bbb”依次存放在磁盘块 4-&gt;23-&gt;3<br />注意：一个磁盘仅设置一张FAT。 开机时，将FAT读入内存，并常驻 内存。 FAT 的各个表项在物理上 连续存储，且每一个表项长度相 同，因此“物理块号”字段可以 是隐含的。<br />用户给出要访问的逻辑块号 i，操作系统找到该文件对应的目录项 （FCB），从目录项中找到起始块号，若i&gt;0，则查询内存中的文件分配表FAT， 往后找到 i 号逻辑块对应的物理块号。逻辑块号转换成物理块号的过 程不需要读磁盘操作。<br />采用链式分配（显式链接）方式的文件，支持顺序访问，也支 持随机访问（想访问 i 号逻辑块时，并不需要依次访问之前的 0 ~ i-1 号逻辑块），由于块号转换的过程不需要访问磁盘，因此相比于隐式 链接来说，访问速度快很多。<br />显然，显式链接也不会产生外部碎片，也可以很方便地对文件进行拓 展。<br /><a name="mYtdo"></a></p><h4 id="总结-3"><a class="markdownIt-Anchor" href="#总结-3"></a> 总结</h4><p>把用于链接文件各物理块的指针显式地存放在一张表中，即 文件分配表（FAT，File Allocation Table）。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内存。<br />优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接 来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。 <br />缺点：文件分配表的需要占用一定的存储空间。<br /><a name="9HHKW"></a></p><h2 id="索引分配"><a class="markdownIt-Anchor" href="#索引分配"></a> 索引分配</h2><p>索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文 件的各个逻辑块对应的物理块（索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间 的映射关系）。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599873449525-d3c63abe-0a39-4a00-9650-64ff1f087c05.png#align=left&amp;display=inline&amp;height=286&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=367&amp;originWidth=523&amp;size=86521&amp;status=done&amp;style=none&amp;width=407" alt="image.png" /><br />假设某个新创建的文件“aaa”的数据依次存放在磁盘块 2-&gt;5-&gt;13-&gt;9 。 7号磁盘块作为“aaa”的索引块， 索引块中保存了索引表的内容。 <br />注：在显式链接的链式分配方式中，文 件分配表FAT 是一个磁盘对应一张。而 索引分配方式中，索引表是一个文件对 应一张。<br />可以用固定的长度表示物理块号（如： 假设磁盘总容量为1TB=240B，磁盘块大 小为1KB，则共有 230个磁盘块，则可用 4B 表示磁盘块号），因此，索引表中 的“逻辑块号”可以是隐含的。<br />用户给出要访问的逻辑块号 i，操作系统找 到该文件对应的目录项（FCB）,从目录项中可知索引表存放位置，将索引表 从外存读入内存，并查找索引表即可只 i 号 逻辑块在外存中的存放位置。<br />可见，索引分配方式可以支持随机访问。 文件拓展也很容易实现（只需要给文件分配 一个空闲块，并增加一个索引表项即可） 但是索引表需要占用一定的存储空间。<br />若每个磁盘块1KB，一个索 引表项4B，则一个磁盘块只 能存放 256 个索引项。如果一个文件的大小超过了256 块，那么一个磁盘块是装不下 文件的整张索引表的，因此引出了链接方案、多层索引、混合索引的解决方案。<br /><a name="YN9Wb"></a></p><h3 id="链接方案"><a class="markdownIt-Anchor" href="#链接方案"></a> 链接方案</h3><p>如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599873745310-6e5bcaa6-f981-4f1a-8bae-04104575e801.png#align=left&amp;display=inline&amp;height=292&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=386&amp;originWidth=512&amp;size=50281&amp;status=done&amp;style=none&amp;width=387" alt="image.png" /><br />假设磁盘块大小为1KB，一个索引表 项占4B，则一个磁盘块只能存放256 个索引项。 <br />若一个文件大小为 256<em>256KB = 65,536 KB = 64MB 该文件共有 256</em>256 个块，也就对应 256*256个索引项，也就需要 256 个 索引块来存储，这些索引块用链接方案连起来。<br />若想要访问文件的最后一个逻辑块， 就必须找到最后一个索引块（第256 个索引块），而各个索引块之间是用 指针链接起来的，因此必须先顺序地 读入前 255 个索引块。<br /><a name="ibefz"></a></p><h3 id="多层索引"><a class="markdownIt-Anchor" href="#多层索引"></a> 多层索引</h3><p>建立多层索引（原理类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据 文件大小的要求再建立第三层、第四层索引块。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599873865528-4f3bdfb6-88c3-455f-9764-22b233a3a3af.png#align=left&amp;display=inline&amp;height=366&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=389&amp;originWidth=442&amp;size=61051&amp;status=done&amp;style=none&amp;width=416" alt="image.png" /><br />假设磁盘块大小为1KB，一个索引表项占4B，则一个 磁盘块只能存放256 个索引项。 <br />若某文件采用两层索引，则该文件的最大长度可以到 256<em>256</em>1KB = 65,536 KB = 64MB 可根据逻辑块号算出应该查找索引表中的哪个表项。 如：要访问 1026 号逻辑块，则 1026/256 = 4，1026%256 = 2 <br />因此可以先将一级索引表调入内存，查询 4 号表项， 将其对应的二级索引表调入内存，再查询二级索引表 的2号表项即可知道 1026 号逻辑块存放的磁盘块号了。 访问目标数据块，需要3次磁盘I/O。采用 K 层索引结构，且顶级索引表未调入 内存，则访问一个数据块只需要 K + 1 次 读磁盘操作。<br />若采用三层索引，则文件的最大长度为 256<em>256</em>256*1KB = 16GB 类似的，访问目标数据块，需要4次磁盘I/O。<br /><a name="CUoxX"></a></p><h3 id="混合索引"><a class="markdownIt-Anchor" href="#混合索引"></a> 混合索引</h3><p>多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接 指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表） 。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599874002172-45342705-242d-43fc-b462-cb24fcd9ddf5.png#align=left&amp;display=inline&amp;height=235&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=362&amp;originWidth=668&amp;size=43963&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br />这种结构的索引支持的最大文件长度为65800KB。<br /><a name="Sn2SQ"></a></p><h2 id="总结-4"><a class="markdownIt-Anchor" href="#总结-4"></a> 总结</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599874094352-0c171eeb-704c-41c7-bebd-d8f7a4fc39a6.png#align=left&amp;display=inline&amp;height=237&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=349&amp;originWidth=835&amp;size=256474&amp;status=done&amp;style=none&amp;width=568" alt="image.png" /><br />“文件的某种逻辑结构支持随机存取/随机访问”是指：采用 这种逻辑结构的文件，可以根据记录号直接算出该记录对应 的逻辑地址 （逻辑块号，块内地址）。<br /><a name="bsSDz"></a></p><h1 id="文件的存储空间管理"><a class="markdownIt-Anchor" href="#文件的存储空间管理"></a> 文件的存储空间管理</h1><p>安装操作系统的必经步骤就是磁盘分区，即存储空间的划分，将物理地址划分为一个个的文件卷（逻辑卷、逻辑盘）。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599874318211-32cdb647-bc74-4390-8608-06b0caac7272.png#align=left&amp;display=inline&amp;height=222&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=309&amp;originWidth=764&amp;size=84226&amp;status=done&amp;style=none&amp;width=550" alt="image.png" /><br /><a name="131up"></a></p><h2 id="空闲表法"><a class="markdownIt-Anchor" href="#空闲表法"></a> 空闲表法</h2><p>该方法适用于连续分配方式的存储空间管理。<br />与内存管理中的动态分区分配类似，唯一个文件分配连续的存储空间，同样可以采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个分区。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599874544520-b34c12cc-63b9-4d26-93bf-48e685964921.png#align=left&amp;display=inline&amp;height=244&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=312&amp;originWidth=711&amp;size=58263&amp;status=done&amp;style=none&amp;width=556" alt="image.png" /><br /><a name="vRUbT"></a></p><h2 id="空闲链表法"><a class="markdownIt-Anchor" href="#空闲链表法"></a> 空闲链表法</h2><p>操作系统保存着链头、链尾指针。<br />若文件申请K个盘块，则可以采用首次适应、最佳适应等算法从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区分配给文件。若没有适合的连续空闲块也可以将不同盘区的潘快同时分配给一个文件，注意分配后可能需要修改相应的链指针、盘区大小等数据。<br />若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为一个单独的空闲盘区挂在链尾。<br />空闲链表又可以分为空闲盘块链、空闲盘区链。<br /><a name="pExGi"></a></p><h3 id="空闲盘块链"><a class="markdownIt-Anchor" href="#空闲盘块链"></a> 空闲盘块链</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599874668487-4ca972fa-529b-4e44-98e2-106dc971d67b.png#align=left&amp;display=inline&amp;height=287&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=300&amp;originWidth=261&amp;size=35961&amp;status=done&amp;style=none&amp;width=250" alt="image.png" /><br /><a name="00D3I"></a></p><h3 id="空闲盘区链"><a class="markdownIt-Anchor" href="#空闲盘区链"></a> 空闲盘区链</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599874679352-d94a93e8-0f10-4899-8f0b-8144e2fd1e6f.png#align=left&amp;display=inline&amp;height=305&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=308&amp;originWidth=367&amp;size=50185&amp;status=done&amp;style=none&amp;width=364" alt="image.png" /><br /><a name="OZdXd"></a></p><h3 id="位示图法"><a class="markdownIt-Anchor" href="#位示图法"></a> 位示图法</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599875375451-2ef28de0-192f-493e-90fb-c6a52dac6c5c.png#align=left&amp;display=inline&amp;height=273&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=407&amp;originWidth=717&amp;size=72374&amp;status=done&amp;style=none&amp;width=481" alt="image.png" /><br />每个二进制对应一个盘块，在本例中，0代表盘块空闲，1代表盘块已分配。位示图一般用连续的字来表示。如本例中一个字的字长为16位，字中的每一位对应一个盘块。因此可以用（字号，位号）对应一个盘块号。<br />（字号，位号）=（i，j）的二进制位对应的盘块号b=ni+j<br />b盘块对应的字号i=b/n，位号j=b%n<br />若文件需要K个块，则按照以下步骤进行分配：</p><ol><li>顺序扫描位示图，找到K个相邻或不相邻的0</li><li>根据字号、位图算出对应的盘块号，将相应盘块号分配给文件</li><li>将相应位设置为1</li></ol><p>回收方式按照以下步骤进行：</p><ol><li>根据回收的盘位号计算出相应的字号、位号。</li><li>将响应二进制位设为0<br /><a name="gjEuw"></a></li></ol><h2 id="成组链接法"><a class="markdownIt-Anchor" href="#成组链接法"></a> 成组链接法</h2><p>空闲链表法、空闲表法不适用于大型文件系统，因为空闲表或空闲链表可能过大，UNIX采用了成组链接法对磁盘的空闲块进行管理。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599875777382-7e01c0fc-3ff9-49c7-8cc4-30dd4c36413c.png#align=left&amp;display=inline&amp;height=206&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=240&amp;originWidth=307&amp;size=16712&amp;status=done&amp;style=none&amp;width=264" alt="image.png" /><br />文件卷的目录中专门用一个磁盘块作为超级块，当系统启动时，需要将超级块读入内存，并且要保证内存与外存的超级快数据一致。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599875917323-5775ce11-7770-4664-b1b8-6f6738b219be.png#align=left&amp;display=inline&amp;height=241&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=376&amp;originWidth=675&amp;size=63294&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br />如果需要100个空闲块，会按照以下步骤进行分配：</p><ol><li>检查第一个分组的块数是否足够，100=100则为足够。</li><li>分配第一个分组的100个空闲块，然是由于300号快内存放了下一组信息，因此300好快的数据需要复制到超级块中。</li></ol><p>如果每个分组最到位100个空闲块，此时第一个分组已经拥有100个块还要回收，需要将超级快中的数据复制到新的回收快中，并修改超级块的内容，让新的块成为第一个分组。<br /><a name="PsOIf"></a></p><h1 id="文件的基本操作"><a class="markdownIt-Anchor" href="#文件的基本操作"></a> 文件的基本操作</h1><p>文件的基本操作分为如下几个功能：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599876232679-2ae6cae6-e233-4215-a073-dbe327016e9e.png#align=left&amp;display=inline&amp;height=202&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=404&amp;originWidth=364&amp;size=97437&amp;status=done&amp;style=none&amp;width=182" alt="image.png" /><br /><a name="mv3Fb"></a></p><h2 id="创建文件-2"><a class="markdownIt-Anchor" href="#创建文件-2"></a> 创建文件</h2><p>电脑上可以通过如下操作进行创建文件：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599876395511-f50411e4-82bf-48a4-b66d-3f3e2aaf073b.png#align=left&amp;display=inline&amp;height=281&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=562&amp;originWidth=770&amp;size=483918&amp;status=done&amp;style=none&amp;width=385" alt="image.png" /><br />在进行Create系统调用时需要提供如下几个参数：</p><ul><li>所需的内存空间大小</li><li>文件存放路径</li><li>文件名</li></ul><p>其在创建文件时，主要进行了如下两个操作：</p><ul><li>在外存中找到文件所需的空间（结合空闲链表法、位示图、成组链接法等管理策略）</li><li>根据文件存放路径的信息找到该目录对应的目录文件，在目录中创建该文件对应的目录项。目录项中包含了文件名、文件在外存中存放位置等信息。<br /><a name="GpvRc"></a></li></ul><h2 id="删除文件-2"><a class="markdownIt-Anchor" href="#删除文件-2"></a> 删除文件</h2><p>电脑上可以通过如下操作进行删除文件：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599876906859-18144f00-0415-4106-a3c5-5bd4b52a7d4f.png#align=left&amp;display=inline&amp;height=332&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=663&amp;originWidth=366&amp;size=35809&amp;status=done&amp;style=none&amp;width=183" alt="image.png" /><br />进行Delete系统调用时，需要提供几个主要参数：</p><ul><li>文件存放路径</li><li>文件名</li></ul><p>在Delete系统调用时，主要做了如下几件事：</p><ul><li>根据文件存放路径找到对应的目录文件，从目录中找到文件名对应的目录项。</li><li>根据该目录项记录的文件在外村存放位置、文件大小等信息，回收文件占用的磁盘块。（根据空闲表法、空闲链表法、位图法等管理策略的不同做出不同的处理）</li><li>从目录中删除文件对应的目录项。<br /><a name="ddRqH"></a></li></ul><h2 id="打开文件-2"><a class="markdownIt-Anchor" href="#打开文件-2"></a> 打开文件</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599877278097-31bcb91c-dec2-40d7-aad8-3aad46673b88.png#align=left&amp;display=inline&amp;height=328&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=468&amp;originWidth=593&amp;size=78386&amp;status=done&amp;style=none&amp;width=416" alt="image.png" /><br />执行Open系统调用打开文件，需要以下几个主要参数：</p><ul><li>文件存放路径</li><li>文件名</li><li>文件的操作类型（r：只读，rw：读写等）</li></ul><p>操作系统在调用函数时，主要做了以下几件事：</p><ul><li>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项，并检查该用户是否由指定的操作权限。</li><li>将目录项复制到内存中的打开文件表中。并将对应表中的编号返回给用户，之后用户使用打开文件表的编号来指明操作的文件。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599877557471-ccfcda6f-b58a-439e-b4eb-b57256658e92.png#align=left&amp;display=inline&amp;height=343&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=498&amp;originWidth=846&amp;size=217312&amp;status=done&amp;style=none&amp;width=583" alt="image.png" /><br /><a name="MRP07"></a></p><h2 id="关闭文件-2"><a class="markdownIt-Anchor" href="#关闭文件-2"></a> 关闭文件</h2><p>关闭文件主要做了以下几件事：</p><ul><li>将进程的打开文件表响应表项删除</li><li>回收分配给该文件的内存空间等资源</li><li>系统打开文件表的打开计数器count减一，若count=0，则删除对应表项。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599877720626-32def3cd-fee3-46fb-abec-3c4152ca2e62.png#align=left&amp;display=inline&amp;height=243&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=485&amp;originWidth=822&amp;size=102753&amp;status=done&amp;style=none&amp;width=411" alt="image.png" /><br /><a name="vQIgN"></a></p><h2 id="读文件-2"><a class="markdownIt-Anchor" href="#读文件-2"></a> 读文件</h2><p>系统的read调用完成写操作，需要指明是哪个文件、读入多少数据和药存放的内存位置即可。<br />系统在处理read系统调用时，会从读指针指向外存中，将用户指定大小的数据读入用户指定的内存区域中。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599877869415-04db04ce-6c5f-4a42-953d-99fdd2578097.png#align=left&amp;display=inline&amp;height=322&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=430&amp;originWidth=771&amp;size=118038&amp;status=done&amp;style=none&amp;width=578" alt="image.png" /><br /><a name="LGx5w"></a></p><h2 id="写文件-2"><a class="markdownIt-Anchor" href="#写文件-2"></a> 写文件</h2><p>进程使用write完成写操作，需要指明是哪个文件、写出多少数据和写回外存的数据放在内存的位置即可。<br />操作系统在处理write系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599878054614-65c3fc38-48c4-476d-a1df-5029e8dd26db.png#align=left&amp;display=inline&amp;height=298&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=426&amp;originWidth=736&amp;size=120887&amp;status=done&amp;style=none&amp;width=515" alt="image.png" /><br /><a name="SDVum"></a></p><h1 id="文件共享"><a class="markdownIt-Anchor" href="#文件共享"></a> 文件共享</h1><p>系统为用户提供文件共享功能，可以让多个用户共享的使用同一个文件。<br />注意：</p><ul><li>多个用户共享同一个文件，意味着系统中只有一份文件数据，并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化。</li><li>如果是多个用户都复制了同一个文件，那么系统中会有好几分文件数据，其中一个用户修改了自己那份数据对其他用户没有影响。</li></ul><p>文件共享分为基于索引节点的共享方式（硬链接）和基于符号链的共享方式（软链接）。<br /><a name="n0Yv6"></a></p><h2 id="基于索引节点的共享方式"><a class="markdownIt-Anchor" href="#基于索引节点的共享方式"></a> 基于索引节点的共享方式</h2><p>索引节点是一种文件目录瘦身策略，由于索引文件时只需用到文件名，因此可以将除了文件名以外的其他信息放到索引节点中。这样目录项只需要包含文件名、索引节点指针。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599878416647-08497fe2-d547-4e64-8b27-eb8d5790185e.png#align=left&amp;display=inline&amp;height=143&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=220&amp;originWidth=809&amp;size=47896&amp;status=done&amp;style=none&amp;width=527" alt="image.png" /><br />索引节点中设置一个连接计数变量count，用于标识链接到本索引节点上的用户目录项数。<br />若count=2，说明此事有两个用户目录项连接到该索引节点上，或者说有两个用户在共享此文件，若某个用户决定删除这个文件，则只要把用户目录中与该文件对应的目录项删除，则索引节点的count减一。<br />若count&gt;0，说明还有别的用户使用该文件，则不能删除文件数据，否则会导致指针悬空。<br />当count=0时说明系统负责删除文件。<br /><a name="dvJ9P"></a></p><h2 id="基于符号链的共享方式"><a class="markdownIt-Anchor" href="#基于符号链的共享方式"></a> 基于符号链的共享方式</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599878722831-12631b1f-4c86-4b5a-a6a7-8daddc2b1638.png#align=left&amp;display=inline&amp;height=247&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=357&amp;originWidth=802&amp;size=104581&amp;status=done&amp;style=none&amp;width=554" alt="image.png" /><br />当User3访问ccc时，操作系统判断文件ccc属于Link类型文件，于是会根据其中的记录路径层层查找目录，最终找到User1的目录表中的aaa表项，于是就找到了文件1的索引信道。<br />所谓的快捷方式就是软链接的表现。<br /><a name="1Kg9x"></a></p><h1 id="文件保护"><a class="markdownIt-Anchor" href="#文件保护"></a> 文件保护</h1><p>文件保护用来保护文件的数据安全，其分为口令保护、加密保护、访问控制。<br /><a name="WMPtV"></a></p><h2 id="口令保护"><a class="markdownIt-Anchor" href="#口令保护"></a> 口令保护</h2><p>为文件设置一个口令，用户请求访问该文件时必须提供口令。<br />口令一般存放在文件对应的FCB或索引节点中，用户访问文件前需要先输入口令，操作系统会将用户提供的口令与FCB中存储的口令进行对比，如果正确则允许用户访问文件。<br />优点：保存口令的空间开销并不多，验证口令的开销也很少。<br />缺点：正确的口令存放在系统内部不够安全。<br /><a name="Tn26d"></a></p><h2 id="加密保护"><a class="markdownIt-Anchor" href="#加密保护"></a> 加密保护</h2><p>使用某个密码对文件进行加密，再访问文件时需要提供正确的密码才能对文件正确的解密，常用的加密算法：异或加密。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599879185234-846c4306-7c0d-4a94-806d-7aa6b745e520.png#align=left&amp;display=inline&amp;height=162&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=226&amp;originWidth=722&amp;size=63487&amp;status=done&amp;style=none&amp;width=519" alt="image.png" /><br />优点：保密性强，不需要在系统中存储密码。<br />缺点：编解码花费时间较长。<br /><a name="HmLZZ"></a></p><h2 id="访问控制"><a class="markdownIt-Anchor" href="#访问控制"></a> 访问控制</h2><p>在每个文件的FCB或索引节点中增加一个访问控制列表，该表中记录了个用户可对用户执行哪些操作。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599879310154-1176e305-3a4a-43e0-abf2-7b530ebfa37e.png#align=left&amp;display=inline&amp;height=201&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=287&amp;originWidth=733&amp;size=97478&amp;status=done&amp;style=none&amp;width=513" alt="image.png" /><br />精简的访问列表以组为单位，标记各族用户可以对用户执行哪些操作。当某用户想要访问文件时，系统会检查用户所属文组来确定是否有相应的权限。<br /><a name="xYIV9"></a></p><h1 id="系统的层次结构总结"><a class="markdownIt-Anchor" href="#系统的层次结构总结"></a> 系统的层次结构总结</h1><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599879466091-a204042b-a0c4-4cfe-9cab-a8949956837f.png#align=left&amp;display=inline&amp;height=329&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=369&amp;originWidth=754&amp;size=206236&amp;status=done&amp;style=none&amp;width=672" alt="image.png" /><br />举个理解来回忆文件系统的层次结构，假设用户请求删除文件“D:/表格/学生信息表.xlsx”的最后100条记录。</p><ul><li>用户需要通过操作系统系统提供的接口发出上述请求——用户接口</li><li>由于用户提供的是文件的存放路径，因此需要操作系统一层一层的查找目录找到对应的目录项——文件目录系统</li><li>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限——存取控制模块（存取控制验证层）</li><li>验证了用户的访问权限之后，需要把用户提供的记录号转变为对应的逻辑地址——逻辑文件系统与文件信息缓冲区</li><li>知道了目标记录的逻辑地址后，需要转换成实际的物理地址——物理文件系统</li><li>要删除这条记录，必定要对磁盘设备发出请求——设备管理程序模块</li><li>删除这些记录后，会有一些盘块空闲，因此要对这些盘块进行回收——辅助分配模块</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之虚拟内存</title>
      <link href="/posts/operating_system_virtual_memory/"/>
      <url>/posts/operating_system_virtual_memory/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统之虚拟内存"><a class="markdownIt-Anchor" href="#操作系统之虚拟内存"></a> 操作系统之虚拟内存</h1><p><a name="1cKIp"></a></p><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>在之前的内存管理的内存空间扩充知识点里提及到了覆盖技术、交换技术和虚拟存储技术。这里的虚拟存储技术就是在传统存储管理方式的基础上引入了交换技术、覆盖技术，使得内存利用率有所提升，并且能从逻辑上扩充内存容量。<br /><a name="K08FW"></a></p><h2 id="传统存储管理方式的特征-缺点"><a class="markdownIt-Anchor" href="#传统存储管理方式的特征-缺点"></a> 传统存储管理方式的特征、缺点</h2><p>传统的存储管理很多暂时用不到的数据也会长期占用内存， 导致内存利用率不高。其特点如下：</p><ul><li>一次性：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：<ul><li>作业很大时，不能全部装入内存，导致大作业无法运行</li><li>当大量作业要求运行时，由于内存无法容纳所有作业，因此只 少量作业能运行，导致多道程序并发度下降。</li></ul></li><li>驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。<br /><a name="yMx2c"></a></li></ul><h2 id="局部性原理"><a class="markdownIt-Anchor" href="#局部性原理"></a> 局部性原理</h2><p>在虚拟存储技术中引入了局部性原理的概念，其分为两种局部性：时间局部性和空间局部性。<br /><a name="rpi31"></a></p><h3 id="时间局部性"><a class="markdownIt-Anchor" href="#时间局部性"></a> 时间局部性</h3><p>如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）<br /><a name="nl5lT"></a></p><h3 id="空间局部性"><a class="markdownIt-Anchor" href="#空间局部性"></a> 空间局部性</h3><p>一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。 （因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）<br /><a name="V7VQb"></a></p><h2 id="虚拟内存的定义和特征"><a class="markdownIt-Anchor" href="#虚拟内存的定义和特征"></a> 虚拟内存的定义和特征</h2><p>快表机构就是将近期 常访问的页表项副本放到更高速的联想寄存器中。<br />高速缓冲技术的思想： 将近期会频繁访问到的 数据放到更高速的存储 器中，暂时用不到的数据放在更低速存储器中。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599729388643-287a7b45-20d6-4f3d-9d9d-94a43870e25e.png#align=left&amp;display=inline&amp;height=231&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=261&amp;originWidth=437&amp;size=50440&amp;status=done&amp;style=none&amp;width=387" alt="image.png" /><br />基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。 <br />在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。 <br />若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。 在操作系统的管理下，在用户看来似乎有一个比实际 内存大得多的内存，这就是虚拟内存。<br />注意：操作系统虚拟性的一个体现是实际的物理内存大小没有变，只是在逻辑上进行了扩充。<br /><a name="9Jd7i"></a></p><h3 id="易混知识点"><a class="markdownIt-Anchor" href="#易混知识点"></a> 易混知识点</h3><p>虚拟内存的最大容量是由计算机的地址结构（CPU寻址范围）确定的 <br />虚拟内存的实际容量 =min（内存和外存容量之和，CPU寻址范围）<br />如：某计算机地址结构为32位，按字节编址，内存大小为512MB，外存大小为2GB。 <br />则虚拟内存的最大容量为 232B = 4GB <br />虚拟内存的实际容量 = min (232B, 512MB+2GB) = 2GB+512MB<br /><a name="ORhYN"></a></p><h3 id="三个特征"><a class="markdownIt-Anchor" href="#三个特征"></a> 三个特征</h3><ul><li>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</li><li>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。</li><li>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。<br /><a name="usN4I"></a></li></ul><h1 id="虚拟内存技术的实现"><a class="markdownIt-Anchor" href="#虚拟内存技术的实现"></a> 虚拟内存技术的实现</h1><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599733584890-e9c82c12-f3d8-4721-ae2c-a553a2e1e488.png#align=left&amp;display=inline&amp;height=266&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=378&amp;originWidth=747&amp;size=188057&amp;status=done&amp;style=none&amp;width=525" alt="image.png" /><br />虚拟内存技术允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此， 虚拟内存的实现需要建立在离散分配的内存管理方式基础上。<br />虚拟内存和传统方式主要的区别就是在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存（操作系统要提供请求调页（或请求调段）功能），然后继续执行程序。 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。（操作系统要提供页面置换（或段置换）的功能）<br /><a name="PgDPX"></a></p><h2 id="请求分页管理方式"><a class="markdownIt-Anchor" href="#请求分页管理方式"></a> 请求分页管理方式</h2><p>请求分页存储管理与基本分页存储管理的主要区别：在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。 （操作系统要提供请求调页功能， 将缺失页面从外存调入内存）<br />若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。（操作系统要提供页面置换的功能， 将暂时用不到的页面换出外存）<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599730296788-bbe46892-0f5f-4676-8d2c-48b5c9dc6125.png#align=left&amp;display=inline&amp;height=104&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=148&amp;originWidth=486&amp;size=42108&amp;status=done&amp;style=none&amp;width=340" alt="image.png" /><br /><a name="yjiuE"></a></p><h3 id="页表机制"><a class="markdownIt-Anchor" href="#页表机制"></a> 页表机制</h3><p>与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存。如果还没调入，那么也需要知道该页面在外存中存放的位置。<br />当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面；有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面 是否被修改的信息。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599731001373-c68369fe-4e3f-45b2-9189-86320e8df51e.png#align=left&amp;display=inline&amp;height=205&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=243&amp;originWidth=805&amp;size=102450&amp;status=done&amp;style=none&amp;width=679" alt="image.png" /><br /><a name="D0RPx"></a></p><h3 id="缺页中断机构"><a class="markdownIt-Anchor" href="#缺页中断机构"></a> 缺页中断机构</h3><p>在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。 <br />此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。<br />如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。<br />如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。<br />缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断 一条指令在执行期间，可能产生多次缺页中断。（如：copy A to B，即将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断）<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599731641054-0fa80b0b-6de3-4e73-8cbe-d136407ae528.png#align=left&amp;display=inline&amp;height=270&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=270&amp;originWidth=713&amp;size=95554&amp;status=done&amp;style=none&amp;width=713" alt="image.png" /><br /><a name="TTZyY"></a></p><h3 id="地址变换机构"><a class="markdownIt-Anchor" href="#地址变换机构"></a> 地址变换机构</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599732055864-5615cdd7-6099-416e-8165-13773c24c082.png#align=left&amp;display=inline&amp;height=229&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=303&amp;originWidth=832&amp;size=114537&amp;status=done&amp;style=none&amp;width=630" alt="image.png" /><br /><a name="6s36f"></a></p><h4 id="执行流程"><a class="markdownIt-Anchor" href="#执行流程"></a> 执行流程</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599732103560-c9b718ef-987c-448d-affd-ecc8af4690a2.png#align=left&amp;display=inline&amp;height=321&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=403&amp;originWidth=758&amp;size=123533&amp;status=done&amp;style=none&amp;width=604" alt="image.png" /><br />在具有快表机构的请求分页系统中，访问一个逻辑地址 时，若发生缺页，则地址变换步骤是：<br />查快表(未命中)——查慢表(发现未调入内存)——调页(调 入的页面对应的表项会直接加入快表)——查快表(命 中)——访问目标内存单元<br />补充细节：</p><ul><li>只有“写指令”才需要修改 “修改位”。并且，一般来说只 需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。</li><li>和普通的中断处理一样，缺页中断处理依然需要保留CPU现场。</li><li>需要用某种“页面置换算法” 来决定一个换出页面（下节内容）</li><li>换入/换出页面都需要启动慢 速的I/O操作，可见，如果换入/ 换出太频繁，会有很大的开销。</li><li>页面调入内存后，需要修改慢 表，同时也需要将表项复制到快 表中。<br /><a name="vczdA"></a></li></ul><h2 id="页面置换算法"><a class="markdownIt-Anchor" href="#页面置换算法"></a> 页面置换算法</h2><p>页面置换算法分为五种实现方法，分别是：最佳置换算法、先进先出置换算法、最近最久未使用置换算法、时钟置换算法、改进型的时钟置换算法。<br /><a name="bzuTc"></a></p><h3 id="最佳置换算法opt"><a class="markdownIt-Anchor" href="#最佳置换算法opt"></a> 最佳置换算法（OPT）</h3><p>每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。<br />例：假设系统为某进程分配了三个内存块，并考虑到有一下页面号引用串（会依次访问这些页面）：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599732595502-91592f7f-f73b-47d9-8a99-9047d03e45a4.png#align=left&amp;display=inline&amp;height=273&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=327&amp;originWidth=845&amp;size=124834&amp;status=done&amp;style=none&amp;width=706" alt="image.png" /><br /><br /><br />最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到 的是哪个页面。操作系统无法ᨀ前预判页面访问序列。因此，最佳置换算法是无法实现的。<br /><a name="VCDeX"></a></p><h3 id="先进先出置换算法fifo"><a class="markdownIt-Anchor" href="#先进先出置换算法fifo"></a> 先进先出置换算法（FIFO）</h3><p>每次选择淘汰的页面是最早进入内存的页面 <br />实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。 队列的最大长度取决于系统为进程分配了多少个内存块。 <br />例：假设系统为某进程分配了三个内存块，并考虑到有以下页面号引用串<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599732718347-95b47cbf-6007-4d24-919c-f3c56c4ee18a.png#align=left&amp;display=inline&amp;height=242&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=309&amp;originWidth=765&amp;size=62446&amp;status=done&amp;style=none&amp;width=598" alt="image.png" /><br /><a name="1JeGi"></a></p><h4 id="belady-异常"><a class="markdownIt-Anchor" href="#belady-异常"></a> Belady 异常</h4><p>当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。<br />例：假设系统为某进程分配了四个内存块，并考虑到有以下页面号引用串：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599732814429-2963be65-f796-4822-affa-2c1dcd36a251.png#align=left&amp;display=inline&amp;height=139&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=212&amp;originWidth=853&amp;size=73398&amp;status=done&amp;style=none&amp;width=558" alt="image.png" /><br />只有 FIFO 算法会产生 Belady 异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的 规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差<br /><a name="9zf87"></a></p><h3 id="最近最久未使用置换算法lru"><a class="markdownIt-Anchor" href="#最近最久未使用置换算法lru"></a> 最近最久未使用置换算法（LRU）</h3><p>每次淘汰的页面是最近最久未使用的页面 <br />实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。 当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面。<br />该算法的实现需要专门的硬件支持，虽然算法性能好， 但是实现困难，开销大。<br />例：假设系统为某进程分配了四个内存块，并考虑到有以下页面号引用串：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599733053182-274fad21-f858-4c7c-a2ea-dfaa6879cfc4.png#align=left&amp;display=inline&amp;height=133&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=192&amp;originWidth=782&amp;size=48657&amp;status=done&amp;style=none&amp;width=542" alt="image.png" /><br /><a name="8KH3D"></a></p><h3 id="时钟置换算法clock"><a class="markdownIt-Anchor" href="#时钟置换算法clock"></a> 时钟置换算法（CLOCK）</h3><p>最佳置换算法性能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用 置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。 时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法（NRU，Not Recently Used）<br />简单的CLOCK 算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成 一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。 如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会 有访问位为0的页面，因此简单的CLOCK 算法选择一个淘汰页面最多会经过两轮扫描）<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599733417516-f40f2fc3-3f32-4a0e-a55d-f78b63afd878.png#align=left&amp;display=inline&amp;height=91&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=116&amp;originWidth=541&amp;size=31880&amp;status=done&amp;style=none&amp;width=426" alt="image.png" /><br /><a name="TYyD7"></a></p><h3 id="改进型的时钟置换算法"><a class="markdownIt-Anchor" href="#改进型的时钟置换算法"></a> 改进型的时钟置换算法</h3><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过， 就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。 <br />因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他 条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作。这就是改进型的时钟置换算法的思想。 修改位=0，表示页面没有被修改过；修改位=1，表示页面被修改过。 <br />为方便讨论，用（访问位，修改位）的形式表示各页面状态。如（1，1）表示一个页面近期被访问过， 且被修改过。<br />算法规则：将所有可能被置换的页面排成一个循环队列 <br />第一轮：从当前位置开始扫᧿到第一个（0,0）的帧用于替换。本轮扫描不修改任何标志位 （第一优先级：最近没访问， 且没修改的页面）<br />第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0,1）的帧用于 替换。本轮将所有扫描过的帧访问位设为0 （第二优先级：最近没访问， 但修改过的页面）<br />第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0,0）的帧用于替换。本轮扫描不修改任何标志位 （第三优先级：最近访问过， 但没修改的页面）<br />第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0,1）的帧用于替换。 （第四优先级：最近访问过， 且修改过的页面）<br />由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一 定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描<br /><a name="AwSc1"></a></p><h2 id="页面分配策略"><a class="markdownIt-Anchor" href="#页面分配策略"></a> 页面分配策略</h2><p><a name="LOvCb"></a></p><h3 id="驻留集"><a class="markdownIt-Anchor" href="#驻留集"></a> 驻留集</h3><p>指请求分页存储管理中给进程分配的物理块的集合。在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。 若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少； 驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。<br />考虑一个极端情况，若某进程共 有100个页面，则该进程的驻留集大小为100时进程可以全部放入内存，运行期间不可能再发生缺页。若驻留集大小为1，则进程运行期间必定会极频繁地缺页。<br /><a name="wCQOt"></a></p><h3 id="置换策略"><a class="markdownIt-Anchor" href="#置换策略"></a> 置换策略</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599743513768-b03965e5-7f26-42e7-b2a6-3e22cf26ce81.png#align=left&amp;display=inline&amp;height=78&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=155&amp;originWidth=546&amp;size=41155&amp;status=done&amp;style=none&amp;width=273" alt="image.png" /></p><ul><li>固定分配：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变。</li><li>可变分配：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。 即，驻留集大小可变</li><li>局部置换：发生缺页时只能选进程自己的物理块进行置换。</li><li>全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换 到外存，再分配给缺页进程。</li></ul><p>可变分配全局置换：只要缺页就给分配新物理块 <br />可变分配局部置换：要根据发生缺页的频率来动态地增加或减少进程的物理块<br /><a name="CLF9o"></a></p><h4 id="固定分配局部置换"><a class="markdownIt-Anchor" href="#固定分配局部置换"></a> 固定分配局部置换</h4><p>系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运 行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略 的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。（采用这种策略的系统可 以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数）<br /><a name="mGU4d"></a></p><h4 id="可变分配全局置换"><a class="markdownIt-Anchor" href="#可变分配全局置换"></a> 可变分配全局置换</h4><p>刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一 个未锁定（系统会锁定一些页面，这些页面中 的内容不能置换出外存（如：重要 的内核数据可以设为“锁定”））的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，只要某进程发生缺页， 都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页 可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。<br /><a name="CcaKH"></a></p><h4 id="可变分配局部置换"><a class="markdownIt-Anchor" href="#可变分配局部置换"></a> 可变分配局部置换</h4><p>刚开始会为个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配 几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减 少分配给该进程的物理块。<br /><a name="QvFnC"></a></p><h3 id="何时调入页面"><a class="markdownIt-Anchor" href="#何时调入页面"></a> 何时调入页面</h3><p>预调页策略：根据局部性原理（主要指空间局部性，即：如果当前访问了某个内存单元， 在之后很有可能会接着访问 与其相邻的那些内存单元），一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如 果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页 面，将它们预先调入内存，但目前预测成功率只有50%左右。故这种策略主要用于进程的首次调入， 由程序员指出应该先调入哪些部分。<br />请求调页策略：进程在运行期间发现缺页时才将所缺页面调入内存。由这种策略调入的页面一定会 被访问到，但由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此I/O开销较大。<br />系统拥有足够的对换区空间：页面的调入、调 出都是在内存与对换区之间进行，这样可以保 证页面的调入、调出速度很快。在进程运行前， 需将进程相关的数据从文件区复制到对换区。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599744660422-f2ee8b06-8e99-491e-a9cb-a4741586292a.png#align=left&amp;display=inline&amp;height=260&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=360&amp;originWidth=440&amp;size=55915&amp;status=done&amp;style=none&amp;width=318" alt="image.png" /><br />系统缺少足够的对换区空间：凡是不会被修改 的数据都直接从文件区调入，由于这些页面不 会被修改，因此换出时不必写回磁盘，下次需 要时再从文件区调入即可。对于可能被修改的 部分，换出时需写回磁盘对换区，下次需要时 再从对换区调入。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599744703306-8af9e8b9-3365-4551-b4ef-7fae22abaa8e.png#align=left&amp;display=inline&amp;height=299&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=398&amp;originWidth=456&amp;size=70184&amp;status=done&amp;style=none&amp;width=343" alt="image.png" /><br />UNIX 方式：运行之前进程有关的数据全部放在 文件区，故未使用过的页面，都可从文件区调 入。若被使用过的页面需要换出，则写回对换 区，下次需要时从对换区调入。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599744738903-f47af07f-4951-4073-8b01-9f963a2247b7.png#align=left&amp;display=inline&amp;height=312&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=370&amp;originWidth=430&amp;size=51478&amp;status=done&amp;style=none&amp;width=363" alt="image.png" /><br /><a name="wEmec"></a></p><h3 id="抖动颠簸现象"><a class="markdownIt-Anchor" href="#抖动颠簸现象"></a> 抖动（颠簸）现象</h3><p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称 为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数（分配给进程 的物理块不够）<br />为了研究为应该为每个进程分配多 少个物理块，Denning 提出了进程 “工作集”的概念<br />为进程分配的物理块太少，会使进 程发生抖动现象。为进程分配的物 理块太多，又会降低系统整体的并 发度，降低某些资源的利用率<br /><a name="BmfUH"></a></p><h3 id="工作集"><a class="markdownIt-Anchor" href="#工作集"></a> 工作集</h3><p>驻留集：指请求分页存储管理中给进程分配的内存块的集合。 <br />工作集：指在某段时间间隔里，进程实际访问页面的集合。<br />操作系统会根据“窗口尺寸”来算出工作集。<br />例： 某进程的页面访问序列如下，窗口尺寸为 4，各时刻的工作集为？<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599744996558-d9c7d785-a0bd-49ce-bc62-aa95ecf42d69.png#align=left&amp;display=inline&amp;height=61&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=122&amp;originWidth=474&amp;size=21235&amp;status=done&amp;style=none&amp;width=237" alt="image.png" /><br />工作集大小可能小于窗口尺寸，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小 给进程分配若干内存块。如：窗口尺寸为5，经过一段时间的监测发现某进程的工作集最大为3，那么 说明该进程有很好的局部性，可以给这个进程分配3个以上的内存块即可满足进程的运行需要。 一般来说，驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页。<br />拓展：基于局部性原理可知，进程在一段时间内访问的页面与不久之后会访问的页面是有相关性的。 因此，可以根据进程近期访问的页面集合（工作集）来设计一种页面置换算法——选择一个不在工作 集中的页面进行淘汰。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之内存</title>
      <link href="/posts/operating_system_memory/"/>
      <url>/posts/operating_system_memory/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统之内存"><a class="markdownIt-Anchor" href="#操作系统之内存"></a> 操作系统之内存</h1><p><a name="Wsdw3"></a></p><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>如图，圈起来的部分就是内存空间大小：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599645535990-f5599de8-b0dd-409f-8946-7ca8e1a260c2.png#align=left&amp;display=inline&amp;height=138&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=275&amp;originWidth=708&amp;size=19747&amp;status=done&amp;style=none&amp;width=354" alt="image.png" /><br />内存可存放数据。程序执行前需要先放到内存中才能被CPU处理——缓和CPU与硬盘之间的速度矛盾。<br /><a name="36bgH"></a></p><h2 id="内存存储方式"><a class="markdownIt-Anchor" href="#内存存储方式"></a> 内存存储方式</h2><p>在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，内存就通过的存储单元编地址区分各个程序的数据是放在什么地方。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599646016912-d72b2511-5042-4a6f-b1b4-66f47414c4a7.png#align=left&amp;display=inline&amp;height=267&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=367&amp;originWidth=743&amp;size=122411&amp;status=done&amp;style=none&amp;width=540" alt="image.png" /><br /><a name="NAvQW"></a></p><h2 id="内存的数量单位"><a class="markdownIt-Anchor" href="#内存的数量单位"></a> 内存的数量单位</h2><p>一台手机/电脑有4GB 内存，代表着内存中可以存放 4*2<sup>30个字节。如果是按字节编址的话，也就是有4*2</sup>30=2^32个“小房间”，这么多“小房间”，需要 2^32个地址才能一一标识，所以地 址需要用 32 个二进制位来表示（0~ 2^32 -1）。<br /><a name="bMoFd"></a></p><h2 id="指令的工作原理"><a class="markdownIt-Anchor" href="#指令的工作原理"></a> 指令的工作原理</h2><p>指令的工作基于“地址”。 每个地址对应一个数据的存储单元。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599646258921-cdf88793-e80f-4532-accc-8f7d7bf67561.png#align=left&amp;display=inline&amp;height=232&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=345&amp;originWidth=885&amp;size=122997&amp;status=done&amp;style=none&amp;width=594" alt="image.png" /><br />可见，写的代码要翻译成CPU能识别的指令。这些指令会告诉CPU应该去内存的哪个地址读/写数据， 这个数据应该做什么样的处理。在这个例子中，默认让这个进程的相关内容从地址#0开始连续存放，指令中的地址参数直接给出了变量 x 的实际存放地址（物理地址）。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599646578081-91698313-81fc-4700-afcb-1ca7b700f340.png#align=left&amp;display=inline&amp;height=357&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=416&amp;originWidth=803&amp;size=161768&amp;status=done&amp;style=none&amp;width=690" alt="image.png" /><br /><a name="D9rcU"></a></p><h2 id="装入的三种方式"><a class="markdownIt-Anchor" href="#装入的三种方式"></a> 装入的三种方式</h2><p>如图，装入分为了三种方式：绝对装入、可重定位装入、动态运行时装入。<br /><a name="uZZFJ"></a></p><h3 id="绝对装入"><a class="markdownIt-Anchor" href="#绝对装入"></a> 绝对装入</h3><p>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。 装入程序按照装入模块中的地址，将程序和数据装入内存。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599646837879-c8589bf8-fb5f-4b10-b8d8-006169f3234a.png#align=left&amp;display=inline&amp;height=264&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=398&amp;originWidth=877&amp;size=133733&amp;status=done&amp;style=none&amp;width=582" alt="image.png" /><br />绝对装入只适用于单道程序环境。 <br />程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。<br /><a name="AqDgw"></a></p><h3 id="可重定位装入"><a class="markdownIt-Anchor" href="#可重定位装入"></a> 可重定位装入</h3><p>又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599647013485-3e837fca-2994-4eb9-8757-67e787a70cde.png#align=left&amp;display=inline&amp;height=252&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=375&amp;originWidth=864&amp;size=108735&amp;status=done&amp;style=none&amp;width=580" alt="image.png" /><br />静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。 作业一旦进入内存后，在运行期间就不能再移动，也不能再申 请内存空间。<br /><a name="p5hKv"></a></p><h3 id="动态运行时装入"><a class="markdownIt-Anchor" href="#动态运行时装入"></a> 动态运行时装入</h3><p>又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行 时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599647098503-9a5f50a8-6423-49e6-ba2f-6a4d98b15f72.png#align=left&amp;display=inline&amp;height=243&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=358&amp;originWidth=835&amp;size=98953&amp;status=done&amp;style=none&amp;width=567" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599647161106-1f4a5f63-1a88-4f26-970e-86fe125cf466.png#align=left&amp;display=inline&amp;height=229&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=358&amp;originWidth=924&amp;size=154036&amp;status=done&amp;style=none&amp;width=592" alt="image.png" /><br /><a name="G59Ox"></a></p><h2 id="从写程序到程序运行"><a class="markdownIt-Anchor" href="#从写程序到程序运行"></a> 从写程序到程序运行</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599647258685-e7e32481-bf70-4c09-b61e-bc0f40e5d610.png#align=left&amp;display=inline&amp;height=209&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=301&amp;originWidth=911&amp;size=77233&amp;status=done&amp;style=none&amp;width=633" alt="image.png" /></p><ul><li>编译：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言翻译为机器语言）</li><li>链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块</li><li>装入（装载）：由装入程序将装入模块装入内存运行<br /><a name="S22ey"></a></li></ul><h2 id="链接的三种方式"><a class="markdownIt-Anchor" href="#链接的三种方式"></a> 链接的三种方式</h2><p>链接氛围了三种方式：静态链接、装入时动态链接、运行时动态链接。<br /><a name="E5rhb"></a></p><h3 id="静态链接"><a class="markdownIt-Anchor" href="#静态链接"></a> 静态链接</h3><p>在程序运行之前， 先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块）， 之后不再拆开。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599647463370-7ea2579b-ca2c-494c-a1b6-1566578cb6b8.png#align=left&amp;display=inline&amp;height=310&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=430&amp;originWidth=625&amp;size=63243&amp;status=done&amp;style=none&amp;width=451" alt="image.png" /><br /><a name="1WKnU"></a></p><h3 id="装入时动态链接"><a class="markdownIt-Anchor" href="#装入时动态链接"></a> 装入时动态链接</h3><p>将各目标模块装入内存时，边装入边链接的链接方式。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599647511328-128e51be-2edb-4b2f-9035-5270fe675aca.png#align=left&amp;display=inline&amp;height=309&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=374&amp;originWidth=493&amp;size=61970&amp;status=done&amp;style=none&amp;width=407" alt="image.png" /><br /><a name="J5Sq2"></a></p><h3 id="运行时动态链接"><a class="markdownIt-Anchor" href="#运行时动态链接"></a> 运行时动态链接</h3><p>在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599647595628-f8744070-2b0d-4211-a7e0-842d01c1674a.png#align=left&amp;display=inline&amp;height=347&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=398&amp;originWidth=497&amp;size=70386&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br /><a name="yCXSk"></a></p><h1 id="内存空间的管理"><a class="markdownIt-Anchor" href="#内存空间的管理"></a> 内存空间的管理</h1><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599648342397-71682d2e-4364-48d1-8d4e-fa97a9380e2b.png#align=left&amp;display=inline&amp;height=103&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=206&amp;originWidth=534&amp;size=41007&amp;status=done&amp;style=none&amp;width=267" alt="image.png" /><br />操作系统作为系统资源的管理者，当然也需要对内存进行管理，其管理着：</p><ol><li>操作系统负责内存空间的分配与回收</li><li>操作系统需要提供某种技术从逻辑上对内存空间进行扩充</li><li>操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换<ul><li>为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而逻辑地址到物理地址 的转换（这个过程称为地址重定位）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。</li></ul></li><li>操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰。<br /><a name="iORYC"></a></li></ol><h3 id="内存保护"><a class="markdownIt-Anchor" href="#内存保护"></a> 内存保护</h3><p>内存保护可采取两种方法：<br /><a name="et11m"></a></p><h4 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h4><p>在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599647950196-581771ff-9ffd-4fa3-bb62-dbddb768dfe8.png#align=left&amp;display=inline&amp;height=258&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=388&amp;originWidth=754&amp;size=76501&amp;status=done&amp;style=none&amp;width=501" alt="image.png" /><br /><a name="zTpwv"></a></p><h4 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h4><p>采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599648023732-5465281a-41ad-4a9f-a0e1-25232b80f6b5.png#align=left&amp;display=inline&amp;height=276&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=408&amp;originWidth=890&amp;size=102904&amp;status=done&amp;style=none&amp;width=601" alt="image.png" /><br /><a name="DIOZd"></a></p><h2 id="内存空间的扩充"><a class="markdownIt-Anchor" href="#内存空间的扩充"></a> 内存空间的扩充</h2><p>内存空间扩充分为三种技术：覆盖技术、交换技术、虚拟存储技术。<br /><a name="6FOfB"></a></p><h3 id="覆盖技术"><a class="markdownIt-Anchor" href="#覆盖技术"></a> 覆盖技术</h3><p>早期的计算机内存很小，比如 IBM 推出的第一台PC机最大只支持1MB大小的内存。因此经常会出现内存大小不够的情况。后来人们引入了覆盖技术，用来解决“程序大小超过物理内存总和”的问题。<br />覆盖技术的思想：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。 内存中分为一个“固定区”和若干个“覆盖区”。需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束） 不常用的段放在“覆盖区”，需要用到时调入内存， 用不到时调出内存。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599648558366-62ca5e0b-5b65-4bf5-b1c1-4809c1c9712e.png#align=left&amp;display=inline&amp;height=211&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=310&amp;originWidth=799&amp;size=75321&amp;status=done&amp;style=none&amp;width=543" alt="image.png" /><br />必须由程序员声明覆盖结构，操作系统完成自动覆盖。<br />缺点：对用户不透明，增加了用户编程负担。 覆盖技术只用于早期的操作系统中，现在已成为历史。<br /><a name="3vT8f"></a></p><h3 id="交换技术"><a class="markdownIt-Anchor" href="#交换技术"></a> 交换技术</h3><p>交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599648614574-00cc6e40-134c-4a03-91ae-4d671a87596a.png#align=left&amp;display=inline&amp;height=138&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=206&amp;originWidth=645&amp;size=80459&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br />暂时换出外存等待的进程状态为挂起状态（挂起态，suspend） 挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态.:<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599648674372-26ad3d3a-f1b0-4f70-8787-2b3ce3bd0a05.png#align=left&amp;display=inline&amp;height=223&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=319&amp;originWidth=813&amp;size=76050&amp;status=done&amp;style=none&amp;width=568" alt="image.png" /><br /></p><ul><li>具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式；对换区空间只占磁盘空间的小部分，被换出的进程数据就存放 在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理 主要追求换入换出速度，因此通常对换区采用连续分配方式。总之，对换区的I/O速度比文件区的更快。</li><li>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在 发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程； 如果缺页率明显下降，就可以暂停换出。</li><li>可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调 入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599648848043-1737b609-11fc-4412-9a00-3eaaf80c231c.png#align=left&amp;display=inline&amp;height=253&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=253&amp;originWidth=146&amp;size=9651&amp;status=done&amp;style=none&amp;width=146" alt="image.png" /><br /><a name="B9ZY8"></a></p><h2 id="内存空间的分配与回收"><a class="markdownIt-Anchor" href="#内存空间的分配与回收"></a> 内存空间的分配与回收</h2><p>内存空间的分配管理分为连续和非连续的方式。<br />连续分配：为用户进程分配的必须是一个连续的内存空间。 <br />非连续分配：为用户进程分配的可以是一些分散的内存空间。<br /><a name="13hRi"></a></p><h1 id="连续分配分配方式"><a class="markdownIt-Anchor" href="#连续分配分配方式"></a> 连续分配分配方式</h1><p>连续分配管理方式分为单一连续分配、固态连续分配和动态连续分配。<br /><a name="kwpbu"></a></p><h2 id="单一连续分配"><a class="markdownIt-Anchor" href="#单一连续分配"></a> 单一连续分配</h2><p>在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据。用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599649096969-1fe01e25-ccc9-49c5-a7d3-431f551b6840.png#align=left&amp;display=inline&amp;height=372&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=372&amp;originWidth=376&amp;size=29125&amp;status=done&amp;style=none&amp;width=376" alt="image.png" /><br />优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护（eg：早期的 PC 操作系统 MS-DOS）。 <br />缺点：只能用于单用户、单任务的操作系统中；有内部碎片（分配给某进程的内存区域 中，如果有些部分没有用 上，就是“内部碎片”）；存储器利用率极低。<br /><a name="4l0Ij"></a></p><h2 id="固定分区分配"><a class="markdownIt-Anchor" href="#固定分区分配"></a> 固定分区分配</h2><p>20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。<br />固定分区分配又分为：分区大小相等、分区大小不等两种分配方式。<br /><a name="BWsL0"></a></p><h3 id="分区大小相等"><a class="markdownIt-Anchor" href="#分区大小相等"></a> 分区大小相等</h3><p>缺乏灵活性，但是很适合用于用一台计 算机控制多个相同对象的场合（比如：钢铁厂有n个相 同的炼钢炉，就可把内存分为n个大小相等的区域存放 n个炼钢炉控制程序）<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599649623948-ef566414-ff59-4dea-a40e-d375af561592.png#align=left&amp;display=inline&amp;height=352&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=352&amp;originWidth=136&amp;size=22917&amp;status=done&amp;style=none&amp;width=136" alt="image.png" /><br /><a name="xsebV"></a></p><h3 id="分区大小不等"><a class="markdownIt-Anchor" href="#分区大小不等"></a> 分区大小不等</h3><p>分区大小不等：增加了灵活性，可以满足不同大小的进 程需求。根据常在系统中运行的作业大小情况进行划分 （比如：划分多个小分区、适量中等分区、少量大分区）<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599649649672-0f2e7844-bf7e-40b2-a93e-febf702d4987.png#align=left&amp;display=inline&amp;height=345&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=371&amp;originWidth=171&amp;size=28931&amp;status=done&amp;style=none&amp;width=159" alt="image.png" /><br />操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的 大小、起始地址、状态（是否已分配）。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599649714058-bd5e8b4a-4f10-4b8f-8c9b-3273c210cfc1.png#align=left&amp;display=inline&amp;height=104&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=159&amp;originWidth=629&amp;size=38820&amp;status=done&amp;style=none&amp;width=410" alt="image.png" /><br />当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表， 从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状 态为“已分配”。<br />优点：实现简单，无外部碎片。 <br />缺点：a. 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采 用覆盖技术来解决，但这又会降低性能；b. 会产生内部碎片，内存利用率低。<br /><a name="a6fdx"></a></p><h2 id="动态分区分配"><a class="markdownIt-Anchor" href="#动态分区分配"></a> 动态分区分配</h2><p>动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数 目是可变的。（eg：假设某计算机内存大小为 64MB，系统区 8MB，用户区共 56 MB…）<br />动态分区分配没有内部碎片，但是有外部碎片。 内部碎片，分配给某进程的内存区域中，如果有些部分没有用上。 外部碎片，是指内存中的某些空闲分区由于太小而难以利用。<br />如果内存中空闲空间的总和本来可以满足某进程的要求， 但由于进程需要的是一整块连续的内存空间，因此这些 “碎片”不能满足进程的需求。 可以通过紧凑（拼凑，Compaction）技术来解决外部碎片。<br />系统记录内存分配情况通常有以下两种方法之一：空闲分区表和空闲分区链。<br /><a name="2vDSX"></a></p><h3 id="空闲分区表"><a class="markdownIt-Anchor" href="#空闲分区表"></a> 空闲分区表</h3><p>每个空闲分区对应 一个表项。表项 中包含分区号、 分区大小、分区 起始地址等信息<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599649889064-781460a6-8db9-4d16-ab36-f76c7baee5b0.png#align=left&amp;display=inline&amp;height=85&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=120&amp;originWidth=414&amp;size=20341&amp;status=done&amp;style=none&amp;width=293" alt="image.png" /><br /><a name="LRhoc"></a></p><h3 id="空闲分区链"><a class="markdownIt-Anchor" href="#空闲分区链"></a> 空闲分区链</h3><p>每个分区的起始部分和末尾部分分别设置前向指 针和后向指针。起始部分处还可记录分区大小等信息<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599649917651-3a8023a4-0d52-475b-8aef-60de24014cef.png#align=left&amp;display=inline&amp;height=53&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=71&amp;originWidth=434&amp;size=6511&amp;status=done&amp;style=none&amp;width=324" alt="image.png" /><br /><a name="xFp2y"></a></p><h3 id="动态分区的内存分配算法"><a class="markdownIt-Anchor" href="#动态分区的内存分配算法"></a> 动态分区的内存分配算法</h3><p>在动态分区分配方式中， 当很多个空闲分区都能满足需求时，一般有如下四个算法可供选择：首次适应算法、最佳适应算法、最坏适应算法、临近适应算法。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599651129016-7288aea0-0b14-42c7-acd1-abc0fc2f385d.png#align=left&amp;display=inline&amp;height=287&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=382&amp;originWidth=781&amp;size=234013&amp;status=done&amp;style=none&amp;width=586" alt="image.png" /><br /><a name="SzT4N"></a></p><h4 id="首次适应算法"><a class="markdownIt-Anchor" href="#首次适应算法"></a> 首次适应算法</h4><p>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。<br />如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区 表），找到大小能满足要求的第一个空闲分区。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599650809528-bc754cb6-004b-4304-9f3c-5bb1c66eb211.png#align=left&amp;display=inline&amp;height=77&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=112&amp;originWidth=495&amp;size=11006&amp;status=done&amp;style=none&amp;width=339" alt="image.png" /><br /><a name="ixmoR"></a></p><h4 id="最佳适应算法"><a class="markdownIt-Anchor" href="#最佳适应算法"></a> 最佳适应算法</h4><p>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区 域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区， 即，优先使用更小的空闲区。 <br />如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区 表），找到大小能满足要求的第一个空闲分区。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599650832200-ca181b0b-8ea7-401c-9cc2-9f2265f5bea4.png#align=left&amp;display=inline&amp;height=65&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=84&amp;originWidth=484&amp;size=9705&amp;status=done&amp;style=none&amp;width=376" alt="image.png" /><br />缺点：每次都选最小的分区进行分配，会留下越来越多的、很小 的、难以利用的内存块。因此这种方法会产生很多的外部碎片。<br /><a name="4snUf"></a></p><h4 id="最坏适应算法"><a class="markdownIt-Anchor" href="#最坏适应算法"></a> 最坏适应算法</h4><p>又称 最大适应算法（Largest Fit） <br />算法思想：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时 优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。 <br />如何实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区 表），找到大小能满足要求的第一个空闲分区。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599650882164-ab16ff3c-0a58-448d-a832-a95f93ff468b.png#align=left&amp;display=inline&amp;height=66&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=86&amp;originWidth=485&amp;size=10015&amp;status=done&amp;style=none&amp;width=373" alt="image.png" /><br />缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的 空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被 迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。<br /><a name="8Bz6n"></a></p><h4 id="邻近适应算法"><a class="markdownIt-Anchor" href="#邻近适应算法"></a> 邻近适应算法</h4><p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲 分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查 找结束的位置开始检索，就能解决上述问题。 <br />如何实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查 找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599651084803-5ac2602f-bfb4-4e56-9e0d-4f769ff9fd44.png#align=left&amp;display=inline&amp;height=86&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=122&amp;originWidth=536&amp;size=12692&amp;status=done&amp;style=none&amp;width=376" alt="image.png" /><br />首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。 但是这种规则也决定了当低地址部分有更小的分区可以满足需求时， 会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的 大分区保留下来（最佳适应算法的优点） 邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区 都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点） 综合来看，四种算法中，首次适应算法的效果反而更好。<br /><a name="oh5EM"></a></p><h1 id="非连续分配分配方式"><a class="markdownIt-Anchor" href="#非连续分配分配方式"></a> 非连续分配分配方式</h1><p>非连续分配管理分为基本分页存储管理、基本分段存储管理和段页式分配管理。<br /><a name="iqApb"></a></p><h2 id="什么是分页存储"><a class="markdownIt-Anchor" href="#什么是分页存储"></a> 什么是分页存储</h2><p>将内存空间分为一个个大小相等的分区（比如：每个分区 4KB），每个分区就是一个“页框”（页框=页帧=内存块=物理块=物理页面）。每个页框有一个编号，即“页框号”（页框 号=页帧号=内存块号=物理块号=物理页号），页框号从0开始。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599651925056-a484ead8-b5ac-4870-803c-abb2fb0ec07f.png#align=left&amp;display=inline&amp;height=410&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=410&amp;originWidth=190&amp;size=24957&amp;status=done&amp;style=none&amp;width=190" alt="image.png" /><br />将进程的逻辑地址空间也分为与页框大小相等的一个个部分， 每个部分称为一个“页”或“页面” 。每个页面也有一个编号， 即“页号”，页号也是从0开始。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599651682212-848451b5-2731-4e44-938c-2bf53cf169f0.png#align=left&amp;display=inline&amp;height=173&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=173&amp;originWidth=116&amp;size=14728&amp;status=done&amp;style=none&amp;width=116" alt="image.png" /><br />操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。 <br />各个页面不必连续存放，可以放到不相邻的各个页框中。<br />（注：进程的最后一个页面可能没有一个页框那么大。也就是说，分页存储有可能产生内部碎片，因此页框不能太大，否则可能产生过大的内部碎片造成浪费）<br /><a name="UPxp7"></a></p><h3 id="页表"><a class="markdownIt-Anchor" href="#页表"></a> 页表</h3><p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。 <br />注：页表通常存在PCB（进程控制块）中<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599652145535-1643f709-5e93-4c58-952c-0b4829d52f18.png#align=left&amp;display=inline&amp;height=252&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=357&amp;originWidth=803&amp;size=95281&amp;status=done&amp;style=none&amp;width=567" alt="image.png" /><br />假设某系统物理内存大小为 4GB，页面大小为 4KB，则 每个页表项至少应该为多少字节？<br />内存块大小=页面大小=4KB= 2^12B<br />4GB 的内存总共会被分为 2^32 / 2^12 = 2^20个内存块 <br />内存块号的范围应该是 0 ~2^20 -1 <br />内存块号至少要用 20 bit 来表示 <br />至少要用3B来表示块号（3*8=24bit）<br /><a name="G4wdP"></a></p><h4 id="每个页表项占多少字节"><a class="markdownIt-Anchor" href="#每个页表项占多少字节"></a> 每个页表项占多少字节</h4><p>页表项连续存放，因此页号 可以是隐含的，不占存储空 间（类比数组）<br />由于页号是隐含的，因此每个页表项占3B，存储整个页表至少需要 3*(n+1)B<br />注意：页表记录的只是内存块号，而不 是内存块的起始地址！ <br />J 号内存块的起始地址 = J *内存块大小<br /><a name="Gr4v3"></a></p><h4 id="如何实现地址的转换"><a class="markdownIt-Anchor" href="#如何实现地址的转换"></a> 如何实现地址的转换</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599652533919-60f9fc8d-3a3e-4509-bb48-0852af4dc768.png#align=left&amp;display=inline&amp;height=293&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=404&amp;originWidth=707&amp;size=88235&amp;status=done&amp;style=none&amp;width=512" alt="image.png" /><br />特点：虽然进程的各个页面是离散存放的，但是页面内部是连续存放的 <br />如果要访问逻辑地址 A，则</p><ul><li>确定逻辑地址A 对应的“页号”P</li><li>找到P号页面在内存中的起始地址（需要查页表）</li><li>确定逻辑地址A 的“页内偏移量”W</li></ul><p>逻辑地址A 对应的物理地址 = P号页面在内存中的起始地址+页内偏移量W<br /><a name="MuWZV"></a></p><h4 id="如何确定一个逻辑地址对应-的页号-页内偏移量"><a class="markdownIt-Anchor" href="#如何确定一个逻辑地址对应-的页号-页内偏移量"></a> 如何确定一个逻辑地址对应 的页号、页内偏移量</h4><p>在某计算机系统中，页面大小是50B。某进程逻辑地址空间大小为200B，则逻辑地址 110 对应 的页号、页内偏移量是多少？<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599652726890-ce8e0ba7-c13e-43b9-9884-3f36065bb240.png#align=left&amp;display=inline&amp;height=200&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=305&amp;originWidth=865&amp;size=108625&amp;status=done&amp;style=none&amp;width=568" alt="image.png" /><br />在计算机内部，地址是用二进制表示的， 如果页面大小 刚好是 2 的整数幂，则计 算机硬件可以很快速的把逻辑地址拆分 成（页号，页内偏移量）。<br />结论：如果每个页面 大小为 2^K B，用二进 制数表示逻辑地址， 则末尾 K 位即为页内 偏移量，其余部分就 是页号。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599652829184-fff882fa-159e-4be6-b476-9368b0efc6ae.png#align=left&amp;display=inline&amp;height=216&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=331&amp;originWidth=704&amp;size=187673&amp;status=done&amp;style=none&amp;width=459" alt="image.png" /><br />根据页号可以查询页表，而页表中记录的 只是内存块号，而不是内存块的起始地址！ J 号内存块的起始地址 = J *内存块大小<br />结论：如果页面大小刚好是2 的整数幂，则只需把页表中记 录的物理块号拼接上页内偏移 量就能得到对应的物理地址<br /><a name="Q8mzh"></a></p><h4 id="为何页面大小要取2的整数幂"><a class="markdownIt-Anchor" href="#为何页面大小要取2的整数幂"></a> 为何页面大小要取2的整数幂</h4><p>逻辑地址的拆分更加迅速——如果每个页面大小为 2KB，用二进制数表示逻辑地址，则末尾 K 位 即为页内偏移量，其余部分就是页号。因此，如果让每个页面的大小为 2 的整数幂，计算机硬件就 可以很方便地得出一个逻辑地址对应的页号和页内偏移量，而无需进行除法运算，从而提升了运行 速度。 <br />物理地址的计算更加迅速——根据逻辑地址得到页号，根据页号查询页表从而找到页面存放的内 存块号，将二进制表示的内存块号和页内偏移量拼接起来，就可以得到最终的物理地址。<br /><a name="aNvrD"></a></p><h3 id="逻辑地址结构"><a class="markdownIt-Anchor" href="#逻辑地址结构"></a> 逻辑地址结构</h3><p>分页存储管理的逻辑地址结构如下所示：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599652949756-5014cb5e-4423-4adc-93dd-0ccd5c5c8d54.png#align=left&amp;display=inline&amp;height=41&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=65&amp;originWidth=629&amp;size=9819&amp;status=done&amp;style=none&amp;width=399" alt="image.png" /><br />地址结构包含两个部分：前一部分为页号，后一部分为页内偏移量 W。在上图所示的例子中，地址 长度为 32 位，其中 0~11位 为“页内偏移量”，或称“页内地址” ；12~31 位为“页号”。<br />页面大小 ↔页内偏移量位数-&gt;逻辑地址结构。<br /><a name="puq68"></a></p><h2 id="基本地址变换机构"><a class="markdownIt-Anchor" href="#基本地址变换机构"></a> 基本地址变换机构</h2><p>基本地址变换机构可以借助进程的页表将逻辑转换为逻辑地址。<br />通常会在系统中设置一个页表寄存器（PTR），存放页表在内存中的起始地址F和页表长度M。进程为执行时，页表的初始地址和页表长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把他们放到页表寄存器中。<br />注意，页面大小是2的整数幂。<br />设置页面大小为L，逻辑地址A到物理地址E的变换过程如下：</p><ol><li>计算页号P和页内偏移量W（如果用十进制数计算则，P=A/L，W=A%L，但是在计算及实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快的得到二进制表示的页号）</li><li>比较页号P和页表长度M，若P&gt;=M，则产生越界中断，否则继续执行（注意：页号是从0开始的，而也表长度是，因此P=M也会发生越界）</li><li>页表中的页号P对应的页表项地址=页表起始地址F+页号P*页表项长度，取出该页表项内容b，即为内存块号。（注意区分页表项长度、页表长度、页面大小的区别。页表长度是指这个页表中总共有几个页表项，即总共有几个页。页表项长度是指每个页表项占多大的存储空间，页面大小事只一个页面占多大的存储空间）<br /><a name="XmUw7"></a></li></ol><h3 id="页表项进一步分析"><a class="markdownIt-Anchor" href="#页表项进一步分析"></a> 页表项进一步分析</h3><p>每个页表项长度是相同的，页号是“隐含”的。<br />假设某系统内存大小为4GB，页面大小为4KB，内存总共会被分为2<sup>32/2</sup>12=20<sup>20个内存块，因此内存块号的范围应该是0~20</sup>20-1因此至少要20个二进制位才能表示这么多的的内存块号，因此至少要3个字节才够（每个字节8个二进制位，3个字节共24个二进制位）<br />各页表项会按顺序连续存放在内存中，如果该也表在内存中存放的起始地址是X，则M号页对应的页表项是存放在内存地址为X+3<em>M。<br />一个页面为4KB，则每个页框可以存放4096/3=1365个页表项，但是这个页框会剩余4096%3=1B页内存片。因此，1365号页表项存放的地址为X+3</em>1365+1。如果每个页表项占4字节，则每个页框刚好可以存放1024个页表项。<br /><a name="lsQSH"></a></p><h2 id="具有快表的地址变换机构"><a class="markdownIt-Anchor" href="#具有快表的地址变换机构"></a> 具有快表的地址变换机构</h2><p><a name="RjqYD"></a></p><h3 id="什么是快表tlb"><a class="markdownIt-Anchor" href="#什么是快表tlb"></a> 什么是快表（TLB）</h3><p>快表，又称联想寄存器（TLB， translation lookaside buffer），是一种访问速度比内存快很多的高速缓存（不是内存），用来存放最近访问的页表项的副本，可以加速地址变换的速度。 与此对应，内存中的页表常称为慢表。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599701517877-7af931b5-bd10-4fc8-80d1-c589b6a5e033.png#align=left&amp;display=inline&amp;height=294&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=355&amp;originWidth=391&amp;size=42028&amp;status=done&amp;style=none&amp;width=324" alt="image.png" /><br /><a name="YmhsR"></a></p><h4 id="快表数据读取流程"><a class="markdownIt-Anchor" href="#快表数据读取流程"></a> 快表数据读取流程</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599701736068-7d527c29-524b-458b-a0a7-a192107b99a2.png#align=left&amp;display=inline&amp;height=351&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=442&amp;originWidth=775&amp;size=145987&amp;status=done&amp;style=none&amp;width=616" alt="image.png" /><br /><a name="m2sxT"></a></p><h4 id="引入快表的地址变换过程"><a class="markdownIt-Anchor" href="#引入快表的地址变换过程"></a> 引入快表的地址变换过程</h4><ul><li>CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</li><li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块 号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。</li><li>如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要两次访存（注意：在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）</li></ul><p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。 因为局部性原理，一般来说快表的命中率可以达到 90% 以上。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599702290494-9327c477-0f8c-49eb-a179-2fd1584ff497.png#align=left&amp;display=inline&amp;height=161&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=224&amp;originWidth=788&amp;size=49859&amp;status=done&amp;style=none&amp;width=565" alt="image.png" /><br /><a name="FtQMh"></a></p><h4 id="tlb存储内容"><a class="markdownIt-Anchor" href="#tlb存储内容"></a> TLB存储内容</h4><p>TLB的价格昂贵，显然无法存下整个页表，因此要选择淘汰 一些页表 项——置换算法。<br /><a name="Aopt3"></a></p><h3 id="局部性原理"><a class="markdownIt-Anchor" href="#局部性原理"></a> 局部性原理</h3><p>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环） <br />空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）<br />每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599702532994-b71163cf-e7a3-4821-aa11-040b55b71083.png#align=left&amp;display=inline&amp;height=114&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=148&amp;originWidth=425&amp;size=29464&amp;status=done&amp;style=none&amp;width=328" alt="image.png" /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599702544061-7788599c-28c3-4912-9325-153bb85ce1ba.png#align=left&amp;display=inline&amp;height=231&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=348&amp;originWidth=223&amp;size=19117&amp;status=done&amp;style=none&amp;width=148" alt="image.png" /><br /><a name="7sj1w"></a></p><h2 id="两级页表"><a class="markdownIt-Anchor" href="#两级页表"></a> 两级页表</h2><p><a name="0KIjr"></a></p><h3 id="单级页表存在的问题"><a class="markdownIt-Anchor" href="#单级页表存在的问题"></a> 单级页表存在的问题</h3><p>某计算机系统按字节寻址，支持 32 位的逻辑地址，采用分页存储管理，页面大小为4KB，页表项长度为 4B。 <br />4KB = 2^12B，因此页内地址要用12位表示，剩余 20 位表示页号。 因此，该系统中用户进程最多有 220 页。相应的，一个进程的页表中，最多会 有 220 = 1M = 1,048,576 个页表项，所以一个页表最大需要 220 * 4B = 222 B，共 需要 222/212 = 210个页框存储该页表。 （需要专门给进程分配 210 = 1024 个连续的页 框来存放它的页表）<br />根据页号查询页表的方法：K 号页对应的页表项存放位置 = 页表始址 + K *4 要在所有的页表项都连续存放的基础上才能用这种方法找到页表项。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599703156865-a7b9a455-96ae-4735-baf6-a343e8b79676.png#align=left&amp;display=inline&amp;height=322&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=445&amp;originWidth=875&amp;size=133615&amp;status=done&amp;style=none&amp;width=633" alt="image.png" /><br /><a name="Jd5Cc"></a></p><h4 id="问题汇总"><a class="markdownIt-Anchor" href="#问题汇总"></a> 问题汇总</h4><ol><li>页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。</li><li>没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</li></ol><p>解决问题1可以把页表再分页并离散存储，然后再建立一张页表记录页表各个部分的存放位置，称为页目录表，或称外层页表，或称顶层页表。<br />解决问题2可以在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599704651632-e42b54d0-0df5-4b25-b961-455a3f008329.png#align=left&amp;display=inline&amp;height=218&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=266&amp;originWidth=436&amp;size=43516&amp;status=done&amp;style=none&amp;width=358" alt="image.png" /><br /><a name="nPAl0"></a></p><h2 id="两级页表的原理-地址结构"><a class="markdownIt-Anchor" href="#两级页表的原理-地址结构"></a> 两级页表的原理、地址结构</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599703242947-afe934df-d30b-43bc-9fa5-6375626cf471.png#align=left&amp;display=inline&amp;height=364&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=500&amp;originWidth=879&amp;size=118216&amp;status=done&amp;style=none&amp;width=640" alt="image.png" /></p><ol><li>按照地址结构将逻辑地址拆分成三部分</li><li>从PCB 中读出页目录表始址，再根据一级页号查页目录 表，找到下一级页表在内存中的存放位置</li><li>根据二级页号查二级页表，找到最终想访问的内存块号</li><li>结合页内偏移量得到物理地址<br /><a name="d4Vum"></a></li></ol><h3 id="注意细节"><a class="markdownIt-Anchor" href="#注意细节"></a> 注意细节</h3><p>若分为两级页表后，页表依然很长，则可以采用更多级页表，一般来说各级页表的大小不能超过一个页面。<br />两级页表的访存次数分析（假设没有快表机构）</p><ul><li>第一次访存：访问内存中的页目录表</li><li>第二次访存：访问内存中的二级页表</li><li>第三次访存：访问目标内存单元<br /><a name="AUW27"></a></li></ul><h2 id="基本分段存储管理方式"><a class="markdownIt-Anchor" href="#基本分段存储管理方式"></a> 基本分段存储管理方式</h2><p><a name="8PqtG"></a></p><h3 id="什么是分段"><a class="markdownIt-Anchor" href="#什么是分段"></a> 什么是分段</h3><p>进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址 <br />内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599704869004-dd0e9a0c-467e-4c2e-9fbe-b5d7519110e6.png#align=left&amp;display=inline&amp;height=259&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=347&amp;originWidth=843&amp;size=125091&amp;status=done&amp;style=none&amp;width=630" alt="image.png" /><br />分段系统的逻辑地址结构由段号（段名）和段内地址（段内偏移量）所组成。如：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599705002241-8cd629f0-201e-4fa3-b0b0-6956f829b70c.png#align=left&amp;display=inline&amp;height=50&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=77&amp;originWidth=643&amp;size=9156&amp;status=done&amp;style=none&amp;width=420" alt="image.png" /><br />段号的位数决定了每个进程最多可以分几个段，段内地址位数决定了每个段的最大长度是多少。<br />在上述例子中，若系统是按字节寻址的，则段号占16位，因此在该系统中，每个进程最多有 216 = 64K 个段，段内地址占 16位，因此每个段的最大长度是 216 = 64KB。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599705726679-910d256e-031f-4313-a8ef-0fda5e19724b.png#align=left&amp;display=inline&amp;height=112&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=176&amp;originWidth=602&amp;size=64824&amp;status=done&amp;style=none&amp;width=384" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599705751613-7a2af8c1-8946-48db-b8fb-4014a2e542b4.png#align=left&amp;display=inline&amp;height=304&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=371&amp;originWidth=287&amp;size=31875&amp;status=done&amp;style=none&amp;width=235" alt="image.png" /><br /><br /><br />每个段对应一个段表项，其中记录了该段在内存中的起始位置（又称 “基址”）和段的长度。 <br />各个段表项的长度是相同的。例如：某系统按字节寻址，采用分段存 储管理，逻辑地址结构为（段号16位, 段内地址16位），因此用16位 即可表示最大段长。物理内存大小为4GB（可用32位表示整个物理内 存地址空间）。因此，可以让每个段表项占 16+32 = 48位，即6B。由 于段表项长度相同，因此段号可以是隐含的，不占存储空间。若段表 存放的起始地址为 M，则 K号段对应的段表项存放的地址为 M + K*6<br /><a name="X52mX"></a></p><h3 id="执行流程"><a class="markdownIt-Anchor" href="#执行流程"></a> 执行流程</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599705891658-b73c2305-ad2a-44a9-92f0-8e6fc70e4848.png#align=left&amp;display=inline&amp;height=385&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=521&amp;originWidth=930&amp;size=205626&amp;status=done&amp;style=none&amp;width=687" alt="image.png" /><br /><a name="1m6xb"></a></p><h3 id="分段-分页管理的对比"><a class="markdownIt-Anchor" href="#分段-分页管理的对比"></a> 分段、分页管理的对比</h3><p>页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管 理上的需要，完全是系统行为，对用户是不可见的。 <br />段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻 辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。 <br />页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。 <br />分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。 <br />分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599706639309-1a6bc759-051e-4e5c-96b0-10034da6fa6b.png#align=left&amp;display=inline&amp;height=171&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=247&amp;originWidth=874&amp;size=65155&amp;status=done&amp;style=none&amp;width=606" alt="image.png" /><br />分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的（比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据 不一致）<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599706703595-6f3f7787-9adb-464e-95d7-650af4be7299.png#align=left&amp;display=inline&amp;height=304&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=359&amp;originWidth=831&amp;size=119224&amp;status=done&amp;style=none&amp;width=703" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599706751173-0e66edd3-849d-45e2-bfe3-d96285b60931.png#align=left&amp;display=inline&amp;height=332&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=399&amp;originWidth=844&amp;size=164238&amp;status=done&amp;style=none&amp;width=703" alt="image.png" /><br /><br /><br />访问一个逻辑地址需要几次访存<br />分页（单级页表）：第一次访存——查内存中的页表，第二次访存——访问目标内存单元。总共两次访存 <br />分段：第一次访存——查内存中的段表，第二次访存——访问目标内存单元。总共两次访存与分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表项放到快表中，这样可以 少一次访问，加快地址变换速度。<br /><a name="iEn0n"></a></p><h2 id="段页式管理方式"><a class="markdownIt-Anchor" href="#段页式管理方式"></a> 段页式管理方式</h2><p>分页分段优缺点如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599707114990-a382f1a9-e3d6-410f-a34a-814e8ce1e6dc.png#align=left&amp;display=inline&amp;height=186&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=248&amp;originWidth=773&amp;size=97499&amp;status=done&amp;style=none&amp;width=580" alt="image.png" /><br />分段+分页=段页式管理：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599707377362-83bdbbee-f736-4d9e-861a-23818b25f9dc.png#align=left&amp;display=inline&amp;height=341&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=413&amp;originWidth=789&amp;size=112957&amp;status=done&amp;style=none&amp;width=651" alt="image.png" /><br /></p><p><a name="i1F03"></a></p><h3 id="逻辑地址结构-2"><a class="markdownIt-Anchor" href="#逻辑地址结构-2"></a> 逻辑地址结构</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599707588960-e1ac574b-b624-4dc7-bcff-7c608b071c00.png#align=left&amp;display=inline&amp;height=70&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=98&amp;originWidth=608&amp;size=26238&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599707597683-bf643c47-b67d-48bb-903d-08b5d9b9f469.png#align=left&amp;display=inline&amp;height=70&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=102&amp;originWidth=632&amp;size=31943&amp;status=done&amp;style=none&amp;width=433" alt="image.png" /><br />分段是对用户可见的，程序员编程时需要显式的给出段号、段内地址。而降各段分页，分页是对用户不可兼得。系统会分局段内地址自动划分页号和页内偏移量。<br />因此段页式管理的地址结构是二维的。<br />段号的位数决定了每个进程最多可以分为几段，位号的椰树决定了每个段最大有多少页，页内偏移量决定了页面的大小、内存块大小。<br /><a name="8JnpP"></a></p><h3 id="执行流程-2"><a class="markdownIt-Anchor" href="#执行流程-2"></a> 执行流程</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599708180878-92fb2831-b561-426a-ab55-07cfb1154809.png#align=left&amp;display=inline&amp;height=378&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=540&amp;originWidth=896&amp;size=218221&amp;status=done&amp;style=none&amp;width=628" alt="image.png" /><br /></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之死锁</title>
      <link href="/posts/operating_system_deadlock/"/>
      <url>/posts/operating_system_deadlock/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统之死锁"><a class="markdownIt-Anchor" href="#操作系统之死锁"></a> 操作系统之死锁</h1><p><a name="IwCDS"></a></p><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>举个例子阐述一下什么是死锁：有一首歌的歌词：我爱你，你爱他，他爱她，她爱我……这世界每个人都爱别人，形成结构图如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599628936052-ddbbf910-e457-4db4-9877-bb8e6b5ba78e.png#align=left&amp;display=inline&amp;height=324&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=362&amp;originWidth=478&amp;size=79671&amp;status=done&amp;style=none&amp;width=428" alt="image.png" /><br />每个人都占有一个资源， 同时又在等待另一个人手里的资源。发生“死锁”。<br /><a name="L5rg2"></a></p><h2 id="什么是死锁"><a class="markdownIt-Anchor" href="#什么是死锁"></a> 什么是死锁</h2><p>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”。 发生死锁后若无外力干涉， 这些进程都将无法向前推进。<br /><a name="nLqdA"></a></p><h2 id="死锁-饥饿-死循环的区别"><a class="markdownIt-Anchor" href="#死锁-饥饿-死循环的区别"></a> 死锁、饥饿、死循环的区别</h2><p>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。 <br />饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。 <br />死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599629047626-da47f62e-adaf-4726-b0cb-f1e1fd4a2d8c.png#align=left&amp;display=inline&amp;height=204&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=213&amp;originWidth=660&amp;size=147950&amp;status=done&amp;style=none&amp;width=633" alt="image.png" /><br /><a name="zuUp8"></a></p><h2 id="死锁产生的必要条件"><a class="markdownIt-Anchor" href="#死锁产生的必要条件"></a> 死锁产生的必要条件</h2><p>产生死锁必须同时满足一下四个条件，只要其中任一条件不成立，死锁就不会发生。</p><ul><li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁（如打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。</li><li>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li><li>循环等待条件：存在一种进程资源的循环等待链，链中的 每一个进程已获得的资源同时被下一个进程所请求。</li></ul><p>注意！发生死锁时一定有循环等待，但是发生循环等待时未必死锁（循环等待是死锁的必要不充分条件）<br />如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。<br /><a name="uwtMD"></a></p><h2 id="什么时候会发生死锁"><a class="markdownIt-Anchor" href="#什么时候会发生死锁"></a> 什么时候会发生死锁</h2><ul><li>对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的。</li><li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、 P2 分别申请并占有了资源 R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1， 两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</li><li>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的 P操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源）</li></ul><p>总之，对不可剥夺资源的不合理分配，可能导致死锁。<br /><a name="6FrwE"></a></p><h2 id="死锁的处理策略"><a class="markdownIt-Anchor" href="#死锁的处理策略"></a> 死锁的处理策略</h2><ol><li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个。</li><li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）。</li><li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措 施解除死锁。<br /><a name="GWCqU"></a></li></ol><h1 id="预防死锁"><a class="markdownIt-Anchor" href="#预防死锁"></a> 预防死锁</h1><p>死锁的产生必须满足四个必要条件，只要其中一个或者几个条件不满足，死锁就不会发生。因此预防死锁可以通过：破坏互斥条件、破坏不剥夺条件、破坏请求和保持条件、破坏循环等待条件中的任意一种或多种来预防死锁。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599630421051-0e034cf4-4bf8-467f-ac4d-f473010652fd.png#align=left&amp;display=inline&amp;height=300&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=377&amp;originWidth=684&amp;size=184445&amp;status=done&amp;style=none&amp;width=544" alt="image.png" /><br /><a name="BE2Zr"></a></p><h2 id="破坏互斥条件"><a class="markdownIt-Anchor" href="#破坏互斥条件"></a> 破坏互斥条件</h2><p>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。<br />如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如: SPOOLing技术。 操作系统可以采用 SPOOLing 技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599629690843-16c5c001-445e-476a-ac3c-b5f6c9ab0627.png#align=left&amp;display=inline&amp;height=198&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=238&amp;originWidth=807&amp;size=119503&amp;status=done&amp;style=none&amp;width=673" alt="image.png" /><br />该策略的缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件。<br /><a name="q5nRs"></a></p><h2 id="破坏不剥夺条件"><a class="markdownIt-Anchor" href="#破坏不剥夺条件"></a> 破坏不剥夺条件</h2><p>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。<br />破坏不剥夺条件已拥有如下两个方案：<br /><a name="xYF5f"></a></p><h3 id="方案一"><a class="markdownIt-Anchor" href="#方案一"></a> 方案一</h3><p>当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。<br /><a name="TdaVo"></a></p><h3 id="方案二"><a class="markdownIt-Anchor" href="#方案二"></a> 方案二</h3><p>当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）<br /><a name="YeYgw"></a></p><h3 id="该策略的缺点"><a class="markdownIt-Anchor" href="#该策略的缺点"></a> 该策略的缺点</h3><ol><li>实现起来比较复杂。</li><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。<br /><a name="RJ27s"></a></li></ol><h2 id="破坏请求和保持条件"><a class="markdownIt-Anchor" href="#破坏请求和保持条件"></a> 破坏请求和保持条件</h2><p>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。<br />可以采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前， 不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599630106483-637941f0-2ded-40da-a604-57017431ae02.png#align=left&amp;display=inline&amp;height=181&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=181&amp;originWidth=464&amp;size=25202&amp;status=done&amp;style=none&amp;width=464" alt="image.png" /><br />该策略实现起来简单，但也有明显的缺点： 有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。<br /><a name="4BdM0"></a></p><h2 id="破坏循环等待条件"><a class="markdownIt-Anchor" href="#破坏循环等待条件"></a> 破坏循环等待条件</h2><p>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。<br />可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源， 同类资源（即编号相同的资源）一次申请完。<br />原理分析：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599630320833-574cab43-93b4-48f9-bacd-8744bfa894f0.png#align=left&amp;display=inline&amp;height=195&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=238&amp;originWidth=501&amp;size=66787&amp;status=done&amp;style=none&amp;width=411" alt="image.png" /><br />该策略的缺点：</p><ol><li>不方便增加新的设备，因为可能 需要重新分配所有的编号</li><li>进程实际使用资源的顺序可能和 编号递增顺序不一致，会导致资源浪费</li><li>必须按规定次序申请资源，用户编程麻烦。<br /><a name="kA35S"></a></li></ol><h1 id="避免死锁"><a class="markdownIt-Anchor" href="#避免死锁"></a> 避免死锁</h1><p><a name="FTw69"></a></p><h2 id="什么是安全序列"><a class="markdownIt-Anchor" href="#什么是安全序列"></a> 什么是安全序列</h2><p>假如现在手上有100个亿的资金，有三个公司想要借贷款，如果借给企业的钱总数达不到企业提出的最大要求，那么不管你之前给企业借了多少钱，那些钱都拿不回来了。三家公司分别最大的需求是70、40、50，已经分别借走了20、10、30，手上剩余40亿。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599630631323-4393e28e-ab85-4497-9290-d99ad84a0fab.png#align=left&amp;display=inline&amp;height=125&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=125&amp;originWidth=342&amp;size=16125&amp;status=done&amp;style=none&amp;width=342" alt="image.png" /><br />给B借30亿是不安全的…之后手里只剩10亿，如果BAT都提出再借20亿的请求，那么任何一个企 业的需求都得不到满足。给A借 20亿是安全的，因为存在T-&gt;A-&gt;B这样的安全序列。<br /><a name="Vcz1s"></a></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。 如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过在分配资源之前总是要考虑到最坏的情况。<br />如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态就可能发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态） 因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是“银行家算法”的核心思想。<br /><a name="DEcoC"></a></p><h2 id="银行家算法"><a class="markdownIt-Anchor" href="#银行家算法"></a> 银行家算法</h2><p>银行家算法是荷兰学者 Dijkstra 为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，用于避免死锁。 <br />核心思想：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。<br /><a name="FFrOQ"></a></p><h3 id="案例分析"><a class="markdownIt-Anchor" href="#案例分析"></a> 案例分析</h3><p>初始数量为 (10, 5, 7)，此时总共已分配 (7, 2, 5)，还剩余 (3, 3, 2) 可把最大需求、已分配的数据看作矩阵， 两矩阵相减，就可算出各进程最多还需要多少资源了。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599631208501-871bf719-8ba7-4f65-817a-9165504e81ed.png#align=left&amp;display=inline&amp;height=183&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=183&amp;originWidth=274&amp;size=29864&amp;status=done&amp;style=none&amp;width=274" alt="image.png" /><br />尝试找出一个安全序列： <br />依次检查剩余可用资源 (3, 3, 2) 是否能满足各进程的需求<br />可满足P1需求，将 P1 加入安全序列，并更新剩余可用资源值为 (5, 3, 2) <br />依次检查剩余可用资源 (5, 3, 2) 是否能满足剩余进程（不包括已加入安全序列的进程）的需求 <br />可满足P3需求，将 P3 加入安全序列，并更新剩余可用资源值为 (7, 4, 3) 。<br />依次检查剩余可用资源 (7, 4, 3) 是否能满足剩余进程（不包括已加入安全序列的进程）的需求<br />…… ……<br />以此类推，共五次循环检查即可将5个进程都加入安全序列中，最终可得一个安全序列。该算法 称为安全性算法。可以很方便地用代码实现以上流程，每一轮检查都从编号较小的进程开始检查。 实际做题时可以更快速的得到安全序列。<br /><a name="ulG9O"></a></p><h2 id="计算方法"><a class="markdownIt-Anchor" href="#计算方法"></a> 计算方法</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599631759605-82dd081f-24cd-4da8-a364-58af6cbbb859.png#align=left&amp;display=inline&amp;height=361&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=501&amp;originWidth=854&amp;size=358440&amp;status=done&amp;style=none&amp;width=615" alt="image.png" /><br />长度为 m 的一维数组 Available 表示还有多少可用资源 <br />n<em>m 矩阵 Max 表示各进程对资源的最大需求数 <br />n</em>m 矩阵 Allocation 表示已经给各进程分配了多少资源 <br />Max – Allocation = Need 矩阵表示各进程最多还需要多少资源 <br />用长度为 m 的一位数组 Request 表示进程此次申请的各种资源数<br /><a name="8gTHE"></a></p><h3 id="银行家算法计算步骤"><a class="markdownIt-Anchor" href="#银行家算法计算步骤"></a> 银行家算法计算步骤</h3><ol><li>检查此次申请是否超过了之前声明的最大需求数</li><li>检查此时系统剩余的可用资源是否还能满足这次请求</li><li>试探着分配，更改各数据结构</li><li>用安全性算法检查此次分配是否会导致系统进入不安全状态<br /><a name="IYLhy"></a></li></ol><h3 id="安全性算法步骤"><a class="markdownIt-Anchor" href="#安全性算法步骤"></a> 安全性算法步骤</h3><p>检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列， 并把该进程持有的资源全部回收。 <br />不断重复上述过程，看最终是否能让所有进程都加入安全序列。<br /><a name="yXNzC"></a></p><h1 id="检测和解除"><a class="markdownIt-Anchor" href="#检测和解除"></a> 检测和解除</h1><p>如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。在这种 情况下，系统应当提供两个算法：</p><ul><li>死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁。</li><li>死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。<br /><a name="uwEMz"></a></li></ul><h2 id="死锁的检测"><a class="markdownIt-Anchor" href="#死锁的检测"></a> 死锁的检测</h2><p>为了能对系统是否已发生了死锁进行检测，必须：</p><ul><li>用某种数据结构来保存资源的请求和分配信息</li><li>提供一种算法，利用上述信息来检测系统是否已进入死锁状态。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599632257231-430a0920-cbcb-451f-a5b6-f68c9e13cc19.png#align=left&amp;display=inline&amp;height=116&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=154&amp;originWidth=822&amp;size=83829&amp;status=done&amp;style=none&amp;width=619" alt="image.png" /><br />如果系统中剩余的可用资源数足够满足进程的需求，那 么这个进程暂时是不会阻塞的，可以顺利地执行下去。 如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。 相应的，这些被激活的进程执行完了之后又会归还一些 资源，这样可能又会激活另外一些阻塞的进程。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599632278844-beeaa800-f978-4fa6-8b9e-f69ebd998be0.png#align=left&amp;display=inline&amp;height=160&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=228&amp;originWidth=522&amp;size=46469&amp;status=done&amp;style=none&amp;width=367" alt="image.png" /><br />如果按上述过程分析，最终能消除所有边，就称这个图 是可完全简化的。此时一定没有发生死锁（相当于能找到一个安全序列），如果最终不能消除所有边，那么此时就是发生了死锁，最终还连着边的那些进程就是处于死锁状态的进程。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599632479313-d449d4dd-7083-4d58-a834-f0256aca7557.png#align=left&amp;display=inline&amp;height=206&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=250&amp;originWidth=423&amp;size=25388&amp;status=done&amp;style=none&amp;width=348" alt="image.png" /><br /><a name="vcJ8V"></a></p><h3 id="检测算法"><a class="markdownIt-Anchor" href="#检测算法"></a> 检测算法</h3><ul><li>在资源分配图中，找出既不阻塞又不是孤点的进程 Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。如下图中，R1没有空闲资源，R2有 一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然 后释放它所占有的所有资源）。消去它所有的请求边和分配变，使之称为孤立的结点。在下图中， P1 是满足这一条件的进程结点，于是将P1的所有边消去。</li><li>进程 Pi 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变 为非阻塞进程。在下图中，P2 就满足这样的条件。根据 1）中的方法进行一系列简化后，若能消 去途中所有的边，则称该图是可完全简化的。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599632625325-0bd05889-0066-4cdf-97e3-4005eb379202.png#align=left&amp;display=inline&amp;height=198&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=219&amp;originWidth=405&amp;size=20677&amp;status=done&amp;style=none&amp;width=366" alt="image.png" /><br /><a name="XNIc9"></a></p><h2 id="死锁的解除"><a class="markdownIt-Anchor" href="#死锁的解除"></a> 死锁的解除</h2><p>一旦检测出死锁的发生，就应该立即解除死锁。 <br />补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的 那些进程就是死锁进程。<br />解除死锁的主要方法有：</p><ul><li>资源剥夺法。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给 其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li><li>撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资 源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行 了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li><li>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程 的历史信息，设置还原点。</li></ul><p>死锁解除应考虑的因素：</p><ul><li>进程优先级</li><li>已执行多长时间</li><li>还要多久能完成</li><li>进程已经使用了多少资源</li><li>进程是交互式的还是批处理式的</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之同步与互斥问题</title>
      <link href="/posts/operating_system_synchronization/"/>
      <url>/posts/operating_system_synchronization/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统之同步与互斥问题"><a class="markdownIt-Anchor" href="#操作系统之同步与互斥问题"></a> 操作系统之同步与互斥问题</h1><p><a name="VP7GV"></a></p><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>进程具有异步性的特点。异步性是指各并发执行的进程以各自独立的、不可预期的速度向前推进。如下图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599444995847-14f639ed-e4b7-4cd9-93ae-50a1cfe2fa99.png#align=left&amp;display=inline&amp;height=67&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=104&amp;originWidth=820&amp;size=29293&amp;status=done&amp;style=none&amp;width=529" alt="image.png" /><br />读进程和写进程并发的运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不一定的。但是实际应用中又必须按照“写数据–&gt;读数据”的顺序来执行。解决这种问题就是进程同步所讨论的内容。<br />同步也叫作直接制约关系，他是为了完成某种任务而建立的两个或者多个进程，这些进程因为需要在某些位置上协调他们的工作次序而产生的制约关系。进程间的直接制约关系就是源于他们之间的相互合作。<br /><a name="oxjt7"></a></p><h2 id="进程互斥"><a class="markdownIt-Anchor" href="#进程互斥"></a> 进程互斥</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599446369066-8c65ee67-6760-4fdf-af14-2c44b940efa4.png#align=left&amp;display=inline&amp;height=296&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=373&amp;originWidth=839&amp;size=163183&amp;status=done&amp;style=none&amp;width=666" alt="image.png" /><br />进程的并发需要共享的支持，各个并发执行的进程不可避免的需要共享一些系统资源（比如内存、打印机/摄像头这样的I/O设备）。<br />把一段时间内只允许一个进程是用的资源叫做临界资源。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。<br />对于临界资源的访问，必须互斥的进行。互斥也叫作间接制约关系。进程互斥是指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当访问临界资源的进程访问结束，释放该资源以后才能访问临界资源。<br /><a name="V4viM"></a></p><h3 id="逻辑过程"><a class="markdownIt-Anchor" href="#逻辑过程"></a> 逻辑过程</h3><p>对于互斥访问，可以在逻辑上分为如下四个部分：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599445896278-742bdee8-4ca5-4339-8083-c72f424fabb7.png#align=left&amp;display=inline&amp;height=188&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=270&amp;originWidth=793&amp;size=109673&amp;status=done&amp;style=none&amp;width=553" alt="image.png" /><br />临界区是进程中访问临界资源的代码段。进入区和退出区是负责实现互斥的代码段。临界区也可以称为临界段。<br /><a name="Ywjnl"></a></p><h3 id="遵循原则"><a class="markdownIt-Anchor" href="#遵循原则"></a> 遵循原则</h3><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循如下原则：</p><ul><li>空闲让进：临界空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</li><li>忙则等待：已有的进程进入临界区时，其他试图进入临界区的进程必须等待。</li><li>有限等待：对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）。</li><li>让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。<br /><a name="gzuUR"></a></li></ul><h1 id="进程互斥软件实现"><a class="markdownIt-Anchor" href="#进程互斥软件实现"></a> 进程互斥软件实现</h1><p>进程互斥软件实现主要有四种实现方法：单标志法、双标志先检查、双标志后检查、Peterson算法。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599455934089-05bd1b9e-6438-44a6-ad48-2f0ae778ae9e.png#align=left&amp;display=inline&amp;height=314&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=365&amp;originWidth=627&amp;size=145535&amp;status=done&amp;style=none&amp;width=540" alt="image.png" /><br /><a name="oXB3h"></a></p><h2 id="单标志法"><a class="markdownIt-Anchor" href="#单标志法"></a> 单标志法</h2><p>两个进程在访问临界区后会把使用临界区的权限交给另外一个进程，也就是说每个进程进入临界区的权限只能被一个进程赋予。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599446759091-d45d31a8-d573-4777-a3fe-9dcde59a2ae2.png#align=left&amp;display=inline&amp;height=139&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=200&amp;originWidth=804&amp;size=94024&amp;status=done&amp;style=none&amp;width=560" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599446816025-94f3935f-6a82-4c8d-bb07-88a50a1276af.png#align=left&amp;display=inline&amp;height=59&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=85&amp;originWidth=790&amp;size=72103&amp;status=done&amp;style=none&amp;width=545" alt="image.png" /><br />显然，该算法可以实现“同一个时刻最多只允许一个进程访问临界区”。<br />单标志法的主要问题是违背空闲让进的原则：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599447037550-f455e9d3-a277-4f68-ad13-3661472013c6.png#align=left&amp;display=inline&amp;height=59&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=86&amp;originWidth=764&amp;size=83844&amp;status=done&amp;style=none&amp;width=525" alt="image.png" /><br /><a name="D6X1N"></a></p><h2 id="双标志先检查法"><a class="markdownIt-Anchor" href="#双标志先检查法"></a> 双标志先检查法</h2><p>设置一个布尔数组flag[]，数组中的各个元素用来标记个进程想进入临界区的意愿。比如flag[0]=true意味着0号进程P0现在想要进入临界区，每个进程在进入临界区之前先检查当前有没有别的进程想要进入临界区，如果没有，则把自身的标志flag[i]设为true，之后开始访问临界区。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599447325760-6a0c63b9-38e4-4206-a886-03e85cd7862e.png#align=left&amp;display=inline&amp;height=162&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=211&amp;originWidth=826&amp;size=127957&amp;status=done&amp;style=none&amp;width=636" alt="image.png" /><br />按照①⑤②⑥③⑦…的顺序执行，P1P2会同时访问临界区，因此，双标志先检查法违反忙则等待原则。原因在于进入区的检查和上锁不是一气呵成的，可能会发生进程切换所导致的数据不一致。<br /><a name="PDTNW"></a></p><h2 id="双标志后检查法"><a class="markdownIt-Anchor" href="#双标志后检查法"></a> 双标志后检查法</h2><p>这个是双标志的先检查法的改良，这个是先上锁后检查。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599447610689-f20f608c-63f7-4f20-aed3-03029b82430e.png#align=left&amp;display=inline&amp;height=186&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=235&amp;originWidth=832&amp;size=128444&amp;status=done&amp;style=none&amp;width=659" alt="image.png" /><br />按照①⑤②⑥…的顺序执行可以完美解决忙则等待的问题，但是这个又违背了空闲让进和有限等待原则，会因为长期无法访问到临界资源导致产生饥饿现象，也会因为两个进程都要进入临界区但是没有谦让可能会导致死锁的产生。<br /><a name="oeHav"></a></p><h2 id="peterson算法"><a class="markdownIt-Anchor" href="#peterson算法"></a> Peterson算法</h2><p>双标志后检查法中，两个进程都争着想要进入临界区，最终导致死锁。Peterson想出一种方法，类似于孔融让梨，主动让对方先进入临界区。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599455683839-da14efd5-0ec7-4f96-a633-67d7a08e38b4.png#align=left&amp;display=inline&amp;height=277&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=357&amp;originWidth=724&amp;size=144409&amp;status=done&amp;style=none&amp;width=562" alt="image.png" /><br />Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待的原则。<br /><a name="JT6Yt"></a></p><h1 id="进程互斥算法硬件实现"><a class="markdownIt-Anchor" href="#进程互斥算法硬件实现"></a> 进程互斥算法硬件实现</h1><p>其实现方法大致分为三种：中断屏蔽方法、TestAndSet（TS指令/TSL指令）和Swap指令（XCHG指令）。<br /><a name="CnrUV"></a></p><h2 id="中断屏蔽方法"><a class="markdownIt-Anchor" href="#中断屏蔽方法"></a> 中断屏蔽方法</h2><p>利用“开/关中断指令”实现，与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况，保证了原子性。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599456247406-27505329-82a6-4e60-8e7c-ddb09ce132b4.png#align=left&amp;display=inline&amp;height=162&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=162&amp;originWidth=393&amp;size=48951&amp;status=done&amp;style=none&amp;width=393" alt="image.png" /><br />但是这种方法并不适用于多处理机，只适用于操作系统内核进程，不适用于用户进程（（因为开/关中断指令只能运行在内核态）。<br /><a name="yRvad"></a></p><h2 id="testandset指令"><a class="markdownIt-Anchor" href="#testandset指令"></a> TestAndSet指令</h2><p>简称TS指令，也称为TestAndSetLock指令或TSL指令。TSL是基于硬件实现的，执行过程各种不能被中断只能一气呵成，以下是C语言写的逻辑：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599456566418-57910d94-48f9-4a2f-8848-efa90d9000cd.png#align=left&amp;display=inline&amp;height=168&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=280&amp;originWidth=1267&amp;size=194137&amp;status=done&amp;style=none&amp;width=761" alt="image.png" /><br />若刚开始 lock 是 false，则 TSL 返回的 old 值为 false，while 循环条件不满足，直接跳过循环，进入临界区。若刚开始 lock 是 true，则执行 TLS 后 old 返回的值为 true，while 循环条件满足，会一直 循环，直到当前访问临界区的进程在退出区进行“解锁”。 相比软件实现方法，TSL 指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。 <br />优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞，适用于多处理机环境。<br />缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。<br /><a name="Vjopj"></a></p><h2 id="swap指令"><a class="markdownIt-Anchor" href="#swap指令"></a> Swap指令</h2><p>Swap指令也称Exchange 指令，或简称 XCHG 指令。 Swap 指令也是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言模拟的逻辑：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599456818049-a64abde0-49ef-4e63-b5f2-37b6e293957b.png#align=left&amp;display=inline&amp;height=150&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=201&amp;originWidth=829&amp;size=93172&amp;status=done&amp;style=none&amp;width=620" alt="image.png" /><br />逻辑上来看 Swap 和 TSL 并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在 old 变量上），再将上锁标记 lock 设置为 true，最后检查 old，如果 old 为 false 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。 <br />优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞，适用于多处理机环境。<br />缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从 而导致“忙等”。<br /><a name="CqJ8e"></a></p><h1 id="信号量机制"><a class="markdownIt-Anchor" href="#信号量机制"></a> 信号量机制</h1><p>之前的所有解决方案都无法实现让权等待的问题，1965年荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥、同步的方法——信号量机制。<br />信号量机制分为两种类型：整型信号量和记录型信号量。<br /><a name="Rpo0i"></a></p><h2 id="信号量机制概念"><a class="markdownIt-Anchor" href="#信号量机制概念"></a> 信号量机制概念</h2><p>用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断/开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。<br />一对原语：wait(S) 原语和 signal(S) 原语，可以把原语理解为自己写的函数，函数名分别为 wait 和 signal，括号里的信号量 S 其实就是函数调用时传入的一个参数。wait、signal 原语常简称为 P、V操作（来自荷兰语 proberen 和 verhogen）。因此，做题的时候常把 wait(S)、signal(S) 两个操作分别写为 P(S)、V(S)。<br />信号量其实就是一个变量 ，可以用一个信号量 来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量。<br /><a name="PQmHE"></a></p><h2 id="整型信号量"><a class="markdownIt-Anchor" href="#整型信号量"></a> 整型信号量</h2><p>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。与普通整数变量的区别： 对信号量的操作只有三种， 即 初始化、P操作、V操作。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599457957819-a866c6b5-40e0-444e-a505-5ed8e41595db.png#align=left&amp;display=inline&amp;height=230&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=254&amp;originWidth=572&amp;size=96865&amp;status=done&amp;style=none&amp;width=517" alt="image.png" /><br />wait函数“检查”和“上锁”一气呵成， 避免了并发、异步导致的问题。存在的问题：不满足“让权等待” 原则，会发生“忙等”。<br /><a name="Y9sD0"></a></p><h2 id="imagepng记录型信号量"><a class="markdownIt-Anchor" href="#imagepng记录型信号量"></a> <img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599458061236-9c958a34-aa22-4d83-affa-e6dc15be2b54.png#align=left&amp;display=inline&amp;height=143&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=178&amp;originWidth=852&amp;size=75626&amp;status=done&amp;style=none&amp;width=684" alt="image.png" />记录型信号量</h2><p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599458551857-bb81fb4f-2ada-4fac-9e9e-7a2bbf617dfc.png#align=left&amp;display=inline&amp;height=298&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=453&amp;originWidth=1043&amp;size=228045&amp;status=done&amp;style=none&amp;width=686" alt="image.png" /><br /><a name="0OclD"></a></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>wait(S)、signal(S) 也可以记为 P(S)、V(S)， 这对原语可用于实现系统资源的“申请”和“释放”。S.value 的初值表示系统中某种资源的数目。<br />对信号量 S 的一次 P 操作意味着进程请求一个单位的该类资源，因此需要执行 S.value–，表示资源数减1，当 S.value &lt; 0 时表示该类资源已分配完毕，因此进程应调 用 block 原语进行自我阻塞（当前运行的进程从运行态 à阻塞态），主动放弃处理机，并插入该类资源的等待队列 S.L 中。可见，该机制遵循了“让权等待”原则， 不会出现“忙等”现象。<br />对信号量 S 的一次 V 操作意味着进程释放一个单位的 该类资源，因此需要执行 S.value++，表示资源数加1， 若加1后仍是 S.value &lt;= 0，表示依然有进程在等待该类资源，因此应调用wakeup原语唤醒等待队列中的第一 个进程（被唤醒进程从阻塞态-&gt;就绪态）。<br /><a name="MA88z"></a></p><h2 id="实现进程互斥-同步-前驱关系"><a class="markdownIt-Anchor" href="#实现进程互斥-同步-前驱关系"></a> 实现进程互斥、同步、前驱关系</h2><p><a name="fzZqI"></a></p><h3 id="实现进程互斥"><a class="markdownIt-Anchor" href="#实现进程互斥"></a> 实现进程互斥</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599459140732-d93cda55-929e-4cc9-b4ae-ce7377cd2737.png#align=left&amp;display=inline&amp;height=330&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=467&amp;originWidth=415&amp;size=80987&amp;status=done&amp;style=none&amp;width=293" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599459185445-2f5c818b-6f1c-4fdb-b9c1-943d05274807.png#align=left&amp;display=inline&amp;height=144&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=229&amp;originWidth=608&amp;size=68785&amp;status=done&amp;style=none&amp;width=382" alt="image.png" /><br /><a name="TVk2K"></a></p><h4 id="实现流程如下"><a class="markdownIt-Anchor" href="#实现流程如下"></a> 实现流程如下：</h4><ol><li>分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）</li><li>设置互斥信号量 mutex，初值为 1</li><li>在进入区 P(mutex)——申请资源</li><li>在退出区 V(mutex)——释放资源</li></ol><p>注意：对不同的临界资源需要设置 不同的互斥信号量。 P、V操作必须成对出现。缺少 P(mutex) 就不能保证临界资源的互斥访问。缺少 V(mutex) 会导致资源 永不被释放，等待进程永不被唤醒。<br /><a name="69Pkg"></a></p><h3 id="实现进程同步"><a class="markdownIt-Anchor" href="#实现进程同步"></a> 实现进程同步</h3><p><a name="PhB4x"></a></p><h4 id="什么是进程同步"><a class="markdownIt-Anchor" href="#什么是进程同步"></a> 什么是进程同步</h4><p>进程同步：要让各并发进程按要求有序地推进。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599459265981-7e39a2ae-5c0b-4ef2-9be5-4512c42afc3a.png#align=left&amp;display=inline&amp;height=187&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=374&amp;originWidth=140&amp;size=30607&amp;status=done&amp;style=none&amp;width=70" alt="image.png" /><br />比如，P1、P2 并发执行，由于存在异步性，因此二者交替推进的次序是不确定的。 若 P2 的“代码4”要基于 P1 的“代码1”和“代码2”的运行结果才能执行，那么就必须保证“代码4”一定是在“代码2”之后才会执行。 这就是进程同步问题，让本来异步并发的进程互相配合，有序推进。<br /><a name="Iw2J9"></a></p><h4 id="实现流程"><a class="markdownIt-Anchor" href="#实现流程"></a> 实现流程</h4><ol><li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）</li><li>设置同步信号量 S, 初始为 0</li><li>在“前操作”之后执行 V(S)</li><li>在“后操作”之前执行 P(S)<br /><a name="Iknox"></a></li></ol><h4 id="具体实现"><a class="markdownIt-Anchor" href="#具体实现"></a> 具体实现</h4><p>信号量S代表“某种资源”，刚开始是没有这种资源的。P2需要使用这种资源， 而又只能由P1产生这种资源。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599461241957-7324ccec-de8d-44de-86a7-77bb34cbb5c6.png#align=left&amp;display=inline&amp;height=246&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=339&amp;originWidth=557&amp;size=96807&amp;status=done&amp;style=none&amp;width=405" alt="image.png" /><br />若先执行到 V(S) 操作，则 S++ 后 S=1。之后当执行到 P(S) 操作 时，由于 S=1，表示有可用资源，会执行 S–，S 的值变回 0， P2 进程不会执行 block 原语，而是继续往下执行代码4。 若先执行到 P(S) 操作，由于 S=0，S-- 后 S=-1，表示此时没有 可用资源，因此P操作中会执行 block 原语，主动请求阻塞。 之后当执行完代码2，继而执行 V(S) 操作， S++，使 S 变回 0， 由于此时有进程在该信号量对应的阻塞队列中，因此会在 V 操作中执行 wakeup 原语，唤醒 P2 进程。这样 P2 就可以继续 执行代码4了。<br /><a name="DgH9S"></a></p><h3 id="实现前驱关系"><a class="markdownIt-Anchor" href="#实现前驱关系"></a> 实现前驱关系</h3><p>进程 P1 中有句代码 S1，P2 中有句代码 S2 ，P3中有句代码S3 …… P6 中有句代码 S6。这些代码要求 按如下前驱图所示的顺序来执行：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599461657492-5c077d79-025e-44d3-a576-f113b7496e1a.png#align=left&amp;display=inline&amp;height=309&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=462&amp;originWidth=443&amp;size=52354&amp;status=done&amp;style=none&amp;width=296" alt="image.png" /><br />其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作），因此拟定执行流程如下：</p><ol><li>要为每一对前驱关系各设置一个同步信号量</li><li>在“前操作”之后对相应的同步信号量执行 V 操作</li><li>在“后操作”之前对相应的同步信号量执行 P 操作</li></ol><p>实现如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599461764625-61d466d0-b587-43fb-9d51-ede76bc43d82.png#align=left&amp;display=inline&amp;height=158&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=240&amp;originWidth=702&amp;size=75515&amp;status=done&amp;style=none&amp;width=462" alt="image.png" /><br /><a name="oDMJC"></a></p><h1 id="生产者消费者问题"><a class="markdownIt-Anchor" href="#生产者消费者问题"></a> 生产者消费者问题</h1><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者 进程每次从缓冲区中取出一个产品并使用。（注：这里的“产品”理解为某种数据） 生产者、消费者共享一个初始为空、大小为n的缓冲区。 只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。 只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。 缓冲区是临界资源，各进程必须互斥地访问。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599461943472-fb5383a2-af47-46bd-877f-0ea3bd49a867.png#align=left&amp;display=inline&amp;height=168&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=238&amp;originWidth=742&amp;size=61625&amp;status=done&amp;style=none&amp;width=523" alt="image.png" /><br /><a name="CuOi0"></a></p><h2 id="pv问题分析"><a class="markdownIt-Anchor" href="#pv问题分析"></a> PV问题分析</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599461996932-5c4d7dce-7fa1-4bbc-8747-ef29ed871d65.png#align=left&amp;display=inline&amp;height=87&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=120&amp;originWidth=570&amp;size=31045&amp;status=done&amp;style=none&amp;width=411" alt="image.png" /><br />定义信号量初始值：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599462628279-a186a534-323f-4e2e-834e-6adc5653fa2c.png#align=left&amp;display=inline&amp;height=54&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=80&amp;originWidth=815&amp;size=54882&amp;status=done&amp;style=none&amp;width=555" alt="image.png" /><br />生产者、消费者共享一个初始为空、大小为n的缓冲区。 只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。 只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。 缓冲区是临界资源，各进程必须互斥地访问。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599462688275-b12befb5-7f4d-4b54-a386-d97128e46a35.png#align=left&amp;display=inline&amp;height=167&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=269&amp;originWidth=1017&amp;size=126465&amp;status=done&amp;style=none&amp;width=633" alt="image.png" /><br />若此时缓冲区内已经放满产品，则 empty=0，full=n。 <br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599464246303-8e8f272c-6677-45ef-a260-5187d422e805.png#align=left&amp;display=inline&amp;height=126&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=251&amp;originWidth=853&amp;size=77575&amp;status=done&amp;style=none&amp;width=426.5" alt="image.png" /><br />则生产者进程执行：</p><ol><li>使mutex变为0，再执行</li><li>由于已没有空闲缓冲区，因此生产者被阻塞。 由于生产者阻塞，因此切换回消费者进程。消费者进程执行</li><li>由于mutex为0，即生产者还没释放对临界资源的“锁”，因此消费者也被阻塞。</li></ol><p>这就造成了生产者等待消费者释放空闲缓冲区，而消费者又等待生产者释放临界区的情况，生产者和消费者循环等待被对方唤醒，出现“死锁”。 <br />同样的，若缓冲区中没有产品，即full=0，empty=n。按③④① 的顺序执行就会发生死锁。 因此，实现互斥的P操作一定要在实现同步的P操作之后。 <br />V操作不会导致进程阻塞，因此两个V操作顺序可以交换。<br /><a name="cGzr4"></a></p><h1 id="多消费者模式"><a class="markdownIt-Anchor" href="#多消费者模式"></a> 多消费者模式</h1><p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放 橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才 可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。 用PV操作实现上述过程。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599464920878-3262793c-6c8e-40d8-be34-b38a49342aea.png#align=left&amp;display=inline&amp;height=216&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=275&amp;originWidth=804&amp;size=108449&amp;status=done&amp;style=none&amp;width=632" alt="image.png" /><br /><a name="7bqrM"></a></p><h2 id="pv分析"><a class="markdownIt-Anchor" href="#pv分析"></a> PV分析：</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599465202045-8b0c9d81-a785-440f-9502-2c3e44f027b2.png#align=left&amp;display=inline&amp;height=181&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=207&amp;originWidth=707&amp;size=98449&amp;status=done&amp;style=none&amp;width=618" alt="image.png" /><br />拟实现：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599465292175-97e58ec1-2204-4711-9f53-a86c856e1e46.png#align=left&amp;display=inline&amp;height=253&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=343&amp;originWidth=777&amp;size=117751&amp;status=done&amp;style=none&amp;width=574" alt="image.png" /><br />即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象，因为缓冲区大小为1，在任何时刻，apple、orange、plate 三个同步信号量中最多只有一个是1。因此在任何时刻， 最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区。<br />修改：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599465500590-c34b13ad-0703-4e61-8af2-df31b1d33efd.png#align=left&amp;display=inline&amp;height=137&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=174&amp;originWidth=784&amp;size=61864&amp;status=done&amp;style=none&amp;width=616" alt="image.png" /><br /><a name="PL51m"></a></p><h1 id="管程"><a class="markdownIt-Anchor" href="#管程"></a> 管程</h1><p>之前的PV操作的负载有目共睹，但是这里引出了管程的封装思想来对PV操作进行封装，来减少程序员的复杂操作。Brinch Hansen 首次在程序设计语言 (Pascal) 中引入了“管程”成分，其是一种高级同步机制。<br /><a name="FFe43"></a></p><h2 id="管程的组成部分"><a class="markdownIt-Anchor" href="#管程的组成部分"></a> 管程的组成部分</h2><p>管程是一种特殊的软件模块，有这些部分组成：</p><ul><li>局部于管程的共享数据结构说明</li><li>对该数据结构进行操作的一组过程</li><li>对局部于管程的共享数据设置初始值的语句</li><li>管程有一个名字。</li></ul><p>“过程”其实就是“函数”<br /><a name="OsGJo"></a></p><h2 id="管程的基本特征"><a class="markdownIt-Anchor" href="#管程的基本特征"></a> 管程的基本特征</h2><ul><li>局部于管程的数据只能被局部于管程的过程所访问</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li><li>每次仅允许一个进程在管程内执行某个内部过程。<br /><a name="DikNg"></a></li></ul><h2 id="解决消费者问题"><a class="markdownIt-Anchor" href="#解决消费者问题"></a> 解决消费者问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599467226570-126012b5-0734-4f3a-b89d-c69ccc22e50b.png#align=left&amp;display=inline&amp;height=454&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=605&amp;originWidth=525&amp;size=143288&amp;status=done&amp;style=none&amp;width=394" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599467246511-ecb27994-b56d-4b40-b78a-798b6d1d86aa.png#align=left&amp;display=inline&amp;height=306&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=335&amp;originWidth=384&amp;size=54648&amp;status=done&amp;style=none&amp;width=351" alt="image.png" /><br />引入管程的目的无非就是要更方便地实现进程互斥和同步。</p><ol><li>需要在管程中定义共享数据（如生产者消费者问题的缓冲区）</li><li>需要在管程中定义用于访问这些共享数据的“入口”——其实就是一些函数（如生产者消费者 问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品）</li><li>只有通过这些特定的“入口”才能访问共享数据</li><li>管程中有很多“入口”，但是每次只能开放其中一个“入口”，并且只能让一个进程或线程进 入（如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一 个时间段内最多只会有一个进程在访问缓冲区。注意：这种互斥特性是由编译器负责实现的， 程序员不用关心）</li><li>可在管程中设置条件变量及等待/唤醒操作以解决同步问题。可以让一个进程或线程在条件变量 上等待（此时，该进程应先释放管程的使用权，也就是让出“入口”）；可以通过唤醒操作将 等待在条件变量上的进程或线程唤醒。</li></ol><p>程序员可以用某种特殊的语法定义一个管程（比如: monitor ProducerConsumer …… end monitor;）， 之后其他程序员就可以使用这个管程ᨀ供的特定“入口”很方便地使用实现进程同步/互斥了。<br /><a name="ucef3"></a></p><h2 id="java-中类似于管程的机制"><a class="markdownIt-Anchor" href="#java-中类似于管程的机制"></a> Java 中类似于管程的机制</h2><p>Java中的synchronized就运用了管程的思想，Java 中，如果用关键字 synchronized 来᧿述一个函数，那么这个函数同一时间段内只能被一个线程调用如果多个线程 同时调用 insert 函数，则后 来者需要排队等待。<br /></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之处理机调度</title>
      <link href="/posts/operating_system_dispatch/"/>
      <url>/posts/operating_system_dispatch/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统之处理机调度"><a class="markdownIt-Anchor" href="#操作系统之处理机调度"></a> 操作系统之处理机调度</h1><p><a name="CvPC6"></a></p><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。 <br />处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。<br /><a name="OPFVk"></a></p><h2 id="调度的三个层次"><a class="markdownIt-Anchor" href="#调度的三个层次"></a> 调度的三个层次</h2><p>调度分为三个层次，分别是：高级调度、中级调度和初级调度。<br /><a name="v0GsL"></a></p><h3 id="高级调度"><a class="markdownIt-Anchor" href="#高级调度"></a> 高级调度</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599278572805-d5988500-0432-4a51-83cd-a08a1b8a9029.png#align=left&amp;display=inline&amp;height=125&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=249&amp;originWidth=1010&amp;size=98965&amp;status=done&amp;style=none&amp;width=505" alt="image.png" /><br />由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。 高级调度（作业调度），按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业， 给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它（们）获得竞争处理机的权利。高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。<br /><a name="hTTWr"></a></p><h3 id="中级调度"><a class="markdownIt-Anchor" href="#中级调度"></a> 中级调度</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599278655918-78edf85c-56f8-43ea-97e8-437e802df67c.png#align=left&amp;display=inline&amp;height=142&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=243&amp;originWidth=1037&amp;size=96631&amp;status=done&amp;style=none&amp;width=606" alt="image.png" /><br />引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。 这么做的目的是为了提高内存利用率和系统吞吐量。 暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB 来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。 中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。 一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。<br /><a name="sOV39"></a></p><h4 id="进程的挂起态与七状态模型"><a class="markdownIt-Anchor" href="#进程的挂起态与七状态模型"></a> 进程的挂起态与七状态模型</h4><p>暂时调到外存等待的进程状态为挂起状态（挂起态，suspend） 挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599278782157-358ab814-79df-4217-8302-67b936db915a.png#align=left&amp;display=inline&amp;height=269&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=441&amp;originWidth=1135&amp;size=118325&amp;status=done&amp;style=none&amp;width=692" alt="image.png" /><br />注意“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。 有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。<br /><a name="7BQee"></a></p><h3 id="低级调度"><a class="markdownIt-Anchor" href="#低级调度"></a> 低级调度</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599278817277-ed56b58a-d8b5-4233-984f-6683232d1a13.png#align=left&amp;display=inline&amp;height=144&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=200&amp;originWidth=737&amp;size=66317&amp;status=done&amp;style=none&amp;width=529" alt="image.png" /><br />低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。 进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。 进程调度的频率很高，一般几十毫秒一次。<br /><a name="SAFhR"></a></p><h3 id="三者关系"><a class="markdownIt-Anchor" href="#三者关系"></a> 三者关系</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599278850567-865ba8cd-4806-4b53-992e-1f8e76771655.png#align=left&amp;display=inline&amp;height=260&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=394&amp;originWidth=1000&amp;size=201974&amp;status=done&amp;style=none&amp;width=659" alt="image.png" /><br /><a name="m3S7Y"></a></p><h1 id="调度的时机切换与过程调度方式"><a class="markdownIt-Anchor" href="#调度的时机切换与过程调度方式"></a> 调度的时机切换与过程调度方式</h1><p>进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。<br /><a name="JN9aE"></a></p><h2 id="进程调度的时机"><a class="markdownIt-Anchor" href="#进程调度的时机"></a> 进程调度的时机</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599279068430-413a55b3-1bd4-49b0-800e-e10caa874e37.png#align=left&amp;display=inline&amp;height=173&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=303&amp;originWidth=1141&amp;size=165532&amp;status=done&amp;style=none&amp;width=651" alt="image.png" /><br />有的系统中，只允许进程主动放弃处理机。还有的系统中，进程可以主动放弃处理机，当有更紧急的任务需要处理时，也会强行剥夺处理机（被动放弃）。<br /><a name="yWfmB"></a></p><h3 id="不能调度的时候"><a class="markdownIt-Anchor" href="#不能调度的时候"></a> 不能调度的时候</h3><ul><li>在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。</li><li>进程在操作系统内核程序临界区中。</li><li>在原子操作过程中（原语）。原子操作不可中断，要一气呵成（如 之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）</li></ul><hr /><p>注意：操作系统内核程序临界区不等于临界区！进程在普通临界区中是可以进行调度、切换的。</p><ul><li>临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。</li><li>临界区：访问临界资源的那段代码。</li><li>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）</li></ul><hr /><p>当进程访问就绪队列时：如果还没退出临界区（还没解锁） 就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此又无法顺利进行进程调度。内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换。</p><hr /><p>在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致。普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。</p><hr /><p><a name="15pDs"></a></p><h2 id="进程调度的方式"><a class="markdownIt-Anchor" href="#进程调度的方式"></a> 进程调度的方式</h2><p>进程调度的方式分为非剥夺调度和剥夺调度方式。<br /><a name="VtEkf"></a></p><h3 id="非剥夺调度方式"><a class="markdownIt-Anchor" href="#非剥夺调度方式"></a> 非剥夺调度方式</h3><p>非剥夺调度方式，又称非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。<br />实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统。<br /><a name="JHdGU"></a></p><h3 id="剥夺调度方式"><a class="markdownIt-Anchor" href="#剥夺调度方式"></a> 剥夺调度方式</h3><p>剥夺调度方式，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。<br />可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统。<br /><a name="pI6Dm"></a></p><h2 id="进程调度与进程切换的"><a class="markdownIt-Anchor" href="#进程调度与进程切换的"></a> 进程调度与进程切换的</h2><p>狭义的进程调度指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换） 进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。<br />广义的进程调度包含了选择一个进程和进程切换两个步骤。<br />进程切换的过程主要完成了：</p><ul><li>对原来运行进程各种数据的保存</li><li>对新的进程各种数据的恢复 （如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）</li></ul><p>注意：进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低， 使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。<br /><a name="xYZKL"></a></p><h1 id="调度算法的评价指标"><a class="markdownIt-Anchor" href="#调度算法的评价指标"></a> 调度算法的评价指标</h1><p>调度算法的衡量指标通常有：CPU利用率、系统吞吐量、周转时间、等待时间和响应时间。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599287884584-1d68003c-4c28-48f5-9936-27e7c8d43624.png#align=left&amp;display=inline&amp;height=361&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=567&amp;originWidth=983&amp;size=222563&amp;status=done&amp;style=none&amp;width=625" alt="image.png" /><br /><a name="lJjJq"></a></p><h2 id="cpu利用率"><a class="markdownIt-Anchor" href="#cpu利用率"></a> CPU利用率</h2><p>由于早期的CPU造价极其昂贵，因此人们会希望让CPU尽可能多地工作。<br />CPU利用率：指CPU “忙碌”的时间占总时间的比例：<img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599286935874-45d9a61a-7d23-4557-970a-a0a5a3c72a81.png#align=left&amp;display=inline&amp;height=51&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=102&amp;originWidth=268&amp;size=10747&amp;status=done&amp;style=none&amp;width=134" alt="image.png" /><br /><a name="lpwz9"></a></p><h2 id="系统吞吐量"><a class="markdownIt-Anchor" href="#系统吞吐量"></a> 系统吞吐量</h2><p>对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业。 <br />系统吞吐量：单位时间内完成作业的数量：<img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599287047090-03d680cc-3e69-46ff-a8a4-23d1667b7a78.png#align=left&amp;display=inline&amp;height=45&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=90&amp;originWidth=434&amp;size=21656&amp;status=done&amp;style=none&amp;width=217" alt="image.png" /><br /><a name="EEHF0"></a></p><h2 id="周转时间"><a class="markdownIt-Anchor" href="#周转时间"></a> 周转时间</h2><p>对于计算机的用户来说，他很关心自己的作业从提交到完成花了多少时间。 周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔。 它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。<br />对于用户来说，更关心自 己的单个作业的周转时间:（作业）周转时间 = 作业完成时间 – 作业提交时间<br />对于操作系统来说，更关心系统的整体表现， 因此更关心所有作业周转时间的平均:<img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599287348397-af20431a-0f1a-48b6-9a06-8d7c284d4293.png#align=left&amp;display=inline&amp;height=43&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=86&amp;originWidth=405&amp;size=17491&amp;status=done&amp;style=none&amp;width=202.5" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599287391194-ee335060-e1c7-47be-8bc1-fb64ce820875.png#align=left&amp;display=inline&amp;height=43&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=86&amp;originWidth=755&amp;size=41183&amp;status=done&amp;style=none&amp;width=377.5" alt="image.png" />(带权周转时间必然 ≥1，带权周转时间与周转时 间都是越小越好)<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599287397704-1232d87b-54f7-480e-a8fa-56c3097daefc.png#align=left&amp;display=inline&amp;height=62&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=123&amp;originWidth=519&amp;size=22513&amp;status=done&amp;style=none&amp;width=259.5" alt="image.png" /><br />对于周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多， 带权周转时间更小，用户满意度更高。对于实际运行时间相同的两个作业，周转时 间短的带权周转时间更小，用户满意度更高。<br /><a name="9PkHH"></a></p><h2 id="等待时间"><a class="markdownIt-Anchor" href="#等待时间"></a> 等待时间</h2><p>计算机的用户希望自己的作业尽可能少的等待处理机 等待时间，指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599287519852-c7d76180-acf1-4e38-8009-b790ad8b394e.png#align=left&amp;display=inline&amp;height=163&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=276&amp;originWidth=1157&amp;size=172079&amp;status=done&amp;style=none&amp;width=682" alt="image.png" /><br />对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。 对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。<br />一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有“平均等待时间”来评价整体性能。<br /><a name="ITDnw"></a></p><h2 id="响应时间"><a class="markdownIt-Anchor" href="#响应时间"></a> 响应时间</h2><p>对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应。 响应时间，指从用户提交请求到首次产生响应所用的时间。<br /><a name="l53wS"></a></p><h1 id="调度算法"><a class="markdownIt-Anchor" href="#调度算法"></a> 调度算法</h1><p>最基本的调度算法分为三种：先来先服务、短作业优先和高响应比优先。这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算 法一般适合用于早期的批处理系统，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。<br /><a name="2dUrN"></a></p><h2 id="先来先服务fcfs-first-come-first-serve"><a class="markdownIt-Anchor" href="#先来先服务fcfs-first-come-first-serve"></a> 先来先服务（FCFS, First Come First Serve）</h2><p>例题：各进程到达就绪队列的时间、需要的运行时间如下表所示。使用先来先服务调度算法，计算各 进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。<br />注意：本例中的进程都是纯计算型的进程，一个进程到达后要么在等待，要么在运行。如果是又有计算、又有 I/O操作的进程，其等待时间就是周转时间 - 运行时间 - I/O操作的时间<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599288111859-687a201b-9282-48e1-a638-286bbba818a8.png#align=left&amp;display=inline&amp;height=137&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=163&amp;originWidth=277&amp;size=13801&amp;status=done&amp;style=none&amp;width=232" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599288366285-0f58c2bc-a1cf-42b9-b97d-0d802cdc8ccb.png#align=left&amp;display=inline&amp;height=124&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=163&amp;originWidth=535&amp;size=44729&amp;status=done&amp;style=none&amp;width=407" alt="image.png" /><br />周转时间 = 完成时间 - 到达时间 P1=7-0=7；P2=11-2=9；P3=12-4=8；P4=16-5=11 <br />带权周转时间 = 周转时间/运行时间 P1=7/7=1；P2=9/4=2.25；P3=8/1=8；P4=11/4=2.75 <br />等待时间 = 周转时间 – 运行时间 P1=7-7=0；P2=9-4=5；P3=8-1=7；P4=11-4=7<br />平均周转时间 = (7+9+8+11)/4 = 8.75 <br />平均带权周转时间 = (1+2.25+8+2.75)/4 = 3.5 <br />平均等待时间 = (0+5+7+7)/4 = 4.75</p><table><thead><tr><th>算法思想</th><th>主要从“公平”的角度考虑（类似于生活中排队买东 西的例子）</th></tr></thead><tbody><tr><td>算法规则</td><td>按照作业/进程到达的先后顺序进行服务</td></tr><tr><td>用于作业/进程调度</td><td>用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列</td></tr><tr><td>是否可抢占？</td><td>非抢占式的算法</td></tr><tr><td>优缺点</td><td>优点：公平、算法实现简单 缺点：排在长作业（进程）后面的短作业需要等待很长时 间，带权周转时间很大，对短作业来说用户体验不好。即， FCFS算法对长作业有利，对短作业不利（Eg ：排队买奶茶…）</td></tr><tr><td>是否会导致饥饿</td><td>不会</td></tr></tbody></table><p><a name="3JkAm"></a></p><h2 id="短作业优先sjf-shortest-job-first"><a class="markdownIt-Anchor" href="#短作业优先sjf-shortest-job-first"></a> 短作业优先（SJF, Shortest Job First）</h2><p>例题：各进程到达就绪队列的时间、需要的运行时间如下表所示。使用非抢占式的短作业优先调度算 法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周 转时间。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599288349517-dc67e236-9fe1-452d-ba66-3f3756608a82.png#align=left&amp;display=inline&amp;height=159&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=159&amp;originWidth=268&amp;size=13279&amp;status=done&amp;style=none&amp;width=268" alt="image.png" /><br /><a name="9H2k6"></a></p><h3 id="spf"><a class="markdownIt-Anchor" href="#spf"></a> SPF</h3><p>严格来说，用于进程调度 应该称为短进程优先调度算法（SPF）<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599288408146-99784ceb-944f-4947-bd4f-a788de215d54.png#align=left&amp;display=inline&amp;height=122&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=180&amp;originWidth=531&amp;size=40303&amp;status=done&amp;style=none&amp;width=359" alt="image.png" /><br />周转时间 = 完成时间 - 到达时间 P1=7-0=7；P3=8-4=4；P2=12-2=10；P4=16-5=11 <br />带权周转时间 = 周转时间/运行时间 P1=7/7=1；P3=4/1=4；P2=10/4=2.5；P4=11/4=2.75 <br />等待时间 = 周转时间 – 运行时间 P1=7-7=0；P3=4-1=3；P2=10-4=6；P4=11-4=7 <br />平均周转时间 = (7+4+10+11)/4 = 8 <br />平均带权周转时间 = (1+4+2.5+2.75)/4 = 2.56 <br />平均等待时间 = (0+3+6+7)/4 = 4<br />对比FCFS算法的结果，显然SPF算法的 平均等待/周转/带权周转时间都要更低。<br /><a name="2xsWG"></a></p><h3 id="srtn"><a class="markdownIt-Anchor" href="#srtn"></a> SRTN</h3><p>抢占式的短作业优先算法又称“最短剩余时间优先 算法（SRTN）”<br />最短剩余时间优先算法：每当有进程加入就绪队列改变时就需 要调度，如果新到达的进程剩余时间比当前运行的进程剩余时 间更短，则由新进程抢占处理机，当前运行进程重新回到就绪 队列。另外，当一个进程完成时也需要调度。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599288626515-6151c4c5-27df-4b16-adfa-70a726338a81.png#align=left&amp;display=inline&amp;height=65&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=87&amp;originWidth=551&amp;size=10140&amp;status=done&amp;style=none&amp;width=412" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599288650846-b9f2c9c7-e509-414c-b7c8-46bfaa42d1c7.png#align=left&amp;display=inline&amp;height=137&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=228&amp;originWidth=1043&amp;size=116438&amp;status=done&amp;style=none&amp;width=626" alt="image.png" /><br />周转时间 = 完成时间 - 到达时间 P1=16-0=16；P2=7-2=5；P3=5-4=1；P4=11-5=6 <br />带权周转时间 = 周转时间/运行时间 P1=16/7=2.28；P2=5/4=1.25；P3=1/1=1；P4=6/4=1.5 <br />等待时间 = 周转时间 – 运行时间 P1=16-7=9；P2=5-4=1；P3=1-1=0；P4=6-4=2 <br />平均周转时间 = (16+5+1+6)/4 = 7 <br />平均带权周转时间 = (2.28+1.25+1+1.5)/4 = 1.50 <br />平均等待时间 = (9+1+0+2)/4 = 3<br />对比非抢占式的短作业优先算法，显然抢占式的这几个指标又要更低。<br /><a name="0T0PD"></a></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><ol><li>如果题目中未特别说明，所提到的“短作业/进程优先算法”默认是非抢占式的</li><li>很多书上都会说“SJF 调度算法的平均等待时间、平均周转时间最少” 严格来说，这个表述是错误的，不严谨的。之前的例子表明，最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少应该加上一个条件“在所有进程同时可运行时，采用SJF调度算法的平均等待时间、平均周转时间最 少”； 或者说“在所有进程都几乎同时到达时，采用SJF调度算法的平均等待时间、平均周转时间最少”； 如果不加上述前提条件，则应该说“抢占式的短作业/进程优先调度算法（最短剩余时间优先, SRNT算法）的平均等待时间、平均周转时间最少”</li><li>虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如 FCFS）， SJF依然可以获得较少的平均等待时间、平均周转时间</li><li>如果选择题中遇到“SJF 算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项 是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项<br />| 算法思想 | 追求最少的平均等待时间，最少的平均周转时间、最少的 平均平均带权周转时间 |<br />| — | — |<br />| 算法规则 | 最短的作业/进程优先得到服务（所谓“最短”，是指要求 服务时间最短） |<br />| 用于作业/进程调度 | 即可用于作业调度，也可用于进程调度。用于进程调度时 称为“短进程优先（SPF, Shortest Process First）算法” |<br />| 是否可抢占？ | SJF和SPF是非抢占式的算法。但是也有抢占式的版本——最 短剩余时间优先算法（SRTN, Shortest Remaining Time Next） |<br />| 优缺点 | 优点：“最短的”平均等待时间、平均周转时间 缺点：不公平。对短作业有利，对长作业不利。可能产生 饥饿现象。另外，作业/进程的运行时间是由用户提供的， 并不一定真实，不一定能做到真正的短作业优先 |<br />| 是否会导致饥饿 | 会。如果源源不断地有短作业/进程到来，可能使长作业/进 程长时间得不到服务，产生“饥饿”现象。如果一直得不 到服务，则称为“饿死” |</li></ol><p><a name="4bKgM"></a></p><h2 id="fcfs和sjf思考"><a class="markdownIt-Anchor" href="#fcfs和sjf思考"></a> FCFS和SJF思考</h2><p>FCFS 算法是在每次调度的时候选择一个等待时间最长 的作业（进程）为其服务。但是没有考虑到作业的运 行时间，因此导致了对短作业不友好的问题。而SJF 算法是选择一个执行时间最短的作业为其服务。但是又完全不考虑各个作业的等待时间，因此导致了对长作业不友好的问题，甚至还会造成饥饿问题。<br />因此衍生出了一个较为全面的全新算法：高响应比优先算法，即考虑到各个作业 的等待时间，也能兼顾运行时间。<br /><a name="gkHDg"></a></p><h2 id="高响应比优先hrrnhighest-response-ratio-next"><a class="markdownIt-Anchor" href="#高响应比优先hrrnhighest-response-ratio-next"></a> 高响应比优先（HRRN,Highest Response Ratio Next）</h2><p>例题：各进程到达就绪队列的时间、需要的运行时间如下表所示。使用高响应比优先调度算法，计算 各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599289137430-a3afcd74-9a19-4dce-a056-4e2c0c468d7d.png#align=left&amp;display=inline&amp;height=173&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=193&amp;originWidth=319&amp;size=17032&amp;status=done&amp;style=none&amp;width=286" alt="image.png" /><br />高响应比优先算法：非抢占式的调度算法，只有当前运行的进程主动放弃CPU时（正常/异常完成，或主动阻塞），才需要进 行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599289194234-806f96ce-6067-456e-82b2-413c12151a32.png#align=left&amp;display=inline&amp;height=59&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=99&amp;originWidth=652&amp;size=10426&amp;status=done&amp;style=none&amp;width=387" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599289245808-f67338ee-639b-44d5-8442-8e36b18d06c3.png#align=left&amp;display=inline&amp;height=123&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=212&amp;originWidth=1091&amp;size=101165&amp;status=done&amp;style=none&amp;width=633" alt="image.png" /></p><table><thead><tr><th>算法思想</th><th>要综合考虑作业/进程的等待时间和要求服务的时间</th></tr></thead><tbody><tr><td>算法规则</td><td>在每次调度时先计算各个作 业/进程的响应比，选择响应 比最高的作业/进程为其服务<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599289105264-9cae55a9-60b6-4bfe-a9e2-56cb7a3fe472.png#align=left&amp;display=inline&amp;height=34&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=68&amp;originWidth=340&amp;size=18332&amp;status=done&amp;style=none&amp;width=170" alt="image.png" /></td></tr><tr><td>用于作业/进程调度</td><td>即可用于作业调度，也可用于进程调度</td></tr><tr><td>是否可抢占？</td><td>非抢占式的算法。因此只有当前运行的作业/进程主动放弃 处理机时，才需要调度，才需要计算响应比</td></tr><tr><td>优缺点</td><td>综合考虑了等待时间和运行时间（要求服务时间） 等待时间相同时，要求服务时间短的优先（SJF 的优点） 要求服务时间相同时，等待时间长的优先（FCFS 的优点） 对于长作业来说，随着等待时间越来越久，其响应比也会 越来越大，从而避免了长作业饥饿的问题</td></tr><tr><td>是否会导致饥饿</td><td>不会</td></tr></tbody></table><p><a name="Fl9j0"></a></p><h1 id="交互式调度算法"><a class="markdownIt-Anchor" href="#交互式调度算法"></a> 交互式调度算法</h1><p><br />该类型主要有三种：时间片轮询调度算法、优先级调度算法和多级反馈。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599293423654-9505fc47-d733-4d1f-9356-27a466988c84.png#align=left&amp;display=inline&amp;height=286&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=571&amp;originWidth=1350&amp;size=368839&amp;status=done&amp;style=none&amp;width=675" alt="image.png" /><br /><a name="0APbz"></a></p><h2 id="时间片轮询调度算法rrround-robin"><a class="markdownIt-Anchor" href="#时间片轮询调度算法rrround-robin"></a> 时间片轮询调度算法（RR，Round-Robin）</h2><p>常用于分时操作系统，因此更注重响应时间，所以此处不计算周转时间。<br /><a name="2BgdY"></a></p><h3 id="时间片为2"><a class="markdownIt-Anchor" href="#时间片为2"></a> 时间片为2：</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599290313075-e2f0427b-5f01-4f83-b8b0-1afa392e2ec7.png#align=left&amp;display=inline&amp;height=323&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=646&amp;originWidth=1225&amp;size=447682&amp;status=done&amp;style=none&amp;width=612.5" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599290378151-63decae1-e5f7-4584-ad90-03207baa6a46.png#align=left&amp;display=inline&amp;height=133&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=265&amp;originWidth=700&amp;size=31758&amp;status=done&amp;style=none&amp;width=350" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599290348380-b04c0cb5-2337-4809-8d07-f6371067b38a.png#align=left&amp;display=inline&amp;height=100&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=200&amp;originWidth=1191&amp;size=162532&amp;status=done&amp;style=none&amp;width=595.5" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599290435761-54388a69-a2fc-4757-949f-0d59b5e68a9c.png#align=left&amp;display=inline&amp;height=126&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=252&amp;originWidth=656&amp;size=31181&amp;status=done&amp;style=none&amp;width=328" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599290426603-2486173e-d91c-4db6-b6a9-b1c2896dcbe9.png#align=left&amp;display=inline&amp;height=56&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=111&amp;originWidth=1010&amp;size=70529&amp;status=done&amp;style=none&amp;width=505" alt="image.png" /><br /><a name="uu1qv"></a></p><h3 id="时间片为5"><a class="markdownIt-Anchor" href="#时间片为5"></a> 时间片为5：</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599290553637-7c2a9062-f9ae-47b7-900e-9ecf8708478d.png#align=left&amp;display=inline&amp;height=80&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=160&amp;originWidth=770&amp;size=16376&amp;status=done&amp;style=none&amp;width=385" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599290547738-b2ac0d72-5012-4cae-a934-0c2518faf2d3.png#align=left&amp;display=inline&amp;height=158&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=315&amp;originWidth=1117&amp;size=234434&amp;status=done&amp;style=none&amp;width=558.5" alt="image.png" /><br /><a name="W92oF"></a></p><h4 id="与先来先服务对比"><a class="markdownIt-Anchor" href="#与先来先服务对比"></a> 与先来先服务对比：</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599290618983-59f0e021-33c9-4e56-991f-c185fbf8619c.png#align=left&amp;display=inline&amp;height=125&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=249&amp;originWidth=787&amp;size=29290&amp;status=done&amp;style=none&amp;width=393.5" alt="image.png" /><br />两者没什么区别。<br /><a name="3WTnJ"></a></p><h3 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3><p>设计时间片要让切换进程的开销占比不超过1%。比如如果有十个进程并发，如果时间片为1s，则一个进程被相应可能需要等待9s。<br />如果时间片太大会导致时间片轮转退化为先来先服务的形式。</p><table><thead><tr><th>算法思想</th><th>公平的、轮流的为各个进程服务，让每个进程在一定时间间隔内都可以得到相应。</th></tr></thead><tbody><tr><td>算法规则</td><td>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完成则剥离处理机，把进程重新放在就绪队列对尾重新排队。</td></tr><tr><td>用于作业/进程调度</td><td>即可用于作业调度（只有作业放入内存建立了相应的进程后才会被分配处理机时间片）</td></tr><tr><td>是否可抢占？</td><td>若进程未能在时间片内运行完，将会被剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知时CPU时间片已到。</td></tr><tr><td>优缺点</td><td>优点：公平，响应快，是用于分时操作系统。<br />缺点：用于高频率的进程切换，因此有一定开销，且不区分任务的紧急度。</td></tr><tr><td>是否会导致饥饿</td><td>不会</td></tr></tbody></table><p><a name="4zBbh"></a></p><h2 id="优先调度算法"><a class="markdownIt-Anchor" href="#优先调度算法"></a> 优先调度算法</h2><p><a name="rfhLw"></a></p><h3 id="非抢占式"><a class="markdownIt-Anchor" href="#非抢占式"></a> 非抢占式</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599291604715-4eb7a042-6f28-41f5-97a8-18b5c45348ad.png#align=left&amp;display=inline&amp;height=280&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=559&amp;originWidth=1274&amp;size=319467&amp;status=done&amp;style=none&amp;width=637" alt="image.png" /><br /><a name="nJm0y"></a></p><h3 id="抢占式"><a class="markdownIt-Anchor" href="#抢占式"></a> 抢占式</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599291700071-736ab3ba-bfa2-4cb4-9507-79f9c4b0bdd2.png#align=left&amp;display=inline&amp;height=307&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=614&amp;originWidth=1259&amp;size=406405&amp;status=done&amp;style=none&amp;width=629.5" alt="image.png" /><br /><a name="ax0U2"></a></p><h3 id="总结-3"><a class="markdownIt-Anchor" href="#总结-3"></a> 总结</h3><p>就绪队列未必只有一个，可以按照不同的优先级来组织。另外，也可以把优先级高的进程排在队头。<br />根据优先级是否可以动态改变可将优先级分为静态优先级和动态优先级两种：</p><ul><li>静态优先级：创建进程时确定，之后保持不变。</li><li>动态优先级：创建进程是只有一个初始值，之后会根据情况动态的调整优先级。</li></ul><p>通常，系统进程的优先级高于用户进程，前台优先级高于后台进程，操作系统更偏好I/O型进程（或称I/O繁忙型进程）。<br />I/O设备可以和CPU并行工作。如果优先让I/O繁忙型进程优先运行的话，则I/O设备越早投入工作，资源利用率、系统吞吐量等都会越早得到提升。<br />注：I/O型进程相对的是计算机型进程（或称CPU繁忙型进程）。<br />可以从追求公平、提升资源利用率等角度考虑：<br />如果某进程在就绪队列中等待了很长的时间，则可以适当提升其优先级。<br />如果某进程占用处理机运行了很长时间，则可以适当降低其优先级。<br />如果发现了一个进程频繁的进行了I/O操作，则可以适当的提升其优先级。<br /></p><table><thead><tr><th>算法思想</th><th>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序。</th></tr></thead><tbody><tr><td>算法规则</td><td>每个作业/进程都有各自的优先级，调度室选择优先级最高的作业/进程</td></tr><tr><td>用于作业/进程调度</td><td>即可以用于作业调度，也可以用于进程调度。甚至，还会用于在I/O调度中。</td></tr><tr><td>是否可抢占？</td><td>抢占式、非抢占式都有。区别在于：非抢占式只需在进程主动放弃处理及时进行调度即可，而抢占式还需在就绪队列变化时检查是否会发生抢占。</td></tr><tr><td>优缺点</td><td>优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活的调整对各种作业/进程的偏好程度。<br />缺点：若源源不断地有高优先级进程到来，则可能导致饥饿。</td></tr><tr><td>是否会导致饥饿</td><td>会</td></tr></tbody></table><p><a name="maOj0"></a></p><h2 id="多级反馈队列调度算法"><a class="markdownIt-Anchor" href="#多级反馈队列调度算法"></a> 多级反馈队列调度算法</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599293383631-6b816895-5b9b-492f-be45-fd9feedce3f9.png#align=left&amp;display=inline&amp;height=311&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=622&amp;originWidth=1286&amp;size=321520&amp;status=done&amp;style=none&amp;width=643" alt="image.png" /></p><table><thead><tr><th>算法思想</th><th>对其他调度算法的这种权衡</th></tr></thead><tbody><tr><td>算法规则</td><td><br />1. 设置多级就绪队列，各级队列优先级从高到低，时间片由小到大。<br />1. 新进程到达时先进入第1级阶段，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是最下级的队列，则重新放回到该队列队尾。<br />1. 只有第K级队列为空时，才会为k+1级队头的进程分配时间片用于进程调度。<br /></td></tr><tr><td>用于作业/进程调度</td><td>用于进程调度</td></tr><tr><td>是否可抢占？</td><td>抢占式的算法。在k级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列，因此新进程会抢占处理机。原来运行的进程放回K级队列队尾。</td></tr><tr><td>优缺点</td><td>对各类型进程相对公平（FCFS的优点），每个新到达的进程都很快就得到响应（RR的优点），断金程志勇较少的时间就完成（SPF的优点），不必实现估计进程的运行时间（避免用户作假），集型进程（拓展：可以将因I/O阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高的优先级）</td></tr><tr><td>是否会导致饥饿</td><td>会</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之进程</title>
      <link href="/posts/operating_system_process/"/>
      <url>/posts/operating_system_process/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统之进程"><a class="markdownIt-Anchor" href="#操作系统之进程"></a> 操作系统之进程</h1><p><a name="e1nnw"></a></p><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>任务管理器如下图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599212600999-8644da9c-68e2-42d9-b0ef-d60f46d32e0a.png#align=left&amp;display=inline&amp;height=372&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=744&amp;originWidth=1070&amp;size=92296&amp;status=done&amp;style=none&amp;width=535" alt="image.png" /><br />程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。<br />进程（Process）：是动态的，是程序的一次执行过程。同一个程序多次执行会对应多个进程。<br /><a name="kWv0Z"></a></p><h2 id="进程的特征"><a class="markdownIt-Anchor" href="#进程的特征"></a> 进程的特征</h2><p>程序是静态的，进程是动态的，相比于程序，进程拥有以下特征：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599213836986-7618c585-e1e6-467d-b725-a88136c107b6.png#align=left&amp;display=inline&amp;height=318&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=635&amp;originWidth=1568&amp;size=404039&amp;status=done&amp;style=none&amp;width=784" alt="image.png" /><br /><a name="UIPjV"></a></p><h1 id="计算机组成"><a class="markdownIt-Anchor" href="#计算机组成"></a> 计算机组成</h1><p>更确切的说，应该是“进程实体(进程映像)的组成”。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599213178682-a3f02d8c-9058-41e1-9aab-c4b529cc2378.png#align=left&amp;display=inline&amp;height=255&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=510&amp;originWidth=1532&amp;size=148785&amp;status=done&amp;style=none&amp;width=766" alt="image.png" /><br />其中PCB是给操作系统用的。 程序段、数据段是给进程自己用的。<br />程序段、数据段、PCB三部分组成了进程实体（进程映像） 引入进程实体的概念后，可把进程定义为： 进程是进程实体的运行过程，是系统进行资源分配和调度（一个进程被“调度”，就是指操作系统决定让这个进程上CPU运行）的一个独立单位。<br /><a name="98mmL"></a></p><h2 id="pcb"><a class="markdownIt-Anchor" href="#pcb"></a> PCB</h2><p>如上图，每个进程都有专属的PID，当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”就是PID（Process ID，进程ID）。<br />除此以外，其还会记录进程所属用户ID（UID），基本的进程描述信息，可以让操作系统区分各个进程。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599212730059-1b34d031-535e-461f-a96e-40aaf4148329.png#align=left&amp;display=inline&amp;height=59&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=117&amp;originWidth=1062&amp;size=12703&amp;status=done&amp;style=none&amp;width=531" alt="image.png" /><br />还要记录给进程分配了哪些资源（如：分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件）（可用于实现操作系统对资源的管理）、要记录进程的运行情况（如：CPU使用时间、磁盘使用情况、网络流量使用情况等）（可用于实现操作系统对进程的控制、调度）。<br />这些信息都被保存在一个数据结构PCB （Process Control Block）中，即进程控制块操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在PCB中。<br /><a name="iA9OT"></a></p><h3 id="pcb概念"><a class="markdownIt-Anchor" href="#pcb概念"></a> PCB概念</h3><p>操作系统对进程进行管理工作所需的信息都存在PCB中，PCB是进程存在的唯一标志。<br />PCB是进程存在的唯 一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599213103222-be9b99a4-33ec-410b-afff-f6c61d0f87de.png#align=left&amp;display=inline&amp;height=285&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=570&amp;originWidth=1584&amp;size=195775&amp;status=done&amp;style=none&amp;width=792" alt="image.png" /><br />同时挂三个QQ号，会对应三个QQ 进程，它们的PCB、数据段各不相同，但程序段的内容都是相同的 （都是运行着相同的QQ程序）。<br /><a name="lTypu"></a></p><h3 id="程序段和数据段的产生"><a class="markdownIt-Anchor" href="#程序段和数据段的产生"></a> 程序段和数据段的产生</h3><p>程序段是指程序代码（指令序列），数据段是指运行过程中产生的各种数据。<br />程序运行的过程其实就是CPU执行一条一条的机器指令的过程。如下图即单条指令翻译过程：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599213283819-61c6e5d1-c139-49a4-b0ae-7572b2454167.png#align=left&amp;display=inline&amp;height=98&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=196&amp;originWidth=1040&amp;size=68172&amp;status=done&amp;style=none&amp;width=520" alt="image.png" /><br />因此推断程序执行流程如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599213390418-85e6bc78-1ef7-4b55-a8c0-a5da1f3a4460.png#align=left&amp;display=inline&amp;height=364&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=728&amp;originWidth=1525&amp;size=241406&amp;status=done&amp;style=none&amp;width=762.5" alt="image.png" /><br />一个进程实体（进程映像）由PCB、程序段、数据段组成。 进程是动态的，进程实体（进程映像）是静态的。 进程实体反应了进程在某一时刻的状态（如：x++后，x=2）。<br /><a name="GrfT7"></a></p><h1 id="进程的组织"><a class="markdownIt-Anchor" href="#进程的组织"></a> 进程的组织</h1><p>在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。 <br />注：进程的组成讨论的是一个进程内部由哪些部分构成的问题，而进程的组织讨论的是多个进程之间的组织方式问题。<br /><a name="AdpLA"></a></p><h2 id="进程的组织方式"><a class="markdownIt-Anchor" href="#进程的组织方式"></a> 进程的组织方式</h2><p>其组织方式有两种，一种是索引方式，另一种就是链接方式。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599213930177-79884b3d-768d-4a37-9882-c3d475a8a0ea.png#align=left&amp;display=inline&amp;height=163&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=325&amp;originWidth=1340&amp;size=209323&amp;status=done&amp;style=none&amp;width=670" alt="image.png" /><br /><a name="SJ89p"></a></p><h3 id="链接方式"><a class="markdownIt-Anchor" href="#链接方式"></a> 链接方式</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599213985145-6237609d-228f-48a9-bd96-4ffea052b9b3.png#align=left&amp;display=inline&amp;height=348&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=541&amp;originWidth=1070&amp;size=146777&amp;status=done&amp;style=none&amp;width=688" alt="image.png" /><br /><a name="itTYI"></a></p><h3 id="索引方式"><a class="markdownIt-Anchor" href="#索引方式"></a> 索引方式</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599214003578-53fcd1fc-8d2a-44db-a617-8bb19730c866.png#align=left&amp;display=inline&amp;height=349&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=505&amp;originWidth=988&amp;size=68718&amp;status=done&amp;style=none&amp;width=682" alt="image.png" /><br /><a name="zMPqA"></a></p><h1 id="进程控制"><a class="markdownIt-Anchor" href="#进程控制"></a> 进程控制</h1><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现 进程状态转换等功能。<br />进程转化流程：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599216033517-37594efe-63ef-4c0d-a7ff-1620cfc27479.png#align=left&amp;display=inline&amp;height=175&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=305&amp;originWidth=1156&amp;size=56226&amp;status=done&amp;style=none&amp;width=664" alt="image.png" /><br /><a name="hDWSK"></a></p><h2 id="如何实现进程控制"><a class="markdownIt-Anchor" href="#如何实现进程控制"></a> 如何实现进程控制</h2><p>进程控制是通过使用“原语”实现的。<br />之前讲过，原语使内核中的关键的一部分：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599216088116-b8b0e0e1-d388-42ce-82ad-0cdbbd0a4db2.png#align=left&amp;display=inline&amp;height=294&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=495&amp;originWidth=1184&amp;size=133348&amp;status=done&amp;style=none&amp;width=704" alt="image.png" /><br /><a name="RVSLn"></a></p><h3 id="为什么要一气呵成"><a class="markdownIt-Anchor" href="#为什么要一气呵成"></a> 为什么要“一气呵成”</h3><p>如果不能“一气呵成”，就有可能导致操作系 统中的某些关键数据结构信息不统一的情况， 这会影响操作系统进行别的管理工作。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599216330604-8dc1bea9-bedd-4df4-b97d-d9688987530d.png#align=left&amp;display=inline&amp;height=255&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=398&amp;originWidth=1082&amp;size=183730&amp;status=done&amp;style=none&amp;width=694" alt="image.png" /><br /><a name="DKsvj"></a></p><h3 id="原子性的实现"><a class="markdownIt-Anchor" href="#原子性的实现"></a> 原子性的实现</h3><p>可以用 “关中断指令”和“开中断指令”这两个特权指令实现原子性。<br />正常情况：CPU每执行完一条指令都会例行检查是否有中断信号需要处理，如果有， 则暂停运行当前这段程序，转而执行相应的中断处理程序。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599216480233-d06187d6-706f-4c3e-a77e-089fd910e8df.png#align=left&amp;display=inline&amp;height=344&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=465&amp;originWidth=633&amp;size=89935&amp;status=done&amp;style=none&amp;width=468" alt="image.png" /><br />CPU执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后才会恢复检查。 这样，关中断、开中断之间的这些指令序列就是不可被中断的，这就实现了“原子性”<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599216535162-81d9b236-d3db-497f-b444-bd0a0f3308ab.png#align=left&amp;display=inline&amp;height=328&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=433&amp;originWidth=597&amp;size=65353&amp;status=done&amp;style=none&amp;width=452" alt="image.png" /><br /><a name="XUDb9"></a></p><h2 id="原语类型"><a class="markdownIt-Anchor" href="#原语类型"></a> 原语类型</h2><p>无论哪个进程控制原语，要做的无非三类事情：</p><ul><li>更新PCB中的信息<ul><li>所有的进程控制原语一定都会修改进程状态标志</li><li>剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li><li>某进程开始运行前必然要恢复期运行环境</li></ul></li><li>将PCB插入合适的队列</li><li>分配/回收资源<br /><a name="VSArr"></a></li></ul><h3 id="进程创建相关原语"><a class="markdownIt-Anchor" href="#进程创建相关原语"></a> 进程创建相关原语</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599216626772-896930a6-5ad3-46ba-8fe8-c630990f5768.png#align=left&amp;display=inline&amp;height=360&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=497&amp;originWidth=1214&amp;size=230253&amp;status=done&amp;style=none&amp;width=879" alt="image.png" /><br /><a name="Z3rm6"></a></p><h3 id="进程终止相关原语"><a class="markdownIt-Anchor" href="#进程终止相关原语"></a> 进程终止相关原语</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599216681520-6878afde-3340-472b-bce1-396b8d31037e.png#align=left&amp;display=inline&amp;height=362&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=542&amp;originWidth=1181&amp;size=258874&amp;status=done&amp;style=none&amp;width=789" alt="image.png" /><br /><a name="D6k0p"></a></p><h3 id="进程阻塞和唤醒的原语"><a class="markdownIt-Anchor" href="#进程阻塞和唤醒的原语"></a> 进程阻塞和唤醒的原语</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599216716635-862d5039-4126-4b92-b769-b8bc596d2b8d.png#align=left&amp;display=inline&amp;height=380&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=524&amp;originWidth=1231&amp;size=274363&amp;status=done&amp;style=none&amp;width=893" alt="image.png" /><br /><a name="f5MP7"></a></p><h3 id="进程切换的原语"><a class="markdownIt-Anchor" href="#进程切换的原语"></a> 进程切换的原语</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599217734216-976345c1-de44-4da6-b481-3f9daec33570.png#align=left&amp;display=inline&amp;height=341&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=549&amp;originWidth=1111&amp;size=238632&amp;status=done&amp;style=none&amp;width=690" alt="image.png" /><br /><a name="B2aTL"></a></p><h2 id="原语转换图"><a class="markdownIt-Anchor" href="#原语转换图"></a> 原语转换图</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599218323463-925854e5-3b83-4db5-94dc-f0ddbdb36c27.png#align=left&amp;display=inline&amp;height=421&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=699&amp;originWidth=1183&amp;size=332831&amp;status=done&amp;style=none&amp;width=713" alt="image.png" /><br /><a name="ozkCh"></a></p><h1 id="进程通信"><a class="markdownIt-Anchor" href="#进程通信"></a> 进程通信</h1><p>顾名思义，进程通信就是指进程之间的信息交换。 进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599218774690-b1767483-49e8-4c80-a3da-8db329ef98b7.png#align=left&amp;display=inline&amp;height=354&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=541&amp;originWidth=673&amp;size=62784&amp;status=done&amp;style=none&amp;width=440" alt="image.png" /><br />为了保证安全，一个进程不能直接访问另 一个进程的地址空间。 但是进程之间的信息交换又是必须实现的。 为了保证进程间的安全通信，操作系统提供了一些方法：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599218788636-41f507e4-c2f4-4007-89a8-fa3e34b0bd28.png#align=left&amp;display=inline&amp;height=144&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=217&amp;originWidth=535&amp;size=33531&amp;status=done&amp;style=none&amp;width=355" alt="image.png" /><br /><a name="LzHFY"></a></p><h2 id="共享存储"><a class="markdownIt-Anchor" href="#共享存储"></a> 共享存储</h2><p>两个进程对共享空间的访问必须是互斥的（互斥访问通过操作系统提供的工具实现）。操作系统只负责提供共享空间和同步互斥工具（如P、V操作）<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599219471111-c5b5aed1-b72a-4e69-add1-bf0a50b0dcdd.png#align=left&amp;display=inline&amp;height=325&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=551&amp;originWidth=1003&amp;size=58901&amp;status=done&amp;style=none&amp;width=592" alt="image.png" /><br />共享存储又分为两种方式：基于数据结构共享和基于存储区共享。<br /><a name="Gh1G9"></a></p><h3 id="基于数据结构共享"><a class="markdownIt-Anchor" href="#基于数据结构共享"></a> 基于数据结构共享</h3><p>基于数据结构的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式。<br /><a name="ZRsu1"></a></p><h3 id="基于存储区共享"><a class="markdownIt-Anchor" href="#基于存储区共享"></a> 基于存储区共享</h3><p>基于存储区的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制， 而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。<br /><a name="0I9Gx"></a></p><h2 id="管道通信"><a class="markdownIt-Anchor" href="#管道通信"></a> 管道通信</h2><p>“管道”是指用于连接读写进程的一个共享文件，又名pipe 文件。其实就是在内存中开辟 一个大小固定的缓冲区。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599219513182-075f2e89-0e2f-4b5b-b6f6-787f7719628d.png#align=left&amp;display=inline&amp;height=133&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=265&amp;originWidth=1263&amp;size=67015&amp;status=done&amp;style=none&amp;width=631.5" alt="image.png" /></p><ul><li>管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</li><li>各进程要互斥地访问管道。</li><li>数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据 取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。</li><li>如果没写满，就不允许读。如果没读空，就不允许写。</li><li>数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。<br /><a name="SKVZN"></a></li></ul><h2 id="消息传递"><a class="markdownIt-Anchor" href="#消息传递"></a> 消息传递</h2><p>进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。<br />下图是消息的格式：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599219672069-46e2119d-9f46-4b0b-b492-c700f4cb80c3.png#align=left&amp;display=inline&amp;height=144&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=251&amp;originWidth=717&amp;size=83157&amp;status=done&amp;style=none&amp;width=410" alt="image.png" /><br />消息传递分为直接通信方式和间接通信方式。<br /><a name="0ZMxi"></a></p><h3 id="直接通信方式"><a class="markdownIt-Anchor" href="#直接通信方式"></a> 直接通信方式</h3><p>消息直接挂到接收进程的消息缓冲队列上。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599219681993-27f0af3e-fc3a-4e83-a979-9ead63b616dc.png#align=left&amp;display=inline&amp;height=241&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=332&amp;originWidth=462&amp;size=40844&amp;status=done&amp;style=none&amp;width=336" alt="image.png" /><br /><a name="G9PFn"></a></p><h3 id="间接通信方式"><a class="markdownIt-Anchor" href="#间接通信方式"></a> 间接通信方式</h3><p>消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”。Eg：计网中的电子邮件系统。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599219707180-158219f2-9bbf-4bb8-a98b-5876297af0fd.png#align=left&amp;display=inline&amp;height=163&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=276&amp;originWidth=726&amp;size=42361&amp;status=done&amp;style=none&amp;width=428" alt="image.png" /><br /><a name="5hlOU"></a></p><h1 id="线程的概念和特点"><a class="markdownIt-Anchor" href="#线程的概念和特点"></a> 线程的概念和特点</h1><p>进程是程序的一次执行。这些功能显然需要用不同的几段程序才能实现，并且这几段程序还要并发运行。<br />比如下述有三个进程来实现三个功能：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599219852120-ae449e3f-52b3-4d7b-a0cf-c893a5a24979.png#align=left&amp;display=inline&amp;height=115&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=181&amp;originWidth=885&amp;size=41811&amp;status=done&amp;style=none&amp;width=562" alt="image.png" /><br />其内部如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599220036923-d1d69cc0-25f9-493c-a5eb-1dda82ee8542.png#align=left&amp;display=inline&amp;height=333&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=546&amp;originWidth=954&amp;size=150933&amp;status=done&amp;style=none&amp;width=582" alt="image.png" /><br />当切换进程时，需要保存/恢复进程运行环境， 还需要切换内存地址空间（更新快表、更新缓存）开销很大。<br /><a name="ylS7g"></a></p><h2 id="线程的引出"><a class="markdownIt-Anchor" href="#线程的引出"></a> 线程的引出</h2><p>有的进程可能需要“同时”做很多事，而传统 的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599220194317-60601251-4438-4cc3-8a17-1e9e5c72a9ab.png#align=left&amp;display=inline&amp;height=357&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=591&amp;originWidth=1016&amp;size=189134&amp;status=done&amp;style=none&amp;width=614" alt="image.png" /><br />引入线程后，进程是资源分配的基本单位。而线程几乎不拥有资源，只拥有极少量的资源 （线程控制块TCB、寄存器信息、堆栈等）<br /><a name="o2Cs8"></a></p><h3 id="线程的特性和优点"><a class="markdownIt-Anchor" href="#线程的特性和优点"></a> 线程的特性和优点</h3><p>进程间并发，开销很大<br />线程间并发，开销更小<br />引入线程机制后，并发带来的系统开销降低，系统并发性提升 <br />注意：从属于不同进程的线程间切换，也会导致进程的切换，开销也大。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599220333044-ae118df9-de0c-4b64-b58f-d179fefd6527.png#align=left&amp;display=inline&amp;height=285&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=569&amp;originWidth=1178&amp;size=230936&amp;status=done&amp;style=none&amp;width=589" alt="image.png" /><br /><a name="61huc"></a></p><h2 id="什么是线程"><a class="markdownIt-Anchor" href="#什么是线程"></a> 什么是线程</h2><p>可以把线程理解为“轻量级进程”。 线程是一个基本的CPU执行单元， 也是程序执行流的最小单位。引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配 给进程的）。 线程则作为处理机的分配单元。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599220500105-74cc7e8c-9e0f-4c0b-809f-50fd3791c7df.png#align=left&amp;display=inline&amp;height=443&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=597&amp;originWidth=715&amp;size=135240&amp;status=done&amp;style=none&amp;width=531" alt="image.png" /><br /><a name="dmIpR"></a></p><h2 id="线程的实现方式"><a class="markdownIt-Anchor" href="#线程的实现方式"></a> 线程的实现方式</h2><p><a name="0fGPI"></a></p><h3 id="用户级线程user-level-thread-ult"><a class="markdownIt-Anchor" href="#用户级线程user-level-thread-ult"></a> 用户级线程（User-Level Thread, ULT）</h3><p>历史背景：早期的操作系统（如：早期Unix）只支持进程，不支持线程。当时的“线程”是由线程库实现的。<br />用户级线程由应用程序通过线程库实现。 所有的线程管理工作都由应用程序负责（包括线程切换）用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。 在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用户级线程对用户不透明，对操作系统透明） 可以这样理解，“用户级线程”就是“从用户视角看能看到的线程”。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599220570573-92d55ef6-369e-4dde-a1dd-0b84e65cdff2.png#align=left&amp;display=inline&amp;height=318&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=452&amp;originWidth=583&amp;size=45155&amp;status=done&amp;style=none&amp;width=410" alt="image.png" /><br />优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高 <br />缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。<br /><a name="2SZBv"></a></p><h3 id="内核级线程kernel-level-thread-klt-又称内核支持的线程"><a class="markdownIt-Anchor" href="#内核级线程kernel-level-thread-klt-又称内核支持的线程"></a> 内核级线程（Kernel-Level Thread, KLT, 又称“内核支持的线程”）</h3><p>内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。可以这样理解，“内核级线程”就是“从操作系统内核视角看能看到的线程”。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599220616504-8cb14264-80b1-4899-8fa7-5731601fdf5e.png#align=left&amp;display=inline&amp;height=389&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=515&amp;originWidth=536&amp;size=62126&amp;status=done&amp;style=none&amp;width=405" alt="image.png" /><br />优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。 <br />缺点：一个用户进程会占用多个内核级线程， 线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。<br /><a name="WsFnX"></a></p><h3 id="组合使用"><a class="markdownIt-Anchor" href="#组合使用"></a> 组合使用</h3><p>在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将n个用户级线程映射到m 个内核级线程上（ n &gt;= m）<br />操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。 <br />例如：下图这个模型中，该进程 由两个内核级线程，三个用户级线程，在用户看来，这个进程中有三个线程。但即使该进程在一 个4核处理机的计算机上运行，也 最多只能被分配到两个核，最多 只能有两个用户线程并行执行。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599220697082-db115fd8-b05c-4376-b8cf-7caa3ad96b0d.png#align=left&amp;display=inline&amp;height=420&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=477&amp;originWidth=509&amp;size=64885&amp;status=done&amp;style=none&amp;width=448" alt="image.png" /><br /><a name="pgXNI"></a></p><h3 id="多线程模型"><a class="markdownIt-Anchor" href="#多线程模型"></a> 多线程模型</h3><p>在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引 出了“多线程模型”问题。<br /><a name="k4e56"></a></p><h4 id="一对一模型"><a class="markdownIt-Anchor" href="#一对一模型"></a> 一对一模型</h4><p>一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599220901945-58ef57b1-88aa-4791-b798-e8e59988d990.png#align=left&amp;display=inline&amp;height=312&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=443&amp;originWidth=503&amp;size=57797&amp;status=done&amp;style=none&amp;width=354" alt="image.png" /><br />优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核 处理机上并行执行。 <br />缺点：一个用户进程会占用多个内核级线程， 线程切换由操作系统内核完成，需要切换到 核心态，因此线程管理的成本高，开销大。<br /><a name="sNeMC"></a></p><h4 id="多对一模型"><a class="markdownIt-Anchor" href="#多对一模型"></a> 多对一模型</h4><p>多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。 <br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599220815877-5d10f90f-dca0-4e5b-9a25-d8966f2aa988.png#align=left&amp;display=inline&amp;height=326&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=442&amp;originWidth=492&amp;size=49131&amp;status=done&amp;style=none&amp;width=363" alt="image.png" /><br />优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高 <br />缺点：当一个用户级线程被阻塞后，整个进 程都会被阻塞，并发度不高。多个线程不可 在多核处理机上并行运行<br /><a name="ZFIg7"></a></p><h4 id="多对多模型"><a class="markdownIt-Anchor" href="#多对多模型"></a> 多对多模型</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599220978986-d9a2675b-81db-48ab-a7cf-2e71dc8b7f25.png#align=left&amp;display=inline&amp;height=349&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=456&amp;originWidth=492&amp;size=61608&amp;status=done&amp;style=none&amp;width=377" alt="image.png" /><br />n 用户及线程映射到 m 个内核级线程（n &gt;= m）。每个用户进程对应 m 个 内核级线程。 克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统知识架构</title>
      <link href="/posts/operating_system_menu/"/>
      <url>/posts/operating_system_menu/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统知识架构"><a class="markdownIt-Anchor" href="#操作系统知识架构"></a> 操作系统知识架构</h1><p><a name="mFKlG"></a></p><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>没有任何软件支持的计算机成为裸机。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器。<br />通常把覆盖了软件的机器称为扩充机器，又称之为虚拟机。<br />计算机层次系统结构如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599131411000-7999c6a8-518a-406e-8971-8b9d011d1de3.png#align=left&amp;display=inline&amp;height=266&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=337&amp;originWidth=768&amp;size=81369&amp;status=done&amp;style=none&amp;width=606" alt="image.png" /><br /><a name="LVXiU"></a></p><h2 id="什么是操作系统"><a class="markdownIt-Anchor" href="#什么是操作系统"></a> 什么是操作系统</h2><p>操作系统（Operating System，OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。<br />如下图是操作系统提供最直观查看系统状态的界面：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599132523924-6ec283d0-8524-4792-a8cc-b8daaecf6a28.png#align=left&amp;display=inline&amp;height=209&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=417&amp;originWidth=1083&amp;size=76371&amp;status=done&amp;style=none&amp;width=541.5" alt="image.png" /><br />凸显出下述结构：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599132542874-7c95821e-7462-4d7c-a56e-5cf320267610.png#align=left&amp;display=inline&amp;height=265&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=311&amp;originWidth=334&amp;size=35165&amp;status=done&amp;style=none&amp;width=285" alt="image.png" /><br /><a name="svFXr"></a></p><h2 id="应用执行流程"><a class="markdownIt-Anchor" href="#应用执行流程"></a> 应用执行流程</h2><p>注意：执行一个程序前需要将该程序放到内存中，才能被CPU处理。<br />以QQ为例，我们日常启动的都是QQ的链接（快捷方式），对应启动的是其对应安装目录下的QQ.exe。</p><ul><li>在启动的过程中，需要把关键数据放入内存。</li><li>正常运行的时候，其对应的进程被处理器（CPU）处理。</li><li>再开始视频通话时，将摄像头设备分配给进程然后给CPU处理。<br /><a name="mGMet"></a></li></ul><h2 id="操作系统思想"><a class="markdownIt-Anchor" href="#操作系统思想"></a> 操作系统思想</h2><p>操作系统把一些复杂的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599134817856-c34446b9-bc75-4109-b650-9e3f77ff4150.png#align=left&amp;display=inline&amp;height=314&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=628&amp;originWidth=1522&amp;size=178929&amp;status=done&amp;style=none&amp;width=761" alt="image.png" /><br /><a name="1Dhwq"></a></p><h3 id="gui"><a class="markdownIt-Anchor" href="#gui"></a> GUI</h3><p>GUI即图形化用户接口（Graphical User Interface） 用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。 例子：在 Windows 操作系统中，删除一个文件只需要把文件“拖拽”到回收站即可。<br /><a name="zTriI"></a></p><h3 id="程序接口"><a class="markdownIt-Anchor" href="#程序接口"></a> 程序接口</h3><p>可以在程序中进行系统调用来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599134746278-e52a7609-5351-4d6f-86a6-acd6bf539146.png#align=left&amp;display=inline&amp;height=266&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=532&amp;originWidth=1279&amp;size=174416&amp;status=done&amp;style=none&amp;width=639.5" alt="image.png" /><br /><a name="IXxO7"></a></p><h3 id="联机命令接口"><a class="markdownIt-Anchor" href="#联机命令接口"></a> 联机命令接口</h3><p>联机命令接口实例（Windows系统） 联机命令接口=交互式命令接口，其特点是用户说一句， 系统跟着做一句。<br /><a name="5sA0P"></a></p><h3 id="脱机命令接口"><a class="markdownIt-Anchor" href="#脱机命令接口"></a> 脱机命令接口</h3><p>脱机命令接口实例（Windows系统） 脱机命令接口=批处理命令接口。以windows为例使用windows系统的搜索功能，搜索C盘中的 *.bat文件，用记事本任意打开一个，如下图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599134583288-e51711b4-2b4b-4f74-9119-5d712909ad59.png#align=left&amp;display=inline&amp;height=232&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=341&amp;originWidth=738&amp;size=137660&amp;status=done&amp;style=none&amp;width=502" alt="image.png" /><br />其特点是：用户说一堆， 系统跟着做一堆。<br /><a name="Ohf15"></a></p><h1 id="操作系统的四个特征"><a class="markdownIt-Anchor" href="#操作系统的四个特征"></a> 操作系统的四个特征</h1><p>操作系统的四个特征如下图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599143509856-bcec4f28-7b7f-41d1-8baa-091932bea30b.png#align=left&amp;display=inline&amp;height=197&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=395&amp;originWidth=1228&amp;size=96440&amp;status=done&amp;style=none&amp;width=614" alt="image.png" /><br /><a name="DckcY"></a></p><h2 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h2><p>指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。 （并行：指两个或多个事件在同一时刻同时发生）<br />操作系统的并发性指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。 操作系统就是伴随着“多道程序技术”而出现的。因此，操作系统和程序并发是一起诞生的。<br /><a name="305aQ"></a></p><h2 id="共享"><a class="markdownIt-Anchor" href="#共享"></a> 共享</h2><p>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。<br /><a name="Jk5N8"></a></p><h3 id="两种资源共享方式"><a class="markdownIt-Anchor" href="#两种资源共享方式"></a> 两种资源共享方式</h3><p>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）。<br /><a name="3gkU8"></a></p><h4 id="互斥共享方式"><a class="markdownIt-Anchor" href="#互斥共享方式"></a> 互斥共享方式</h4><p>系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允 许一个进程访问该资源<br />举例：<br />使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。<br /><a name="Lf98S"></a></p><h4 id="同时共享方式"><a class="markdownIt-Anchor" href="#同时共享方式"></a> 同时共享方式</h4><p>系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问。<br />举例：<br />使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。<br /><a name="HTWgk"></a></p><h2 id="并发和共享的关系"><a class="markdownIt-Anchor" href="#并发和共享的关系"></a> 并发和共享的关系</h2><p>并发性指计算机系统中同时存在着多个运行着的程序。<br />共享性是指系统中的资源可供内存中多个并发执行的进程共同使用。<br />通过上述例子来看并发与共享的关系： <br />使用QQ发送文件A，同时使用微信发送文件B。</p><ul><li>两个进程正在并发执行（并发性）</li><li>需要共享地访问硬盘资源（共享性）<br /><a name="kBGGc"></a></li></ul><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>如果失去并发性，则系统中只有一个 程序正在运行，则共享性失去存在的意义。<br />如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发 送文件，也就无法并发。<br />因此，并发性和共享性互为表里，密不可分。<br /><a name="EG3qc"></a></p><h2 id="虚拟"><a class="markdownIt-Anchor" href="#虚拟"></a> 虚拟</h2><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。<br /><a name="7ufr0"></a></p><h3 id="虚拟技术"><a class="markdownIt-Anchor" href="#虚拟技术"></a> 虚拟技术</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599145651315-d85a309c-275c-4e77-9915-cabaadd67373.png#align=left&amp;display=inline&amp;height=90&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=116&amp;originWidth=617&amp;size=45680&amp;status=done&amp;style=none&amp;width=480" alt="image.png" /><br />知识背景：一个程序需要放入内存并给它分配CPU才能执行。<br />虚拟技术中的“时分复用技术”。微观上处理机在各个微小的时间段内交替着为各个进程服务。因此我们即使有单核CPU也可以在计算机中同时开启多个软件，好像有多个CPU为我们工作一样。<br />因为虚拟技术中的“空分复用技术”，因此我们可以在系统中打开多个软件即使软件的内存和远远大于我们的计算机内存。<br />显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，没有并发性，就谈不上虚拟性<br /><a name="XwxrR"></a></p><h2 id="异步"><a class="markdownIt-Anchor" href="#异步"></a> 异步</h2><p>异步是指在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的， 而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。<br />如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性。<br /><a name="dMcco"></a></p><h1 id="发展与分类"><a class="markdownIt-Anchor" href="#发展与分类"></a> 发展与分类</h1><p>OS的发展分类如下图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599177929314-7f509fc1-c15d-49df-9d01-610616a65b9f.png#align=left&amp;display=inline&amp;height=280&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=459&amp;originWidth=939&amp;size=124782&amp;status=done&amp;style=none&amp;width=573" alt="image.png" /><br /><a name="9gPDT"></a></p><h2 id="手工操作阶段"><a class="markdownIt-Anchor" href="#手工操作阶段"></a> 手工操作阶段</h2><p>该阶段流程是人工打卡带，将卡带插入计算机，然后计算机读卡带并输出卡带，然后人工分析卡带，这就是知名的图灵机。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599178069989-9d4b109d-bccb-4b39-bf86-3062583cb3b2.png#align=left&amp;display=inline&amp;height=227&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=392&amp;originWidth=1239&amp;size=74257&amp;status=done&amp;style=none&amp;width=719" alt="image.png" /><br /><a name="QDwOP"></a></p><h2 id="单道批处理系统"><a class="markdownIt-Anchor" href="#单道批处理系统"></a> 单道批处理系统</h2><p>该阶段引入脱机输入/输出技术（用外围机+磁带完成），并由监督程序负责控制作业的输入、输出。通过外围机把程序提前存到磁带里，磁带的读/写速度比纸带机快很多，这样缓解了一定 程度的人机速度矛盾， 资源利用率有所提升。<br />但是内存中仅能有一道程序运行，只有 该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待I/O完成。资源利用率依然很低。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599178305773-212592c0-498d-4052-91b3-98f5a6405147.png#align=left&amp;display=inline&amp;height=203&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=353&amp;originWidth=1213&amp;size=48569&amp;status=done&amp;style=none&amp;width=696" alt="image.png" /><br /><a name="FkayP"></a></p><h2 id="多道批处理系统"><a class="markdownIt-Anchor" href="#多道批处理系统"></a> 多道批处理系统</h2><p>该阶段每次往内存中读入多道程序，操作系统正式诞生，用于支持多道程序并发运行。该阶段多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。但是用户响应时间长，没有人机交互功能（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。eg：无法调试程序/无法在程序运行过 程中输入一些参数）<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599178429555-e3e3c9f6-00f3-4053-be89-6b6f387e6f76.png#align=left&amp;display=inline&amp;height=363&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=363&amp;originWidth=621&amp;size=36333&amp;status=done&amp;style=none&amp;width=621" alt="image.png" /><br /><a name="rCREH"></a></p><h2 id="分时操作系统"><a class="markdownIt-Anchor" href="#分时操作系统"></a> 分时操作系统</h2><p>计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。 <br />主要优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。但是不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/ 作业服务一个时间片，不区分任务的紧急性。<br /><a name="1tECG"></a></p><h2 id="实时操作系统"><a class="markdownIt-Anchor" href="#实时操作系统"></a> 实时操作系统</h2><p>实时系统又分为硬实时操作系统和软实时操作系统。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599178560715-4eefb349-f77b-4f1f-9313-363dd5a3a58f.png#align=left&amp;display=inline&amp;height=242&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=372&amp;originWidth=1014&amp;size=92212&amp;status=done&amp;style=none&amp;width=659" alt="image.png" /><br />主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性。<br /><a name="zJJWd"></a></p><h2 id="其他操作系统"><a class="markdownIt-Anchor" href="#其他操作系统"></a> 其他操作系统</h2><ul><li>网络操作系统：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。（如：Windows NT 就是 一种典型的网络操作系统，网站服务器就可以使用）</li><li>分布式操作系统：主要特点是分布性和并行性。系统中的各台计算机地位相同，任何工作都可以分布在这些 计算机上，由它们并行、协同完成这个任务。</li><li>个人计算机操作系统：如 Windows XP、MacOS，方便个人使用。<br /><a name="vegnO"></a></li></ul><h1 id="操作系统的运行机制与体系结构"><a class="markdownIt-Anchor" href="#操作系统的运行机制与体系结构"></a> 操作系统的运行机制与体系结构</h1><p>操作系统的运行机制与体系结构核心内容如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599180272445-3062ffce-6580-43fd-ad55-4b708b49043d.png#align=left&amp;display=inline&amp;height=498&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=597&amp;originWidth=956&amp;size=119836&amp;status=done&amp;style=none&amp;width=798" alt="image.png" /><br /><a name="tvybB"></a></p><h2 id="什么是指令"><a class="markdownIt-Anchor" href="#什么是指令"></a> 什么是指令</h2><p>由于机器的语言的可读性很差，因此为了增强可读性，人们使用助记符的方式表示各个指令（汇编语言），例如第一条数据转移指令可记为MOV AX,[4FH]，第二条加法指令可记为ADD AX,1。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599179036328-9f9145d5-7a99-4a16-a768-b2782dc8933c.png#align=left&amp;display=inline&amp;height=277&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=417&amp;originWidth=1014&amp;size=106969&amp;status=done&amp;style=none&amp;width=673" alt="image.png" /><br />指令就是CPU（处理器）能识别的最基本的命令，比如让CPU执行加减法。<br /><a name="EaJ4m"></a></p><h2 id="运行机制"><a class="markdownIt-Anchor" href="#运行机制"></a> 运行机制</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599179746467-1c093286-25b3-44f6-bbab-77f693b2ca7a.png#align=left&amp;display=inline&amp;height=236&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=293&amp;originWidth=714&amp;size=61618&amp;status=done&amp;style=none&amp;width=574" alt="image.png" /><br /><a name="JOssX"></a></p><h3 id="两种指令"><a class="markdownIt-Anchor" href="#两种指令"></a> 两种指令</h3><p>指令拥有以下两种指令：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599178837730-f09770d0-bf9f-4cb5-92df-5110c46a37cb.png#align=left&amp;display=inline&amp;height=161&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=196&amp;originWidth=709&amp;size=38232&amp;status=done&amp;style=none&amp;width=581" alt="image.png" /><br />非特权指令是“人畜无害”的，用户程序可以随意使用，而非特权指令会十分危险，因此不会允许用户程序使用。<br /><a name="W5Nv8"></a></p><h3 id="两种处理器状态"><a class="markdownIt-Anchor" href="#两种处理器状态"></a> 两种处理器状态</h3><p>处理器拥有两种状态，一个是用户态（目态），另一个是核心态（管态）。<br />用程序状态字寄存器（PSW）中的某标志位来表示当前处理器处于什么状态，如0为用户态，1为核心态。<br />用户态只能执行非特权指令，核心态既可以执行非特权指令也可以执行特权指令。<br /><a name="PK940"></a></p><h3 id="两种程序"><a class="markdownIt-Anchor" href="#两种程序"></a> 两种程序</h3><p>操作系统中的程序分为两种程序，一种是内核程序，另一种是普通的应用程序。<br />操作系统中的内核程序是系统的管理者，既可以执行特权指令也可以执行非特权指令运行在核心态。<br />为了保证系统能安全地运行，普通应用程序只能执行非特权指令运行在用户态。<br /><a name="faW7K"></a></p><h2 id="操作系统内核"><a class="markdownIt-Anchor" href="#操作系统内核"></a> 操作系统内核</h2><p>系统的内核结构如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599179852278-b60e4f41-e18f-463a-a717-7487b5e990e5.png#align=left&amp;display=inline&amp;height=309&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=509&amp;originWidth=1458&amp;size=152816&amp;status=done&amp;style=none&amp;width=886" alt="image.png" /><br />内核使计算机上配置的底层软件，是操作系统最基本最核心的部分，实现操作系统内核功能的程序就是内核程序。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599179975201-1caf364d-714a-47af-88ef-a0e80095eba4.png#align=left&amp;display=inline&amp;height=283&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=383&amp;originWidth=935&amp;size=170337&amp;status=done&amp;style=none&amp;width=691" alt="image.png" /><br />因为对系统资源管理的功能有时候不会被划分为内核功能，因此我们可以再次划分内核为大内核和微内核：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599180061039-ee192300-0023-4b1a-912b-9055f76bd953.png#align=left&amp;display=inline&amp;height=385&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=524&amp;originWidth=895&amp;size=97781&amp;status=done&amp;style=none&amp;width=658" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599180098785-294463d5-246d-4353-b886-f35eb471cde9.png#align=left&amp;display=inline&amp;height=229&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=301&amp;originWidth=1095&amp;size=149354&amp;status=done&amp;style=none&amp;width=832" alt="image.png" /><br /><br /><br /></p><p><a name="3D4Ij"></a></p><h1 id="中断和异常"><a class="markdownIt-Anchor" href="#中断和异常"></a> 中断和异常</h1><p>中断和异常的知识体系如下图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599180219559-33b71d2c-2283-48e7-9d8c-cb5955f3f909.png#align=left&amp;display=inline&amp;height=147&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=293&amp;originWidth=878&amp;size=45295&amp;status=done&amp;style=none&amp;width=439" alt="image.png" /><br /><a name="jPROF"></a></p><h2 id="中断的作用"><a class="markdownIt-Anchor" href="#中断的作用"></a> 中断的作用</h2><p>CPU 上会运行两种程序，一种是操作系统内核程序，一种是应用程序，在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序，“中断”是让操作系统内核夺回CPU使用权的唯一途径。“中断”会使CPU由用户态变为内核态，使操作系统重新夺回对CPU的控制权。<br />如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序。<br /><a name="9GEuQ"></a></p><h2 id="中断的类型"><a class="markdownIt-Anchor" href="#中断的类型"></a> 中断的类型</h2><p>中断分为内中断和外中断：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599181099478-eece4f77-2e81-4c4a-a1fc-41dd6aa898da.png#align=left&amp;display=inline&amp;height=368&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=434&amp;originWidth=965&amp;size=202795&amp;status=done&amp;style=none&amp;width=818" alt="image.png" /><br /><a name="u2FrS"></a></p><h3 id="内中断"><a class="markdownIt-Anchor" href="#内中断"></a> 内中断</h3><p>与当前执行的指令有关， 中断信号来源于CPU内部。<br />若当前执行的指令是非法的，则会引发一个中断信号，比如：试图在用户态下执行特权指令、执行除法指令时发现除数为 0、有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令——陷入指令，该指令会引发一个内部中断信号。<br /><a name="Lr0gI"></a></p><h3 id="外中断"><a class="markdownIt-Anchor" href="#外中断"></a> 外中断</h3><p>与当前执行的指令无关， 中断信号来源于CPU外部。每一条指令执行结束 时，CPU都会例行检查 是否有外中断信号。<br /><a name="sKHsO"></a></p><h4 id="io中断"><a class="markdownIt-Anchor" href="#io中断"></a> IO中断</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599181010137-f1b74a79-8a97-4815-80d6-ed169e038972.png#align=left&amp;display=inline&amp;height=388&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=390&amp;originWidth=553&amp;size=143255&amp;status=done&amp;style=none&amp;width=550" alt="image.png" /><br /><a name="kSTT9"></a></p><h4 id="时钟中断"><a class="markdownIt-Anchor" href="#时钟中断"></a> 时钟中断</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599181072456-d6d48ecd-b445-4da5-8670-2bce668620cb.png#align=left&amp;display=inline&amp;height=343&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=423&amp;originWidth=533&amp;size=66688&amp;status=done&amp;style=none&amp;width=432" alt="image.png" /><br /><a name="51sgb"></a></p><h2 id="中断的原理"><a class="markdownIt-Anchor" href="#中断的原理"></a> 中断的原理</h2><p>不同的中断信号，需要用不同的中断处理程序来处理。当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599181189469-669b8f71-c98d-459e-a414-561940adef42.png#align=left&amp;display=inline&amp;height=315&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=364&amp;originWidth=788&amp;size=75291&amp;status=done&amp;style=none&amp;width=682" alt="image.png" /><br />中断包含两个方向：核心态到用户态、用户态到核心态。<br />内核态–&gt;用户态：执行一条特权指令——修改PSW的标志位为“用户态”，这个动作意味着操作系统 将主动让出CPU使用权 <br />用户态–&gt;内核态：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权<br /><a name="mp9Il"></a></p><h1 id="系统调用"><a class="markdownIt-Anchor" href="#系统调用"></a> 系统调用</h1><p>由操作系统内核对共享资源进行统一的管理，并向上提供 “系统调用” ，用户进程想要使用打印机这种共享资源，只能通过系统 调用向操作系统内核发出请求。内核会对各个请求进行协调处理。<br /><a name="D0ycv"></a></p><h2 id="什么是系统调用"><a class="markdownIt-Anchor" href="#什么是系统调用"></a> 什么是系统调用</h2><p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599181298661-2a91e7da-f11b-4b01-8081-b93a4ef5d6a2.png#align=left&amp;display=inline&amp;height=234&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=327&amp;originWidth=1167&amp;size=83358&amp;status=done&amp;style=none&amp;width=834" alt="image.png" /><br />“系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务。<br /><a name="WG6Up"></a></p><h2 id="系统调用与库函数的区别"><a class="markdownIt-Anchor" href="#系统调用与库函数的区别"></a> 系统调用与库函数的区别</h2><p>主要区别如下图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599181359923-1d46ee23-feeb-4f8b-94ca-d3eed6029cdc.png#align=left&amp;display=inline&amp;height=374&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=488&amp;originWidth=550&amp;size=33165&amp;status=done&amp;style=none&amp;width=422" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599181375726-de856762-07eb-4c29-9dd9-862e065d82d1.png#align=left&amp;display=inline&amp;height=192&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=272&amp;originWidth=637&amp;size=112750&amp;status=done&amp;style=none&amp;width=449" alt="image.png" /><br /><a name="2etOp"></a></p><h2 id="什么功能要用到系统调用"><a class="markdownIt-Anchor" href="#什么功能要用到系统调用"></a> 什么功能要用到系统调用</h2><p>应用程序通过系统调用请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此凡是 与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599181464326-3f4c79fc-9903-4aff-a13c-6263160ab9a5.png#align=left&amp;display=inline&amp;height=197&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=325&amp;originWidth=1131&amp;size=167097&amp;status=done&amp;style=none&amp;width=687" alt="image.png" /><br /><a name="y571l"></a></p><h2 id="系统调用的过程"><a class="markdownIt-Anchor" href="#系统调用的过程"></a> 系统调用的过程</h2><p>传递系统调用参数–&gt;执行陷入指令（用户态）—&gt;执行相应的内请求核程序处理系统调用（核心态）–&gt; 返回应用程序 。<br />注意：</p><ul><li>陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态</li><li>发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599181597986-48a4b5fe-4cc4-4de5-95c9-145b1add9592.png#align=left&amp;display=inline&amp;height=273&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=476&amp;originWidth=1162&amp;size=208167&amp;status=done&amp;style=none&amp;width=667" alt="image.png" /><br /><a name="JnVgt"></a></p><h1 id="操作系统的体系结构"><a class="markdownIt-Anchor" href="#操作系统的体系结构"></a> 操作系统的体系结构</h1><p>前面有提及过操作系统的体系内核结构分为大内核和微内核：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599181723949-7f7bc9d5-f14c-4ccb-b8a1-9c31ba4ed6c4.png#align=left&amp;display=inline&amp;height=381&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=418&amp;originWidth=924&amp;size=131867&amp;status=done&amp;style=none&amp;width=842" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599181790689-a3cd195a-6618-4595-980d-dd89551a50e0.png#align=left&amp;display=inline&amp;height=381&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=420&amp;originWidth=891&amp;size=96156&amp;status=done&amp;style=none&amp;width=809" alt="image.png" /><br />内核是操作系统最基本、最核心的部分。 实现操作系统内核功能的那些程序就是内核程序。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599181841028-98fea65c-3d80-43ff-9b92-90353aba90f0.png#align=left&amp;display=inline&amp;height=388&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=464&amp;originWidth=947&amp;size=156354&amp;status=done&amp;style=none&amp;width=792" alt="image.png" /><br /><br /><br /></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建WEB服务器（三）</title>
      <link href="/posts/io_web_3/"/>
      <url>/posts/io_web_3/</url>
      
        <content type="html"><![CDATA[<h1 id="简易的web服务器三"><a class="markdownIt-Anchor" href="#简易的web服务器三"></a> 简易的WEB服务器（三）</h1><p><a name="svRNH"></a></p><h1 id="动态资源的获取"><a class="markdownIt-Anchor" href="#动态资源的获取"></a> 动态资源的获取</h1><p>因为TimeServlet无法直接调用，所以获得相应的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> processor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> connector.ConnectorUtils;</span><br><span class="line"><span class="keyword">import</span> connector.Request;</span><br><span class="line"><span class="keyword">import</span> connector.Response;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Servlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备好URLClassLoader</span></span><br><span class="line"></span><br><span class="line">    <span class="function">URLClassLoader <span class="title">getServletLoader</span><span class="params">()</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">        File webRoot = <span class="keyword">new</span> File(ConnectorUtils.WEB_ROOT);</span><br><span class="line">        URL webRootUrl = webRoot.toURI().toURL();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;webRootUrl&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Servlet <span class="title">getServlet</span><span class="params">(URLClassLoader loader, Request request)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         /servlet/TimeServlet</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String uri = request.getRequestUri();</span><br><span class="line">        String servletName = uri.substring(uri.lastIndexOf(<span class="string">&quot;/&quot;</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Class servletClass = loader.loadClass(servletName);</span><br><span class="line">        Servlet servlet = (Servlet) servletClass.getDeclaredConstructor().newInstance();</span><br><span class="line">        <span class="keyword">return</span> servlet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URLClassLoader loader = getServletLoader();</span><br><span class="line">            Servlet servlet = getServlet(loader, request);</span><br><span class="line">            servlet.service(request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="TgJKr"></a></p><h1 id="测试servletprocessor"><a class="markdownIt-Anchor" href="#测试servletprocessor"></a> 测试ServletProcessor</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> processor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> connector.Request;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assertions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> test.util.TestUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Servlet;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: hszjj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/11/26 15:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletProcessorTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVLET_REQUEST=<span class="string">&quot;GET /servlet/TimeServlet HTTP/1.1&quot;</span>;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenServletRequest_thenLoadServlet</span><span class="params">()</span> <span class="keyword">throws</span> MalformedURLException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        Request request= TestUtils.createRequest(SERVLET_REQUEST);</span><br><span class="line">        ServletProcessor processor=<span class="keyword">new</span> ServletProcessor();</span><br><span class="line">        URLClassLoader loader=processor.getServletLoader();</span><br><span class="line">        Servlet servlet=processor.getServlet(loader,request);</span><br><span class="line"></span><br><span class="line">        Assertions.assertEquals(<span class="string">&quot;webroot.TimeServlet&quot;</span>,servlet.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="NfPXh"></a></p><h1 id="使用facade模式"><a class="markdownIt-Anchor" href="#使用facade模式"></a> 使用facade模式</h1><p>示例中这个代码明显出现问题，既涉及到服务器的开发也涉及到Servlet的开发，现实中这两个开发应属于不同群体。所以我们要保证服务器的开发不会被Servlet的人员过分利用，例如如下情况：<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574847588642-93711a4f-1345-44f3-ab4b-495fe1178120.png#align=left&amp;display=inline&amp;height=511&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=511&amp;originWidth=1341&amp;size=84670&amp;status=done&amp;style=none&amp;width=1341" alt="image.png" /><br />这种情况很危险，Servlet的人员可以肆意调用函数。<br />为了防止这种问题发生，我们需要应用Facade模式。<br />首先需要写如下两个函数<br /><a name="XBpuC"></a></p><h2 id="responsefacade"><a class="markdownIt-Anchor" href="#responsefacade"></a> ResponseFacade</h2><p>把ServletResponse放置在ResponseFacade中就可以有效防止这种非法转型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> connector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletOutputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseFacade</span> <span class="keyword">implements</span> <span class="title">ServletResponse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServletResponse response = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseFacade</span><span class="params">(Response response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.response = response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCharacterEncoding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> response.getCharacterEncoding();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> response.getContentType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletOutputStream <span class="title">getOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> response.getOutputStream();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PrintWriter <span class="title">getWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> response.getWriter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCharacterEncoding</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        response.setCharacterEncoding(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentLength</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        response.setContentLength(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentLengthLong</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">        response.setContentLengthLong(l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentType</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        response.setContentType(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBufferSize</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        response.setBufferSize(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBufferSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> response.getBufferSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        response.flushBuffer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resetBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        response.resetBuffer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCommitted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> response.isCommitted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        response.reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocale</span><span class="params">(Locale locale)</span> </span>&#123;</span><br><span class="line">        response.setLocale(locale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Locale <span class="title">getLocale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> response.getLocale();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="56LSk"></a></p><h2 id="requestfacade"><a class="markdownIt-Anchor" href="#requestfacade"></a> RequestFacade</h2><p>同理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> connector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestFacade</span> <span class="keyword">implements</span> <span class="title">ServletRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServletRequest request = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestFacade</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getAttribute</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getAttribute(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getAttributeNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getAttributeNames();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCharacterEncoding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getCharacterEncoding();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCharacterEncoding</span><span class="params">(String s)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        request.setCharacterEncoding(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getContentLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getContentLength();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getContentLengthLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getContentLengthLong();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getContentType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletInputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getInputStream();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getParameter(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getParameterNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getParameterNames();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getParameterValues(String s) &#123;</span><br><span class="line">        <span class="keyword">return</span> request.getParameterValues(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String[]&gt; getParameterMap() &#123;</span><br><span class="line">        <span class="keyword">return</span> request.getParameterMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getProtocol();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getScheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getScheme();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServerName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getServerName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getServerPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getServerPort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BufferedReader <span class="title">getReader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getReader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRemoteAddr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getRemoteAddr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRemoteHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getRemoteHost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String s, Object o)</span> </span>&#123;</span><br><span class="line">        request.setAttribute(s,o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        request.removeAttribute(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Locale <span class="title">getLocale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getLocale();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;Locale&gt; <span class="title">getLocales</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getLocales();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSecure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.isSecure();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestDispatcher <span class="title">getRequestDispatcher</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getRequestDispatcher(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRealPath</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getRealPath(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRemotePort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getRemotePort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLocalName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getLocalName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLocalAddr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getLocalAddr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLocalPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getLocalPort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getServletContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AsyncContext <span class="title">startAsync</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.startAsync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AsyncContext <span class="title">startAsync</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.startAsync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAsyncStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.isAsyncStarted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAsyncSupported</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.isAsyncSupported();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AsyncContext <span class="title">getAsyncContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getAsyncContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DispatcherType <span class="title">getDispatcherType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getDispatcherType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="k0gk8"></a></p><h2 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h2><p>修改Processor代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        URLClassLoader loader = getServletLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Servlet servlet = getServlet(loader, request);</span><br><span class="line">            RequestFacade requestFacade=<span class="keyword">new</span> RequestFacade(request);</span><br><span class="line">            ResponseFacade responseFacade=<span class="keyword">new</span> ResponseFacade(response);</span><br><span class="line">            servlet.service(requestFacade, responseFacade);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a name="cgeov"></a></p><h1 id="动态资源支持的实现"><a class="markdownIt-Anchor" href="#动态资源支持的实现"></a> 动态资源支持的实现</h1><p><a name="ySlwb"></a></p><h2 id="首先修改connector的代码"><a class="markdownIt-Anchor" href="#首先修改connector的代码"></a> 首先修改Connector的代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server=<span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器已启动，监听端口【&quot;</span>+port+<span class="string">&quot;】&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                Socket socket=server.accept();</span><br><span class="line">                InputStream input=socket.getInputStream();</span><br><span class="line">                OutputStream output=socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">                Request request=<span class="keyword">new</span> Request(input);</span><br><span class="line">                request.parse();</span><br><span class="line">                Response response=<span class="keyword">new</span> Response(output);</span><br><span class="line">                response.setRequest(request);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (request.getRequestUri().startsWith(<span class="string">&quot;/servlet/&quot;</span>))&#123;</span><br><span class="line">                    ServletProcessor processor=<span class="keyword">new</span> ServletProcessor();</span><br><span class="line">                    processor.process(request,response);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    StaticProcessor processor = <span class="keyword">new</span> StaticProcessor();</span><br><span class="line">                    processor.process(request, response);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                shutDown(socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a name="XV6uT"></a></p><h2 id="更改testclient类"><a class="markdownIt-Anchor" href="#更改testclient类"></a> 更改TestClient类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: hszjj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/11/26 14:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Socket socket=<span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>,<span class="number">9999</span>);</span><br><span class="line">            OutputStream outputStream=socket.getOutputStream();</span><br><span class="line">            outputStream.write(<span class="string">&quot;GET /servlet/TimeServlet HTTP/1.1&quot;</span>.getBytes());</span><br><span class="line">            socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">            InputStream inputStream=socket.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line">            <span class="keyword">int</span> length=inputStream.read(buffer);</span><br><span class="line">            StringBuilder response=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;length;j++)&#123;</span><br><span class="line">                <span class="keyword">char</span> a=(<span class="keyword">char</span>)buffer[j];</span><br><span class="line">                response.append(a);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(response.toString());</span><br><span class="line">            socket.shutdownInput();</span><br><span class="line"></span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException i) &#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="IZeHF"></a></p><h2 id="结果显示如下"><a class="markdownIt-Anchor" href="#结果显示如下"></a> 结果显示如下：</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574853100198-f825c84b-afb6-4a24-b90b-9ac7d1f83805.png#align=left&amp;display=inline&amp;height=213&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=213&amp;originWidth=766&amp;size=38890&amp;status=done&amp;style=none&amp;width=766" alt="image.png" /><br /><a name="AML8z"></a></p><h1 id="使用nio模型重写"><a class="markdownIt-Anchor" href="#使用nio模型重写"></a> 使用NIO模型重写</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> connector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> processor.ServletProcessor;</span><br><span class="line"><span class="keyword">import</span> processor.StaticProcessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioConnector</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">9999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel server;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shutDown</span><span class="params">(Closeable... closeables)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Closeable shut : closeables) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shut != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    shut.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NioConnector</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NioConnector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = ServerSocketChannel.open();</span><br><span class="line">            server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            server.socket().bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line"></span><br><span class="line">            selector=Selector.open();</span><br><span class="line">            server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            System.out.println(<span class="string">&quot;启动服务器，监听端口[&quot;</span>+port+<span class="string">&quot;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                selector.select();</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys=selector.selectedKeys();</span><br><span class="line">                <span class="keyword">for</span> (SelectionKey key:selectionKeys)&#123;</span><br><span class="line">                    handles(key);</span><br><span class="line">                &#125;</span><br><span class="line">                selectionKeys.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            shutDown(selector,server);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handles</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//ACCEPT</span></span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class="line">            SocketChannel client = server.accept();</span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">            SocketChannel client= (SocketChannel) key.channel();</span><br><span class="line">            key.cancel();</span><br><span class="line">            client.configureBlocking(<span class="keyword">true</span>);</span><br><span class="line">            Socket clientSocket=client.socket();</span><br><span class="line">            InputStream inputStream=clientSocket.getInputStream();</span><br><span class="line">            OutputStream outputStream=clientSocket.getOutputStream();</span><br><span class="line">            </span><br><span class="line">            Request request=<span class="keyword">new</span> Request(inputStream);</span><br><span class="line">            request.parse();</span><br><span class="line">            </span><br><span class="line">            Response response=<span class="keyword">new</span> Response(outputStream);</span><br><span class="line">            response.setRequest(request);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (request.getRequestUri().startsWith(<span class="string">&quot;/servlet/&quot;</span>))&#123;</span><br><span class="line">                ServletProcessor processor=<span class="keyword">new</span> ServletProcessor();</span><br><span class="line">                processor.process(request,response);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                StaticProcessor processor=<span class="keyword">new</span> StaticProcessor();</span><br><span class="line">                processor.process(request,response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">this</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="DgD8n"></a></p><h1 id="测试重写"><a class="markdownIt-Anchor" href="#测试重写"></a> 测试重写</h1><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574854984056-cdcae5d3-ec8d-49e3-ad4c-a779874ee1a4.png#align=left&amp;display=inline&amp;height=146&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=146&amp;originWidth=494&amp;size=17247&amp;status=done&amp;style=none&amp;width=494" alt="image.png" /></p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 网络编程 </tag>
            
            <tag> io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建WEB服务器（二）</title>
      <link href="/posts/io_web_2/"/>
      <url>/posts/io_web_2/</url>
      
        <content type="html"><![CDATA[<h1 id="简易的web服务器二"><a class="markdownIt-Anchor" href="#简易的web服务器二"></a> 简易的WEB服务器（二）</h1><p><a name="dOh8q"></a></p><h1 id="实现response"><a class="markdownIt-Anchor" href="#实现response"></a> 实现Response</h1><p>对回复的抽象处理<br /><a name="zxP2S"></a></p><h2 id="实现connectorutils"><a class="markdownIt-Anchor" href="#实现connectorutils"></a> 实现ConnectorUtils</h2><p>获取资源主目录对应的路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> connector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: hszjj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/11/26 12:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectorUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEB_ROOT =</span><br><span class="line">            System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + File.separator + <span class="string">&quot;webroot&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROTOCOL = <span class="string">&quot;HTTP/1.1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CARRIAGE = <span class="string">&quot;\r&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NEWLINE = <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPACE = <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">renderStatus</span><span class="params">(HttpStatus status)</span></span>&#123;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder(PROTOCOL)</span><br><span class="line">                .append(SPACE)</span><br><span class="line">                .append(status.getStatusCode())</span><br><span class="line">                .append(SPACE)</span><br><span class="line">                .append(status.getReason())</span><br><span class="line">                .append(CARRIAGE).append(NEWLINE)</span><br><span class="line">                .append(CARRIAGE).append(NEWLINE);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="zqhBA"></a></p><h2 id="实现httpstatus"><a class="markdownIt-Anchor" href="#实现httpstatus"></a> 实现HttpStatus</h2><p>获取网络状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> connector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: hszjj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/11/26 13:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  HttpStatus &#123;</span><br><span class="line">    SC_OK(<span class="number">200</span>,<span class="string">&quot;OK&quot;</span>),</span><br><span class="line">    SC_NOT_FOUND(<span class="number">404</span>,<span class="string">&quot;File Not Found&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> statusCode;</span><br><span class="line">    <span class="keyword">private</span> String reason;</span><br><span class="line"></span><br><span class="line">    HttpStatus(<span class="keyword">int</span> Code,String reason)&#123;</span><br><span class="line">        <span class="keyword">this</span>.statusCode=Code;</span><br><span class="line">        <span class="keyword">this</span>.reason=reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStatusCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> statusCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getReason</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="GTqvG"></a></p><h2 id="实现response-2"><a class="markdownIt-Anchor" href="#实现response-2"></a> 实现Response</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> connector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:HTTP/1.1 200 OK</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: hszjj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/11/26 12:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    Request request;</span><br><span class="line">    OutputStream output;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Response</span><span class="params">(OutputStream output)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.output = output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendStaticResource</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(ConnectorUtils.WEB_ROOT, request.getRequestUri());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            write(file, HttpStatus.SC_OK);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            write(<span class="keyword">new</span> File(ConnectorUtils.WEB_ROOT, <span class="string">&quot;404.html&quot;</span>), HttpStatus.SC_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(File resource, HttpStatus status)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream input = <span class="keyword">new</span> FileInputStream(resource)) &#123;</span><br><span class="line">            output.write(ConnectorUtils.renderStatus(status).getBytes());</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">            <span class="keyword">int</span> lenth = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((lenth = input.read(buffer, <span class="number">0</span>, BUFFER_SIZE)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                output.write(buffer, <span class="number">0</span>, lenth);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="M8zhb"></a></p><h1 id="response测试"><a class="markdownIt-Anchor" href="#response测试"></a> Response测试</h1><p><a name="QbxtI"></a></p><h2 id="testutils"><a class="markdownIt-Anchor" href="#testutils"></a> TestUtils</h2><p>工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> connector.Request;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: hszjj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/11/26 13:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Request <span class="title">createRequest</span><span class="params">(String requestString)</span></span>&#123;</span><br><span class="line">        InputStream input=<span class="keyword">new</span> ByteArrayInputStream(requestString.getBytes());</span><br><span class="line">        Request request=<span class="keyword">new</span> Request(input);</span><br><span class="line">        request.parse();</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readFileToString</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(Files.readAllBytes(Paths.get(filename)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="BVPSA"></a></p><h2 id="responsetest"><a class="markdownIt-Anchor" href="#responsetest"></a> ResponseTest</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test.connector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> connector.ConnectorUtils;</span><br><span class="line"><span class="keyword">import</span> connector.Request;</span><br><span class="line"><span class="keyword">import</span> connector.Response;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assertions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> test.util.TestUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: hszjj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/11/26 13:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String VAliD_REQUEST = <span class="string">&quot;GET /index.html HTTP/1.1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String INVAliD_REQUEST = <span class="string">&quot;GET /notfound.html HTTP/1.1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String STATUS200 = <span class="string">&quot;HTTP/1.1 200 OK\r\n\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String STATUS404 = <span class="string">&quot;HTTP/1.1 404 File Not Found\r\n\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenValidRequest_thenReturnStaticResource</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = TestUtils.createRequest(VAliD_REQUEST);</span><br><span class="line">        ByteArrayOutputStream outputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        Response response = <span class="keyword">new</span> Response(outputStream);</span><br><span class="line">        response.setRequest(request);</span><br><span class="line">        response.sendStaticResource();</span><br><span class="line"></span><br><span class="line">        Assertions.assertEquals(</span><br><span class="line">                (STATUS200 + TestUtils.readFileToString(ConnectorUtils.WEB_ROOT + request.getRequestUri())),</span><br><span class="line">                outputStream.toString()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenInvalidRequest_thenReturnError</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = TestUtils.createRequest(INVAliD_REQUEST);</span><br><span class="line">        ByteArrayOutputStream outputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        Response response = <span class="keyword">new</span> Response(outputStream);</span><br><span class="line">        response.setRequest(request);</span><br><span class="line">        response.sendStaticResource();</span><br><span class="line">        String resource=TestUtils.readFileToString(ConnectorUtils.WEB_ROOT +<span class="string">&quot;/404.html&quot;</span>);</span><br><span class="line">        Assertions.assertEquals(</span><br><span class="line">                (STATUS404 + resource),</span><br><span class="line">                outputStream.toString()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="j3HTZ"></a></p><h1 id="实现connector和processor"><a class="markdownIt-Anchor" href="#实现connector和processor"></a> 实现Connector和Processor</h1><p><a name="REo91"></a></p><h2 id="processor"><a class="markdownIt-Anchor" href="#processor"></a> Processor</h2><p>处理用户发送的请求，把请求对应的Response准备好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> processor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> connector.Request;</span><br><span class="line"><span class="keyword">import</span> connector.Response;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: hszjj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/11/26 14:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Request request, Response response)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.sendStaticResource();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="SqlxX"></a></p><h2 id="connector"><a class="markdownIt-Anchor" href="#connector"></a> Connector</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> connector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> processor.ServletProcessor;</span><br><span class="line"><span class="keyword">import</span> processor.StaticProcessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Connector</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT=<span class="number">9999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocket server;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>  port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shutDown</span><span class="params">(Closeable...closeables)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Closeable shut:closeables)&#123;</span><br><span class="line">                <span class="keyword">if</span> (shut!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    shut.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Connector</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port=port;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Connector</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">this</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server=<span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器已启动，监听端口【&quot;</span>+port+<span class="string">&quot;】&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                Socket socket=server.accept();</span><br><span class="line">                InputStream input=socket.getInputStream();</span><br><span class="line">                OutputStream output=socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">                Request request=<span class="keyword">new</span> Request(input);</span><br><span class="line">                request.parse();</span><br><span class="line">                Response response=<span class="keyword">new</span> Response(output);</span><br><span class="line">                response.setRequest(request);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (request.getRequestUri().startsWith(<span class="string">&quot;/servlet/&quot;</span>))&#123;</span><br><span class="line">                    ServletProcessor processor=<span class="keyword">new</span> ServletProcessor();</span><br><span class="line">                    processor.process(request,response);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    StaticProcessor processor = <span class="keyword">new</span> StaticProcessor();</span><br><span class="line">                    processor.process(request, response);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                shutDown(socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="XLQrQ"></a></p><h2 id="服务器主函数bootstrap"><a class="markdownIt-Anchor" href="#服务器主函数bootstrap"></a> 服务器主函数Bootstrap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> connector.Connector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: hszjj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/11/26 14:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bootstrap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connector connector=<span class="keyword">new</span> Connector();</span><br><span class="line">        connector.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="K0pMg"></a></p><h1 id="测试服务器"><a class="markdownIt-Anchor" href="#测试服务器"></a> 测试服务器</h1><p><a name="4tzHN"></a></p><h2 id="启动客户端"><a class="markdownIt-Anchor" href="#启动客户端"></a> 启动客户端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: hszjj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/11/26 14:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Socket socket=<span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>,<span class="number">9999</span>);</span><br><span class="line">            OutputStream outputStream=socket.getOutputStream();</span><br><span class="line">            outputStream.write(<span class="string">&quot;GET /index.html HTTP/1.1&quot;</span>.getBytes());</span><br><span class="line">            socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">            InputStream inputStream=socket.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line">            <span class="keyword">int</span> length=inputStream.read(buffer);</span><br><span class="line">            StringBuilder response=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;length;j++)&#123;</span><br><span class="line">                response.append((<span class="keyword">char</span>)buffer[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(response.toString());</span><br><span class="line">            socket.shutdownInput();</span><br><span class="line">            </span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="kDD46"></a></p><h2 id="结果"><a class="markdownIt-Anchor" href="#结果"></a> 结果</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574750876207-63477f1e-f987-428b-89a7-afeb04f0e6b8.png#align=left&amp;display=inline&amp;height=463&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=463&amp;originWidth=867&amp;size=27388&amp;status=done&amp;style=none&amp;width=867" alt="image.png" /><br /><a name="lc3BL"></a></p><h2 id="效果查看"><a class="markdownIt-Anchor" href="#效果查看"></a> 效果查看</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574751003508-751ce4d9-4c7a-4d20-97e1-45a6dfa1d88a.png#align=left&amp;display=inline&amp;height=456&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=456&amp;originWidth=708&amp;size=204509&amp;status=done&amp;style=none&amp;width=708" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574751023681-12372fc7-0f94-4bd9-90cd-26e19bfe0d18.png#align=left&amp;display=inline&amp;height=326&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=243&amp;originWidth=414&amp;size=15162&amp;status=done&amp;style=none&amp;width=556" alt="image.png" /><br /><a name="0A2U0"></a></p><h1 id="实现servletrequest和servletresponse"><a class="markdownIt-Anchor" href="#实现servletrequest和servletresponse"></a> 实现ServletRequest和ServletResponse</h1><p>如图使Request继承ServletRequest接口和重写所有方法。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574752794822-1957d711-5893-4d3b-a2b2-d5c1bc1c375a.png#align=left&amp;display=inline&amp;height=563&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=563&amp;originWidth=935&amp;size=86051&amp;status=done&amp;style=none&amp;width=935" alt="image.png" />同理，对Response做出同样的修改继承自ServletResponse。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574752908505-ed1d0d08-fef3-4bee-b45d-6dd0ca5462c7.png#align=left&amp;display=inline&amp;height=590&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=590&amp;originWidth=899&amp;size=65300&amp;status=done&amp;style=none&amp;width=899" alt="image.png" /><br />其中，大部分函数都仅仅用默认修改即可，不过要对Response中的getWriter进行改写，方便动态资源写入进行便捷：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PrintWriter <span class="title">getWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//自动Flush</span></span><br><span class="line">        PrintWriter writer=<span class="keyword">new</span> PrintWriter(output,<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> writer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a name="Cw9Db"></a></p><h1 id="实现servlet"><a class="markdownIt-Anchor" href="#实现servlet"></a> 实现Servlet</h1><p>动态资源的Servlet<br /><code>public class TimeServlet implements Servlet</code><br />主要的Service函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        PrintWriter writer=servletResponse.getWriter();</span><br><span class="line">        writer.println(ConnectorUtils.renderStatus(HttpStatus.SC_OK));</span><br><span class="line">        writer.println(<span class="string">&quot;what time is it now?&quot;</span>);</span><br><span class="line">        writer.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br />]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 网络编程 </tag>
            
            <tag> io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建WEB服务器（一）</title>
      <link href="/posts/io_web_1/"/>
      <url>/posts/io_web_1/</url>
      
        <content type="html"><![CDATA[<h1 id="简易的web服务器一"><a class="markdownIt-Anchor" href="#简易的web服务器一"></a> 简易的WEB服务器（一）</h1><p>因为内容复杂繁多，预计分三次完成<br /><a name="h3vwi"></a></p><h1 id="回顾聊天室应用"><a class="markdownIt-Anchor" href="#回顾聊天室应用"></a> 回顾聊天室应用</h1><p>拥有一个服务器端用来收到客户端的消息并实现业务逻辑、一个客户端发送消息<br />注意，这里并没有使用任何应用层面的协议，只简单的发送转发等，没有添加额外内容。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574684831394-7f84b754-c98c-49c8-a482-56291a520f4a.png#align=left&amp;display=inline&amp;height=173&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=345&amp;originWidth=1014&amp;size=150561&amp;status=done&amp;style=none&amp;width=507" alt="image.png" /><br />不过，显示上在发送消息过程中只是这么简单的转发发送消息是远远不够的，如果BUFFER尺寸不够大，消息残缺也不会报错，我们需要能确保消息发送完整等等特别的应用层协议。<br /><a name="MbIEt"></a></p><h1 id="网络应用"><a class="markdownIt-Anchor" href="#网络应用"></a> 网络应用</h1><p>除了聊天室应用我们还需要知道一些其他应用广泛的应用——网络应用<br />同样，网络应用也是只是需要一个客户端和一个服务器端进行收发消息的操作。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574685158133-82b75248-059f-48d1-b172-d9f8c6d32fc4.png#align=left&amp;display=inline&amp;height=181&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=361&amp;originWidth=1027&amp;size=148855&amp;status=done&amp;style=none&amp;width=513.5" alt="image.png" /><br />其中请求及分为两大类：静态资源和动态资源。<br /><a name="mr9xE"></a></p><h2 id="静态资源"><a class="markdownIt-Anchor" href="#静态资源"></a> 静态资源</h2><p><a name="J3Hd2"></a></p><h3 id="它拥有如下几个特点"><a class="markdownIt-Anchor" href="#它拥有如下几个特点"></a> 它拥有如下几个特点：</h3><ul><li>不因请求的次数或顺序而变化</li><li>HTML、CSS、GIF、PNG</li><li>服务器直接通过路径获取静态资源<br /><a name="PJyv6"></a></li></ul><h3 id="请求静态资源"><a class="markdownIt-Anchor" href="#请求静态资源"></a> 请求静态资源</h3><p>客户端请求资源，服务器在获取请求以后会根据相应路径获取资源然后响应给客户端。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574685414171-f1c1769b-8bc8-420e-ae3a-58a589a65245.png#align=left&amp;display=inline&amp;height=152&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=304&amp;originWidth=1196&amp;size=201807&amp;status=done&amp;style=none&amp;width=598" alt="image.png" /><br /><a name="Jz8i5"></a></p><h2 id="动态资源"><a class="markdownIt-Anchor" href="#动态资源"></a> 动态资源</h2><p>如果只有静态资源网络会变得无趣，网络中需要一些比如随时间等变量变化变化的资源<br /><a name="gzNzF"></a></p><h3 id="它有如下几个特点"><a class="markdownIt-Anchor" href="#它有如下几个特点"></a> 它有如下几个特点：</h3><ul><li>随着请求方/发起时间/请求内容等因素而变化</li><li>目前的商品库存量</li><li>服务器通过容器获取动态资源<br /><a name="dqzpv"></a></li></ul><h3 id="请求动态资源"><a class="markdownIt-Anchor" href="#请求动态资源"></a> 请求动态资源</h3><p>客户端请求资源，服务器会请求容器，容器又会通过Servlet来获取动态资源，然后逐步返回最后响应客户端。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574685726760-01d3f959-1499-4a22-acf5-d51081d8dbcc.png#align=left&amp;display=inline&amp;height=277&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=554&amp;originWidth=1189&amp;size=257858&amp;status=done&amp;style=none&amp;width=594.5" alt="image.png" /><br /><a name="AN7CC"></a></p><h1 id="tomcat结构"><a class="markdownIt-Anchor" href="#tomcat结构"></a> Tomcat结构</h1><p>Tomcat是一个开源的网络服务器，它支持开发人员编译自己的Servlet发送到服务器中，概要结构如图：<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574685868829-584c603f-f65f-455f-b05b-6da5a934faa7.png#align=left&amp;display=inline&amp;height=296&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=591&amp;originWidth=1048&amp;size=217525&amp;status=done&amp;style=none&amp;width=524" alt="image.png" /><br /><a name="M0pCZ"></a></p><h2 id="接下来解析一下基本结构"><a class="markdownIt-Anchor" href="#接下来解析一下基本结构"></a> 接下来解析一下基本结构。</h2><p>由图注意到在最里面才包裹着Servlet，在外面一层一层的包裹有什么用呢？+<br /><a name="8TZkk"></a></p><h2 id="server"><a class="markdownIt-Anchor" href="#server"></a> Server：</h2><p><a name="MJt4z"></a></p><h3 id="拥有以下几个特点"><a class="markdownIt-Anchor" href="#拥有以下几个特点"></a> 拥有以下几个特点：</h3><ul><li>Tomcat服务器最顶层的组件</li><li>负责运行Tomcat服务器</li><li>负责加载服务器资源和环境变量<br /><a name="7oS7W"></a></li></ul><h2 id="service"><a class="markdownIt-Anchor" href="#service"></a> Service：</h2><p><a name="hZxyZ"></a></p><h3 id="拥有如下几个特点"><a class="markdownIt-Anchor" href="#拥有如下几个特点"></a> 拥有如下几个特点：</h3><ul><li>集合Connector和Engine的抽象组件（盒子）</li><li>一个Server可以包含多个Service</li><li>一个Service可以包含多个Connector和Engine<br /><a name="PHjgI"></a></li></ul><h2 id="connector和processor"><a class="markdownIt-Anchor" href="#connector和processor"></a> Connector和Processor：</h2><p>它主要负责提供给服务器的客户一个可以和服务器创建连接的端点，它负责接收请求，负责把相应递交给服务器，它也可以根据请求做出基本的解析来判断下一步如何操作，但它不做具体操作，它会把请求传递给Processor，Processor再把资源传递给Engine。<br /><a name="DOsAi"></a></p><h3 id="概括一下"><a class="markdownIt-Anchor" href="#概括一下"></a> 概括一下：</h3><p>Connector负责和外界链接建立和请求和响应发送。<br />Processor负责从Connector接收到请求。<br /><a name="klxGY"></a></p><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h4><ul><li>Connector提供基于不同特定协议的实现</li><li>Connector接受解析请求，返回响应</li><li>经Processor派遣请求至Engine进行处理<br /><a name="W8HoL"></a></li></ul><h2 id="engine"><a class="markdownIt-Anchor" href="#engine"></a> Engine：</h2><p>这里和以后的每一层都被称为容器<br /><a name="LluD7"></a></p><h3 id="拥有特点如下"><a class="markdownIt-Anchor" href="#拥有特点如下"></a> 拥有特点如下：</h3><ul><li>容器时Tomcat用来处理请求的组件</li><li>容器内部的组件按照层级排列</li><li>Engine是容器的顶层组件<br /><br /><a name="HRLhu"></a></li></ul><h2 id="host"><a class="markdownIt-Anchor" href="#host"></a> Host：</h2><p>即虚拟主机<br /><a name="oUc1T"></a></p><h3 id="拥有特点如下-2"><a class="markdownIt-Anchor" href="#拥有特点如下-2"></a> 拥有特点如下：</h3><ul><li>Host代表一个虚拟主机</li><li>一个Engine可以支持对多个虚拟主机的请求</li><li>Engine通过解析请求来决定将请求发送给哪一个Host<br /><a name="ZH4u1"></a></li></ul><h2 id="context"><a class="markdownIt-Anchor" href="#context"></a> Context：</h2><p>最复杂的组件<br /><a name="kPxVm"></a></p><h3 id="拥有特点如下-3"><a class="markdownIt-Anchor" href="#拥有特点如下-3"></a> 拥有特点如下：</h3><ul><li>Context代表一个Web Application</li><li>Tomcat最复杂的组件之一</li><li>应用资源管理，应用类加载，Servlet管理，安全管理<br /><a name="qyqCU"></a></li></ul><h2 id="wrapper"><a class="markdownIt-Anchor" href="#wrapper"></a> Wrapper：</h2><p><a name="HYMMr"></a></p><h3 id="拥有特点如下-4"><a class="markdownIt-Anchor" href="#拥有特点如下-4"></a> 拥有特点如下：</h3><ul><li>Wrapper是容器最底层的组件</li><li>包裹住Servlet实例</li><li>负责管理Servlet实例的生命周期<br /><a name="Ztwv6"></a></li></ul><h1 id="精简版的服务器设计"><a class="markdownIt-Anchor" href="#精简版的服务器设计"></a> 精简版的服务器设计</h1><p>省略掉Engine、Host、Context、Wrapper<br /><a name="hWgHx"></a></p><h1 id="实现request"><a class="markdownIt-Anchor" href="#实现request"></a> 实现Request</h1><p>抽象出需要操作的请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> connector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 和Socket对应的InputStream，通过这里真正的读到quest</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> InputStream input;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体的资源名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String uri;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(InputStream input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.input = input;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRequestUri</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            length = input.read(buffer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder request = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">            request.append((<span class="keyword">char</span>) buffer[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进一步解析</span></span><br><span class="line">        uri = parseUri(request.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">parseUri</span><span class="params">(String request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index1, index2;</span><br><span class="line">        index1 = request.indexOf(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (index1 != -<span class="number">1</span>) &#123;</span><br><span class="line">            index2 = request.indexOf(<span class="string">&quot; &quot;</span>, index1 + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (index2 != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> request.substring(index1 + <span class="number">1</span>, index2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="7k8Hw"></a></p><h1 id="测试request"><a class="markdownIt-Anchor" href="#测试request"></a> 测试Request</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test.connector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> connector.Request;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assertions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String VALID_REQUEST=<span class="string">&quot;GET /index.html HTTP/1.1&quot;</span>;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenValidRequestThenExtrackUri</span><span class="params">()</span></span>&#123;</span><br><span class="line">        InputStream input=<span class="keyword">new</span> ByteArrayInputStream(VALID_REQUEST.getBytes());</span><br><span class="line">        Request request=<span class="keyword">new</span> Request(input);</span><br><span class="line">        request.parse();</span><br><span class="line"></span><br><span class="line">        Assertions.assertEquals(<span class="string">&quot;/index.html&quot;</span>,request.getRequestUri());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过：<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574689721049-1f140c15-4d7a-42da-afd5-1ff419546b8a.png#align=left&amp;display=inline&amp;height=85&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=111&amp;originWidth=600&amp;size=12616&amp;status=done&amp;style=none&amp;width=462" alt="image.png" /><br /><br /><br /></p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 网络编程 </tag>
            
            <tag> io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AIO&amp;&amp;BIO&amp;&amp;NIO阶段性总结</title>
      <link href="/posts/aio_bio_nio/"/>
      <url>/posts/aio_bio_nio/</url>
      
        <content type="html"><![CDATA[<h1 id="阶段性总结"><a class="markdownIt-Anchor" href="#阶段性总结"></a> 阶段性总结</h1><p><a name="p3kcO"></a></p><h1 id="bio聊天室"><a class="markdownIt-Anchor" href="#bio聊天室"></a> BIO聊天室</h1><p><a name="rpRRQ"></a></p><h2 id="不使用线程池"><a class="markdownIt-Anchor" href="#不使用线程池"></a> 不使用线程池</h2><p>每个线程都对应着一个连接，随着客户端的增多，线程会增多很多，资源浪费也会大量增加，最后耗尽系统资源，服务器崩溃。<br /><a name="BUd0E"></a></p><h2 id="使用线程池"><a class="markdownIt-Anchor" href="#使用线程池"></a> 使用线程池</h2><p>使用线程池后，会固定线程的数量，从而从根本上减少了浪费。<br /><a name="vKvtL"></a></p><h1 id="nio聊天室"><a class="markdownIt-Anchor" href="#nio聊天室"></a> NIO聊天室</h1><p>不会为每一个连接都创建一个线程池了，自然性能会大幅提高。<br /><a name="tf4IA"></a></p><h1 id="aio聊天室"><a class="markdownIt-Anchor" href="#aio聊天室"></a> AIO聊天室</h1><p>线程比NIO要多，因为NIO各个类的内部都有线程池，而AIO内部实现里应用了更多线程<br /><a name="fjtEs"></a></p><h1 id="三种io模型适应状态"><a class="markdownIt-Anchor" href="#三种io模型适应状态"></a> 三种IO模型适应状态</h1><p><a name="mvYHk"></a></p><h2 id="bio"><a class="markdownIt-Anchor" href="#bio"></a> BIO</h2><p>连接数目少，服务器资源多，开发难度低<br /><a name="VSMyf"></a></p><h2 id="nio"><a class="markdownIt-Anchor" href="#nio"></a> NIO</h2><p>连接数目多，连接时间短，开发难度高<br /><a name="DmRpv"></a></p><h2 id="aio"><a class="markdownIt-Anchor" href="#aio"></a> AIO</h2><p>连接数目多，连接时间长，开发难度高<br /></p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 网络编程 </tag>
            
            <tag> io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于AIO改写多人聊天室</title>
      <link href="/posts/aio_2/"/>
      <url>/posts/aio_2/</url>
      
        <content type="html"><![CDATA[<h1 id="基于aio改写多人聊天室"><a class="markdownIt-Anchor" href="#基于aio改写多人聊天室"></a> 基于AIO改写多人聊天室</h1><p><a name="ecLJt"></a></p><h1 id="aio编程模型梳理"><a class="markdownIt-Anchor" href="#aio编程模型梳理"></a> AIO编程模型梳理</h1><p>回忆上一篇文章的AIO模型，这里做一些大概梳理。<br />首先在服务器端创建一部服务器通道，绑定监听端口<br />这里使用的AsynchronousServerSocketChannel 他其实属于一个通道群（AsynchronousChannelGroups），而这个通道群代表着一组可以被多个一部通道共享的资源群组。通过这个通道群来调用handler 。<br />当我们不做额外设定时候，系统会使用默认的通道群。<br />异步如何实现？<br />创建一个handler ，然后通过行为调用handler 来处理行为。<br />具体物理逻辑见上一篇文章<br /><a name="qA7Qe"></a></p><h1 id="服务器创建"><a class="markdownIt-Anchor" href="#服务器创建"></a> 服务器创建</h1><p><a name="DSfIc"></a></p><h2 id="chatserver"><a class="markdownIt-Anchor" href="#chatserver"></a> chatServer:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo5.aio.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousChannelGroup;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCALHOST = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">9999</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUIT = <span class="string">&quot;quit&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADPOOL_SIZE = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AsynchronousServerSocketChannel serverSocketChannel;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousChannelGroup channelGroup;</span><br><span class="line">    <span class="keyword">private</span> Charset charset = StandardCharsets.UTF_8;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ClientHandler&gt; connectedClients;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">(Closeable... closeables)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Closeable shut : closeables) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shut != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    shut.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">readyToQuit</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QUIT.equalsIgnoreCase(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatServer</span><span class="params">(<span class="keyword">int</span> port, String host)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        connectedClients = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_PORT, LOCALHOST);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ExecutorService pool = Executors.newFixedThreadPool(THREADPOOL_SIZE);</span><br><span class="line">            channelGroup = AsynchronousChannelGroup.withThreadPool(pool);</span><br><span class="line">            serverSocketChannel = AsynchronousServerSocketChannel.open(channelGroup);</span><br><span class="line">            serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(host, port));</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器已启动，监听端口[&quot;</span> + serverSocketChannel.getLocalAddress() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                serverSocketChannel.accept(<span class="keyword">null</span>, <span class="keyword">new</span> AcceptHandler());</span><br><span class="line">                System.in.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            shutdown(serverSocketChannel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>, <span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel clientChannel, Object attachment)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (serverSocketChannel.isOpen()) &#123;</span><br><span class="line">                serverSocketChannel.accept(<span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (clientChannel != <span class="keyword">null</span> &amp;&amp; clientChannel.isOpen()) &#123;</span><br><span class="line">                ClientHandler handler = <span class="keyword">new</span> ClientHandler(clientChannel);</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(BUFFER);</span><br><span class="line">                <span class="comment">//将用户添加到在线列表</span></span><br><span class="line">                addClient(handler);</span><br><span class="line">                clientChannel.read(buffer, buffer, handler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户连接失败&quot;</span> + exc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addClient</span><span class="params">(ClientHandler handler)</span> </span>&#123;</span><br><span class="line">        connectedClients.add(handler);</span><br><span class="line">        System.out.println(getClientName(handler.clientChannel) + <span class="string">&quot;已成功连接到服务器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeClient</span><span class="params">(ClientHandler clientHandler)</span> </span>&#123;</span><br><span class="line">        connectedClients.remove(clientHandler);</span><br><span class="line">        System.err.println(getClientName(clientHandler.clientChannel) + <span class="string">&quot;已断开服务器连接&quot;</span>);</span><br><span class="line">        shutdown(clientHandler.clientChannel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getClientName</span><span class="params">(AsynchronousSocketChannel clientChannel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InetSocketAddress address= (InetSocketAddress) clientChannel.getRemoteAddress();</span><br><span class="line">            String str=<span class="string">&quot;客户端[&quot;</span>+address.getPort()+<span class="string">&quot;]:&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;获取客户端失败&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>, <span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> AsynchronousSocketChannel clientChannel;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ClientHandler</span><span class="params">(AsynchronousSocketChannel clientChannel)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.clientChannel = clientChannel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (attachment != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//客户端异常</span></span><br><span class="line">                    <span class="comment">//移除在线列表</span></span><br><span class="line">                    removeClient(<span class="keyword">this</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    attachment.flip();</span><br><span class="line">                    String msg = receive(attachment);</span><br><span class="line">                    System.out.println(getClientName(clientChannel) + msg);</span><br><span class="line">                    forwardMessage(clientChannel, msg);</span><br><span class="line">                    attachment.clear();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//检查用户是否决定退出</span></span><br><span class="line">                    <span class="keyword">if</span> (readyToQuit(msg)) &#123;</span><br><span class="line">                        removeClient(<span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        clientChannel.read(attachment, attachment, <span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户读写失败&quot;</span> + exc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">forwardMessage</span><span class="params">(AsynchronousSocketChannel clientChannel, String msg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ClientHandler handler : connectedClients) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!clientChannel.equals(handler.clientChannel)) &#123;</span><br><span class="line">                    String str = getClientName(handler.clientChannel);</span><br><span class="line">                    ByteBuffer buffer = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (readyToQuit(msg)) &#123;</span><br><span class="line">                        buffer = charset.encode(str + <span class="string">&quot;已断开连接&quot;</span>);</span><br><span class="line">                        handler.clientChannel.write(buffer, <span class="keyword">null</span>, handler);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        buffer = charset.encode(str + msg);</span><br><span class="line">                        handler.clientChannel.write(buffer, <span class="keyword">null</span>, handler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">receive</span><span class="params">(ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(charset.decode(attachment)).trim();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="uDgH0"></a></p><h2 id="servermain"><a class="markdownIt-Anchor" href="#servermain"></a> ServerMain:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo5.aio.server;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: hszjj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/11/23 19:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChatServer server=<span class="keyword">new</span> ChatServer();</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="T3X35"></a></p><h1 id="客户端创建"><a class="markdownIt-Anchor" href="#客户端创建"></a> 客户端创建</h1><p><a name="VumVM"></a></p><h2 id="chatclient"><a class="markdownIt-Anchor" href="#chatclient"></a> chatClient：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo5.aio.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCALHOST = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">9999</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUIT = <span class="string">&quot;quit&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Charset charset = Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel clientChannel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(LOCALHOST, DEFAULT_PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">(Closeable... closeables)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Closeable shut : closeables) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shut != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    shut.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readyToQuit</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QUIT.equalsIgnoreCase(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clientChannel = AsynchronousSocketChannel.open();</span><br><span class="line">            Future&lt;Void&gt; future = clientChannel.connect(<span class="keyword">new</span> InetSocketAddress(host, port));</span><br><span class="line">            System.out.println(<span class="string">&quot;已成功连接到服务器&quot;</span>);</span><br><span class="line">            future.get();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理用户输入</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> UserInputHander(<span class="keyword">this</span>)).start();</span><br><span class="line"></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(BUFFER);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Future&lt;Integer&gt; readResult = clientChannel.read(buffer);</span><br><span class="line">                <span class="keyword">int</span> result = readResult.get();</span><br><span class="line">                <span class="keyword">if</span> (result &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//服务器异常</span></span><br><span class="line">                    System.err.println(<span class="string">&quot;服务器断开&quot;</span>);</span><br><span class="line">                    shutdown(clientChannel);</span><br><span class="line">                    System.exit(-<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    String msg = String.valueOf(charset.decode(buffer));</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ByteBuffer buffer = charset.encode(msg);</span><br><span class="line">                Future&lt;Integer&gt; future = clientChannel.write(buffer);</span><br><span class="line">                future.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.err.println(<span class="string">&quot;消息发送失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="i9rAc"></a></p><h2 id="userinputhander"><a class="markdownIt-Anchor" href="#userinputhander"></a> UserInputHander:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo5.aio.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> demo3.nio1.client.Demo3ChatClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInputHander</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ChatClient chatClient;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader reader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserInputHander</span><span class="params">(ChatClient chatClient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.chatClient = chatClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                String msg = reader.readLine();</span><br><span class="line">                chatClient.send(msg);</span><br><span class="line">                <span class="keyword">if</span> (chatClient.readyToQuit(msg)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;已断开服务器连接&quot;</span>);</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="2hqmE"></a></p><h2 id="clientmain"><a class="markdownIt-Anchor" href="#clientmain"></a> ClientMain:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo5.aio.client;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: hszjj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/11/23 20:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChatClient client=<span class="keyword">new</span> ChatClient();</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="JDtWr"></a></p><h1 id="效果演示"><a class="markdownIt-Anchor" href="#效果演示"></a> 效果演示</h1><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574512407634-792dd610-1bde-4dc9-a413-df418f78189e.png#align=left&amp;display=inline&amp;height=540&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1080&amp;originWidth=1920&amp;size=149822&amp;status=done&amp;style=none&amp;width=960" alt="image.png" /></p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 网络编程 </tag>
            
            <tag> io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AIO异步调用机制</title>
      <link href="/posts/aio_1/"/>
      <url>/posts/aio_1/</url>
      
        <content type="html"><![CDATA[<h1 id="aio异步调用机制"><a class="markdownIt-Anchor" href="#aio异步调用机制"></a> AIO异步调用机制</h1><p><a name="mmEfk"></a></p><h1 id="aio的异步操作"><a class="markdownIt-Anchor" href="#aio的异步操作"></a> AIO的异步操作</h1><p>AsyncSocketChannel和AsyncServerSocketChannel都是支持如图几个IO操作异步调用的。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574316912617-10b6e8a5-552c-4244-a45c-3a36683aa933.png#align=left&amp;display=inline&amp;height=201&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=401&amp;originWidth=1248&amp;size=87502&amp;status=done&amp;style=none&amp;width=624" alt="image.png" /><br /><a name="zC8W1"></a></p><h1 id="如何实现异步调用"><a class="markdownIt-Anchor" href="#如何实现异步调用"></a> 如何实现异步调用</h1><p><a name="U8Nbl"></a></p><h2 id="future"><a class="markdownIt-Anchor" href="#future"></a> Future</h2><p>简单来说通过Channel来调用那几个函数，然后返回一个Future的对象，Future在线程池中介绍过，他是一个描述未来的一个对象，通过get、isDone等等的调用查询未来的任务。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574317208579-f33b1cbf-6da0-436b-9187-96ae88bef384.png#align=left&amp;display=inline&amp;height=190&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=379&amp;originWidth=983&amp;size=78654&amp;status=done&amp;style=none&amp;width=491.5" alt="image.png" /><br /><a name="90KYi"></a></p><h2 id="completionhander"><a class="markdownIt-Anchor" href="#completionhander"></a> CompletionHander</h2><p>通过Channel调用IO操作，然后不等待是否完成，然后把一些参数传入一个回调函数（Handler）进一步操作（实现）。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574317439275-8b8225da-8d02-4ba7-8b32-9fc38d1637c7.png#align=left&amp;display=inline&amp;height=188&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=376&amp;originWidth=1217&amp;size=91840&amp;status=done&amp;style=none&amp;width=608.5" alt="image.png" /><br />Handler拥有两种函数，一个是Completed，是在完成后调用，另一种是Failed，是在失败了后调用。<br /><a name="nDWQ7"></a></p><h1 id="echodemo实现异步操作机制"><a class="markdownIt-Anchor" href="#echodemo实现异步操作机制"></a> EchoDemo实现异步操作机制</h1><p><a name="28Vp3"></a></p><h2 id="server"><a class="markdownIt-Anchor" href="#server"></a> Server：</h2><p><a name="Kg0Bz"></a></p><h3 id="主体函数"><a class="markdownIt-Anchor" href="#主体函数"></a> 主体函数：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo4.aio.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String LOCALHOST=<span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT=<span class="number">9999</span>;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousServerSocketChannel serverSocketChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUIT=<span class="string">&quot;quit&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">readyToQuit</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QUIT.equalsIgnoreCase(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shutDown</span><span class="params">(Closeable...closeables)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Closeable shut : closeables) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shut != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    shut.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//绑定监听端口</span></span><br><span class="line">            serverSocketChannel=AsynchronousServerSocketChannel.open();</span><br><span class="line">            serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(LOCALHOST,DEFAULT_PORT));</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器已启动，正在监听：[&quot;</span>+LOCALHOST+<span class="string">&quot;,&quot;</span>+DEFAULT_PORT+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//AcceptHandler在AsynchronousChannelGroup线程池中完成,而非主线程。</span></span><br><span class="line">                <span class="comment">//AsynchronousChannelGroup未定义时使用默认的AsynchronousChannelGroup</span></span><br><span class="line">                serverSocketChannel.accept(<span class="keyword">null</span>, <span class="keyword">new</span> AcceptHandler());</span><br><span class="line">                <span class="comment">//防止频繁调用accept函数。</span></span><br><span class="line">                System.in.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            shutDown(serverSocketChannel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>,<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel result, Object attachment)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//并不会造成stepOverFlow在底层实现拥有次数限制</span></span><br><span class="line">            <span class="keyword">if</span> (serverSocketChannel.isOpen())&#123;</span><br><span class="line">                serverSocketChannel.accept(<span class="keyword">null</span>,<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AsynchronousSocketChannel clientChannel=result;</span><br><span class="line">            <span class="keyword">if</span> (clientChannel!=<span class="keyword">null</span>&amp;&amp;clientChannel.isOpen()) &#123;</span><br><span class="line">                ClientHander hander = <span class="keyword">new</span> ClientHander(clientChannel);</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                Map&lt;String, Object&gt; info = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                info.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;read&quot;</span>);</span><br><span class="line">                info.put(<span class="string">&quot;buffer&quot;</span>, buffer);</span><br><span class="line">                clientChannel.read(buffer, info, hander);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//异常处理,略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHander</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>,<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> AsynchronousSocketChannel clientChannel;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ClientHander</span><span class="params">(AsynchronousSocketChannel clientChannel)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端[&quot;</span>+clientChannel.getLocalAddress()+<span class="string">&quot;]已连接到服务器&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.clientChannel=clientChannel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, Object attachment)</span> </span>&#123;</span><br><span class="line">            Map&lt;String,Object&gt; info= (Map&lt;String, Object&gt;) attachment;</span><br><span class="line">            String type= (String) info.get(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;read&quot;</span>.equalsIgnoreCase(type)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ByteBuffer buffer = (ByteBuffer) info.get(<span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">                    String str = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                    <span class="keyword">if</span> (readyToQuit(str)) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;客户端[&quot;</span> + clientChannel.getLocalAddress() + <span class="string">&quot;]已断开连接&quot;</span>);</span><br><span class="line">                        shutDown(clientChannel);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        info.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;write&quot;</span>);</span><br><span class="line">                        clientChannel.write(buffer, info, <span class="keyword">this</span>);</span><br><span class="line">                        buffer.clear();</span><br><span class="line">                        System.out.println(<span class="string">&quot;客户端[&quot;</span> + clientChannel.getLocalAddress() + <span class="string">&quot;]:&quot;</span> + str);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;write&quot;</span>.equalsIgnoreCase(type))&#123;</span><br><span class="line">                ByteBuffer buffer= ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                info.put(<span class="string">&quot;type&quot;</span>,<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                info.put(<span class="string">&quot;buffer&quot;</span>,buffer);</span><br><span class="line">                clientChannel.read(buffer,info,<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//异常处理,略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="6cEVn"></a></p><h3 id="main"><a class="markdownIt-Anchor" href="#main"></a> Main:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo4.aio.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Server server=<span class="keyword">new</span> Server();</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="vYvjv"></a></p><h2 id="client"><a class="markdownIt-Anchor" href="#client"></a> Client</h2><p><a name="Mg95x"></a></p><h3 id="主题函数"><a class="markdownIt-Anchor" href="#主题函数"></a> 主题函数：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo4.aio.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String LOCALHOST = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">9999</span>;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel clientChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUIT=<span class="string">&quot;quit&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">readyToQuit</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QUIT.equalsIgnoreCase(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shutDown</span><span class="params">(Closeable... closeables)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Closeable shut : closeables) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shut != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    shut.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建channel</span></span><br><span class="line">            clientChannel = AsynchronousSocketChannel.open();</span><br><span class="line">            Future&lt;Void&gt; future = clientChannel.connect(<span class="keyword">new</span> InetSocketAddress(LOCALHOST, DEFAULT_PORT));</span><br><span class="line">            future.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端[&quot;</span>+LOCALHOST+<span class="string">&quot;，&quot;</span>+DEFAULT_PORT+<span class="string">&quot;]已连接到服务器&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//等待用户输入</span></span><br><span class="line">            BufferedReader consoleReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                String intput = consoleReader.readLine();</span><br><span class="line">                <span class="keyword">byte</span>[] inputBytes = intput.getBytes();</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.wrap(inputBytes);</span><br><span class="line">                Future&lt;Integer&gt; writeRes = clientChannel.write(buffer);</span><br><span class="line">                writeRes.get();</span><br><span class="line">                <span class="keyword">if</span> (readyToQuit(intput))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">                buffer.flip();</span><br><span class="line">                Future&lt;Integer&gt; readRes = clientChannel.read(buffer);</span><br><span class="line">                readRes.get();</span><br><span class="line">                System.out.print(<span class="string">&quot;收到服务器消息：&quot;</span>);</span><br><span class="line">                buffer.clear();</span><br><span class="line">                String res = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                res=<span class="string">&quot;[ECHO]:&quot;</span> +res;</span><br><span class="line">                System.out.println(res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            shutDown(clientChannel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Main：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo4.aio.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Client client=<span class="keyword">new</span> Client();</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="L3WPJ"></a></p><h1 id="结果展示"><a class="markdownIt-Anchor" href="#结果展示"></a> 结果展示</h1><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574326786588-d0c6a73a-428e-4242-ac1a-48f72e2cc2b9.png#align=left&amp;display=inline&amp;height=540&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1080&amp;originWidth=1920&amp;size=120802&amp;status=done&amp;style=none&amp;width=960" alt="image.png" /></p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 网络编程 </tag>
            
            <tag> io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO模型总结</title>
      <link href="/posts/io_sum_1/"/>
      <url>/posts/io_sum_1/</url>
      
        <content type="html"><![CDATA[<h1 id="io模型总结"><a class="markdownIt-Anchor" href="#io模型总结"></a> IO模型总结</h1><p><a name="bKgnQ"></a></p><h1 id="数据物理传输过程"><a class="markdownIt-Anchor" href="#数据物理传输过程"></a> 数据物理传输过程</h1><p>数据首先通过物理连接方式收到数据：<br />通过网卡设备接收数据，然后拷贝到操作系统内部缓冲区，从缓冲区复制到应用程序的缓冲区，从应用程序缓冲区提取数据。<br /><a name="TRguh"></a></p><h1 id="阻塞式io"><a class="markdownIt-Anchor" href="#阻塞式io"></a> 阻塞式IO</h1><p><a name="jbWNO"></a></p><h2 id="数据传输过程"><a class="markdownIt-Anchor" href="#数据传输过程"></a> 数据传输过程：</h2><p>通过操作系统（大部分为Unix）调用函数查询数据是否准备好。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574258954290-0eff205b-a272-40cd-ad39-4093339b1fce.png#align=left&amp;display=inline&amp;height=87&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=209&amp;originWidth=980&amp;size=85304&amp;status=done&amp;style=none&amp;width=407" alt="image.png" /><br /><br /><br />数据没有准备好，一直阻塞在内核中<br />数据准备好了，拷贝到内核的缓冲区，然后复制到应用程序缓冲区<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574259187969-70e6f819-7dab-4217-abd8-136301f190ce.png#align=left&amp;display=inline&amp;height=205&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=495&amp;originWidth=984&amp;size=120965&amp;status=done&amp;style=none&amp;width=407" alt="image.png" /><br />返回数据到应用程序<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574259267830-6fa6dca8-3075-4dbb-83bb-a997303de924.png#align=left&amp;display=inline&amp;height=203&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=487&amp;originWidth=994&amp;size=133843&amp;status=done&amp;style=none&amp;width=415" alt="image.png" /><br /><a name="Qd90c"></a></p><h1 id="非阻塞式io"><a class="markdownIt-Anchor" href="#非阻塞式io"></a> 非阻塞式IO</h1><p><a name="sqt4u"></a></p><h2 id="数据传输过程-2"><a class="markdownIt-Anchor" href="#数据传输过程-2"></a> 数据传输过程：</h2><p>如果在系统调用后数据没有准备好，这是不会进行阻塞，会直接返回无数据，然后之后再次系统调用，在这样不断询问直到数据准备好为止，过程如图：<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574259460441-5afc416d-c07f-474d-910b-8101f14fb515.png#align=left&amp;display=inline&amp;height=238&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=566&amp;originWidth=973&amp;size=167344&amp;status=done&amp;style=none&amp;width=410" alt="image.png" /><br /></p><p><a name="KwERt"></a></p><h2 id="与阻塞的不同点"><a class="markdownIt-Anchor" href="#与阻塞的不同点"></a> 与阻塞的不同点：</h2><p>显然，区别就是不再等待到数据准备好为止，而是不断发送查询直到数据准备好为止。<br /><a name="uLxff"></a></p><h1 id="阻塞小结"><a class="markdownIt-Anchor" href="#阻塞小结"></a> 阻塞小结</h1><p>对比NIO和BIO模型，这里就对应着非阻塞和阻塞模型。<br />不过请注意，这里的是NIO模型而非NIO具体实现，因为具体实现会涉及到Selector，将在后面具体分析。<br /><a name="8XTXV"></a></p><h1 id="io多路复用"><a class="markdownIt-Anchor" href="#io多路复用"></a> IO多路复用</h1><p><a name="gq5aH"></a></p><h2 id="数据传输过程-3"><a class="markdownIt-Anchor" href="#数据传输过程-3"></a> 数据传输过程：</h2><p>通过系统调用（select）查看数据是否准备就绪，若数据没有准备好，于是准备监听内核通道，等待直到数据准备好为止，返回可读信号（条件），然后再次系统调用，随后复制数据，最后成功返回。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574260059147-80ec27f1-361e-4527-9994-cae44412272e.png#align=left&amp;display=inline&amp;height=294&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=572&amp;originWidth=992&amp;size=176398&amp;status=done&amp;style=none&amp;width=510" alt="image.png" /><br /></p><p><a name="6xGxI"></a></p><h2 id="何为多路"><a class="markdownIt-Anchor" href="#何为多路"></a> 何为多路？</h2><p>应用程序可以不止监听一个IO，可以监听多个IO，当满足条件时，都可以返回条件，故为多路。<br /><a name="wcowe"></a></p><h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2><p>如上所述，IO多路复用是NIO+Selector（IO多路复用器）的模型。<br /><a name="nwV06"></a></p><h1 id="异步io"><a class="markdownIt-Anchor" href="#异步io"></a> 异步IO</h1><p>不管是上述哪种模型，它们都属于同步模型，因为发起调用以后，无论数据准备好与否都会返回数据。<br /><a name="3ftze"></a></p><h2 id="异步io的过程"><a class="markdownIt-Anchor" href="#异步io的过程"></a> 异步IO的过程：</h2><p>和之前相同，若没有准备好数据的话会返回空数据，当数据准备好以后，会直接进行数据复制，当一切都准备好以后会递交信号给应用程序。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574260649001-4cdab418-2fe2-4cc7-b8b2-7f5c0ce17353.png#align=left&amp;display=inline&amp;height=288&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=570&amp;originWidth=983&amp;size=158188&amp;status=done&amp;style=none&amp;width=496" alt="image.png" /><br /><strong>对应模型即AIO模型</strong></p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIO的多人聊天室</title>
      <link href="/posts/nio_3/"/>
      <url>/posts/nio_3/</url>
      
        <content type="html"><![CDATA[<h1 id="nio的多人聊天室"><a class="markdownIt-Anchor" href="#nio的多人聊天室"></a> NIO的多人聊天室</h1><p><a name="kHxHh"></a></p><h1 id="nio编程模型概述"><a class="markdownIt-Anchor" href="#nio编程模型概述"></a> NIO编程模型概述</h1><p><a name="8XTAj"></a></p><h2 id="accept事件"><a class="markdownIt-Anchor" href="#accept事件"></a> ACCEPT事件：</h2><p>服务器端启动ServerSocketChannel，绑定端口后注册ACCEPT事件，当客户端发送并被服务器接收的时候则触发ACCEPT事件，并通过handles处理事件、注册新的事件READ。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574142293436-c660bf4c-c90a-4118-9617-8071bd2a007a.png#align=left&amp;display=inline&amp;height=241&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=315&amp;originWidth=800&amp;size=83696&amp;status=done&amp;style=none&amp;width=612" alt="image.png" /><br />在客户发送信息以后READ事件就可以被触发。<br />注意：<br />处理事件都是在同一线程中完成的：<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574142431039-abbe788c-624e-4df2-8a5e-3cd8f2ab8f9b.png#align=left&amp;display=inline&amp;height=219&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=236&amp;originWidth=582&amp;size=67714&amp;status=done&amp;style=none&amp;width=539" alt="image.png" /><br /><a name="EpEqm"></a></p><h2 id="read事件"><a class="markdownIt-Anchor" href="#read事件"></a> READ事件：</h2><p>接上文，当用户SocketChannel中拥有数据时，Selector会发现拥有可读事件，READ被触发，通过handles把数据转发出去，同样，处理事件都是在同一线程中完成的。<br /><a name="4wcY3"></a></p><h2 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意：</h2><p>虽然NIO的读写都是非阻塞性的但是Selector是阻塞性的，当没有事件发生的时候Selector的select会一直阻塞，直到新的事件触发。<br /><a name="089wq"></a></p><h2 id="第二个链接建立"><a class="markdownIt-Anchor" href="#第二个链接建立"></a> 第二个链接建立：</h2><p>过程同上，形成如图：<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574142847655-96977996-ed4a-4e26-bc8a-c9c81e66275b.png#align=left&amp;display=inline&amp;height=269&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=380&amp;originWidth=838&amp;size=110493&amp;status=done&amp;style=none&amp;width=593" alt="image.png" /><br />注册了监听Client2的READ事件。<br /><a name="APBdW"></a></p><h1 id="代码实践"><a class="markdownIt-Anchor" href="#代码实践"></a> 代码实践</h1><p><a name="dc8ZY"></a></p><h2 id="服务器端"><a class="markdownIt-Anchor" href="#服务器端"></a> 服务器端</h2><p><a name="DRpi3"></a></p><h3 id="chatserver"><a class="markdownIt-Anchor" href="#chatserver"></a> ChatServer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo3.nio1.server;</span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUIT=<span class="string">&quot;quit&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT=<span class="number">9999</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER=<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel server;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ByteBuffer readBuffer=ByteBuffer.allocate(BUFFER);</span><br><span class="line">    <span class="keyword">private</span> ByteBuffer writeBuffer=ByteBuffer.allocate(BUFFER);</span><br><span class="line">    <span class="comment">//编码解码</span></span><br><span class="line">    <span class="keyword">private</span> Charset charset=Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatServer</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port=port;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">readyToQuit</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QUIT.equalsIgnoreCase(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable...closeables)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Closeable shut : closeables) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shut != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    shut.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">//关闭阻塞状态</span></span><br><span class="line">            server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//绑定监听端口</span></span><br><span class="line">            server.socket().bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line"></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">//注册ACCEPT</span></span><br><span class="line">            server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器[&quot;</span> + port + <span class="string">&quot;]已启动&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                selector.select();</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                <span class="keyword">for</span> (SelectionKey key : selectionKeys) &#123;</span><br><span class="line">                    handles(key);</span><br><span class="line">                &#125;</span><br><span class="line">                selectionKeys.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ClosedSelectorException e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//不必要关闭ServerChannel，因为关闭selector以后会把它对应的通道一起关闭</span></span><br><span class="line">            close(selector);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handles</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel client = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// ACCEPT事件--和客户端建立连接</span></span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            ServerSocketChannel channel = (ServerSocketChannel) key.channel();</span><br><span class="line">            client = channel.accept();</span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            System.out.println(getClientName(client) + <span class="string">&quot;已连接到服务器&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// READ事件--客户端发送了消息</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            client = (SocketChannel) key.channel();</span><br><span class="line">            String msg = recieve(client);</span><br><span class="line">            <span class="comment">//客户端异常</span></span><br><span class="line">            <span class="keyword">if</span> (msg.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">//取消继续监视这个通达</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                <span class="comment">//更新selector的状态</span></span><br><span class="line">                selector.wakeup();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//检查是否退出</span></span><br><span class="line">                <span class="keyword">if</span> (readyToQuit(msg)) &#123;</span><br><span class="line">                    key.cancel();</span><br><span class="line">                    selector.wakeup();</span><br><span class="line">                    System.out.println(getClientName(client) + <span class="string">&quot;断开连接&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(getClientName(client)+msg);</span><br><span class="line">                    <span class="comment">//转发数据</span></span><br><span class="line">                    forwardMessage(client, msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getClientName</span><span class="params">(SocketChannel client)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;客户端[&quot;</span>+client.socket().getPort()+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">forwardMessage</span><span class="params">(SocketChannel client, String msg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (SelectionKey key:selector.keys())&#123;</span><br><span class="line">            Channel connectedClient= key.channel();</span><br><span class="line">            <span class="keyword">if</span> (connectedClient <span class="keyword">instanceof</span> ServerSocketChannel)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (key.isValid()&amp;&amp;!client.equals(connectedClient))&#123;</span><br><span class="line">                writeBuffer.clear();</span><br><span class="line">                writeBuffer.put(charset.encode(getClientName(client)+<span class="string">&quot;:&quot;</span>+msg+<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">                writeBuffer.flip();</span><br><span class="line">                <span class="keyword">while</span> (writeBuffer.hasRemaining())&#123;</span><br><span class="line">                    ((SocketChannel) connectedClient).write(writeBuffer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">recieve</span><span class="params">(SocketChannel client)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        readBuffer.clear();</span><br><span class="line">        <span class="keyword">while</span> (client.read(readBuffer) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        readBuffer.flip();</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(charset.decode(readBuffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="gpkwK"></a></p><h3 id="main"><a class="markdownIt-Anchor" href="#main"></a> Main</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo3.nio1.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChatServer chatServer=<span class="keyword">new</span> ChatServer();</span><br><span class="line">        chatServer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="7wCVJ"></a></p><h2 id="用户端"><a class="markdownIt-Anchor" href="#用户端"></a> 用户端</h2><p><a name="8gC2g"></a></p><h3 id="chatclient"><a class="markdownIt-Anchor" href="#chatclient"></a> ChatClient</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo3.nio1.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_IP = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">9999</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUIT = <span class="string">&quot;quit&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> post;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ByteBuffer readBuffer = ByteBuffer.allocate(BUFFER);</span><br><span class="line">    <span class="keyword">private</span> ByteBuffer writeBuffer = ByteBuffer.allocate(BUFFER);</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> Charset charset = Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClient</span><span class="params">(String host, <span class="keyword">int</span> post)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.post = post;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_IP, DEFAULT_PORT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readyToQuit</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QUIT.equalsIgnoreCase(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable... closeables)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Closeable shut : closeables) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shut != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    shut.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client = SocketChannel.open();</span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            client.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">            client.connect(<span class="keyword">new</span> InetSocketAddress(host, post));</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端[&quot;</span> + host + <span class="string">&quot;]已连接到服务器&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                selector.select();</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                <span class="keyword">for</span> (SelectionKey key : selectionKeys) &#123;</span><br><span class="line">                    handles(key);</span><br><span class="line">                &#125;</span><br><span class="line">                selectionKeys.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ClosedSelectorException e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            close(selector);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handles</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//CONNECT事件--连接就绪</span></span><br><span class="line">        <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//判断是否就绪建立连接</span></span><br><span class="line">            <span class="keyword">if</span> (channel.isConnectionPending()) &#123;</span><br><span class="line">                channel.finishConnect();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理用户的输入</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> UserInputHander(<span class="keyword">this</span>)).start();</span><br><span class="line">            channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//READ事件--服务器转发消息</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line">            String msg = recieve(channel);</span><br><span class="line">            <span class="keyword">if</span> (msg.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">//服务器异常</span></span><br><span class="line">                System.out.println(<span class="string">&quot;客户端[&quot;</span> + host + <span class="string">&quot;]已断开服务器&quot;</span>);</span><br><span class="line">                close(selector);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">recieve</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        readBuffer.clear();</span><br><span class="line">        <span class="keyword">while</span> (client.read(readBuffer) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        readBuffer.flip();</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(charset.decode(readBuffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        writeBuffer.clear();</span><br><span class="line">        writeBuffer.put(charset.encode(msg));</span><br><span class="line">        writeBuffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (writeBuffer.hasRemaining()) &#123;</span><br><span class="line">            client.write(writeBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (readyToQuit(msg)) &#123;</span><br><span class="line">            close(selector);</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端[&quot;</span> + host + <span class="string">&quot;]已断开服务器&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="wNn9Y"></a></p><h3 id="输入线程"><a class="markdownIt-Anchor" href="#输入线程"></a> 输入线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo3.nio1.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInputHander</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ChatClient chatClient;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader reader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserInputHander</span><span class="params">(ChatClient chatClient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.chatClient = chatClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                String msg = reader.readLine();</span><br><span class="line">                chatClient.send(msg);</span><br><span class="line">                <span class="keyword">if</span> (chatClient.readyToQuit(msg)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="m26i3"></a></p><h3 id="main-2"><a class="markdownIt-Anchor" href="#main-2"></a> Main</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo3.nio1.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChatClient chatClient=<span class="keyword">new</span> ChatClient();</span><br><span class="line">        chatClient.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="G1Qx3"></a></p><h1 id="测试结果"><a class="markdownIt-Anchor" href="#测试结果"></a> 测试结果</h1><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574179411430-852ee411-272e-47e6-a757-655550840171.png#align=left&amp;display=inline&amp;height=540&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1080&amp;originWidth=1920&amp;size=120654&amp;status=done&amp;style=none&amp;width=960" alt="image.png" /></p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 网络编程 </tag>
            
            <tag> io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIO零拷贝</title>
      <link href="/posts/nio_2/"/>
      <url>/posts/nio_2/</url>
      
        <content type="html"><![CDATA[<h1 id="nio零拷贝"><a class="markdownIt-Anchor" href="#nio零拷贝"></a> NIO零拷贝</h1><p><a name="vCSGr"></a></p><h1 id="问题引出"><a class="markdownIt-Anchor" href="#问题引出"></a> 问题引出</h1><p><a name="ZPOrd"></a></p><h2 id="传统文件拷贝过程"><a class="markdownIt-Anchor" href="#传统文件拷贝过程"></a> 传统文件拷贝过程</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1577688277144-5fae642e-e679-454b-8f41-8680a43370a0.png#align=left&amp;display=inline&amp;height=417&amp;name=image.png&amp;originHeight=649&amp;originWidth=680&amp;size=98806&amp;status=done&amp;style=none&amp;width=437" alt="image.png" /><br />它将硬盘上的文件读取到内核空间的缓冲区中，然后再将缓冲区内容拷贝到Socket缓冲区再拷贝到用户缓冲区中，调用写的方法时会从用户缓冲区到内核传冲区到Socket缓冲区再到服务器端的拷贝，总而言之会进行多次拷贝。<br />显然，会拥有极大的性能损耗。<br /><a name="z7JS3"></a></p><h2 id="简化拷贝过程"><a class="markdownIt-Anchor" href="#简化拷贝过程"></a> 简化拷贝过程</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1577688060888-ae5d24e6-68bb-44cc-a122-a26be313d12f.png#align=left&amp;display=inline&amp;height=389&amp;name=image.png&amp;originHeight=646&amp;originWidth=710&amp;size=95642&amp;status=done&amp;style=none&amp;width=428" alt="image.png" /><br />通过sendfile将用户空间切换到内核空间，从而节省了用户缓冲区的操作，直接由内核和硬件的对话，但是仍然会有拷贝的过程，这时候就要依赖操作系统的操作了。<br /><a name="kNHJE"></a></p><h2 id="零拷贝过程"><a class="markdownIt-Anchor" href="#零拷贝过程"></a> 零拷贝过程</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1577688659391-de8375dd-5bd6-4d64-ad73-6e99501cff57.png#align=left&amp;display=inline&amp;height=318&amp;name=image.png&amp;originHeight=636&amp;originWidth=900&amp;size=107607&amp;status=done&amp;style=none&amp;width=450" alt="image.png" /><br />经过操作系统的配合实现了零拷贝的过程，即通过scatter/gather的方法。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1577688761172-98ae4a78-451b-45e4-9c37-ec4261e0439d.png#align=left&amp;display=inline&amp;height=348&amp;name=image.png&amp;originHeight=596&amp;originWidth=759&amp;size=243024&amp;status=done&amp;style=none&amp;width=444" alt="image.png" /><br /><a name="XC4qI"></a></p><h1 id="代码实验"><a class="markdownIt-Anchor" href="#代码实验"></a> 代码实验</h1><p>经过理论分析，接下来要用代码实际查看是不是性能拥有差距。<br /><a name="45lwa"></a></p><h2 id="老式拷贝文件"><a class="markdownIt-Anchor" href="#老式拷贝文件"></a> 老式拷贝文件</h2><p><a name="a8gLo"></a></p><h3 id="oldeioserver"><a class="markdownIt-Anchor" href="#oldeioserver"></a> OldeIOServer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.zerocopy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HandSomeMaker</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/12/30 15:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OldIoServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器已启动&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端【&quot;</span>+socket.getInetAddress()+<span class="string">&quot;】已连接到服务器&quot;</span>);</span><br><span class="line">                DataInputStream inputStream = <span class="keyword">new</span> DataInputStream(socket.getInputStream());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">while</span> (inputStream.read(bytes) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="R9ORz"></a></p><h3 id="oldioclient"><a class="markdownIt-Anchor" href="#oldioclient"></a> OldIOClient</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.zerocopy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HandSomeMaker</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/12/30 15:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OldIoClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;C:&quot;</span> + File.separator + <span class="string">&quot;Program Files&quot;</span> + File.separator + <span class="string">&quot;CCleaner&quot;</span> + File.separator + <span class="string">&quot;CCleaner64.exe&quot;</span>);</span><br><span class="line">            InputStream inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            DataOutputStream outputStream = <span class="keyword">new</span> DataOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">while</span> (inputStream.read(bytes, <span class="number">0</span>, bytes.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                outputStream.write(bytes);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;传送完成，耗时：&quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line"></span><br><span class="line">            outputStream.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="ybZgx"></a></p><h2 id="新式拷贝文件"><a class="markdownIt-Anchor" href="#新式拷贝文件"></a> 新式拷贝文件</h2><p><a name="Z3slA"></a></p><h3 id="newioserver"><a class="markdownIt-Anchor" href="#newioserver"></a> NewIOServer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.zerocopy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HandSomeMaker</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/12/30 15:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewIoServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocketChannel serverSocketChannel=ServerSocketChannel.open();</span><br><span class="line">            ServerSocket serverSocket=serverSocketChannel.socket();</span><br><span class="line">            <span class="comment">//开启端口复用</span></span><br><span class="line">            serverSocket.setReuseAddress(<span class="keyword">true</span>);</span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器已启动&quot;</span>);</span><br><span class="line"></span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端已连接到服务器&quot;</span>);</span><br><span class="line">                <span class="comment">//开启阻塞</span></span><br><span class="line">                socketChannel.configureBlocking(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (socketChannel.read(byteBuffer) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    byteBuffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="EYpvm"></a></p><h3 id="newioclient"><a class="markdownIt-Anchor" href="#newioclient"></a> NewIOClient</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.zerocopy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HandSomeMaker</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/12/30 15:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewIoClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">            socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>));</span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;C:&quot;</span> + File.separator + <span class="string">&quot;Program Files&quot;</span> + File.separator + <span class="string">&quot;CCleaner&quot;</span> + File.separator + <span class="string">&quot;CCleaner64.exe&quot;</span>);</span><br><span class="line">            FileChannel fileChannel = <span class="keyword">new</span> FileInputStream(file).getChannel();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将一个通道和另一个通道直接相连接</span></span><br><span class="line">            fileChannel.transferTo(<span class="number">0</span>, fileChannel.size(), socketChannel);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;传送完成，耗时：&quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line"></span><br><span class="line">            socketChannel.close();</span><br><span class="line">            fileChannel.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="vKkYt"></a></p><h2 id="效果演示"><a class="markdownIt-Anchor" href="#效果演示"></a> 效果演示</h2><p><a name="aX5jR"></a></p><h3 id="老式拷贝文件-2"><a class="markdownIt-Anchor" href="#老式拷贝文件-2"></a> 老式拷贝文件</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1577692535223-78b50d87-5e69-42f1-9a14-09e72406041a.png#align=left&amp;display=inline&amp;height=45&amp;name=image.png&amp;originHeight=72&amp;originWidth=323&amp;size=4049&amp;status=done&amp;style=none&amp;width=202" alt="image.png" /><br /><a name="OcY5p"></a></p><h3 id="新式拷贝文件-2"><a class="markdownIt-Anchor" href="#新式拷贝文件-2"></a> 新式拷贝文件</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1577692553540-25e5750c-67bf-4e0a-975b-10f91fff7ca7.png#align=left&amp;display=inline&amp;height=41&amp;name=image.png&amp;originHeight=60&amp;originWidth=296&amp;size=3827&amp;status=done&amp;style=none&amp;width=201" alt="image.png" /><br /><a name="lN7q5"></a></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>显然，新式拷贝文件要比老式拷贝快上成倍的速度。<br />但是也不绝对，详情请查看<a href="https://www.cnblogs.com/interdrp/p/3785164.html">https://www.cnblogs.com/interdrp/p/3785164.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 网络编程 </tag>
            
            <tag> io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIO非阻塞模型</title>
      <link href="/posts/nio_1/"/>
      <url>/posts/nio_1/</url>
      
        <content type="html"><![CDATA[<h1 id="nio非阻塞模型"><a class="markdownIt-Anchor" href="#nio非阻塞模型"></a> NIO非阻塞模型</h1><p><a name="3tuuc"></a></p><h1 id="nio概述"><a class="markdownIt-Anchor" href="#nio概述"></a> NIO概述</h1><p><a name="5SRK7"></a></p><h2 id="对比bio"><a class="markdownIt-Anchor" href="#对比bio"></a> 对比BIO</h2><p><a name="edSqH"></a></p><h3 id="bio即blockio"><a class="markdownIt-Anchor" href="#bio即blockio"></a> BIO即blockIO：</h3><ul><li>ServerSocket.accept()</li></ul><p>调用了这个函数后，就会一直处于阻塞状态，直到服务端接收了新的连接请求</p><ul><li>InputStream.read(),OutputStream.write()</li></ul><p>这个其实更严重，若用户长时间不输入信息则会造成长时间的阻塞</p><ul><li>无法在同一线程里处理多个StreamIO</li></ul><p>即使在伪异步优化以后，也是多个线程处理多个流的IO<br /><a name="FQAWA"></a></p><h2 id="非阻塞式nio"><a class="markdownIt-Anchor" href="#非阻塞式nio"></a> 非阻塞式NIO</h2><p><a name="LAG1x"></a></p><h3 id="nio即nonblocking"><a class="markdownIt-Anchor" href="#nio即nonblocking"></a> NIO即NonBlocking：</h3><ul><li>使用channel代替Stream</li></ul><p>流是单向的写入或者写出数据，而channel是有两种模式的，一种是类似于Stream的单向阻塞式操作，另一种则是非阻塞式的方法。</p><ul><li>使用Selector监控多条Channel</li></ul><p>非阻塞的意义则是某一channel的去数据时，若数据没准备好即立刻返回状态并保持查询状态。</p><ul><li>可以在一个线程处理多个ChannelIO</li></ul><p>多线程是很浪费资源的，而一个线程处理多个Channel则把现成的利用率最大化了。<br /><a name="UboLS"></a></p><h1 id="channel与buffer"><a class="markdownIt-Anchor" href="#channel与buffer"></a> Channel与Buffer</h1><p><a name="uYS5j"></a></p><h2 id="buffer是干什么的"><a class="markdownIt-Anchor" href="#buffer是干什么的"></a> Buffer是干什么的？</h2><p>在NIO中读写是要通过Buffer来完成的，在Channel写数据是要写在Buffer中的，读数据也是要在Buffer中读取的，因此Buffer也是双向的。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574080021222-0572aaff-8802-460e-ab37-27ea97b77bdf.png#align=left&amp;display=inline&amp;height=90&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=122&amp;originWidth=588&amp;size=25044&amp;status=done&amp;style=none&amp;width=436" alt="image.png" /><br /><a name="TNSvo"></a></p><h2 id="buffer的写入数据"><a class="markdownIt-Anchor" href="#buffer的写入数据"></a> Buffer的写入数据：</h2><p><a name="5wLCJ"></a></p><h3 id="step-1"><a class="markdownIt-Anchor" href="#step-1"></a> step 1：</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574080147624-42308ae3-66c3-4c38-bf13-56683fdf7cfd.png#align=left&amp;display=inline&amp;height=362&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=392&amp;originWidth=426&amp;size=49329&amp;status=done&amp;style=none&amp;width=393" alt="image.png" /><br />如图所示，图中由三个指针类的变量：postion、limit、capacity。<br />capacity：即整个Buffer最大的容量，及最多可写到的位置。<br />position：即当前位置<br />在最开始的时候，position指向最开始，从最开始的地方开始写入。<br />而limit暂时不做解释，他只是指在了capacity这个位置。<br /><a name="jcdZq"></a></p><h3 id="step-2"><a class="markdownIt-Anchor" href="#step-2"></a> step 2：</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574080395237-4ad315c2-012b-4edc-aa85-6f05ff4d61a5.png#align=left&amp;display=inline&amp;height=370&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=394&amp;originWidth=419&amp;size=52792&amp;status=done&amp;style=none&amp;width=394" alt="image.png" /><br />在写入一定的数据后，poistion的位置发生了改变，这时候为了接下来的读取，调用flip()方法。<br /><a name="nql5z"></a></p><h3 id="step-3"><a class="markdownIt-Anchor" href="#step-3"></a> step 3：</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574080536507-9c48ebe6-c093-44cf-8262-438c3c255b57.png#align=left&amp;display=inline&amp;height=344&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=385&amp;originWidth=415&amp;size=53237&amp;status=done&amp;style=none&amp;width=371" alt="image.png" /><br />调用flip函数后，position对到了最开始的位置，limit移动到了写入道德最远位置。<br /><a name="37m74"></a></p><h2 id="buffer读取数据"><a class="markdownIt-Anchor" href="#buffer读取数据"></a> Buffer读取数据：</h2><p>接上图，在position和limit之间则是写入的数据。<br /><a name="fqVmd"></a></p><h3 id="情况一"><a class="markdownIt-Anchor" href="#情况一"></a> 情况一：</h3><p><a name="of5kj"></a></p><h4 id="step-1-2"><a class="markdownIt-Anchor" href="#step-1-2"></a> step 1：</h4><p>数据全部读完，position移动到了limit的位置。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574080800207-93078c4a-3852-4484-aac1-0da7bbe9383b.png#align=left&amp;display=inline&amp;height=359&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=384&amp;originWidth=409&amp;size=51706&amp;status=done&amp;style=none&amp;width=382" alt="image.png" /><br />这时候需要调用clear()函数将指针调整方便下一次写入数据。<br /><a name="60V2q"></a></p><h4 id="step-2-2"><a class="markdownIt-Anchor" href="#step-2-2"></a> step 2：</h4><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574080971748-fb7e0668-c90f-4cee-8c9a-d6d474a9a08c.png#align=left&amp;display=inline&amp;height=351&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=386&amp;originWidth=404&amp;size=51691&amp;status=done&amp;style=none&amp;width=367" alt="image.png" /><br />熟悉的样子，熟悉的配方，这里就不过多阐述了。注意：数据没有进行清除，只是移动了指针，在下一次写入数据时后进行覆盖。<br /><a name="CHGSF"></a></p><h3 id="情况二"><a class="markdownIt-Anchor" href="#情况二"></a> 情况二：</h3><p><a name="PthRg"></a></p><h4 id="step-1-3"><a class="markdownIt-Anchor" href="#step-1-3"></a> step 1：</h4><p>数据没有全部读完，却要进行模式转换。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574081258438-a0359762-5936-4caa-97d1-a1e5536d96b0.png#align=left&amp;display=inline&amp;height=387&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=389&amp;originWidth=403&amp;size=56762&amp;status=done&amp;style=none&amp;width=401" alt="image.png" /><br />这时候则调用compact()函数。<br /><a name="ILMWZ"></a></p><h4 id="step-2-3"><a class="markdownIt-Anchor" href="#step-2-3"></a> step 2：</h4><p>compat函数将未读数据拷贝到开始的位置，position会指向未读数据以下位置，在未读数据以前的数据则会进行覆盖。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574081450217-a17f402f-6243-422d-84db-204a52a0cdd9.png#align=left&amp;display=inline&amp;height=391&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=380&amp;originWidth=405&amp;size=56650&amp;status=done&amp;style=none&amp;width=417" alt="image.png" /><br /><a name="AOHA0"></a></p><h1 id="channel简析"><a class="markdownIt-Anchor" href="#channel简析"></a> Channel简析</h1><p><a name="6bOyo"></a></p><h2 id="channel的基本操作"><a class="markdownIt-Anchor" href="#channel的基本操作"></a> Channel的基本操作</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574082005312-1303815c-2b2b-44d1-8910-221f86df5543.png#align=left&amp;display=inline&amp;height=182&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=250&amp;originWidth=543&amp;size=46974&amp;status=done&amp;style=none&amp;width=396" alt="image.png" /><br />如图，进行双向的数据传输。<br /><a name="LjxT4"></a></p><h2 id="几个重要的channel"><a class="markdownIt-Anchor" href="#几个重要的channel"></a> 几个重要的Channel</h2><p>Channel的子类还有很多，这里就不一一列出了，以后找时间扩展好了。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574082084432-de7ad8b5-64dd-4a1a-9aad-44f2631ea8e2.png#align=left&amp;display=inline&amp;height=187&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=277&amp;originWidth=616&amp;size=61897&amp;status=done&amp;style=none&amp;width=415" alt="image.png" /><br />ServerSocketChannel和SocketChannel主要用于网络编程中的数据传输。<br />这里举例FileChannel的例子。<br /><a name="gacVG"></a></p><h2 id="多方法实现文件拷贝"><a class="markdownIt-Anchor" href="#多方法实现文件拷贝"></a> 多方法实现文件拷贝</h2><p>shutdown方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">(Closeable... closeable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Closeable shut : closeable) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (shut != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    shut.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a name="0SOJH"></a></p><h3 id="没有buffer的stream"><a class="markdownIt-Anchor" href="#没有buffer的stream"></a> 没有Buffer的Stream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">FileCopyRunner noBufferStreamCopy;</span><br><span class="line"></span><br><span class="line">        noBufferStreamCopy = <span class="keyword">new</span> FileCopyRunner() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(File source, File target)</span> </span>&#123;</span><br><span class="line">                InputStream input = <span class="keyword">null</span>;</span><br><span class="line">                OutputStream output = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    input = <span class="keyword">new</span> FileInputStream(source);</span><br><span class="line">                    output = <span class="keyword">new</span> FileOutputStream(target);</span><br><span class="line">                    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((result = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        output.write(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    shutdown(input, output);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;noBufferStreamCopy&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p><a name="WWfq4"></a></p><h3 id="有buffer的stream"><a class="markdownIt-Anchor" href="#有buffer的stream"></a> 有Buffer的Stream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">FileCopyRunner bufferedStreamCopy;</span><br><span class="line"></span><br><span class="line">        bufferedStreamCopy = <span class="keyword">new</span> FileCopyRunner() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(File source, File target)</span> </span>&#123;</span><br><span class="line">                BufferedInputStream input = <span class="keyword">null</span>;</span><br><span class="line">                BufferedOutputStream output = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    input = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(source));</span><br><span class="line">                    output = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(target));</span><br><span class="line">                    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                    <span class="keyword">int</span> result= <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((result = input.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        output.write(buffer, <span class="number">0</span>, result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    shutdown(input, output);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;bufferedStreamCopy&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p><a name="2cqKE"></a></p><h3 id="nio的channelcopy"><a class="markdownIt-Anchor" href="#nio的channelcopy"></a> NIO的ChannelCopy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">FileCopyRunner nioBufferCopy;</span><br><span class="line"></span><br><span class="line">        nioBufferCopy = <span class="keyword">new</span> FileCopyRunner() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(File source, File target)</span> </span>&#123;</span><br><span class="line">                FileChannel input = <span class="keyword">null</span>;</span><br><span class="line">                FileChannel output = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    input = <span class="keyword">new</span> FileInputStream(source).getChannel();</span><br><span class="line">                    output = <span class="keyword">new</span> FileOutputStream(target).getChannel();</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="keyword">while</span> ((input.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                            output.write(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                        buffer.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    shutdown(input, output);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;nioBufferCopy&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p><a name="PLpsn"></a></p><h3 id="nio的transfercopy"><a class="markdownIt-Anchor" href="#nio的transfercopy"></a> NIO的TransferCopy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">FileCopyRunner nioTransfertCopy;</span><br><span class="line"></span><br><span class="line">        nioTransfertCopy = <span class="keyword">new</span> FileCopyRunner() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(File source, File target)</span> </span>&#123;</span><br><span class="line">                FileChannel input = <span class="keyword">null</span>;</span><br><span class="line">                FileChannel output = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    input = <span class="keyword">new</span> FileInputStream(source).getChannel();</span><br><span class="line">                    output = <span class="keyword">new</span> FileOutputStream(target).getChannel();</span><br><span class="line">                    <span class="keyword">long</span> size = <span class="number">0L</span>;</span><br><span class="line">                    <span class="keyword">long</span> sumsize = input.size();</span><br><span class="line">                    <span class="keyword">while</span> (sumsize != size) &#123;</span><br><span class="line">                        size = input.transferTo(<span class="number">0</span>,sumsize,output);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    shutdown(input, output);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;nioTransfertCopy&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p><a name="xzxMB"></a></p><h2 id="运行情况测试"><a class="markdownIt-Anchor" href="#运行情况测试"></a> 运行情况测试</h2><p>打包复制类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">benchmark</span><span class="params">(FileCopyRunner test, File source, File targe)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> elapsed = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ROUNDS; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            test.copyFile(source, targe);</span><br><span class="line">            elapsed += System.currentTimeMillis() - startTime;</span><br><span class="line">            targe.delete();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(test + <span class="string">&quot;: &quot;</span> + elapsed / ROUNDS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a name="Pce9d"></a></p><h3 id="小文件实现代码"><a class="markdownIt-Anchor" href="#小文件实现代码"></a> 小文件实现代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;--------smallDemo----noBufferStreamCopy----------&quot;</span>);</span><br><span class="line">        benchmark(noBufferStreamCopy, smallFile, smallFileCopy);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------smallDemo----bufferedStreamCopy----------&quot;</span>);</span><br><span class="line">        benchmark(bufferedStreamCopy, smallFile, smallFileCopy);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------smallDemo----nioBufferCopy----------&quot;</span>);</span><br><span class="line">        benchmark(nioBufferCopy, smallFile, smallFileCopy);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------smallDemo----nioTransferCopy----------&quot;</span>);</span><br><span class="line">        benchmark(nioTransferCopy, smallFile, smallFileCopy);</span><br></pre></td></tr></table></figure><p>OutPut：<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574087861716-d517a81a-2295-4467-9ec8-92b32bd6261d.png#align=left&amp;display=inline&amp;height=186&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=214&amp;originWidth=528&amp;size=14894&amp;status=done&amp;style=none&amp;width=459" alt="image.png" /><br /><a name="JNp7o"></a></p><h3 id="大文件实现代码"><a class="markdownIt-Anchor" href="#大文件实现代码"></a> 大文件实现代码：</h3><p>OutPut：<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574089385350-9dd6b1c9-41b5-4f3e-be7e-b54f1b1c4105.png#align=left&amp;display=inline&amp;height=210&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=222&amp;originWidth=488&amp;size=15359&amp;status=done&amp;style=none&amp;width=461" alt="image.png" /><br />大文件暂不做处理了，类似，而且耗时久。<br /><a name="drPpR"></a></p><h3 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论：</h3><ol><li>缓冲区对于IO的帮助是很大的</li><li>NIO相比传统IO差距并不大，不过相对来说NIO稍微好一点。（JDK1.4时推出的NIO，相比传统IO性能极佳，新版本的IO基层也用了NIO的方法，所以性能也不会太差）。<br /><a name="BnZ31"></a></li></ol><h1 id="selector简析"><a class="markdownIt-Anchor" href="#selector简析"></a> Selector简析</h1><p><a name="IGVFw"></a></p><h2 id="selector与channel"><a class="markdownIt-Anchor" href="#selector与channel"></a> Selector与Channel</h2><p>可以选择通道进行非阻塞式的数据传输，但是通道是否可操作却需要不停的询问，因此需要用Selector监听Channel。<br />在使用之前，要将Channel注册到Selector中，形成下图状态。<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574088583984-c9464e1a-7ef5-4171-b2c6-312b52eb7edb.png#align=left&amp;display=inline&amp;height=245&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=303&amp;originWidth=649&amp;size=76821&amp;status=done&amp;style=none&amp;width=524" alt="image.png" /><br /><a name="7daY0"></a></p><h2 id="channel的状态变化"><a class="markdownIt-Anchor" href="#channel的状态变化"></a> Channel的状态变化</h2><p>CONNECT：与服务器建立连接<br />ACCEPT：服务器端接受了请求<br />READ：有可读取信息<br />WRITE：可写入状态<br />无状态：没有任何状态。<br />无论哪一种Channel都会处于一种状态<br /><a name="xZhQy"></a></p><h2 id="在selector上注册channel"><a class="markdownIt-Anchor" href="#在selector上注册channel"></a> 在Selector上注册Channel</h2><p>inserstOps()：注册的状态<br />readyOps()：显示可操作的状态<br />channel()：返回注册的channel对象<br />selector()：所注册的是哪个selector对象<br />attachment()：附加对象<br /><a name="Twc5L"></a></p><h2 id="使用selector选择channel"><a class="markdownIt-Anchor" href="#使用selector选择channel"></a> 使用Selector选择Channel</h2><p><a name="TQcgr"></a></p><h3 id="没有开启通道"><a class="markdownIt-Anchor" href="#没有开启通道"></a> 没有开启通道：</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574089183486-8675fee3-c414-4af5-90d4-b347e830476d.png#align=left&amp;display=inline&amp;height=208&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=285&amp;originWidth=604&amp;size=57493&amp;status=done&amp;style=none&amp;width=441" alt="image.png" /><br /><a name="XzNj0"></a></p><h3 id="开启了一个通道"><a class="markdownIt-Anchor" href="#开启了一个通道"></a> 开启了一个通道：</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574089212557-9e4a3540-bef0-44cd-8fb0-e53c0efd6194.png#align=left&amp;display=inline&amp;height=230&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=308&amp;originWidth=585&amp;size=60945&amp;status=done&amp;style=none&amp;width=437" alt="image.png" /><br />注意：处理完Channel需要手动重置Channel为等待状态<br /><a name="onmuA"></a></p><h3 id="开启了两个通道"><a class="markdownIt-Anchor" href="#开启了两个通道"></a> 开启了两个通道：</h3><p><br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1574089346583-bc1d0263-dedc-4313-8458-db7c1f86502f.png#align=left&amp;display=inline&amp;height=229&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=307&amp;originWidth=590&amp;size=66071&amp;status=done&amp;style=none&amp;width=440" alt="image.png" /><br /><br /><br /><br /><br /></p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 网络编程 </tag>
            
            <tag> io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于BIO的多人聊天室</title>
      <link href="/posts/bio/"/>
      <url>/posts/bio/</url>
      
        <content type="html"><![CDATA[<h1 id="基于bio的多人聊天室"><a class="markdownIt-Anchor" href="#基于bio的多人聊天室"></a> 基于BIO的多人聊天室</h1><p><a name="TI8tI"></a></p><h1 id="bio编程模型概述"><a class="markdownIt-Anchor" href="#bio编程模型概述"></a> BIO编程模型概述</h1><p>Acceptor：接受客户的请求<br />Client：客户端发送的请求<br /><a name="DvYcq"></a></p><h2 id="问题引出"><a class="markdownIt-Anchor" href="#问题引出"></a> 问题引出：</h2><p>如果像前一个Socket和ServerSocket的模型一样设计<br />在Client发送请求的时候，Acceptor接受了以后，就不能再接受更多的请求了，就变成了自言自语模式了<br /><a name="PB9Nr"></a></p><h2 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法：</h2><p>因此引出了的Handler来处理请求，于是再发送请求，Acceptor就可以接受请求了。<br />形成模型如下图：<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1573913217517-fc2b0f48-0fd2-4f0e-a95c-2962f7f7d96d.png#align=left&amp;display=inline&amp;height=239&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=378&amp;originWidth=820&amp;size=190688&amp;status=done&amp;style=none&amp;width=519" alt="image.png" /><br />这样的模型即BIO传统模型<br /><a name="S4IW2"></a></p><h2 id="主要功能"><a class="markdownIt-Anchor" href="#主要功能"></a> 主要功能</h2><ol><li>基于BIO模型</li><li>支持多人同时在线</li><li>每个用户的发言都被转发给其他用户<br /><a name="fR4gE"></a></li></ol><h2 id="架构设计"><a class="markdownIt-Anchor" href="#架构设计"></a> 架构设计</h2><p>首先需要一个主线程来做Acceptor<br />其次需要另外一个线程来做Handler，来进行数据处理和数据据读写<br />每一个客户都要对应一个Handler<br />服务器端需要存储所有客户信息，才可以把消息广播给所有客户<br />客户端不能在输入的时候阻塞接收信息<br /><a name="6lULc"></a></p><h1 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h1><p><a name="1d93Y"></a></p><h2 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo2.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String DEFAULT_IP=<span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT=<span class="number">9999</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String QUIT=<span class="string">&quot;quit&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader reader;</span><br><span class="line">    <span class="keyword">private</span> BufferedWriter writer;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(msg!=<span class="keyword">null</span>&amp;&amp;!socket.isOutputShutdown())&#123;</span><br><span class="line">            writer.write(msg+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">receive</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String msg=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!socket.isInputShutdown())&#123;</span><br><span class="line">            msg=reader.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isQuit</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QUIT.equalsIgnoreCase(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (writer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端[&quot;</span>+socket.getPort()+<span class="string">&quot;]关闭&quot;</span>);</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket=<span class="keyword">new</span> Socket(DEFAULT_IP,DEFAULT_PORT);</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端[&quot;</span>+DEFAULT_IP+<span class="string">&quot;]成功启动&quot;</span>);</span><br><span class="line">            writer=<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream()));</span><br><span class="line">            reader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> UserInputHander(<span class="keyword">this</span>)).start();</span><br><span class="line">            String msg=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((msg=receive())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="1I9Uj"></a></p><h3 id="线程部分与输出不同线程"><a class="markdownIt-Anchor" href="#线程部分与输出不同线程"></a> 线程部分（与输出不同线程）：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo2.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInputHander</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ChatClient chatClient;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader reader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserInputHander</span><span class="params">(ChatClient chatClient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.chatClient = chatClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                String msg = reader.readLine();</span><br><span class="line">                chatClient.send(msg);</span><br><span class="line">                <span class="keyword">if</span> (chatClient.isQuit(msg)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="a53oS"></a></p><h3 id="主函数"><a class="markdownIt-Anchor" href="#主函数"></a> 主函数：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo2.client;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChatClient chatClient=<span class="keyword">new</span> ChatClient();</span><br><span class="line">        chatClient.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="fL4ML"></a></p><h2 id="服务器"><a class="markdownIt-Anchor" href="#服务器"></a> 服务器：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo2.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT=<span class="number">9999</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String QUIT=<span class="string">&quot;quit&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Writer&gt; connectedClients;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        connectedClients=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addClient</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(socket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> port=socket.getPort();</span><br><span class="line">            BufferedWriter writer=<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream()));</span><br><span class="line">            connectedClients.put(port,writer);</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端[&quot;</span>+port+<span class="string">&quot;]已连接到服务器&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeClient</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(socket!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> port=socket.getPort();</span><br><span class="line">            <span class="keyword">if</span> (connectedClients.containsKey(port)) &#123;</span><br><span class="line">                connectedClients.get(port).close();</span><br><span class="line">                connectedClients.remove(port);</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端[&quot;</span> + port + <span class="string">&quot;]已断开连接&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">forwardMessage</span><span class="params">(Socket socket,String msg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (socket!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer port : connectedClients.keySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (port != socket.getPort()) &#123;</span><br><span class="line">                    Writer writer = connectedClients.get(port);</span><br><span class="line">                    writer.write(msg);</span><br><span class="line">                    writer.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">shutdownClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (serverSocket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            serverSocket.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器已关闭&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isQuit</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QUIT.equalsIgnoreCase(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket=<span class="keyword">new</span> ServerSocket(DEFAULT_PORT);</span><br><span class="line">            System.out.println(<span class="string">&quot;启动服务器[&quot;</span>+DEFAULT_PORT+<span class="string">&quot;]成功&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                Socket socket=serverSocket.accept();</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> ChatHander(socket,<span class="keyword">this</span>)).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                shutdownClient();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="0rRIH"></a></p><h3 id="线程部份处理用户信息"><a class="markdownIt-Anchor" href="#线程部份处理用户信息"></a> 线程部份（处理用户信息）：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo2.server;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatHander</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ChatServer chatServer;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader reader;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatHander</span><span class="params">(Socket socket,ChatServer chatServer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.chatServer=chatServer;</span><br><span class="line">        <span class="keyword">this</span>.socket=socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            chatServer.addClient(socket);</span><br><span class="line">            reader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">            String msg=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> port=socket.getPort();</span><br><span class="line">            <span class="keyword">while</span> ((msg=reader.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chatServer.isQuit(msg)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String nwmsg = <span class="string">&quot;客户端[&quot;</span> + port + <span class="string">&quot;]：&quot;</span> + msg + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                System.out.print(nwmsg);</span><br><span class="line">                chatServer.forwardMessage(socket, nwmsg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    chatServer.removeClient(socket);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="ZZ5pm"></a></p><h3 id="主函数-2"><a class="markdownIt-Anchor" href="#主函数-2"></a> 主函数：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo2.server;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChatServer chatServer=<span class="keyword">new</span> ChatServer();</span><br><span class="line">        chatServer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="0STS6"></a></p><h1 id="代码的效果"><a class="markdownIt-Anchor" href="#代码的效果"></a> 代码的效果</h1><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1573928918359-0d874587-6880-47d2-82c3-a4e51f1950fa.png#align=left&amp;display=inline&amp;height=540&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1080&amp;originWidth=1920&amp;size=156815&amp;status=done&amp;style=none&amp;width=960" alt="image.png" /><br /><a name="nEpgz"></a></p><h1 id="四-伪异步io编程"><a class="markdownIt-Anchor" href="#四-伪异步io编程"></a> 四、伪异步IO编程</h1><p>随着客户端增加和退出，会产生线程的调度和资源的浪费，回忆线程池的知识，这里引入线程池的做法来解决资源的问题。<br /><a name="Ok0DU"></a></p><h2 id="功能建模"><a class="markdownIt-Anchor" href="#功能建模"></a> 功能建模：</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1573929498513-5b2efca0-6791-4aaf-8b51-84be4955e959.png#align=left&amp;display=inline&amp;height=281&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=400&amp;originWidth=837&amp;size=143099&amp;status=done&amp;style=none&amp;width=587" alt="image.png" /><br />如果Client4用户想要加入群聊时，线程池却没有空余线程，Client则等待其他用户退出时才可以加入。<br /><a name="sr9tf"></a></p><h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现：</h2><p>这里我只对服务器端进行修改，因为客户端的资源浪费少之又少，就不做阐述了。<br />在ChatServer中增加属性：<br /><code>private ExecutorService executorService;</code><br />修改构造方法：<br />设置5个线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ChatServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        executorService= Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        connectedClients=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>修改start方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket=<span class="keyword">new</span> ServerSocket(DEFAULT_PORT);</span><br><span class="line">            System.out.println(<span class="string">&quot;启动服务器[&quot;</span>+DEFAULT_PORT+<span class="string">&quot;]成功&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                Socket socket=serverSocket.accept();</span><br><span class="line">                executorService.execute(<span class="keyword">new</span> ChatHander(socket,<span class="keyword">this</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                shutdownClient();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样我们就实现了简单的BIO的多人聊天室。<br /></p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 网络编程 </tag>
            
            <tag> io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket</title>
      <link href="/posts/socket/"/>
      <url>/posts/socket/</url>
      
        <content type="html"><![CDATA[<h1 id="socket"><a class="markdownIt-Anchor" href="#socket"></a> Socket</h1><p><a name="TBx7j"></a></p><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p><a name="raXSr"></a></p><h2 id="socket也是一种数据源"><a class="markdownIt-Anchor" href="#socket也是一种数据源"></a> Socket也是一种数据源</h2><p>数据源&lt;—IO流—&gt;应用<br /><a name="tC0Wh"></a></p><h2 id="socket是网络通信的端点"><a class="markdownIt-Anchor" href="#socket是网络通信的端点"></a> Socket是网络通信的端点</h2><p>（通过IP地址和端口号绑定）<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1573564053160-3e3bb3b2-e12f-4a75-b36f-7916ab3e1746.png#align=left&amp;display=inline&amp;height=224&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=301&amp;originWidth=571&amp;size=52074&amp;status=done&amp;style=none&amp;width=424" alt="image.png" /><br /><a name="PDtFj"></a></p><h2 id="unix中的socket"><a class="markdownIt-Anchor" href="#unix中的socket"></a> Unix中的Socket</h2><p><a name="CY0mv"></a></p><h3 id="unix系统中-一切都是文件"><a class="markdownIt-Anchor" href="#unix系统中-一切都是文件"></a> Unix系统中 一切都是文件。</h3><p>因为Scoket是网络通信的端点，可以进行数据的输入输入，所以Socket也可以看成文件<br /><a name="UcMF0"></a></p><h3 id="文件描述符是已打开文件的索引"><a class="markdownIt-Anchor" href="#文件描述符是已打开文件的索引"></a> 文件描述符是已打开文件的索引</h3><p>所有被打开的文件都会赋予一个文件描述符，形成文件描述符表<br /><a name="TXf4r"></a></p><h3 id="每个进程都会维护一个文件描述符表"><a class="markdownIt-Anchor" href="#每个进程都会维护一个文件描述符表"></a> 每个进程都会维护一个文件描述符表</h3><p>可能不同的文件描述符值指向同一个文件（流）<br /><a name="SQmEA"></a></p><h2 id="通过socket发送数据"><a class="markdownIt-Anchor" href="#通过socket发送数据"></a> 通过Socket发送数据</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1573564550219-0cb31cfc-2f7e-4af2-9ea5-5d777cd4a6f1.png#align=left&amp;display=inline&amp;height=233&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=327&amp;originWidth=619&amp;size=99893&amp;status=done&amp;style=none&amp;width=442" alt="image.png" /><br />1、创建socket<br />2、告诉驱动程序指定IP地址和端口号绑定到Scoket<br />3、消息发送到Socket<br />4、驱动程序收到Socket的精确定位数据<br /><a name="26AqH"></a></p><h2 id="通过socket接收数据"><a class="markdownIt-Anchor" href="#通过socket接收数据"></a> 通过Socket接收数据</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1573564657739-2b6ae20a-ddb6-4ee7-9f4d-d3431642ddab.png#align=left&amp;display=inline&amp;height=216&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=341&amp;originWidth=662&amp;size=100385&amp;status=done&amp;style=none&amp;width=419" alt="image.png" /><br />1、创建Socket<br />2、绑定IP、端口号<br />3、信息传输给Socket<br />4、读取数据<br />ServerSocker：服务器端在网络通信上的端点<br />Socket：客户端在网络通信上的端点<br /><a name="UJtet"></a></p><h1 id="建立serversocket连接"><a class="markdownIt-Anchor" href="#建立serversocket连接"></a> 建立ServerSocket连接</h1><p><a name="xxCbO"></a></p><h2 id="连接过程如下"><a class="markdownIt-Anchor" href="#连接过程如下"></a> 连接过程如下：</h2><ol><li>服务器端先调用bind绑定端口</li><li>然后进入accept阻塞状态等待客户端连接</li><li>客户端连接客户端，传入主机地址和端口号</li><li>accept接收成功返回客户端的socket</li><li>通过IO流进行信息传输</li><li>通过close关闭服务器端口</li><li>关闭服务器端口</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1573741462823-16813244-7f11-40c8-a1f3-5c4494c3255a.png#align=left&amp;display=inline&amp;height=248&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=385&amp;originWidth=922&amp;size=118508&amp;status=done&amp;style=none&amp;width=595" alt="image.png" /><br /><a name="dHwVr"></a></p><h2 id="简单代码实例如下"><a class="markdownIt-Anchor" href="#简单代码实例如下"></a> 简单代码实例如下：</h2><p>服务器端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo1.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">9999</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        BufferedWriter writer = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(DEFAULT_PORT);</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器[&quot;</span> + DEFAULT_PORT + <span class="string">&quot;]开启，正在等待客户端链接&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                socket = serverSocket.accept();</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端[&quot;</span> + socket.getPort() + <span class="string">&quot;]已连接到服务器&quot;</span>);</span><br><span class="line">                reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                String str =<span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">while</span> ((str =reader.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;quit&quot;</span>.equalsIgnoreCase(str)) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;客户端&quot;</span> + socket.getPort() + <span class="string">&quot;已断开连接&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端[&quot;</span> + socket.getPort() + <span class="string">&quot;]：&quot;</span> + str);</span><br><span class="line">                    writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream()));</span><br><span class="line">                    writer.write(<span class="string">&quot;服务器回复信息：&quot;</span> + str + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                    writer.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;服务器已经关闭&quot;</span>);</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (writer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo1.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line">public class Service &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final <span class="keyword">int</span> DEFAULT_PORT=<span class="number">9999</span>;</span><br><span class="line">        final String DEFAULT_HOST=<span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">        boolean flag=<span class="literal">true</span>;</span><br><span class="line">        Socket socket=null;</span><br><span class="line">        BufferedReader reader=null;</span><br><span class="line">        BufferedWriter writer=null;</span><br><span class="line">        try &#123;</span><br><span class="line">            socket=<span class="built_in">new</span> Socket(DEFAULT_HOST,DEFAULT_PORT);</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">&quot;客户端已开启&quot;</span>);</span><br><span class="line">            reader=<span class="built_in">new</span> BufferedReader(<span class="built_in">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">            writer=<span class="built_in">new</span> BufferedWriter(<span class="built_in">new</span> OutputStreamWriter(socket.getOutputStream()));</span><br><span class="line">            String str=null;</span><br><span class="line">            BufferedReader bufferedReader=<span class="built_in">new</span> BufferedReader(<span class="built_in">new</span> InputStreamReader(System.in));</span><br><span class="line">            while (flag) &#123;</span><br><span class="line">                str = bufferedReader.readLine();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;quit&quot;</span>.equalsIgnoreCase(str)) &#123;</span><br><span class="line">                    flag=<span class="literal">false</span>;</span><br><span class="line">                    writer.write(str);</span><br><span class="line">                    writer.flush();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                writer.write(str + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                writer.flush();</span><br><span class="line">                System.out.<span class="built_in">println</span>(reader.readLine());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                <span class="keyword">if</span> (socket != null) &#123;</span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">&quot;Service已关闭&quot;</span>);</span><br><span class="line">                    socket.<span class="built_in">close</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (writer != null) &#123;</span><br><span class="line">                    writer.<span class="built_in">close</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (reader != null) &#123;</span><br><span class="line">                    reader.<span class="built_in">close</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码实验结果：<br />客户端：<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1573741622842-b880ce39-b4b8-4058-993f-2b0de419a407.png#align=left&amp;display=inline&amp;height=224&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=194&amp;originWidth=295&amp;size=11643&amp;status=done&amp;style=none&amp;width=341" alt="image.png" /><br />服务器端：<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1573741636817-4ac38548-9434-4547-8b57-bdce94dabe1f.png#align=left&amp;display=inline&amp;height=134&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=150&amp;originWidth=377&amp;size=17453&amp;status=done&amp;style=none&amp;width=338" alt="image.png" /><br /></p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络层的简单解析与协议概述</title>
      <link href="/posts/net/"/>
      <url>/posts/net/</url>
      
        <content type="html"><![CDATA[<h1 id="网络层的简单解析与协议概述"><a class="markdownIt-Anchor" href="#网络层的简单解析与协议概述"></a> 网络层的简单解析与协议概述</h1><p><a name="S0gbQ"></a></p><h1 id="url解析与构造"><a class="markdownIt-Anchor" href="#url解析与构造"></a> URL解析与构造</h1><p><a href="http://xn--www-ej9d3pr6j74mm3vuf4d8dcyu1e.baidu.com">我们在互联网输入www.baidu.com</a><br />这个简短的信息其实全称是http://www.baidu.com:80/search?q=test&amp;safe=strict<br />其中http为协议<br />www.baidu.com为域名/IP地址<br />80为端口<br />search为路径<br />q=test&amp;safe=strict为参数<br />通过这些浏览器才能知道我们要干什么。<br /><a name="VxkFS"></a></p><h1 id="dns解析"><a class="markdownIt-Anchor" href="#dns解析"></a> DNS解析</h1><p>计算机识别二进制数字串，因此IP地址的格式像192.168.111.111的形式，但是用户无法记住这么多种数组串，而且这对数字串也很难记忆，于是浏览器采用域名的方式给予用户记忆。<br />但是计算机却只识别IP地址，所以必然要进行转换如下：<br />www.google.com-&gt;172.217.161.164<br />那么又如何解析这个域名呢？<br />首先其实完整的域名为www.google.com.root<br />但因为root是所有域名的统一样式，所以普遍不写出。<br /><a name="MfvjD"></a></p><h2 id="域名层级"><a class="markdownIt-Anchor" href="#域名层级"></a> 域名层级</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1573485344622-9bfbe066-c360-4833-80b3-b1412935714e.png#align=left&amp;display=inline&amp;height=224&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=334&amp;originWidth=720&amp;size=97845&amp;status=done&amp;style=none&amp;width=483" alt="image.png" /><br />如图所示，域名的层级通过根域名、顶级域名、次级域名、主机名的方式实现了索引结构，当需要查找的时候可以通过这种递进的方式快速查找。<br /><a name="h4WyB"></a></p><h1 id="dns查询方式"><a class="markdownIt-Anchor" href="#dns查询方式"></a> DNS查询方式</h1><p><a name="Bh9wV"></a></p><h2 id="递归查询"><a class="markdownIt-Anchor" href="#递归查询"></a> 递归查询</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1573485685291-3bf7c103-b375-44eb-82db-82fb5b8c39ed.png#align=left&amp;display=inline&amp;height=307&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=383&amp;originWidth=633&amp;size=74412&amp;status=done&amp;style=none&amp;width=507" alt="image.png" /><br /><a name="05vDN"></a></p><h2 id="迭代查询"><a class="markdownIt-Anchor" href="#迭代查询"></a> 迭代查询</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1573485697038-3479a92f-e92b-4e96-9e80-9e84b758936b.png#align=left&amp;display=inline&amp;height=297&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=373&amp;originWidth=642&amp;size=93999&amp;status=done&amp;style=none&amp;width=512" alt="image.png" /><br /><a name="o9qX9"></a></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>其中，不管是迭代查询还是递归查询，都会在域名服务器中存储缓存，方便下一次查询。<br /><a name="2OFWR"></a></p><h1 id="网络模型"><a class="markdownIt-Anchor" href="#网络模型"></a> 网络模型</h1><p><a name="4o1mS"></a></p><h2 id="参考模型"><a class="markdownIt-Anchor" href="#参考模型"></a> 参考模型</h2><p>在计算机网络中，有好几种参考模型，不过这里我们只讨论实际应用的参考模型，如下：<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1573485856149-f67fd329-19f7-473a-a5f7-0ecb34f2a604.png#align=left&amp;display=inline&amp;height=313&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=386&amp;originWidth=221&amp;size=54350&amp;status=done&amp;style=none&amp;width=179" alt="image.png" /><br /><a name="ixeSN"></a></p><h3 id="每层解释"><a class="markdownIt-Anchor" href="#每层解释"></a> 每层解释</h3><p><a name="tjag7"></a></p><h4 id="应用层"><a class="markdownIt-Anchor" href="#应用层"></a> 应用层</h4><p>用户所接触到的应用，对于不同类型的数据处理方法和格式。<br /><a name="oFQeh"></a></p><h4 id="传输层"><a class="markdownIt-Anchor" href="#传输层"></a> 传输层</h4><p>端口到端口的连接、数据传输<br /><a name="mQ6pI"></a></p><h4 id="网络层"><a class="markdownIt-Anchor" href="#网络层"></a> 网络层</h4><p>主机到主机的联系<br /><a name="t0t08"></a></p><h4 id="链路层"><a class="markdownIt-Anchor" href="#链路层"></a> 链路层</h4><p>网卡和网卡的信息传输<br /><a name="GB5Qf"></a></p><h4 id="实体层"><a class="markdownIt-Anchor" href="#实体层"></a> 实体层</h4><p>物理连接<br /><a name="ZuTvY"></a></p><h2 id="为什么要分层"><a class="markdownIt-Anchor" href="#为什么要分层"></a> 为什么要分层</h2><p>因为经过分层后，上一层只需要依赖于下一层，不需要跨层考虑，层层之间的影响降低。<br /><a name="8WaGh"></a></p><h2 id="每一层的例子"><a class="markdownIt-Anchor" href="#每一层的例子"></a> 每一层的例子</h2><p><a name="eS4Y5"></a></p><h3 id="应用层-2"><a class="markdownIt-Anchor" href="#应用层-2"></a> 应用层</h3><p>HTTP FTP(文件传输) SMTP<br /><a name="77yhP"></a></p><h3 id="传输层-2"><a class="markdownIt-Anchor" href="#传输层-2"></a> 传输层</h3><p>TCP UDP<br /><a name="M4XAc"></a></p><h3 id="网络层-2"><a class="markdownIt-Anchor" href="#网络层-2"></a> 网络层</h3><p>IP   <br /><a name="FoqqK"></a></p><h3 id="链路层-2"><a class="markdownIt-Anchor" href="#链路层-2"></a> 链路层</h3><p>Ethernet<br /><a name="xD0Nz"></a></p><h3 id="实体层-2"><a class="markdownIt-Anchor" href="#实体层-2"></a> 实体层</h3><p>电信号<br /><a name="4C60k"></a></p><h2 id="连接一切"><a class="markdownIt-Anchor" href="#连接一切"></a> 连接一切</h2><p><a name="ExEkV"></a></p><h3 id="实体层-3"><a class="markdownIt-Anchor" href="#实体层-3"></a> 实体层</h3><p>实现物理连接，传播01的电信号<br /><a name="nk6bu"></a></p><h3 id="链路层-3"><a class="markdownIt-Anchor" href="#链路层-3"></a> 链路层</h3><p>传播网卡与网卡之间的连接（MAC地址），不过MAC地址要通过广播方式传播给子网中的所有网卡，如果MAC地址匹配才收下信息，显然这个方式如果当数量增多的时候，将会大幅度降低效率。<br /><a name="iboO8"></a></p><h3 id="网络层-3"><a class="markdownIt-Anchor" href="#网络层-3"></a> 网络层</h3><p>不同于MAC地址传播，IP地址更为机智，它会识别IP地址来自于哪个子网路、哪个位置<br /><a name="PZOYT"></a></p><h3 id="传输层-3"><a class="markdownIt-Anchor" href="#传输层-3"></a> 传输层：</h3><p>主机中会有好多端口，会通过TCP、UDP来匹配端口<br /><a name="O3puu"></a></p><h3 id="应用层-3"><a class="markdownIt-Anchor" href="#应用层-3"></a> 应用层：</h3><p>通过协议传递数据。<br /><a name="jmy1U"></a></p><h1 id="网络各个层的数据包格式"><a class="markdownIt-Anchor" href="#网络各个层的数据包格式"></a> 网络各个层的数据包格式</h1><p>如图<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1573487825385-62216904-c606-4624-ac28-83e650b2d136.png#align=left&amp;display=inline&amp;height=274&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=400&amp;originWidth=855&amp;size=147603&amp;status=done&amp;style=none&amp;width=586" alt="image.png" /><br /><a name="4Dgnv"></a></p><h2 id="链路层-4"><a class="markdownIt-Anchor" href="#链路层-4"></a> 链路层</h2><p>链路层将应用层的电信号组成不同的数据包，每一个数据包即一帧（最大1518个字节）。<br />一帧由一个Ethernet标头和Ethernet数据组成。<br />标头主要包含MAC地址，即要传送到哪张网卡中，标头占18个字节。<br />因此，数据不能超过1500个字节。<br /><a name="YvxUB"></a></p><h2 id="网络层-4"><a class="markdownIt-Anchor" href="#网络层-4"></a> 网络层</h2><p>网络层依赖于链路层，因此我们不能更改链路层的标头，所以我们只能把IP地址存储到Ethernet数据中，因此Ethernet数据又被分为IP标头和IP数据。<br />IP地址包含目的IP地址和数据长度。<br /><a name="Yf33t"></a></p><h2 id="传输层-4"><a class="markdownIt-Anchor" href="#传输层-4"></a> 传输层</h2><p>同样，传输层不能改变网络层、链路层标头，我们只能在IP数据中再划分，因此我们将IP数据划分为TCP/UDP标头和TCP/UDP数据。<br />UDP标头：端口信息<br />TCP标头：端口信息+其他数据<br /><a name="IeabS"></a></p><h2 id="应用层-4"><a class="markdownIt-Anchor" href="#应用层-4"></a> 应用层</h2><p>同理，不能修改前几层标头，由于协议较多，故暂不做拆分。<br /><a name="EtDht"></a></p><h2 id="一个帧不够怎么办"><a class="markdownIt-Anchor" href="#一个帧不够怎么办"></a> 一个帧不够怎么办</h2><p>可以把一个数据分为好几个帧/数据包传输出去。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stream数据流</title>
      <link href="/posts/stream/"/>
      <url>/posts/stream/</url>
      
        <content type="html"><![CDATA[<h1 id="stream数据流"><a class="markdownIt-Anchor" href="#stream数据流"></a> Stream数据流</h1><p><a name="aGTge"></a></p><h1 id="stream基本操作"><a class="markdownIt-Anchor" href="#stream基本操作"></a> Stream基本操作：</h1><p>Collection中提供了此接口的实例化方法：<code>default Stream&lt;E&gt; stream()</code><br />Stream的主要功能是对数据进行分析处理，尤其是集合中数据的分析操作。<br /><a name="CMcpY"></a></p><h2 id="代码示例"><a class="markdownIt-Anchor" href="#代码示例"></a> 代码示例：</h2><p><a name="AGjcl"></a></p><h3 id="显示元素个数"><a class="markdownIt-Anchor" href="#显示元素个数"></a> 显示元素个数：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Word&quot;</span>, <span class="string">&quot;Happy&quot;</span>, <span class="string">&quot;Hi&quot;</span>, <span class="string">&quot;Has&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">        <span class="comment">//元素个数</span></span><br><span class="line">        System.out.println(stream.count());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>outPut：<br />5<br /><a name="iRRxz"></a></p><h3 id="filter"><a class="markdownIt-Anchor" href="#filter"></a> filter:</h3><p><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</code><br />采用了断言式的函数式接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Word&quot;</span>, <span class="string">&quot;Happy&quot;</span>, <span class="string">&quot;Hi&quot;</span>, <span class="string">&quot;Has&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">        <span class="comment">//有几个是含有字母H的</span></span><br><span class="line">        System.out.println(stream.filter((ele) -&gt; ele.toUpperCase().contains(<span class="string">&quot;H&quot;</span>)).count());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>outPut：<br />4<br /><a name="t71Cs"></a></p><h3 id="数据采集"><a class="markdownIt-Anchor" href="#数据采集"></a> 数据采集：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Word&quot;</span>, <span class="string">&quot;Happy&quot;</span>, <span class="string">&quot;Hi&quot;</span>, <span class="string">&quot;Has&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">        <span class="comment">//将满足条件的数据收集变为List集合</span></span><br><span class="line">        List&lt;String&gt; list1=stream.filter((ele) -&gt; ele.toUpperCase().contains(<span class="string">&quot;H&quot;</span>)).collect(Collectors.toList());</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>outPut：<br />[Hello, Happy, Hi, Has]<br /><a name="4DVU5"></a></p><h3 id="分页处理"><a class="markdownIt-Anchor" href="#分页处理"></a> 分页处理：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Word&quot;</span>, <span class="string">&quot;Happy&quot;</span>, <span class="string">&quot;Hi&quot;</span>, <span class="string">&quot;Has&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">        <span class="comment">//将满足条件的数据收集变为List集合</span></span><br><span class="line">        <span class="comment">//限制最多3个，跳过一个</span></span><br><span class="line">        List&lt;String&gt; list1=stream.filter((ele) -&gt; ele.toUpperCase().contains(<span class="string">&quot;H&quot;</span>)).limit(<span class="number">3</span>).skip(<span class="number">1</span>).collect(Collectors.toList());</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="ciTvl"></a></p><h1 id="mapreduce"><a class="markdownIt-Anchor" href="#mapreduce"></a> MapReduce：</h1><p>分为两部分，Map处理部分，Reduce分析部分。<br /><a name="1brA5"></a></p><h2 id="代码结构大致如下"><a class="markdownIt-Anchor" href="#代码结构大致如下"></a> 代码结构大致如下：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    People(String name,<span class="keyword">int</span> price)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.price=price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;People&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> People(<span class="string">&quot;张二三&quot;</span>,<span class="number">10000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> People(<span class="string">&quot;李二四&quot;</span>,<span class="number">20000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> People(<span class="string">&quot;王二五&quot;</span>,<span class="number">30000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> People(<span class="string">&quot;赵二六&quot;</span>,<span class="number">40000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> People(<span class="string">&quot;王二麻子&quot;</span>,<span class="number">50000</span>));</span><br><span class="line">        LongSummaryStatistics longSummaryStatistics = list.stream().filter((ele) -&gt; ele.getName().contains(<span class="string">&quot;二&quot;</span>)).mapToLong((price) -&gt; price.getPrice() * price.getPrice()).summaryStatistics();</span><br><span class="line">        System.out.println(longSummaryStatistics.getMax());</span><br><span class="line">        System.out.println(longSummaryStatistics.getAverage());</span><br><span class="line">        System.out.println(longSummaryStatistics.getCount());</span><br><span class="line">        System.out.println(longSummaryStatistics.getMin());</span><br><span class="line">        System.out.println(longSummaryStatistics.getSum());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些大数据只是JDK本身提供的支持。</p>]]></content>
      
      
      <categories>
          
          <category> io </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO数据流</title>
      <link href="/posts/io/"/>
      <url>/posts/io/</url>
      
        <content type="html"><![CDATA[<h1 id="io数据流"><a class="markdownIt-Anchor" href="#io数据流"></a> IO数据流</h1><p>通信的基础是IO模型<br />数据源------数据流------&gt;应用<br />数据源&lt;-----数据流-------应用<br /><a name="F0GTa"></a></p><h1 id="数据流"><a class="markdownIt-Anchor" href="#数据流"></a> 数据流</h1><p><a name="kPmAv"></a></p><h2 id="io流总括图"><a class="markdownIt-Anchor" href="#io流总括图"></a> IO流总括图</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599531920550-b8aee814-0360-41b1-bf46-777666550cad.png#align=left&amp;display=inline&amp;height=304&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=372&amp;originWidth=623&amp;size=23962&amp;status=done&amp;style=none&amp;width=509" alt="image.png" /><br /><a name="tThXv"></a></p><h3 id="字符流更复杂扩展"><a class="markdownIt-Anchor" href="#字符流更复杂扩展"></a> 字符流更复杂扩展</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599531973906-fc5300f8-42ce-4aee-88e1-9a276bbac5e6.png#align=left&amp;display=inline&amp;height=298&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=329&amp;originWidth=609&amp;size=16891&amp;status=done&amp;style=none&amp;width=552" alt="image.png" /><br />Buffer~：设置缓冲区，一次性多读取数据，省去了源文件的多次读取<br />Filter~：对字符流额外操作<br />InputStream~：两种流的转换，因为存储方式为逐字节存储，所以要将字节转换为字符。<br /><a name="hXOIc"></a></p><h3 id="字节流更复杂扩展"><a class="markdownIt-Anchor" href="#字节流更复杂扩展"></a> 字节流更复杂扩展</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599531991642-b14160b8-4592-4bad-be9b-e8cc0ca435bc.png#align=left&amp;display=inline&amp;height=273&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=320&amp;originWidth=737&amp;size=16483&amp;status=done&amp;style=none&amp;width=629" alt="image.png" /><br />Buffered~：设置缓冲区，一次性多读取数据，省去了源文件的多次读取<br />Data~：对基本类型变量输入输出<br /><a name="Ajqbr"></a></p><h1 id="装饰器模式"><a class="markdownIt-Anchor" href="#装饰器模式"></a> 装饰器模式</h1><p>例如BufferedInputStream：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Buffer size &lt;= 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>显然，构造方法接受一个InputStream对象结构如下：<br /><br /><br /><img src="https://cdn.nlark.com/yuque/0/2019/png/485026/1573563250335-2d53efb9-c1dd-4305-a39d-e66c79748ea8.png#align=left&amp;display=inline&amp;height=114&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=181&amp;originWidth=377&amp;size=11796&amp;status=done&amp;style=none&amp;width=238" alt="image.png" /><br />InputStream可以向上转型为各种子类，BufferedInputStream这样就不仅可以拥有自己的属性，还可以拥有加入的InputStream的属性。<br />装饰器不更改基本属性还可以叠加多个装饰器模式。</p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven的基本概念</title>
      <link href="/posts/maven-core/"/>
      <url>/posts/maven-core/</url>
      
        <content type="html"><![CDATA[<p>Maven 是一个项目管理工具。它负责管理项目开发过程中的几乎所有的东西。<br />版本、构建、输出物管理、依赖关系、文档和构建结果、项目关系、移植性管理。<br /><a name="yso2z"></a></p><h1 id="maven的目录说明"><a class="markdownIt-Anchor" href="#maven的目录说明"></a> Maven的目录说明</h1><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1599531237461-032fc5d3-dbba-4d46-a894-f453d487a503.png#align=left&amp;display=inline&amp;height=640&amp;margin=%5Bobject%20Object%5D&amp;originHeight=640&amp;originWidth=1296&amp;size=0&amp;status=done&amp;style=none&amp;width=1296" alt="" /><br /><a name="bMw4Y"></a></p><h1 id="maven的生命周期"><a class="markdownIt-Anchor" href="#maven的生命周期"></a> Maven的生命周期</h1><ul><li>clear：移除上一次构建生成的文件</li><li>compile：编辑项目的源代码</li><li>test：使用单元测试框架进行测试，测试代码不会被打包或者部署</li><li>package：接受编译好的代码，打包成可发布的格式</li><li>install：将包安装到maven本地仓库，供本地其他maven项目使用</li><li>deploy：将最终的包发布到远程仓库，供其他开发人员和maven项目使用。</li><li>site：生成项目的站点文档<br /><a name="dLTPi"></a></li></ul><h1 id="maven的标准工程结构"><a class="markdownIt-Anchor" href="#maven的标准工程结构"></a> Maven的标准工程结构</h1><p>MavenProjectRoot(项目根目录)<br />   |----src<br />   |     |----main<br />   |     |         |----java ——存放项目的.java文件<br />   |     |         |----resources ——存放项目资源文件，如spring, hibernate配置文件<br />   |     |----test<br />   |     |         |----java ——存放所有测试.java文件，如JUnit测试类<br />   |     |         |----resources ——存放项目资源文件，如spring, hibernate配置文件<br />   |----target ——项目输出位置<br />   |----pom.xml ----用于标识该项目是一个Maven项目<br /><a name="Vh9y2"></a></p><h1 id="maven的版本规范"><a class="markdownIt-Anchor" href="#maven的版本规范"></a> Maven的版本规范</h1><p>maven使用如下几个要素来唯一定位某一个输出物：<br /><a name="ksob8"></a></p><h2 id="groudid"><a class="markdownIt-Anchor" href="#groudid"></a> groudId</h2><p>团体、组织的标识符。团体标识的约定是，它以创建这个项目的组织名称的逆向域名(reverse domain name)开头。一般对应着JAVA的包的结构。例如org.apache<br /><a name="X7P1S"></a></p><h2 id="artifactid"><a class="markdownIt-Anchor" href="#artifactid"></a> artifactId</h2><p>单独项目的唯一标识符。比如我们的tomcat, commons等。不要在artifactId中包含点号(.)。<br /><a name="lV1ma"></a></p><h2 id="version"><a class="markdownIt-Anchor" href="#version"></a> version</h2><p>一个项目的特定版本。<br /><a name="HbrC2"></a></p><h2 id="packaging"><a class="markdownIt-Anchor" href="#packaging"></a> packaging</h2><p>项目的类型，默认是jar，描述了项目打包后的输出。类型为jar的项目产生一个JAR文件，类型为war的项目产生一个web应用。<br /><a name="Pl1xl"></a></p><h1 id="maven仓库与本地仓储配置"><a class="markdownIt-Anchor" href="#maven仓库与本地仓储配置"></a> maven仓库与本地仓储配置</h1><p>根据Maven坐标定义每个构建在仓库中唯一存储路径，大致为：groupId/artifactId/version/artifactId-version.packaging。<br />分类：本地仓库（每个用户只有一个本地仓库，默认是在<sub>/.m2/repository/，</sub>代表的是用户目录），<br />远程仓库（中央仓库：<a href="http://search.maven.org/%E3%80%81%E7%A7%81%E6%9C%8D%EF%BC%89">http://search.maven.org/、私服）</a><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581768397370-1a4ea706-1662-4436-b7f8-f9aa8431f1ec.png#align=left&amp;display=inline&amp;height=243&amp;margin=%5Bobject%20Object%5D&amp;originHeight=243&amp;originWidth=669&amp;size=0&amp;status=done&amp;style=none&amp;width=669" alt="" /><br />从Maven中心仓库下载到本地的jar包的默认存放在”<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">.</mi><mi>h</mi><mi>o</mi><mi>m</mi><mi>e</mi></mrow><mi mathvariant="normal">/</mi><mi mathvariant="normal">.</mi><mi>m</mi><mn>2</mn><mi mathvariant="normal">/</mi><mi>r</mi><mi>e</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>y</mi><mi mathvariant="normal">”</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">，</mi></mrow><annotation encoding="application/x-tex">{user.home}/.m2/repository”中，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">.</span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span></span><span class="mord">/</span><span class="mord">.</span><span class="mord mathdefault">m</span><span class="mord">2</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">”</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">，</span></span></span></span>{user.home}表示当前登录系统的用户目录(如&quot;C:\Users\gacl&quot;)<br />自定义jar包存放位置（本地仓库）：E盘创建文件加”repository”，修改apache-maven\conf目录下的settings.xml文件，添加<localRepository>xxxx</localRepository><br /><a name="gBHje"></a></p><h2 id="下载顺序"><a class="markdownIt-Anchor" href="#下载顺序"></a> 下载顺序</h2><p>当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库：</p><ul><li><strong>步骤 1</strong> － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。</li><li><strong>步骤 2</strong> － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。</li><li><strong>步骤 3</strong> － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。</li><li><strong>步骤 4</strong> － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。<br /><a name="JZQGy"></a></li></ul><h1 id="maven核心指令"><a class="markdownIt-Anchor" href="#maven核心指令"></a> Maven核心指令</h1><p><a name="3dRc6"></a></p><h2 id="clean"><a class="markdownIt-Anchor" href="#clean"></a> clean</h2><p>clean的主要目的是清空项目工作中产生的一些中间件，比如上次打的jar包，临时文件等。该生命周期主要用于在build生命周期之前做清理工作。<br />clean生命周期包含三个阶段：</p><table><thead><tr><th>阶段</th><th>处理</th><th>描述</th></tr></thead><tbody><tr><td><strong>pre-clean</strong></td><td>预清理</td><td>执行一些需要在clean之前完成的工作</td></tr><tr><td><strong>clean</strong></td><td>清理</td><td>移除所有上一次构建生成的文件</td></tr><tr><td><strong>post-clean</strong></td><td>后清理</td><td>执行一些需要在clean之后立刻完成的工作</td></tr></tbody></table><p>在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行，因此maven clean命令会执行pre-clean和clean阶段，而mvn post-clean命令会执行clean生命周期的三个阶段：pre-clean, clean, post-clean。<br /><a name="rm67X"></a></p><h2 id="default-build"><a class="markdownIt-Anchor" href="#default-build"></a> default (build)</h2><p>build(构建)声明周期是maven的主要生命周期，主要用于构建应用。包括23个阶段，下面介绍常用的7种：</p><table><thead><tr><th>阶段</th><th>处理</th><th>描述</th></tr></thead><tbody><tr><td><strong>validate</strong></td><td>验证项目</td><td>验证项目是否正确且所有必须信息是可用的</td></tr><tr><td><strong>compile</strong></td><td>执行编译</td><td>源代码编译在此阶段完成</td></tr><tr><td><strong>test</strong></td><td>测试</td><td>使用适当的单元测试框架运行测试。</td></tr><tr><td><strong>package</strong></td><td>打包</td><td>将编译后的代码打包成需要的格式，比如JAR</td></tr><tr><td><strong>verify</strong></td><td>检查</td><td>对集成测试的结果进行检查，以保证质量达标</td></tr><tr><td><strong>install</strong></td><td>安装</td><td>安装打包的项目到本地仓库，以供其他项目使用</td></tr><tr><td><strong>deploy</strong></td><td>部署</td><td>将在最终的build环境上面完成，拷贝最终的工程包到远程仓库中，<br />以共享给其他开发人员和工程</td></tr></tbody></table><p><a name="yNTTU"></a></p><h2 id="site"><a class="markdownIt-Anchor" href="#site"></a> site</h2><p>Maven Site 插件一般用来创建新的报告文档、部署站点等。</p><table><thead><tr><th>阶段</th><th>处理</th></tr></thead><tbody><tr><td><strong>pre-site</strong></td><td>执行一些需要在生成站点文档之前完成的工作</td></tr><tr><td><strong>site</strong></td><td>生成项目的站点文档</td></tr><tr><td><strong>post-site</strong></td><td>执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</td></tr><tr><td><strong>site-deploy</strong></td><td>将生成的站点文档部署到特定的服务器上</td></tr></tbody></table><p>经常用到的是site阶段和site-deploy阶段，用以生成和发布Maven站点。<br /><a name="QFp8N"></a></p><h1 id="依赖管理"><a class="markdownIt-Anchor" href="#依赖管理"></a> 依赖管理</h1><p>依赖范围：依赖范围scope用来控制依赖和编译，测试，运行的classpath的关系. 主要的是三种依赖关系如下：</p><ol><li>compile： 默认编译依赖范围。对于编译，测试，运行三种classpath都有效</li><li>test：测试依赖范围。只对于测试classpath有效</li><li>provided：已提供依赖范围。对于编译，测试的classpath都有效，但对于运行无效。因为由容器已经提供，例如servlet-api</li><li>runtime:运行时提供。例如:jdbc驱动<br /><a name="68qFj"></a></li></ol><h2 id="依赖传递"><a class="markdownIt-Anchor" href="#依赖传递"></a> 依赖传递：</h2><p>MakeFriends.jar直接依赖于HelloFriends.jar，而HelloFriends.jar又直接依赖于Hello.jar，那么MakeFriends.jar也依赖于Hello.jar，这就是传递性依赖，只不过这种依赖是间接依赖，如下图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581768397395-bfc44790-87d8-4f4e-bca9-9781b32c4151.png#align=left&amp;display=inline&amp;height=148&amp;margin=%5Bobject%20Object%5D&amp;originHeight=148&amp;originWidth=663&amp;size=0&amp;status=done&amp;style=none&amp;width=663" alt="" /><br /><a name="1mxYa"></a></p><h1 id="聚合继承"><a class="markdownIt-Anchor" href="#聚合继承"></a> 聚合继承</h1><p>聚合主要为了快速构建项目，继承主要为了消除重复。如果我们想一次构建多个项目模块，那我们就需要对多个项目模块进行聚合。<br /><a name="RJtjN"></a></p><h2 id="聚合配置代码"><a class="markdownIt-Anchor" href="#聚合配置代码"></a> 聚合配置代码：</h2><p><modules><br />       <module>模块一</module><br />       <module>模块二</module><br />       <module>模块三</module><br /></modules><br /><a name="4rKgF"></a></p><h2 id="继承配置代码"><a class="markdownIt-Anchor" href="#继承配置代码"></a> 继承配置代码：</h2><p><parent>  <br />          <groupId>me.gacl.maven</groupId><br />          <artifactId>ParentProject</artifactId><br />          <version>0.0.1-SNAPSHOT</version><br />          <relativePath>…/ParentProject/pom.xml</relativePath>  <br /></parent><br />其中父模块用dependencyManagement管理依赖。<br />dependencyManagement是表示依赖jar包的声明，即你在项目中的dependencyManagement下声明了依赖，maven不会加载该依赖，dependencyManagement声明可以被继承。<br />dependencyManagement的一个使用案例是当有父子项目的时候，父项目中可以利用dependencyManagement声明子项目中需要用到的依赖jar包，之后，当某个或者某几个子项目需要加载该插件的时候，就可以在子项目中dependencies节点只配置 groupId 和 artifactId就可以完成插件的引用。<br />dependencyManagement主要是为了统一管理插件，确保所有子项目使用的插件版本保持一致，类似的还是plugins和pluginManagement。</p>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端基础 </tag>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat流程</title>
      <link href="/posts/tomcat-1/"/>
      <url>/posts/tomcat-1/</url>
      
        <content type="html"><![CDATA[<p><a name="znuKs"></a></p><h1 id="tomcat启动流程"><a class="markdownIt-Anchor" href="#tomcat启动流程"></a> Tomcat启动流程</h1><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/485026/1581110101041-2cb21736-11a5-498d-8cdf-71bd0e97a43c.webp#align=left&amp;display=inline&amp;height=165&amp;margin=%5Bobject%20Object%5D&amp;originHeight=227&amp;originWidth=1024&amp;size=0&amp;status=done&amp;style=none&amp;width=746" alt="" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581117189229-9c4fa4b9-e5ff-4eb6-b552-d2307c742ea2.png#align=left&amp;display=inline&amp;height=302&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=534&amp;originWidth=1319&amp;size=189938&amp;status=done&amp;style=none&amp;width=746" alt="image.png" /><br />步骤：</p><ol><li>启动tomcat，需要调用bin/startup.bat，在startup脚本中，调用了catalina.bat。</li><li>在catalina.bat文件中，调用了bootStrap中的main方法。</li><li>在main中调用了init方法，来创建Catalina及初始化类加载器。</li><li>在main中调用了load方法，其中又调用了Cataina的load方法。</li><li>在Catalina的load方法中，需要进行一些初始化的工作，并需要构造Digester对象，用于解析XML。</li><li>调用后续组件初始化操作。</li></ol><p>加载Tomcat配置文件，初始化容器组件，监听对应端口号，准备接收客户端请求。<br /><a name="8NiX2"></a></p><h1 id="请求处理流程"><a class="markdownIt-Anchor" href="#请求处理流程"></a> 请求处理流程</h1><p><a name="dNjyB"></a></p><h2 id="配置gradlebuild"><a class="markdownIt-Anchor" href="#配置gradlebuild"></a> 配置Gradle.build</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;war&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行jar任务时会在jar文件代码清单中加入Main-Class头</span></span><br><span class="line">jar &#123;<span class="comment">//Groovy的闭包委托特性</span></span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes <span class="string">&#x27;Main-Class&#x27;</span>: <span class="string">&#x27;com.shy.todo.ToDoApp&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置阿里源</span></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven&#123; url <span class="string">&#x27;http://maven.aliyun.com/nexus/content/groups/public/&#x27;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group <span class="string">&#x27;org.example&#x27;</span></span><br><span class="line">version <span class="string">&#x27;1.0-SNAPSHOT&#x27;</span></span><br><span class="line"></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    testCompile <span class="attr">group:</span> <span class="string">&#x27;junit&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;junit&#x27;</span>, <span class="attr">version:</span> <span class="string">&#x27;4.11&#x27;</span></span><br><span class="line"></span><br><span class="line">    compile <span class="attr">group:</span> <span class="string">&#x27;org.apache.tomcat&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;tomcat-catalina&#x27;</span>, <span class="attr">version:</span> <span class="string">&#x27;9.0.30&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UTF-8</span></span><br><span class="line">tasks.withType(JavaCompile) &#123;</span><br><span class="line">    options.encoding = <span class="string">&quot;UTF-8&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有生成web.xml文件的解决方法：<br /><a href="https://www.jianshu.com/p/2bd34845df13">https://www.jianshu.com/p/2bd34845df13</a><br /><a name="JMihs"></a></p><h2 id="webxml配置如下"><a class="markdownIt-Anchor" href="#webxml配置如下"></a> web.xml配置如下：</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DemoServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>DemoServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DemoServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo/findAll<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="oFOLn"></a></p><h2 id="tomcat测试"><a class="markdownIt-Anchor" href="#tomcat测试"></a> Tomcat测试：</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581125741836-efd7c650-7759-4ca8-bf50-0c08b5c8489f.png#align=left&amp;display=inline&amp;height=71&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=142&amp;originWidth=1374&amp;size=35276&amp;status=done&amp;style=none&amp;width=687" alt="image.png" /><br />如图，成功执行。<br />那么他又是如何找到web.xml并调用类的呢？<br /><a name="VkFjj"></a></p><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>结构如下<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581126651808-d0f4cf4c-6e11-42cb-8ba5-75553624bf8c.png#align=left&amp;display=inline&amp;height=192&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=384&amp;originWidth=1541&amp;size=32038&amp;status=done&amp;style=none&amp;width=770.5" alt="image.png" /><br />Mapper组件的功能就是将用户请求的URL定位到一个Servlet，它的工作原理是：<br />Mapper组件保存了Web应用的配置信息，其实就是容器组件与访问路径的映射关系，比如Host里配置域名、Context配置Web应用路径、Wrapper里配置Servlet映射的路径。<br /><br /><br />当请求到来时，Mapper组件通过解析请求的URL里的域名和路径，再到自己保存的Map里去查找，就能定位到一个Servlet，注意，一个URL只能定位到一个Wrapper容器，也就是Servlet。<br /><a name="DgabY"></a></p><h3 id="具体步骤"><a class="markdownIt-Anchor" href="#具体步骤"></a> 具体步骤：</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581127465857-35c9cd02-3e05-4355-beff-b0bb70851e90.png#align=left&amp;display=inline&amp;height=246&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=319&amp;originWidth=968&amp;size=216555&amp;status=done&amp;style=none&amp;width=746" alt="image.png" /></p>]]></content>
      
      
      <categories>
          
          <category> tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端基础 </tag>
            
            <tag> web基础 </tag>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat的安装配置与架构</title>
      <link href="/posts/tomcat-1/"/>
      <url>/posts/tomcat-1/</url>
      
        <content type="html"><![CDATA[<h1 id="tomcat的安装配置与架构"><a class="markdownIt-Anchor" href="#tomcat的安装配置与架构"></a> Tomcat的安装配置与架构</h1><p><a name="YkM2z"></a></p><h1 id="下载tomcat"><a class="markdownIt-Anchor" href="#下载tomcat"></a> 下载Tomcat</h1><p>访问官网<a href="https://tomcat.apache.org/download-80.cgi">https://tomcat.apache.org/download-80.cgi</a><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581009121061-083a737f-2df3-44ef-9957-2f29a5f55a58.png#align=left&amp;display=inline&amp;height=29&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=29&amp;originWidth=290&amp;size=4188&amp;status=done&amp;style=none&amp;width=290" alt="image.png" /><br />下载8.5的版本。<br />在目录下找到startup.bat 双击启动tomcat<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581009895213-af787f36-0eee-43d8-aa89-66c628cc99a8.png#align=left&amp;display=inline&amp;height=96&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=96&amp;originWidth=636&amp;size=16636&amp;status=done&amp;style=none&amp;width=636" alt="image.png" /><br />注意，这里如果一闪而过需要编辑startup.bat 增加个pasue查看原因<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581011869467-8d6d4401-a548-4fed-aa6d-7b7f99fb1feb.png#align=left&amp;display=inline&amp;height=57&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=57&amp;originWidth=606&amp;size=3399&amp;status=done&amp;style=none&amp;width=606" alt="image.png" /><br />如图示没有配置JAVA_HOME或者JRE_HOME<br />运行成功界面:<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581012057941-7d293c8c-cce1-457a-ab18-d9c1499f2bc8.png#align=left&amp;display=inline&amp;height=567&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=567&amp;originWidth=1297&amp;size=58461&amp;status=done&amp;style=none&amp;width=1297" alt="image.png" /><br />访问8080：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581012100034-254eb3f7-f0e1-49f3-9fe5-b98b7c09997a.png#align=left&amp;display=inline&amp;height=922&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=922&amp;originWidth=1274&amp;size=158515&amp;status=done&amp;style=none&amp;width=1274" alt="image.png" /><br /><a name="8vml2"></a></p><h1 id="配置环境变量"><a class="markdownIt-Anchor" href="#配置环境变量"></a> 配置环境变量</h1><p>增加变量：<br />CATALINA_HOME、CATALINA_BASE<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581012904101-fcee7922-91a0-4498-b70b-67823cc7afa9.png#align=left&amp;display=inline&amp;height=50&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=50&amp;originWidth=465&amp;size=6133&amp;status=done&amp;style=none&amp;width=465" alt="image.png" /><br />配置Path：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581013294393-a45554dc-c566-49b0-abc0-a406ab7ad22b.png#align=left&amp;display=inline&amp;height=47&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=47&amp;originWidth=176&amp;size=1517&amp;status=done&amp;style=none&amp;width=176" alt="image.png" /><br />测试：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581013357375-0315a297-a208-4d53-a415-6a1ea0514e7d.png#align=left&amp;display=inline&amp;height=128&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=128&amp;originWidth=805&amp;size=10167&amp;status=done&amp;style=none&amp;width=805" alt="image.png" /><br />成功<br /><a name="jaJVO"></a></p><h1 id="配置idea环境"><a class="markdownIt-Anchor" href="#配置idea环境"></a> 配置IDEA环境</h1><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581014585709-05e04199-5da9-4abe-a5f3-c0fa017225a9.png#align=left&amp;display=inline&amp;height=326&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=326&amp;originWidth=395&amp;size=24291&amp;status=done&amp;style=none&amp;width=395" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581017407980-1045a6fc-c809-4cb6-9cd7-70eb1e30fc8a.png#align=left&amp;display=inline&amp;height=721&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=721&amp;originWidth=1092&amp;size=82495&amp;status=done&amp;style=none&amp;width=1092" alt="image.png" /><br />问题出现：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581018131848-16311cdc-bccf-4dc1-8a87-291025469f60.png#align=left&amp;display=inline&amp;height=722&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=722&amp;originWidth=1092&amp;size=66880&amp;status=done&amp;style=none&amp;width=1092" alt="image.png" /><br />如何解决：<br />打开File–&gt;setting,选中圈出选项<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581018268047-6efdbb66-e1f4-47d1-810d-0b4bc395814e.png#align=left&amp;display=inline&amp;height=715&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=715&amp;originWidth=998&amp;size=88709&amp;status=done&amp;style=none&amp;width=998" alt="image.png" /><br />选择第二个<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581022740916-af1c3016-0301-42e9-8fc5-6a36f3c989a1.png#align=left&amp;display=inline&amp;height=718&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=718&amp;originWidth=1092&amp;size=48215&amp;status=done&amp;style=none&amp;width=1092" alt="image.png" /><br />配置完成<br /><a name="sFRw5"></a></p><h1 id="tomcat架构"><a class="markdownIt-Anchor" href="#tomcat架构"></a> Tomcat架构</h1><p>详见：<a href="https://blog.csdn.net/qq_26323323/article/details/84848305">https://blog.csdn.net/qq_26323323/article/details/84848305</a><br /><a href="https://www.jianshu.com/p/8d20e1a057b1">https://www.jianshu.com/p/8d20e1a057b1</a><br /><a href="https://blog.csdn.net/weixin_42146366/article/details/98043043">https://blog.csdn.net/weixin_42146366/article/details/98043043</a> <br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/485026/1581110208973-64d63ce0-c77e-4f2d-898f-515456d40e84.webp#align=left&amp;display=inline&amp;height=309&amp;margin=%5Bobject%20Object%5D&amp;originHeight=253&amp;originWidth=508&amp;size=0&amp;status=done&amp;style=none&amp;width=621" alt="" /><br />Service是由多个Connector和一个Container组成,架构如图。<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/485026/1581110320332-032e1eac-7afb-4748-bf19-1d97ce3e49ca.webp#align=left&amp;display=inline&amp;height=467&amp;margin=%5Bobject%20Object%5D&amp;originHeight=467&amp;originWidth=697&amp;size=0&amp;status=done&amp;style=none&amp;width=697" alt="" /><br />Server服务器负责维护它所包含的所有 Service 的生命周期，包括如何初始化、如何结束服务、如何找到别人要访问的 Service。<br />Service 是在 Connector 和 Container 外面多包一层，把它们组装在一起，向外面提供服务.<br /><a name="JTVLU"></a></p><h2 id="tomcat的核心功能"><a class="markdownIt-Anchor" href="#tomcat的核心功能"></a> Tomcat的核心功能</h2><ul><li>处理Socket连接，负责网络字节流与Request和Response对象的转化</li><li>加载和管理Servlet，以及具体处理Request请求</li></ul><p>因此Tomcat设计了两个核心组件：连接器(Connector)和容器(Contaioner)来分别做这两件事情，连接器负责对外交流，容器负责内部处理。<br /><a name="jBHws"></a></p><h2 id="连接器"><a class="markdownIt-Anchor" href="#连接器"></a> 连接器</h2><p>详见：<a href="https://blog.csdn.net/cwfjimogudan/article/details/54933988">https://blog.csdn.net/cwfjimogudan/article/details/54933988</a><br />Connector将在某个指定的端口上来监听客户的请求，把从socket传递过来的数据，封装成Request，传递给Engine来处理，并从Engine处获得响应并返回给客户。<br />Tomcat通常会用到两种Connector：</p><ul><li>Http Connector 在端口8080处侦听来自客户browser的http请求。 AJP Connector</li><li>在端口8009处侦听来自其它WebServer(Apache)的servlet/jsp代理请求。</li></ul><p><a name="pBo1b"></a></p><h2 id="容器"><a class="markdownIt-Anchor" href="#容器"></a> 容器</h2><p>详见：<a href="https://www.jianshu.com/p/32809479c62c">https://www.jianshu.com/p/32809479c62c</a><br />定义了下属的各种容器，重要的是Wrapper、Host、Engine、Context等。<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/485026/1581110458106-4f4353b9-4174-4efe-a516-3cf97162ff4e.webp#align=left&amp;display=inline&amp;height=451&amp;margin=%5Bobject%20Object%5D&amp;originHeight=451&amp;originWidth=694&amp;size=0&amp;status=done&amp;style=none&amp;width=694" alt="" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/485026/1581110478531-ad86a9a0-a2a5-46c6-825c-86ea9cda3260.webp#align=left&amp;display=inline&amp;height=379&amp;margin=%5Bobject%20Object%5D&amp;originHeight=379&amp;originWidth=792&amp;size=0&amp;status=done&amp;style=none&amp;width=792" alt="" /><br /><a name="PAvbX"></a></p><h3 id="engine"><a class="markdownIt-Anchor" href="#engine"></a> Engine</h3><p>负责处理来自相关联的service的所有请求，处理后，将结果返回给service，而connector是作为service与engine的中间媒介出现的。<br />一个engine下可以配置一个默认主机，每个虚拟主机都有一个域名。当engine获得一个请求时，它把该请求匹配到虚拟主机(host)上，然后把请求交给该主机来处理。<br />Engine有一个默认主机，当请求无法匹配到任何一个虚拟主机时，将交给默认host来处理。Engine以线程的方式启动Host。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581112332415-8863b33b-9d42-43a0-b3dc-f13f7e9bb867.png#align=left&amp;display=inline&amp;height=564&amp;margin=%5Bobject%20Object%5D&amp;originHeight=564&amp;originWidth=586&amp;size=0&amp;status=done&amp;style=none&amp;width=586" alt="" /><br /><a name="host"></a></p><h3 id="host"><a class="markdownIt-Anchor" href="#host"></a> Host</h3><p>代表一个虚拟主机，每个虚拟主机和某个网络域名（Domain Name）相匹配。<br />每个虚拟主机下都可以部署一个或多个web应用，每个web应用对应于一个context，有一个context path。<br />当Host获得一个请求时，将把该请求匹配到某个Context上，然后把该请求交给该Context来处理匹配的方法是“最长匹配”，所以一个path==””的Context将成为该Host的默认Context所有无法和其它Context的路径名匹配的请求都将最终和该默认Context匹配。<br /><a name="context"></a></p><h3 id="context"><a class="markdownIt-Anchor" href="#context"></a> Context</h3><p>一个Context对应于一个Web应用，一个Web应用由一个或者多个Servlet组成Context在创建的时候将根据配置文件$ CATALINA_HOME/conf/web.xml和$ WEBAPP_HOME/WEB-INF/web.xml载入Servlet类。当Context获得请求时，将在自己的映射表(mapping table)中寻找相匹配的Servlet类，如果找到，则执行该类，获得请求的回应，并返回。<br /><a name="mKVPV"></a></p><h3 id="wrapper"><a class="markdownIt-Anchor" href="#wrapper"></a> Wrapper</h3><p>Wrapper 代表一个 Servlet，它负责管理一个 Servlet，包括的 Servlet 的装载、初始化、执行以及资源回收。Wrapper 是最底层的容器，它没有子容器了，所以调用它的 addChild 将会报错。<br />Wrapper 的实现类是 StandardWrapper，StandardWrapper 还实现了拥有一个 Servlet 初始化信息的 ServletConfig，由此看出 StandardWrapper 将直接和 Servlet 的各种信息打交道。<br /><a name="LGQos"></a></p><h2 id="生命周期"><a class="markdownIt-Anchor" href="#生命周期"></a> 生命周期</h2><p>当服务器启动的时候，tomcat需要去调用servlet的init方法和初始化容器等一系列操作，而停止的时候，也需要调用servlet的destory方法。而这些都是通过org.apache.catalina.Lifecycle接口来实现的。由这个类来制定各个组件生命周期的规范。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581113984388-74c98b31-12f3-4fb3-b16d-7d94892670d1.png#align=left&amp;display=inline&amp;height=574&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=726&amp;originWidth=856&amp;size=151369&amp;status=done&amp;style=none&amp;width=677" alt="image.png" /><br />继承图谱：<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/485026/1581119611784-978f4a52-c5d9-4e7e-b9f8-1d89a1ea815f.webp#align=left&amp;display=inline&amp;height=564&amp;margin=%5Bobject%20Object%5D&amp;originHeight=564&amp;originWidth=586&amp;size=0&amp;status=done&amp;style=none&amp;width=586" alt="" /><br />接口方法：<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/485026/1581119636040-b0dee15c-9c67-4521-8f5c-2fa0381a36b6.webp#align=left&amp;display=inline&amp;height=485&amp;margin=%5Bobject%20Object%5D&amp;originHeight=485&amp;originWidth=600&amp;size=0&amp;status=done&amp;style=none&amp;width=600" alt="" /></p>]]></content>
      
      
      <categories>
          
          <category> tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端基础 </tag>
            
            <tag> web基础 </tag>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven的安装</title>
      <link href="/posts/maven-config/"/>
      <url>/posts/maven-config/</url>
      
        <content type="html"><![CDATA[<p><a name="CDPwW"></a></p><h1 id="开发出现的问题"><a class="markdownIt-Anchor" href="#开发出现的问题"></a> 开发出现的问题</h1><ol><li>一个项目就是一个工程，如果项目过于庞大，就不适合继续使用package来划分模块。</li><li>项目中需要jar包必须手动“复制”、“粘贴”到WEB-INF/lib目录下，同样的jar包重复初见在不同的项目工程中，浪费存储空间也让工程变得臃肿。</li><li>jar包需要提前准备好，或者官网下载。</li><li>一个jar包依赖的其他jar包需要手动添加到项目中。</li></ol><p>然而Maven就能完美地解决这些问题，同样之前学习的Gradle也能解决。<br /><a name="EwiXV"></a></p><h1 id="安装配置maven"><a class="markdownIt-Anchor" href="#安装配置maven"></a> 安装配置Maven</h1><p>访问官网：<a href="https://maven.apache.org/">https://maven.apache.org/</a><br /><a name="7jFAs"></a></p><h2 id="下载文件"><a class="markdownIt-Anchor" href="#下载文件"></a> 下载文件</h2><p>下载如下文件：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581732596504-98878054-f5a1-4a1e-9da3-1951e1f4b2dc.png#align=left&amp;display=inline&amp;height=199&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=199&amp;originWidth=1396&amp;size=29739&amp;status=done&amp;style=none&amp;width=1396" alt="image.png" /><br />解压后创建一个仓库：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581732767609-7f8fa67f-6394-4e5e-bdbb-f5112e5f4398.png#align=left&amp;display=inline&amp;height=46&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=46&amp;originWidth=738&amp;size=5138&amp;status=done&amp;style=none&amp;width=738" alt="image.png" /><br /><a name="Vv4Wh"></a></p><h2 id="配置maven"><a class="markdownIt-Anchor" href="#配置maven"></a> 配置Maven</h2><p><a name="V5eju"></a></p><h3 id="配置本地仓库"><a class="markdownIt-Anchor" href="#配置本地仓库"></a> 配置本地仓库：</h3><p>编译文件setting.xml（…\conf）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;settings xmlns=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span> </span><br><span class="line">    xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span><br><span class="line">    xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;pluginGroups /&gt;</span><br><span class="line">    &lt;proxies /&gt;</span><br><span class="line">    &lt;servers /&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;localRepository&gt;D:\LocalMavenSpace&lt;/localRepository&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;mirrors&gt;</span><br><span class="line">        &lt;mirror&gt;</span><br><span class="line">            &lt;id&gt;nexus-aliyun&lt;/id&gt;</span><br><span class="line">            &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">            &lt;name&gt;Nexus aliyun&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;<span class="attr">http:</span><span class="comment">//maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span></span><br><span class="line">        &lt;/mirror&gt;</span><br><span class="line">    &lt;/mirrors&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure><p><a name="5up6L"></a></p><h3 id="配置环境变量"><a class="markdownIt-Anchor" href="#配置环境变量"></a> 配置环境变量：</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581733288476-d34100e4-dce1-49f6-9f3f-00ce818c719d.png#align=left&amp;display=inline&amp;height=154&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=190&amp;originWidth=667&amp;size=10353&amp;status=done&amp;style=none&amp;width=539" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581733349861-d211c5bd-3f9d-4eb4-8561-4596f9050084.png#align=left&amp;display=inline&amp;height=570&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=570&amp;originWidth=541&amp;size=38862&amp;status=done&amp;style=none&amp;width=541" alt="image.png" /><br /><a name="UWlOs"></a></p><h4 id="检查配置结果"><a class="markdownIt-Anchor" href="#检查配置结果"></a> 检查配置结果：</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581733389679-9183a426-ecc3-4905-b6aa-e47397bf541b.png#align=left&amp;display=inline&amp;height=119&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=119&amp;originWidth=606&amp;size=6915&amp;status=done&amp;style=none&amp;width=606" alt="image.png" /><br /><a name="BNvXw"></a></p><h2 id="配置idea"><a class="markdownIt-Anchor" href="#配置idea"></a> 配置IDEA：</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581733832543-991af46f-fffc-4d86-b5bb-066aea19a95a.png#align=left&amp;display=inline&amp;height=715&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=715&amp;originWidth=998&amp;size=75985&amp;status=done&amp;style=none&amp;width=998" alt="image.png" /><br /><a name="SYv3d"></a></p><h1 id="创建项目"><a class="markdownIt-Anchor" href="#创建项目"></a> 创建项目</h1><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581734271450-ff7aae3e-bd72-48ed-b5db-61c48046b7a8.png#align=left&amp;display=inline&amp;height=750&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=750&amp;originWidth=1251&amp;size=125957&amp;status=done&amp;style=none&amp;width=1251" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581734400301-1267129e-77a4-4902-bfa9-d845826f004f.png#align=left&amp;display=inline&amp;height=750&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=750&amp;originWidth=1251&amp;size=46506&amp;status=done&amp;style=none&amp;width=1251" alt="image.png" /><br />等待自动配置完成：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581740820315-26e154f2-2a2f-44c9-af2c-9f64d01d776c.png#align=left&amp;display=inline&amp;height=255&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=255&amp;originWidth=402&amp;size=11931&amp;status=done&amp;style=none&amp;width=402" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581753381592-7413b89a-b912-4c7a-9966-e28d4b49d373.png#align=left&amp;display=inline&amp;height=334&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=334&amp;originWidth=693&amp;size=32788&amp;status=done&amp;style=none&amp;width=693" alt="image.png" /><br />完成创建<br /></p><h1 id="maven与gradle"><a class="markdownIt-Anchor" href="#maven与gradle"></a> Maven与Gradle</h1><p>maven界面：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581842897537-3ff55ab5-badb-40cb-813f-60d68c50d77d.png#align=left&amp;display=inline&amp;height=524&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1048&amp;originWidth=1920&amp;size=164560&amp;status=done&amp;style=none&amp;width=960" alt="image.png" /><br />gradle界面：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1581842906283-33cc36fc-89d9-41fb-ad7e-fce11eb70e2b.png#align=left&amp;display=inline&amp;height=524&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1048&amp;originWidth=1920&amp;size=161861&amp;status=done&amp;style=none&amp;width=960" alt="image.png" /><br />相比Maven的繁文缛节，我更喜欢Gradle，而且Gradle的gradle.build比起Maven的pom.xml是简洁了无数倍，因此我更倾向gradle。<br />详细对比请见：<a href="https://blog.csdn.net/weixin_38405253/article/details/90598666">https://blog.csdn.net/weixin_38405253/article/details/90598666</a></p>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端基础 </tag>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光速入门XML</title>
      <link href="/posts/xml/"/>
      <url>/posts/xml/</url>
      
        <content type="html"><![CDATA[<p><a name="yql4v"></a></p><h1 id="xml"><a class="markdownIt-Anchor" href="#xml"></a> XML</h1><p>xml是可扩展标识语言，就是开发者在符合xml命名规则的基础之上，可以根据自己的需求定义自己的标签。<br /><a name="dcJ0R"></a></p><h2 id="xml文件的作用"><a class="markdownIt-Anchor" href="#xml文件的作用"></a> XML文件的作用</h2><p>主要用来存储数据<br /><a name="42cSH"></a></p><h2 id="xml文件解析的方法"><a class="markdownIt-Anchor" href="#xml文件解析的方法"></a> XML文件解析的方法</h2><p>DOM、DOM4J、SAX<br /><a name="TB6iY"></a></p><h1 id="dom4j解析xml演示"><a class="markdownIt-Anchor" href="#dom4j解析xml演示"></a> DOM4J解析XML演示</h1><p><a name="zr7jI"></a></p><h2 id="环境配置"><a class="markdownIt-Anchor" href="#环境配置"></a> 环境配置</h2><p><a name="OGTzW"></a></p><h3 id="配置gradle"><a class="markdownIt-Anchor" href="#配置gradle"></a> 配置Gradle</h3><p>项目中在src/main/java目录中放置了xml或其他配置文件，需要把它复制到jar包中，并可以在ide中调试运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#39;java&#39;</span><br><span class="line"></span><br><span class="line">jar &#123;</span><br><span class="line">    from(&#39;src&#x2F;main&#x2F;java&#39;)&#123;</span><br><span class="line">        include &#39;**&#x2F;*.xml&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述配置解决了生存jar包时xml配置文件复制的问题，可是没有解决开发环境调试的问题。<br /></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">        java&#123;</span><br><span class="line">            srcDir &#39;src&#x2F;main&#x2F;java&#39;</span><br><span class="line">        &#125;</span><br><span class="line">        resources &#123;</span><br><span class="line">            srcDir &#39;srcsrc&#x2F;main&#x2F;resources&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，resources目录下的文件也会复制到build/resource目录下，而且，不需要前面的jar中的from配置，jar包中也会存在配置文件。<br /><a name="70RAo"></a></p><h3 id="引入jar包"><a class="markdownIt-Anchor" href="#引入jar包"></a> 引入JAR包</h3><p>gradle配置如下：<br /><strong>&quot;org.dom4j:dom4j:2.1.1&quot;</strong><br /><a name="tXCg2"></a></p><h3 id="创建xml文件"><a class="markdownIt-Anchor" href="#创建xml文件"></a> 创建XML文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collage</span>&gt;</span>XX大学<span class="tag">&lt;/<span class="name">collage</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">telephone</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">telephone</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collage</span>&gt;</span>YY大学<span class="tag">&lt;/<span class="name">collage</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">telephone</span>&gt;</span>654321<span class="tag">&lt;/<span class="name">telephone</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>王五<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collage</span>&gt;</span>ZZ大学<span class="tag">&lt;/<span class="name">collage</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">telephone</span>&gt;</span>987654<span class="tag">&lt;/<span class="name">telephone</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="0SO9U"></a></p><h2 id="代码测试"><a class="markdownIt-Anchor" href="#代码测试"></a> 代码测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dom4jTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建解析器</span></span><br><span class="line">        SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过解析器将配置文件读到内存中，生成一个Document[org.dom4j]对象树</span></span><br><span class="line">            Document document = saxReader.read(<span class="string">&quot;conf/students.xml&quot;</span>);</span><br><span class="line">            <span class="comment">//获取根节点</span></span><br><span class="line">            Element root = document.getRootElement();</span><br><span class="line">            <span class="comment">//开始遍历根节点</span></span><br><span class="line">            Iterator&lt;Element&gt; iterator = root.elementIterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                Element student = iterator.next();</span><br><span class="line">                Iterator&lt;Element&gt; innerIterator = student.elementIterator();</span><br><span class="line">                <span class="keyword">while</span> (innerIterator.hasNext()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                        Element element = innerIterator.next();</span><br><span class="line">                        System.out.println(element.getStringValue());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DocumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="RIjiu"></a></p><h2 id="结果演示"><a class="markdownIt-Anchor" href="#结果演示"></a> 结果演示</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1580763515251-0449cc31-0f00-42eb-ba3a-34ed9d988eb2.png#align=left&amp;display=inline&amp;height=248&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=248&amp;originWidth=360&amp;size=7862&amp;status=done&amp;style=none&amp;width=360" alt="image.png" /><br /><a name="D9gPk"></a></p><h1 id="sax解析xml演示"><a class="markdownIt-Anchor" href="#sax解析xml演示"></a> SAX解析XML演示</h1><p><a name="qj5XV"></a></p><h2 id="解析原理"><a class="markdownIt-Anchor" href="#解析原理"></a> 解析原理</h2><p>事件驱动，边读边写<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1580767650035-b8415da6-f92c-4996-9fd0-e11c0c80dd93.png#align=left&amp;display=inline&amp;height=683&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=683&amp;originWidth=1243&amp;size=482346&amp;status=done&amp;style=none&amp;width=1243" alt="image.png" /><br /><a name="l9gkC"></a></p><h2 id="代码测试-2"><a class="markdownIt-Anchor" href="#代码测试-2"></a> 代码测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaxTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建解析工厂</span></span><br><span class="line">        SAXParserFactory factory = SAXParserFactory.newInstance();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建解析器</span></span><br><span class="line">            SAXParser saxParser = factory.newSAXParser();</span><br><span class="line">            <span class="comment">//通过解析器的parse方法</span></span><br><span class="line">            saxParser.parse(<span class="string">&quot;conf/students.xml&quot;</span>, <span class="keyword">new</span> MyDefaultHandler());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParserConfigurationException | SAXException | IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDefaultHandler</span> <span class="keyword">extends</span> <span class="title">DefaultHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startElement</span><span class="params">(String uri, String localName, String qName, Attributes attributes)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&lt;&quot;</span> + qName + <span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endElement</span><span class="params">(String uri, String localName, String qName)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&lt;&quot;</span> + qName + <span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characters</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(ch, start, length));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="U2279"></a></p><h1 id="xpath解析xml演示"><a class="markdownIt-Anchor" href="#xpath解析xml演示"></a> XPath解析XML演示</h1><p>XPath使用路径表达式来选取XML文档中的节点或节点集，节点是通过沿着路经（path）或步（steps）来选取的。<br /><a href="https://www.w3school.com.cn/xpath/index.asp">https://www.w3school.com.cn/xpath/index.asp</a><br /><a name="6bAzW"></a></p><h2 id="环境配置-2"><a class="markdownIt-Anchor" href="#环境配置-2"></a> 环境配置</h2><p><a name="iHOpY"></a></p><h3 id="引入jar包-2"><a class="markdownIt-Anchor" href="#引入jar包-2"></a> 引入jar包</h3><p><strong>&quot;jaxen:jaxen:1.2.0&quot;</strong><br /><a name="L7pyL"></a></p><h3 id="配置xml"><a class="markdownIt-Anchor" href="#配置xml"></a> 配置XML</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">database-info</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">driver_name</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">driver_name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">user</span>&gt;</span>root<span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connector</span> <span class="attr">port</span>=<span class="string">&quot;9999&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">connector</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">database-info</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="pkV1g"></a></p><h2 id="代码测试-3"><a class="markdownIt-Anchor" href="#代码测试-3"></a> 代码测试</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class SysConfigParser &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建解析器</span><br><span class="line">        SAXReader reader=new SAXReader();</span><br><span class="line">        try &#123;</span><br><span class="line">            //通过解析器的Read方法将配置文件读取到内存中，生成一个Document【org.dom4j】</span><br><span class="line">            Document document=reader.read(&quot;conf/sys_config.xml&quot;);</span><br><span class="line">            //diver-name节点元素的路径：config-&gt;database-info-&gt;driver_name</span><br><span class="line">            //driver-name节点元素的xpath路径：/config/database-info/driver_name</span><br><span class="line">            Element driverNameElt= (Element) document.selectSingleNode(&quot;/config/database-info/driver_name&quot;);</span><br><span class="line">            //获取driverNameElt节点元素对象的文本内容</span><br><span class="line">            String name=driverNameElt.getStringValue();</span><br><span class="line">            System.out.println(name);</span><br><span class="line"></span><br><span class="line">            //password元素节点路径 config-&gt;database-info-&gt;password</span><br><span class="line">            //driver-name节点元素的xpath路径：/config/database-info/password</span><br><span class="line">            //url节点元素的xpath路径：/config//password</span><br><span class="line">            //url节点元素的xpath路径：//password</span><br><span class="line">            Element driverPasswordElt= (Element) document.selectSingleNode(&quot;//password&quot;);</span><br><span class="line">            String password=driverPasswordElt.getStringValue();</span><br><span class="line">            System.out.println(password);</span><br><span class="line"></span><br><span class="line">            //connector节点元素对象的路径:config-&gt;database-info-&gt;connector</span><br><span class="line">            //获取connector节点元素对象的xpath路径：/config/database-info/connector</span><br><span class="line">            //获取connector节点元素对象的xpath路径：/config//connector</span><br><span class="line">            //获取connector节点元素对象的xpath路径：//connector</span><br><span class="line">            Element driverConnectorElt= (Element) document.selectSingleNode(&quot;//connector&quot;);</span><br><span class="line"></span><br><span class="line">            //获取属性对象</span><br><span class="line">            //方法一</span><br><span class="line">            String port=driverConnectorElt.attribute(&quot;port&quot;).getStringValue();</span><br><span class="line">            //方法二</span><br><span class="line">            String port2=driverConnectorElt.attributeValue(&quot;port&quot;);</span><br><span class="line">            System.out.println(port2);</span><br><span class="line"></span><br><span class="line">        &#125; catch (DocumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="euMLo"></a></p><h1 id="dom4jxpath解析xml文件"><a class="markdownIt-Anchor" href="#dom4jxpath解析xml文件"></a> Dom4j+XPath解析XML文件</h1><p><a name="U3EQK"></a></p><h2 id="xml文件"><a class="markdownIt-Anchor" href="#xml文件"></a> XML文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collage</span>&gt;</span>XX大学<span class="tag">&lt;/<span class="name">collage</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">telephone</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">telephone</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connector</span> <span class="attr">port</span>=<span class="string">&quot;9999&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">connector</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collage</span>&gt;</span>YY大学<span class="tag">&lt;/<span class="name">collage</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">telephone</span>&gt;</span>654321<span class="tag">&lt;/<span class="name">telephone</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connector</span> <span class="attr">port</span>=<span class="string">&quot;8888&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">connector</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>王五<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collage</span>&gt;</span>ZZ大学<span class="tag">&lt;/<span class="name">collage</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">telephone</span>&gt;</span>987654<span class="tag">&lt;/<span class="name">telephone</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connector</span> <span class="attr">port</span>=<span class="string">&quot;7777&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">connector</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="dALcb"></a></p><h2 id="代码测试-4"><a class="markdownIt-Anchor" href="#代码测试-4"></a> 代码测试</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class MixTest &#123;</span><br><span class="line">    public static void main(String[] args) throws SAXException &#123;</span><br><span class="line">        //创建解析工厂</span><br><span class="line">        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">        try &#123;</span><br><span class="line">            //创建解析器</span><br><span class="line">            DocumentBuilder builder = factory.newDocumentBuilder();</span><br><span class="line">            //通过解析器来读取配置文件，生成一个对象树</span><br><span class="line">            Document document = builder.parse(&quot;conf/students.xml&quot;);</span><br><span class="line">            //创建Xpath对象</span><br><span class="line">            XPath xPath = XPathFactory.newInstance().newXPath();</span><br><span class="line"></span><br><span class="line">            //获取ID为3的名字</span><br><span class="line">            String titleXPath = &quot;/students/student[@id=&#x27;3&#x27;]/name&quot;;</span><br><span class="line">            String res = (String) xPath.evaluate(titleXPath, document, XPathConstants.STRING);</span><br><span class="line">            System.out.println(res);</span><br><span class="line"></span><br><span class="line">            //获取所有Student节点下的Name集合</span><br><span class="line">            NodeList list = (NodeList) xPath.evaluate(&quot;/students/student&quot;, document, XPathConstants.NODESET);</span><br><span class="line">            //遍历</span><br><span class="line">            for (int i = 0; i <span class="tag">&lt; <span class="attr">list.getLength</span>(); <span class="attr">i</span>++) &#123;</span></span><br><span class="line"><span class="tag">                <span class="attr">Element</span> <span class="attr">element</span> = <span class="string">(Element)</span> <span class="attr">list.item</span>(<span class="attr">i</span>);</span></span><br><span class="line"><span class="tag">                <span class="attr">String</span> <span class="attr">name</span> = <span class="string">(String)</span> <span class="attr">xPath.evaluate</span>(&quot;<span class="attr">name</span>&quot;, <span class="attr">element</span>, <span class="attr">XPathConstants.STRING</span>);</span></span><br><span class="line"><span class="tag">                <span class="attr">System.out.println</span>(<span class="attr">name</span>);</span></span><br><span class="line"><span class="tag">            &#125;</span></span><br><span class="line"><span class="tag">        &#125; <span class="attr">catch</span> (<span class="attr">ParserConfigurationException</span> | <span class="attr">IOException</span> | <span class="attr">XPathExpressionException</span> <span class="attr">e</span>) &#123;</span></span><br><span class="line"><span class="tag">            <span class="attr">e.printStackTrace</span>();</span></span><br><span class="line"><span class="tag">        &#125;</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 零散知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端基础 </tag>
            
            <tag> 数据交互 </tag>
            
            <tag> 零碎知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet4</title>
      <link href="/posts/servlet4/"/>
      <url>/posts/servlet4/</url>
      
        <content type="html"><![CDATA[<p><a name="5sTHi"></a></p><h1 id="主要新功能"><a class="markdownIt-Anchor" href="#主要新功能"></a> 主要新功能</h1><p>Servelt4.0支持Http/2、服务器推送并提供了一套全新的API。<br /><a name="HLu3s"></a></p><h2 id="服务器推送"><a class="markdownIt-Anchor" href="#服务器推送"></a> 服务器推送</h2><p>服务器推送是Http2的直接体现，通过PushBuilder接口在servlet中公开。在JavaServer Faces API中也可以实现服务器推送功能，在RenderResponsePhase声明周期内调用，可以增强JSF页面的性能。<br /><a name="9yyel"></a></p><h2 id="全新httpservletmapping-api"><a class="markdownIt-Anchor" href="#全新httpservletmapping-api"></a> 全新HttpServletMapping API</h2><p>新的Servlet映射发现接口HttpServletMapping，框架能够获取到有关激活给定servlet的url信息。对于一些依赖这一信息来运行的框架而言，这算得上是福音了。<br /><a name="O97dX"></a></p><h1 id="服务器推送-2"><a class="markdownIt-Anchor" href="#服务器推送-2"></a> 服务器推送</h1><p><a name="IGh0Q"></a></p><h2 id="改进了浏览器感知的性能"><a class="markdownIt-Anchor" href="#改进了浏览器感知的性能"></a> 改进了浏览器感知的性能</h2><p>启用服务器推送可提高浏览器的性能，因为服务器比客户更能了解请求可能要求的附加资产（如图像，样式表和JavaScript）。         例如，服务器可以知道，无论何时浏览器请求index.html页面，它都会请求标识图像，样式表和菜单JavaScript等。由于服务器知道这一点，他们可以先发制人地开始发送这些资产处理index.html。<br /><a name="Q6Akn"></a></p><h3 id="不是web-sockets的替代品"><a class="markdownIt-Anchor" href="#不是web-sockets的替代品"></a> 不是Web Sockets的替代品</h3><p>它只是允许你填充浏览器缓存。预计构建在像JSF这样的Servlet上的框架将使用这个框架，并且我们使用push builder API来解决这个问题。<br /><a name="blog-content-area-3"></a></p><h2 id="典型的流程"><a class="markdownIt-Anchor" href="#典型的流程"></a> 典型的流程</h2><p>浏览器请求索引页面。服务器会注意到它需要_<strong>style_1.css</strong><em>和</em><strong>javaScript_1.js</strong>_  文件，所以我们从HTTP请求中获取_<strong>PushBuilder</strong><em>，并将路径设置为</em><strong>style_1.css</strong><em>文件并调用push，然后将路径设置为</em><strong>javaScript_1。 js</strong>_文件并再次调用推送。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582715400288-f1a4eff3-78f4-45b2-b9e8-15c618c1190c.png#align=left&amp;display=inline&amp;height=469&amp;margin=%5Bobject%20Object%5D&amp;originHeight=469&amp;originWidth=395&amp;size=0&amp;status=done&amp;style=none&amp;width=395" alt="" /><br /><br /><br />注意在这种情况下，CSS和JavaScript将首先返回到客户端，然后index页面返回。<br /><a name="rsQzK"></a></p><h3 id="从http请求推送生成器"><a class="markdownIt-Anchor" href="#从http请求推送生成器"></a> 从HTTP请求推送生成器</h3><p>只需从HTTP Request对象中获取推式生成器，并将路径设置为资源并推送即可。<br />在这个序列图中有两件事要注意，<br />(adsbygoogle = window.adsbygoogle || []).push({});</p><ul><li>推构建器可以重用。在示例中，我使用推式构建器将两个资源推送到CSS文件和JavaScript文件。</li><li>第二件事是index.html在推送资源后返回浏览器。</li></ul><p>原因是，如果索引在推送资源之前返回，浏览器将分析它并看到它需要这两个资源。**它会查看缓存并查看它没有这些资源，它会请求它们。**此时，浏览器缓存将不会预填充。所以推送的资源必须在索引发送之前先返回。<br /><a name="2wcRB"></a></p><h3 id="推送答应"><a class="markdownIt-Anchor" href="#推送答应"></a> 推送答应</h3><p>前面提到的其中一种框架类型是  _<strong>RST_STREAM，</strong> <em>这就是客户如何拒绝推送承诺。因此，如果服务器推送一个资源，并且浏览器已经将其存储在缓存中，那么不是让服务器发送文件，而是发送一个</em><strong>RST_STREAM</strong> _帧，表明它已经有文件文件，因此不发送它。<br /><a name="NiM1T"></a></p><h2 id="pushbuilder"><a class="markdownIt-Anchor" href="#pushbuilder"></a> PushBuilder</h2><p>要使用服务器推送，从**<em>HttpServletRequest</em><strong>获取对</strong><em>PushBuilder</em> <strong>的引用，根据需要改变生成器，然后调用  <em><strong>push（）</strong></em>  方法。<br />_ 复制_<code>PubshBuilder pubshBuilder= request.getPubshBuilder();</code><br />这会根据从中获取此构建器的</strong><em>HttpServletRequest</em>**构建推送请求<img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582715407378-a1f33cdf-aee3-436b-8a13-324fe6b47c41.png#align=left&amp;display=inline&amp;height=260&amp;margin=%5Bobject%20Object%5D&amp;originHeight=260&amp;originWidth=620&amp;size=0&amp;status=done&amp;style=none&amp;width=620" alt="" /><br /> <br />这会根据从中获取此构建器的_<strong>HttpServletRequest</strong>_生成推送请求。<br />(adsbygoogle = window.adsbygoogle || []).push({}); <br /><a name="Vety5"></a></p><h3 id="javaxservlethttppushbuilder类"><a class="markdownIt-Anchor" href="#javaxservlethttppushbuilder类"></a> javax.servlet.http.PushBuilder类</h3><p>推送请求由请求方法设置为GET 构建。有条件， 范围， 期望， 授权和请求标题被删除。只有在maxAge未过期的情况下才会添加Cookie 。请求标头将被设置为请求URL和存在的任何查询字符串。如果  If-Modified-Since  或  If-None-Match  中的任何一个出现，则  isConditional（）  将被设置为true。<br /><a name="JekTQ"></a></p><h3 id="只有uri路径必需"><a class="markdownIt-Anchor" href="#只有uri路径必需"></a> 只有URI路径必需</h3><p>唯一需要的设置是要用于推送请求的URI路径。这必须在每次调用_<strong>push（）</strong><em>之前调用  。如果路径包含查询字符串，则查询字符串将附加到现有查询字符串（如果有），并且不会发生重复数据删除。<br />以’/'开头的路径被视为绝对路径。所有其他路径都视为相对于用于创建此构建器实例的请求的上下文路径。该路径可能包含查询字符串。<br />通过 在</em><strong>pushBuilder</strong><em>实例上调用</em><strong>push（）</strong><em>方法来</em><strong>推送</strong>_资源  。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/WelcomeServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WelcomeServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span><span class="keyword">throws</span> ServletException,IOException</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(request.getRequestURI.equals(<span class="string">&quot;/index.html&quot;</span>)&amp;&amp;reqeust.isPubshSupported())&#123;</span><br><span class="line">   request.getPushBuilder().path(<span class="string">&quot;/images/logo.jpg&quot;</span>).push();</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="7C1OZ"></a></p><h3 id="过滤器和服务器推送"><a class="markdownIt-Anchor" href="#过滤器和服务器推送"></a> 过滤器和服务器推送</h3><p>解决这个问题的另一种方法是在过滤器中实现服务器推送。Jetty  在  <em><strong>org.eclipse.jetty.servlets</strong></em>  包中有一个  <em><strong>PushCacheFilter</strong></em>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.servlet4preview.http.PushBuilder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns=&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PushFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">HttpServletRequest httpServletRequest=(HttpServletRequest)request;</span><br><span class="line">String uri=httpServletRequest.getRequestURI();</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (uri) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;/index.html&quot;</span>:</span><br><span class="line">PushBuilder pushBuilder=httpServletRequest.getPushBuilder();</span><br><span class="line">pushBuilder.path(<span class="string">&quot;/styles.css&quot;</span>).push();</span><br><span class="line">pushBuilder.path(<span class="string">&quot;/logo.png&quot;</span>).push();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">chain.doFilter(request, response);;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="N2nSh"></a></p><h3 id="jsf用例"><a class="markdownIt-Anchor" href="#jsf用例"></a> JSF用例</h3><p>框架案例是服务器推送最重要的用例之一。它完全依赖于服务器事先知道客户在客户请求之前要求的资源。服务器端Web框架可以充分利用服务器推送的优势。<br />所以JSF可以很容易地使用服务器推送。所以每当JSF要呈现样式表时，例如，它将调用_<strong>encodeResourceURL</strong>_方法，这是入口点，在这里我们可以初始化服务器推送的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalContextImp</span> <span class="keyword">extends</span> <span class="title">ExternalContext</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">encodeResourceURL</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line"> ((HttpServletRequest)request).getPushBuilder().path(url).push();</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line"> <span class="keyword">return</span> ((HttpServletResponse)response).encodeURL(url);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是Web框架的工作原理，就像JSF将能够利用服务器推送修改一样。这还没有实现，我们将看看他们是如何决定这么做的，或者他们是否想出了另一种方法。<br /><a name="UMGVf"></a></p><h3 id="禁用拒绝服务器推送"><a class="markdownIt-Anchor" href="#禁用拒绝服务器推送"></a> 禁用/拒绝服务器推送</h3><p>客户端可以通过发送_<strong>SETTINGS_ENABLE_PUSH</strong><em>设置值0（零）来显式禁用服务器推送。<br />除了允许客户端使用</em><strong>SETTINGS_ENABLE_PUSH</strong><em>设置禁用服务器推送之外，servlet容器还必须尊重客户端的请求，以便不通过引用推送流的流标识符的</em><strong>CANCEL</strong><em>或</em><strong>REFUSED_STREAM</strong>_代码在更细粒度的基础上接收推送的响应。这种交互的一个常见用途是浏览器在其缓存中已有资源时。</p>]]></content>
      
      
      <categories>
          
          <category> Servlet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端基础 </tag>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传下载</title>
      <link href="/posts/fileload/"/>
      <url>/posts/fileload/</url>
      
        <content type="html"><![CDATA[<p><a name="BMU76"></a></p><h1 id="前端部分"><a class="markdownIt-Anchor" href="#前端部分"></a> 前端部分</h1><p>提供一个post方法的表单，并设置<code>enctype</code>属性（设置请求内容的MIME类型）为<code>multpart/from-data</code>，代表该表单支持文件上传，并且提供一个文件上传框：<code>&lt;input type=&quot;file&quot;&gt;。</code><br /><a name="3J79I"></a></p><h2 id="代码演示"><a class="markdownIt-Anchor" href="#代码演示"></a> 代码演示：</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;/xxx&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;description&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;file&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p><a name="UguTv"></a></p><h1 id="后端部分"><a class="markdownIt-Anchor" href="#后端部分"></a> 后端部分</h1><p>将内容通过流读取进来，举例：<br /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    InputStream in = request.getInputStream();</span><br><span class="line">    ServletOutputStream out = response.getOutputStream();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>((len = in.read(b))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        out.write(b, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果为：</span><br><span class="line">------WebKitFormBoundary5x8Olc9cfCFQzCFd</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;description&quot;</span></span><br><span class="line">这是一个测试描述</span><br><span class="line">------WebKitFormBoundary5x8Olc9cfCFQzCFd</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;file&quot;</span>; filename=<span class="string">&quot;1.txt&quot;</span></span><br><span class="line">Content-Type: text/plain</span><br><span class="line">这是<span class="number">1.</span>txt的内容</span><br><span class="line">------WebKitFormBoundary5x8Olc9cfCFQzCFd--</span><br></pre></td></tr></table></figure><p><a name="YLzaC"></a></p><h2 id="文件上传"><a class="markdownIt-Anchor" href="#文件上传"></a> 文件上传</h2><p>是apache的commons组件提供的上传组件，主要用于解析上传的输入流内容，比如上面可以看出内容都是上传的各个表单内容的字节流，并且是混杂在一起的，而该组件则可以对这些流进行分类和处理。<br /><a name="mHxqH"></a></p><h5 id="使用步骤"><a class="markdownIt-Anchor" href="#使用步骤"></a> 使用步骤</h5><p>1.添加相关jar包——<code>commons-fileupload</code>/<code>commons-io</code>（放到<code>WEB-INF/lib</code>下）<br />2.实例化工厂类<code>DiskFileItemFactory()</code>对象<br />3.实例化工厂解析类<code>ServletFileUpload()</code>对象<br />4.调用解析类对象的<code>parseRequest()</code>方法进行解析，里面直接传入<code>request</code>对象即可，返回的是一个<code>List&lt;FileItem&gt;</code>对象（解析前可以先通过<code>isMultipartContent()</code>方法来判断传入的request对象是否支持文件上传）<br /><a name="0zSsX"></a></p><h5 id="核心对象"><a class="markdownIt-Anchor" href="#核心对象"></a> 核心对象</h5><p><a name="x7MaH"></a></p><h6 id="1diskfileitemfactory"><a class="markdownIt-Anchor" href="#1diskfileitemfactory"></a> 1.DiskFileItemFactory</h6><p>工厂类<br /><a name="Snbpl"></a></p><h6 id="2servletfileupload"><a class="markdownIt-Anchor" href="#2servletfileupload"></a> 2.ServletFileUpload</h6><p>用于解析工厂对象的解析类<br /><a name="uabBQ"></a></p><h6 id="3fileitem"><a class="markdownIt-Anchor" href="#3fileitem"></a> 3.FileItem</h6><p>代表表单项，比如下面这样就是一个FileItem：<br /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;file&quot;</span>; filename=<span class="string">&quot;1.txt&quot;</span></span><br><span class="line">Content-Type: text/plain</span><br><span class="line">这是<span class="number">1.</span>txt的内容</span><br></pre></td></tr></table></figure><p>其主要提供了以下方法：<br />(1)<code>isFormField()</code>：判断是否为普通文本字段，如果返回false，表明是文件字段<br />(2)<code>getContentType()</code>：获取上传文件的类型<br />其中对于普通表单项（<code>text</code>、<code>password</code>等）提供了以下方法：<br />(1)<code>getFieldName()</code>：获取字段名<br />(2)<code>getString()</code>：获取值，可以传入编码参数来设置编码<br />对于上传的文件提供了以下方法：<br />(1)<code>getInputStream()</code>：获取文件输入流<br />(2)<code>getName()</code>：获取文件名<br />(3)<code>getSize()</code>：获取文件大小<br />(4)<code>write(File)</code>：把上传的文件内容保存到指定文件中<br /><a name="K6msr"></a></p><h5 id="上传并输出文件示例"><a class="markdownIt-Anchor" href="#上传并输出文件示例"></a> 上传并输出文件示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">    DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();  <span class="comment">//实例化工厂对象</span></span><br><span class="line">    ServletFileUpload fileupload = <span class="keyword">new</span> ServletFileUpload(factory);  <span class="comment">//实例化工厂解析对象</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;FileItem&gt; list = fileupload.parseRequest(request);  <span class="comment">//解析工厂</span></span><br><span class="line">        <span class="keyword">for</span> (FileItem f : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!f.isFormField()) &#123;  <span class="comment">//当为文件字段</span></span><br><span class="line">                String directoryname = <span class="keyword">this</span>.getServletContext().getRealPath(<span class="string">&quot;/upload&quot;</span>);</span><br><span class="line">                File directory = <span class="keyword">new</span> File(directoryname);</span><br><span class="line">                <span class="keyword">if</span>(!directory.exists() || !directory.isDirectory())&#123;  <span class="comment">//创建上传目录</span></span><br><span class="line">                    directory.mkdirs();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(f.getFieldName());   <span class="comment">//file</span></span><br><span class="line">                System.out.println(f.getName()); <span class="comment">// xxx.jpg，只有文件名</span></span><br><span class="line">                System.out.println(f.getContentType()); <span class="comment">//image/jpeg</span></span><br><span class="line">                InputStream in = f.getInputStream();</span><br><span class="line">                ServletOutputStream out = response.getOutputStream();</span><br><span class="line">                FileOutputStream file = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(directoryname, f.getName()));  <span class="comment">//根据传的文件名命名</span></span><br><span class="line">                <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">while</span> ((len = in.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    out.write(b, <span class="number">0</span>, len);  <span class="comment">//输出图像</span></span><br><span class="line">                    file.write(b, <span class="number">0</span>, len);  <span class="comment">//保存文件</span></span><br><span class="line">                &#125;</span><br><span class="line">                file.close();  <span class="comment">//关闭文件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="AyWnF"></a></p><h5 id="文件上传路径名问题"><a class="markdownIt-Anchor" href="#文件上传路径名问题"></a> 文件上传路径名问题</h5><p>可以看到上面传输的文件只会获得文件名，但在一些如IE浏览器中容易出现传输的文件名带路径的问题，如：<code>C:/XXX/xxx.xx</code>，此时上面的代码就会出错。因此可以使用<code>commons-io</code>包下<code>FilenameUtils</code>类提供的静态方法<code>getName()</code>，其对于不管是否带路径的文件字符串，都只会获取文件名部分的字符串，举例：<br /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(FilenameUtils.getName(<span class="string">&quot;c:/sda/fdg/s&quot;</span>));  <span class="comment">//s</span></span><br><span class="line">System.out.println(FilenameUtils.getName(<span class="string">&quot;c:/sda/fdg/s.fs&quot;</span>));  <span class="comment">//s.fs</span></span><br><span class="line">System.out.println(FilenameUtils.getName(<span class="string">&quot;s.de&quot;</span>));  <span class="comment">//s.de</span></span><br><span class="line">System.out.println(FilenameUtils.getName(<span class="string">&quot;fdg/s&quot;</span>));  <span class="comment">//s</span></span><br><span class="line">System.out.println(FilenameUtils.getName(<span class="string">&quot;/sda/fdg/s&quot;</span>));  <span class="comment">//s</span></span><br></pre></td></tr></table></figure><p><a name="9d03A"></a></p><h5 id="文件上传问题"><a class="markdownIt-Anchor" href="#文件上传问题"></a> 文件上传问题</h5><p><a name="huxDx"></a></p><h6 id="1注入问题"><a class="markdownIt-Anchor" href="#1注入问题"></a> 1.注入问题</h6><p>对于上面那段代码，会在项目下新建一个upload文件夹，并生成对应文件，此时访问：<code>http://127.0.0.1:8080/项目名/upload/文件名</code>即可看到刚才上传的文件内容。但是，此时要注意如果上传了像下面这样的文件：<br /></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//xxx.jsp</span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span>%&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">        <span class="attr">Runtime.getRuntime</span>()<span class="attr">.exec</span>(&quot;<span class="attr">notepad</span>&quot;);</span></span><br><span class="line"><span class="tag">    %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时，在服务器上可能就会执行该<code>notepad</code>命令打开记事本，即在服务器上执行了用户上传的脚本文件<br /><strong>解决方式：</strong><br />(1)将上传的文件放到用户无法访问到的文件路径下，如：<code>WEB-INF</code><br />(2)限制上传的文件类型，如jsp、exe、bat等<br /><a name="AePqd"></a></p><h6 id="2文件覆盖问题"><a class="markdownIt-Anchor" href="#2文件覆盖问题"></a> 2.文件覆盖问题</h6><p>对于在上传保存的路径下原有的文件，如果上传的文件和原有的文件重名，将可能发生原文件被覆盖的问题。<br /><strong>解决方式：</strong><br />给文件名进行处理，如给文件名加上UUID使得名字唯一等<br /><a name="gCQ0P"></a></p><h6 id="3文件夹文件内容过多问题"><a class="markdownIt-Anchor" href="#3文件夹文件内容过多问题"></a> 3.文件夹文件内容过多问题</h6><p><strong>解决方式：</strong><br />对文件夹目录等进行分类存储，如按日期/文件类别等<br /><a name="ykCWX"></a></p><h6 id="4文件内容过大"><a class="markdownIt-Anchor" href="#4文件内容过大"></a> 4.文件内容过大</h6><p><strong>解决方式：</strong><br />通过<code>ServletFileUpload</code>下的<code>setFileSizeMax()</code>方法限制单个文件大小，或者<code>setSizeMax()</code>设置总文件上传大小，或者通过<code>getSize()</code>获取文件大小后根据上传的文件大小进行处理，举例：<br /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line">ServletFileUpload fileupload = <span class="keyword">new</span> ServletFileUpload(factory);</span><br><span class="line">fileupload.setSizeMax(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">3</span>);  <span class="comment">//文件大小总和不超过3M</span></span><br><span class="line">fileupload.setFileSizeMax(<span class="number">1024</span> * <span class="number">1024</span>);  <span class="comment">//单个文件大小不超过1M</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileUploadBase.SizeLimitExceededException e) &#123;</span><br><span class="line">    response.getWriter().print(<span class="string">&quot;文件总和内容过大！&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileUploadBase.FileSizeLimitExceededException e) &#123;</span><br><span class="line">    response.getWriter().print(<span class="string">&quot;文件内容过大！&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="HaAk4"></a></p><h6 id="5上传文件为空"><a class="markdownIt-Anchor" href="#5上传文件为空"></a> 5.上传文件为空</h6><p><strong>解决方式：</strong><br />判断上传的文件名是否为空<br /><a name="xbfQ5"></a></p><h6 id="6产生临时文件"><a class="markdownIt-Anchor" href="#6产生临时文件"></a> 6.产生临时文件</h6><p>在上传文件过程中往往会产生临时文件，导致磁盘空间不足，或者造成磁盘空间的浪费<br /><strong>解决方式：</strong><br />(1)使用<code>DiskFileItemFactory</code>对象的<code>setRepository(File)</code>方法设置临时文件存储位置，举例：<br /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line">factory.setRepository(<span class="keyword">new</span> File(<span class="string">&quot;F:/&quot;</span>));  <span class="comment">//在F盘下存放临时文件</span></span><br></pre></td></tr></table></figure><p>(2)通过<code>FileItem</code>下的<code>delete()</code>方法将临时文件删除，举例：<br /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line">ServletFileUpload fileupload = <span class="keyword">new</span> ServletFileUpload(factory);</span><br><span class="line">List&lt;FileItem&gt; list = fileupload.parseRequest(request);</span><br><span class="line"><span class="keyword">for</span> (FileItem f : list) &#123;</span><br><span class="line">    ...</span><br><span class="line">    f.delete();  <span class="comment">//将临时文件删除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="7y7n9"></a></p><h2 id="文件下载"><a class="markdownIt-Anchor" href="#文件下载"></a> 文件下载</h2><p>在返回头response中添加下面的头信息即可：<br /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">&quot;content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=文件名&quot;</span> );</span><br><span class="line">response.setHeader(<span class="string">&quot;content-type&quot;</span>, 文件类型);</span><br></pre></td></tr></table></figure><p>举例：<br /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="keyword">this</span>.getServletContext().getRealPath(<span class="string">&quot;/img/测试图片.jpg&quot;</span>)));</span><br><span class="line">    ServletOutputStream out = response.getOutputStream();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    response.setHeader(<span class="string">&quot;content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + <span class="keyword">new</span> String(<span class="string">&quot;测试.jpg&quot;</span>.getBytes(<span class="string">&quot;utf-8&quot;</span>), <span class="string">&quot;iso-8859-1&quot;</span>));  <span class="comment">//避免文件名乱码</span></span><br><span class="line">    response.setHeader(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>((len = in.read(b)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        out.write(b, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong><br />对于上面的文件类型是手动设置十分不便，因此可以用<code>ServletContext</code>下的<code>getMimeType(文件名)</code>方法来根据文件名自动获得文件类型，举例：<br /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="keyword">this</span>.getServletContext().getMimeType(<span class="string">&quot;xxx.jpg&quot;</span>));  <span class="comment">//自动设置为image/jpeg</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Servlet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端基础 </tag>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet3</title>
      <link href="/posts/servlet3/"/>
      <url>/posts/servlet3/</url>
      
        <content type="html"><![CDATA[<p>默认Servlet3.0是没有web.xml文件的，因此servlet3.0是通过注解注册的而不是web.xml文件进行注册。<br />可以通过如下方法快速生成servlet<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582433597734-bc930080-d1be-4b68-8b3a-99d3a7d59efc.png#align=left&amp;display=inline&amp;height=347&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=694&amp;originWidth=662&amp;size=92456&amp;status=done&amp;style=none&amp;width=331" alt="image.png" /><br /><a name="SnCDU"></a></p><h1 id="注解"><a class="markdownIt-Anchor" href="#注解"></a> 注解</h1><p>web.xml和注释是一样的，所以如果做了相同操作可能会报错或者重复操作，但如果在web.xml中添加属性metadata-complete并赋值为true，则会只让web.xml注册起作用忽略注释，默认为false。<br /><a name="SMc9a"></a></p><h2 id="servlet的注解"><a class="markdownIt-Anchor" href="#servlet的注解"></a> Servlet的注解</h2><p>代码样式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/ServletDemo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response)</span> <span class="keyword">throws</span> javax.servlet.ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response)</span> <span class="keyword">throws</span> javax.servlet.ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="L9Tvo"></a></p><h3 id="url-pattern"><a class="markdownIt-Anchor" href="#url-pattern"></a> url-pattern</h3><p>注解的括号里的value、url-pattern的使用方法和web.xml中的url-pattern使用方法相同（当前形式省略了关键字value），也可以写为如下形式：@WebServlet(value={&quot;/ServletDemo&quot;,&quot;/bb&quot;,&quot;/aa&quot;})、@WebServlet(urlPattens={&quot;/ServletDemo&quot;,&quot;/bb&quot;,&quot;/aa&quot;})。<br /><a name="3Dhxl"></a></p><h3 id="servletname"><a class="markdownIt-Anchor" href="#servletname"></a> ServletName</h3><p>ServletName变为注释中的name属性，可以写为<code>@WebServlet(value = &quot;/ServletDemo&quot;,name = &quot;ServletDemo&quot;)</code>的形式并且通过类中的getServletName等方法调用。<br /><a name="Nz9Po"></a></p><h3 id="init-param"><a class="markdownIt-Anchor" href="#init-param"></a> init-param</h3><p>初始化参数拥有param-name、param-value的属性，需要在注释中按通过initParams的方法赋值，里面的值是一个数组的形式，可以添加多组，如下所示：<code>@WebServlet(value = &quot;/ServletDemo&quot;, initParams = &#123;@WebInitParam(name = &quot;name&quot;, value = &quot;张三&quot;), @WebInitParam(name = &quot;name&quot;, value = &quot;李四&quot;)&#125;)</code><br /><a name="WCJKv"></a></p><h3 id="load-on-startup"><a class="markdownIt-Anchor" href="#load-on-startup"></a> load-on-startup</h3><p>该参数用于调整加载启动顺序，在注释中通过loadOnStartup参数赋值，例如：<code>@WebServlet(value = &quot;/ServletDemo&quot;, loadOnStartup = 2)</code><br /><a name="Gj1s2"></a></p><h2 id="filter的注解"><a class="markdownIt-Anchor" href="#filter的注解"></a> Filter的注解</h2><p>@WebFilter 用于将一个类声明为<mark>过滤器</mark>，该注解将会在部署时被容器处理，容器将根据具体的属性配置将相应的类部署为过滤器。该注解具有下表给出的一些常用属性 ( 以下所有属性均为可选属性，但是 value、urlPatterns、servletNames 三者必需至少包含一个，且 value 和 urlPatterns 不能共存，如果同时指定，通常忽略 value 的取值 )，使用和创建方法和Servlet完全一致。<br /><a name="yeMQL"></a></p><h3 id="常用属性"><a class="markdownIt-Anchor" href="#常用属性"></a> 常用属性</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582436507931-a9911b70-0d81-461d-a12a-6a1da97148cf.png#align=left&amp;display=inline&amp;height=448&amp;margin=%5Bobject%20Object%5D&amp;originHeight=448&amp;originWidth=866&amp;size=0&amp;status=done&amp;style=none&amp;width=866" alt="" /><br /><a name="WoFKU"></a></p><h2 id="linster的注解"><a class="markdownIt-Anchor" href="#linster的注解"></a> Linster的注解</h2><p>Linster很简单，只有一个value的属性用于描述，因此linster注释一般不使用属性。<br /><a name="tfFl4"></a></p><h1 id="文件上传"><a class="markdownIt-Anchor" href="#文件上传"></a> 文件上传</h1><p>重点接口如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582438930556-17999fe3-9eb4-41fc-83ac-1deb156174a1.png#align=left&amp;display=inline&amp;height=421&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=842&amp;originWidth=1277&amp;size=86472&amp;status=done&amp;style=none&amp;width=638.5" alt="image.png" /><br /><a name="hGJx2"></a></p><h2 id="代码演示"><a class="markdownIt-Anchor" href="#代码演示"></a> 代码演示：</h2><p>注意，在IDEA中存在一个BUG，他不会加载空目录，空的目录idea不会更新到服务器（这应该是个bug），所以可以在里面随便放个文件，哪怕再删掉也行，我活活研究一整天。<br /><a name="CTZHU"></a></p><h3 id="html"><a class="markdownIt-Anchor" href="#html"></a> html：</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>$Title$<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/UpLoadServlet&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    文件：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;photo&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上传&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="EbzWz"></a></p><h3 id="uploadservlet"><a class="markdownIt-Anchor" href="#uploadservlet"></a> UpLoadServlet：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/UpLoadServlet&quot;)</span></span><br><span class="line"><span class="comment">//表示当前Servlet可以处理Multipart请求</span></span><br><span class="line"><span class="meta">@MultipartConfig</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpLoadServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取服务器保存上传文件的路径</span></span><br><span class="line">        String path = <span class="keyword">this</span>.getServletContext().getRealPath(<span class="string">&quot;/images&quot;</span>);</span><br><span class="line">        <span class="comment">//从请求中获取Multipart请求中的上传文件对象</span></span><br><span class="line">        Part part = request.getPart(<span class="string">&quot;photo&quot;</span>);</span><br><span class="line">        <span class="comment">//保存到path</span></span><br><span class="line">        System.out.println(path);</span><br><span class="line">        part.write(path + File.separator + part.getSubmittedFileName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="ulFDh"></a></p><h1 id="异步处理"><a class="markdownIt-Anchor" href="#异步处理"></a> 异步处理</h1><p>更多分析见：<a href="https://segmentfault.com/a/1190000012318350">https://segmentfault.com/a/1190000012318350</a><br /><a name="m5Ilq"></a></p><h2 id="问题引出"><a class="markdownIt-Anchor" href="#问题引出"></a> 问题引出</h2><p>这里与AJAX不同，这个是服务器端的异步处理。Web容器一般来说处理请求的方式是：为每个request分配一个thread。创建线程需要付出代价并且Web容器的thread pool都是有上限的。因此，在高负载情况下，thread pool都被占着了，那么后续的request就只能等待，如果运气不好客户端会报等待超时的错误。原先的解决方式是线程池，但耗时request和非耗时request混在一起导致了当大量request到一个耗时操作时，就会将HTTP thread占满，导致整个Web容器就会无法响应。<br />因此，引出了异步处理可以将耗时的操作交给另一个thread去做，这样HTTP thread就被释放出来了，可以去处理其他请求了。<br /><a name="4tjws"></a></p><h2 id="误解"><a class="markdownIt-Anchor" href="#误解"></a> 误解</h2><p>AsyncContext的目的并不是为了提高性能，也并不直接提供性能提升，它提供了把HTTP thread和Worker thread解藕的机制，从而提高Web容器的响应能力。<br /><a name="hlFCE"></a></p><h2 id="图解"><a class="markdownIt-Anchor" href="#图解"></a> 图解</h2><p><a name="sLZU7"></a></p><h3 id="原始"><a class="markdownIt-Anchor" href="#原始"></a> 原始</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582478041678-7f46cc1e-d674-446e-b1e4-8fdc173b2ccc.png#align=left&amp;display=inline&amp;height=246&amp;margin=%5Bobject%20Object%5D&amp;originHeight=246&amp;originWidth=549&amp;size=0&amp;status=done&amp;style=none&amp;width=549" alt="" /><br /><a name="qp6C2"></a></p><h3 id="异步"><a class="markdownIt-Anchor" href="#异步"></a> 异步</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582478103825-c9ecf76f-3ddd-4a74-8da7-02176795f0ad.png#align=left&amp;display=inline&amp;height=246&amp;margin=%5Bobject%20Object%5D&amp;originHeight=246&amp;originWidth=730&amp;size=0&amp;status=done&amp;style=none&amp;width=730" alt="" /><br /><a name="vXHre"></a></p><h2 id="基本异步处理实现"><a class="markdownIt-Anchor" href="#基本异步处理实现"></a> 基本异步处理实现</h2><p><a name="oM4FG"></a></p><h3 id="webxml-开启"><a class="markdownIt-Anchor" href="#webxml-开启"></a> web.xml 开启</h3><p>Servlet3.0 默认是没有 web.xml 文件的，但 Servlet3.0 也是支持 web.xml 文件的，较 Servlet之前的版本，Servlet 3.0 在 <servlet>和 <filter> 标签中增加了 <async-supported> 子标签，该标签默认是 false 。如果想启用异步支持，只需要置为 true 即可。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>asynServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.servlet.AsynServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Filter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>asynFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.filter.AsynFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="mOoJf"></a></p><h3 id="注释开启"><a class="markdownIt-Anchor" href="#注释开启"></a> 注释开启</h3><p>Servlet 3.0 提供的 @WebServlet 和 @WebFilter 进行 Servlet 或 Filter 配置的情况，这两个注解都提供了 asyncSupported 属性，默认该属性的取值为 false。如果想启用异步支持，只需要置为 true 即可。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(value=&quot;/ServletAsyn&quot;,asyncSupported=true)</span><br><span class="line">public class ServletAsyn extends HttpServlet &#123;...&#125;</span><br><span class="line"></span><br><span class="line">@WebFilter(value=&quot;/*&quot;,asyncSupported=true)</span><br><span class="line">public class FilterAsyn implements Filter &#123;...&#125;</span><br></pre></td></tr></table></figure><p><a name="FYY1f"></a></p><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现：</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582481737594-4010bd3f-2e47-4eb8-a366-f315cc7bba30.png#align=left&amp;display=inline&amp;height=77&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=113&amp;originWidth=1094&amp;size=178788&amp;status=done&amp;style=none&amp;width=746" alt="image.png" /><br /><a name="nMMPU"></a></p><h4 id="异步线程类"><a class="markdownIt-Anchor" href="#异步线程类"></a> 异步线程类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.AsyncContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> AsyncContext ac;  <span class="comment">//定义一个异步上下文</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadTask</span><span class="params">(AsyncContext ac)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.ac = ac;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 服务端异步典型应用是注册时向邮箱发送验证码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//进行异步的一些处理</span></span><br><span class="line">HttpServletRequest requst = (HttpServletRequest) ac.getRequest();</span><br><span class="line">HttpSession session = requst.getSession();</span><br><span class="line">System.out.println(<span class="string">&quot;asyn-task start&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>;i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将结果放到session等方式</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;This is the result of asyn&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;asyn-task end&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知主线程已经处理完成</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 除了使用 ac.complete() 方法通知主线程已经处理外</span></span><br><span class="line"><span class="comment"> * 还可以使用 ac.dispatch() 方法重定向到一个页面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ac.dispatch(<span class="string">&quot;/show.jsp&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="e78UW"></a></p><h4 id="servlet"><a class="markdownIt-Anchor" href="#servlet"></a> Servlet:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.AsyncContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(value=&quot;/asyn-servlet&quot;,asyncSupported=true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletAsyn</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Servlet is start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.获得异步上下文对象</span></span><br><span class="line">AsyncContext ac = request.startAsync();</span><br><span class="line"><span class="comment">//2.启动一个耗时的子线程</span></span><br><span class="line">ThreadTask tt = <span class="keyword">new</span> ThreadTask(ac);</span><br><span class="line"><span class="comment">//3.可设置异步超时对象，需在启动异步上下文对象前设置</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设置超时后，在超时时间内子线程没有结束，主线程则会停止等待，继续往下执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ac.setTimeout(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">//4.开启异步上下文对象</span></span><br><span class="line">ac.start(tt);</span><br><span class="line"></span><br><span class="line"><span class="comment">//主线程结束向客户端发送消息</span></span><br><span class="line">System.out.println(<span class="string">&quot;Servlet is end&quot;</span>);</span><br><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">response.getWriter().append(<span class="string">&quot;信息已发送到邮箱&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">doGet(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="48FVl"></a></p><h1 id="组件可插性"><a class="markdownIt-Anchor" href="#组件可插性"></a> 组件可插性</h1><p>在web应用中，使用注解的类仅当它们位于WEB-INF/classes目录中，或它们被打包到位于应用的WEB-INF/lib中的jar文件中时它们的注解才将被处理。<br />Web应用部署描述符的web-app元素包含一个新的”metadata-complete”属性。”metadata-complete”属性定义了web描述符是否是完整的，或是否应该在部署时检查jar包中的类文件和web fragments。如果”metadata-complete”设置为”true”，部署工具必须忽略存在于应用的类文件中的所有servlet注解和web fragments。如果metadata-complete属性没有指定或设置为”false”，部署工具必须检查应用的类文件的注解，并扫描web fragments。<br /><a name="RDi0j"></a></p><h1 id="动态注册"><a class="markdownIt-Anchor" href="#动态注册"></a> 动态注册</h1><p>详见：<a href="https://www.jianshu.com/p/cbe1c3174d41">https://www.jianshu.com/p/cbe1c3174d41</a><br /><a name="kWmH3"></a></p><h2 id="create"><a class="markdownIt-Anchor" href="#create"></a> create</h2><p>在高负载情况下，thread pool都被占着ServletContext接口以下的方法,用来动态地创建Web对象<br /><T extends Filter>createFilter(java.lang.Class<T> clazz)<br /><T extends java.util.EventListener> createListener(java.lang.Class<T> clazz)<br /><T extends Servlet>createServlet(java.lang.Class<T> clazz)<br />例如：Servlet myServlet=createServlet(MyServlet.class);<br /><a name="264KC"></a></p><h2 id="add"><a class="markdownIt-Anchor" href="#add"></a> add</h2><p>创建好Web对象后，可以利用以下方法将它添加到ServletContext中<br />FilterRegistration.Dynamic addFilter(java.lang.String filterName,Filter filter)<br /><T extends java.util.EventListener> addListener(T t)<br />ServletRegistration.Dynamic addServlet (String servletName,Servlet servlet)<br />在创建或者添加监听器时，传给addListener覆盖方法的类必须实现XXXListener接口<br />addFilter 或addServlet 方法返回值是一个FilterRegistration.Dynamic或ServletRegistration.Dynamic<br />他们都是Registration.Dynamic 的子接口，<br />FilterRegistration.Dynamic可以配置一个FIliter<br />ServletRegistration.Dynamic可以配置一个Servlet那么后续的request就只能等待，如果运气不好客户端会报等待超时的错误。<br /><a name="DCoqC"></a></p><h2 id="代码演示-2"><a class="markdownIt-Anchor" href="#代码演示-2"></a> 代码演示</h2><p><a name="UBIpH"></a></p><h4 id="firstservlet类"><a class="markdownIt-Anchor" href="#firstservlet类"></a> FirstServlet类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUIDD=-<span class="number">6045338L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">resp.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">PrintWriter write=resp.getWriter();</span><br><span class="line">write.println(<span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Fist servlet&quot;</span>+</span><br><span class="line"><span class="string">&quot;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;</span>+name);</span><br><span class="line">write.println(<span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name=name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="NHLSM"></a></p><h4 id="dynreglistener类"><a class="markdownIt-Anchor" href="#dynreglistener类"></a> DynRegListener类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.Servlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRegistration;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebListener;</span><br><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynRegListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent arg0)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent arg0)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">ServletContext servletContext=arg0.getServletContext();</span><br><span class="line">Servlet firstServlet=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">firstServlet=servletContext.createServlet(FirstServlet.class);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(firstServlet!=<span class="keyword">null</span>&amp;&amp;firstServlet <span class="keyword">instanceof</span> FirstServlet)&#123;</span><br><span class="line">((FirstServlet)firstServlet).setName(<span class="string">&quot;Dynamically registered servlet&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ServletRegistration.Dynamic dynamic=servletContext.addServlet(<span class="string">&quot;firstServlet&quot;</span>, firstServlet);</span><br><span class="line">dynamic.addMapping(<span class="string">&quot;/dynamic&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Servlet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端基础 </tag>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linster</title>
      <link href="/posts/linster/"/>
      <url>/posts/linster/</url>
      
        <content type="html"><![CDATA[<p><a name="KMVNp"></a></p><h1 id="一-监听器"><a class="markdownIt-Anchor" href="#一-监听器"></a> 一、监听器</h1><p><a name="6hD3U"></a></p><h2 id="什么是监听器"><a class="markdownIt-Anchor" href="#什么是监听器"></a> 什么是监听器</h2><p>监听器的监听器设计者模式跟观察者设计模式十分雷同，它本质上是监听观察某个事件（程序）的发生情况，当被监听的事件真的发生了的时候，事件发生者（事件源） 就会给注册该事件的监听者（监听器）发送消息，告诉监听者某些信息，同时监听者也可以获得一份事件对象，根据这个对象可以获得相关属性和执行相关操作。<br /><a name="7JJIc"></a></p><h2 id="监听器原理"><a class="markdownIt-Anchor" href="#监听器原理"></a> 监听器原理</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582709954560-5ec921a4-2c79-474c-b108-604c56fea965.png#align=left&amp;display=inline&amp;height=560&amp;margin=%5Bobject%20Object%5D&amp;originHeight=560&amp;originWidth=989&amp;size=0&amp;status=done&amp;style=none&amp;width=989" alt="" /><br /><a name="XxOND"></a></p><h1 id="二-servlet监听器"><a class="markdownIt-Anchor" href="#二-servlet监听器"></a> 二、Servlet监听器</h1><p><a name="eSO3z"></a></p><h2 id="监听器种类"><a class="markdownIt-Anchor" href="#监听器种类"></a> 监听器种类</h2><p>在Servlet规范中定义了多种类型的监听器，它们用于监听的事件源分别为  ServletContext, HttpSession 和  ServletRequest 这三个域对象。<img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582710394225-abfc5982-8121-41c9-a5e6-9676eab7522c.png#align=left&amp;display=inline&amp;height=156&amp;margin=%5Bobject%20Object%5D&amp;originHeight=156&amp;originWidth=1112&amp;size=0&amp;status=done&amp;style=none&amp;width=1112" alt="" /><br />使用方法与观察者模式一样，方法的名称和接口的名称就是使用意思。<br /><a name="xsxFh"></a></p><h1 id="三-常用监听器"><a class="markdownIt-Anchor" href="#三-常用监听器"></a> 三、常用监听器</h1><p>1：监听session属性的增加、移除以及属性值改变的HttpSessionAttributeListener</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582713128436-58c1bcdf-b663-4aae-b089-a884e2526c0d.png#align=left&amp;display=inline&amp;height=278&amp;margin=%5Bobject%20Object%5D&amp;originHeight=278&amp;originWidth=510&amp;size=0&amp;status=done&amp;style=none&amp;width=510" alt="" /></p><p>2：监听web上下文的初始化（服务器已准备好接收请求）与销毁的ServletContextListener</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582713128491-4d29dfd3-7ff8-4e5d-969e-f803dcbc371a.png#align=left&amp;display=inline&amp;height=175&amp;margin=%5Bobject%20Object%5D&amp;originHeight=175&amp;originWidth=451&amp;size=0&amp;status=done&amp;style=none&amp;width=451" alt="" /></p><p>3：监听web上下文属性的增加、删除、属性值变化的ServletContextAttributeListener</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582713128590-baa4e178-563e-424e-9592-0b9d08fbf540.png#align=left&amp;display=inline&amp;height=265&amp;margin=%5Bobject%20Object%5D&amp;originHeight=265&amp;originWidth=483&amp;size=0&amp;status=done&amp;style=none&amp;width=483" alt="" /></p><p>4：监听request的创建与销毁的ServletRequestListener</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582713128499-22dc2405-dcc5-46bc-b399-45acdab1b6b4.png#align=left&amp;display=inline&amp;height=168&amp;margin=%5Bobject%20Object%5D&amp;originHeight=168&amp;originWidth=427&amp;size=0&amp;status=done&amp;style=none&amp;width=427" alt="" /></p><p>5：监听request的属性的增加、删除、属性值变化的ServletRequestAttributeListener</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582713128527-77f3493c-55f9-4a45-8d09-7136947ac6af.png#align=left&amp;display=inline&amp;height=261&amp;margin=%5Bobject%20Object%5D&amp;originHeight=261&amp;originWidth=503&amp;size=0&amp;status=done&amp;style=none&amp;width=503" alt="" /></p>]]></content>
      
      
      <categories>
          
          <category> Servlet </category>
          
          <category> Linster </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端基础 </tag>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Filter</title>
      <link href="/posts/filter/"/>
      <url>/posts/filter/</url>
      
        <content type="html"><![CDATA[<p><a name="himAB"></a></p><h1 id="filter介绍"><a class="markdownIt-Anchor" href="#filter介绍"></a> Filter介绍</h1><p><a name="Ph4cO"></a></p><h2 id="什么是filter"><a class="markdownIt-Anchor" href="#什么是filter"></a> 什么是Filter</h2><p>过滤器顾名思义就是过滤或处理用的，它位于客户端与服务器之间，可以在请求到到目标资源之前进行拦截过滤，也可以进行响应过滤。<br /><a name="FXtbU"></a></p><h2 id="filter生命周期"><a class="markdownIt-Anchor" href="#filter生命周期"></a> Filter生命周期</h2><p>Filter的整个生命周期过程的执行，均由Web服务器负责管理。Filter生命周期与Servlet类似，主要阶段有四个：创建、初始化、执行doFilter、对象销毁。<br />Filter是单例多线程的并且是在应用启动的时候创建并初始化，在应用停止的时候销毁的。<br />doFilter只要Filter进行过滤时就会执行，并且每过滤一次就会执行一次。<br /><a name="G8DkX"></a></p><h2 id="filter-有如下几个用处"><a class="markdownIt-Anchor" href="#filter-有如下几个用处"></a> Filter 有如下几个用处：</h2><ul><li>在HttpServletRequest 到达Servlet 之前，拦截客户的HttpServletRequest 。</li><li>根据需要检查HttpServletRequest ，也可以修改HttpServletRequest 头和数据。</li><li>在HttpServletResponse 到达客户端之前，拦截HttpServletResponse 。</li><li>根据需要检查HttpServletResponse ，可以修改HttpServletResponse 头和数据。<br /><a name="CJa1L"></a></li></ul><h2 id="filter-有如下几个种类"><a class="markdownIt-Anchor" href="#filter-有如下几个种类"></a> Filter 有如下几个种类：</h2><ul><li>用户授权的Filter: Filter 负责检查用户请求，根据请求过滤用户非法请求。</li><li>日志Filter: 详细记录某些特殊的用户请求。</li><li>负责解码的Filter: 包括对非标准编码的请求解码。</li><li>能改变XML 内容的XSLTFilter 等。 <br /><a name="zNhv6"></a></li></ul><h2 id="filter执行原理"><a class="markdownIt-Anchor" href="#filter执行原理"></a> Filter执行原理</h2><p>Web容器中有一个数组一个Map。</p><ul><li>Map：key为url-pattern的值，value为Filter实例对象的引用。</li><li>数组：存放着与请求匹配的所有Filter</li></ul><p>像存放Servlet信息的两个Map一样，在服务器中同样存在用于存放Filter相关信息的Map但Map只有一个，因为Filter的创建时机不同于Servlet,其是由在服务器启动时由Web容器自动创建的这个Map的K是Filter的<url-pattern/>，当然，若Filter没有设置<url-pattern>，而是使用了<servlet-name/>则会将制定的Servlet的<url-pattern>值放到Map中作为KMap的V为该Filter的引用在应用被启动时，服务器会自动的创建所有的Filter实列，并将他们一一存入Map。<br />在服务器中，对于每一个请求还存在一个数组，用于存储满足当前请求的所有Filter及最终的目标资源当请求到达服务器后，服务器会解析出URI,首先查询Map中与该请求匹配的Filter每找到一个满足要求的Filter,就将其放入到数组中，直到过滤完所有的Filter这个数组中存放的是与请求匹配的Filter,可以看作一个“链”，服务器会按照顺序对请求进行依次过滤处理。<br />对于Filter的Map而言，会查询过滤所有的Key,将所有符合匹配的都装入到数组中<br />而Servlet的Map的查询过程是，只要找到一个匹配的Key,就不会再往后面找了<br /><br /><a name="JGhmj"></a></p><h1 id="filter实现"><a class="markdownIt-Anchor" href="#filter实现"></a> Filter实现</h1><p><a name="tlHwd"></a></p><h2 id="简单demo"><a class="markdownIt-Anchor" href="#简单demo"></a> 简单Demo</h2><p><a name="U8JAh"></a></p><h3 id="filter的注册"><a class="markdownIt-Anchor" href="#filter的注册"></a> Filter的注册</h3><p>若Filter为全路径匹配方式，url-pattern要写/*，而不要写/，因为/不会对动态资源进行拦截。<br /><a name="xdWhG"></a></p><h4 id="webxml"><a class="markdownIt-Anchor" href="#webxml"></a> web.xml</h4><p>注册Filter的方式和Servlet类似</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册Filter--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>SomeFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.test.demo.SomeFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>SomeFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="uYAwJ"></a></p><h4 id="注释方法注册"><a class="markdownIt-Anchor" href="#注释方法注册"></a> 注释方法注册</h4><p><code>@WebFilter(&quot;/*&quot;)</code>详见Servlet3.0新特性。<br /><a name="2TJKH"></a></p><h3 id="filter实现-2"><a class="markdownIt-Anchor" href="#filter实现-2"></a> Filter实现</h3><p>Filter的实现要实现Filter接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//将请求递交给下一个资源</span></span><br><span class="line">        chain.doFilter(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="rc54G"></a></p><h2 id="filterconfig"><a class="markdownIt-Anchor" href="#filterconfig"></a> FilterConfig</h2><p>FilterConfig和ServletConfig一样的使用方法，由init初始化并赋值供给给doFilter使用。但是ServletConfig是封装到GnericServlet中的，GnericFilter是否也一样？进入源码分析：<br /><a name="xjKJ5"></a></p><h3 id="gnericfilter"><a class="markdownIt-Anchor" href="#gnericfilter"></a> GnericFilter：</h3><p>它拥有一个属性：private transient FilterConfig config;<br />在init方法中进行了初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.config = config;</span><br><span class="line"><span class="keyword">this</span>.init();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><a name="RNx2a"></a></p><h3 id="httpfilter"><a class="markdownIt-Anchor" href="#httpfilter"></a> HttpFilter：</h3><p>HttpFilter又实现了GnericFilter因此他可以在自己的子类中使用Config属性。<br /><a name="UpSGD"></a></p><h2 id="dispatcher的四个标签"><a class="markdownIt-Anchor" href="#dispatcher的四个标签"></a> dispatcher的四个标签</h2><p>注意：<dispatcher></dispatcher>必须写在filter-mapping的最后。dispatcher的前提条件当然是要先满足url-pattern，也可以通过注释注册这个属性，详见servlet3.0。<br /><a name="gXdVd"></a></p><h3 id="request"><a class="markdownIt-Anchor" href="#request"></a> REQUEST</h3><p>表示普通请求的拦截，但对于forward与include的跳转不拦截。默认值为REQUEST<br /><a name="dgGyA"></a></p><h3 id="foward"><a class="markdownIt-Anchor" href="#foward"></a> FOWARD</h3><p>拦截转发的forward时候的请求<br /><a name="haeC1"></a></p><h3 id="include"><a class="markdownIt-Anchor" href="#include"></a> INCLUDE</h3><p>拦截转发的include时候的请求<br /><a name="EgMzr"></a></p><h3 id="error"><a class="markdownIt-Anchor" href="#error"></a> ERROR</h3><p>表示当跳转到指定的错误处理页面时，这个跳转请求会被当前过滤器拦截。<br /><a name="Hzszf"></a></p><h2 id="过滤链filterchain"><a class="markdownIt-Anchor" href="#过滤链filterchain"></a> 过滤链FilterChain</h2><p>两个过滤器，EncodingFilter负责设置编码，SecurityFilter负责控制权限，服务器会按照web.xml中过滤器定义的先后循序组装成一条链，然后一次执行其中的doFilter()方法。执行的顺序就如下图所示，执行第一个过滤器的chain.doFilter()之前的代码，第二个过滤器的chain.doFilter()之前的代码，请求的资源，第二个过滤器的chain.doFilter()之后的代码，第一个过滤器的chain.doFilter()之后的代码，最后返回响应。<br /><a name="VDfGO"></a></p><h1 id="filter应用"><a class="markdownIt-Anchor" href="#filter应用"></a> Filter应用</h1><p>之前的乱码问题需要在post和get中进行处理，再多servlet的代码组中，容易产生大量无用代码，如果在过滤器中就对response和request进行了处理就可以避免这个问题。<br /><a name="y6pSo"></a></p><h2 id="post中文乱码问题"><a class="markdownIt-Anchor" href="#post中文乱码问题"></a> POST中文乱码问题</h2><p>例如如下代码会产生乱码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(name = &quot;LoginServlet&quot;, urlPatterns = &quot;/LoginServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//接收参数：</span></span><br><span class="line">        String name = request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        String password = request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(name + <span class="string">&quot;：&quot;</span> + password);</span><br><span class="line"></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.println(name + <span class="string">&quot;  is online&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时需要更改request的编码为UTF-8。<br />增加如下Filter即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(filterName = &quot;CharacterEncodingFilter&quot;, value = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterEncodingFilter</span> <span class="keyword">extends</span> <span class="title">HttpFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//解决响应乱码</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">//解决请求乱码</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        chain.doFilter(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="cpbuM"></a></p><h2 id="总结中文乱码问题"><a class="markdownIt-Anchor" href="#总结中文乱码问题"></a> 总结中文乱码问题</h2><p>当用户提交了一个包含中文参数的请求时，浏览器会先将这些中文转化为一个字节序列发送到服务器，服务器收到这个字节序列后，会按照其默认的字符编码ISO8859-1对其进行解码，因此产生了乱码，但紧接着，服务器会将解码过的乱码参数存放到parameterMap中，那么这个Map就乱码了。<br />这种属性传递过程中的乱码是无法仅仅通过Filter完成的，因此我们考虑重写HttpServletRequest（Response）类。这种方法无论是get还是post都能解决乱码问题。<br /><a name="Q2SAB"></a></p><h3 id="httpservletrequestwrapper"><a class="markdownIt-Anchor" href="#httpservletrequestwrapper"></a> HttpServletRequestWrapper</h3><blockquote><p>Provides a convenient implementation of the HttpServletRequest interface that  can be subclassed by developers wishing to adapt the request to a Servlet.  This class implements the Wrapper or Decorator pattern. Methods default to  calling through to the wrapped request object.</p></blockquote><p>提供了一个方便的HttpServletRequest接口实现，希望将Request适应到Servlet的开发人员可以将其子类化。这个类实现包装器或装饰器模式。方法默认为调用包装的请求对象。<br /><a name="pcLMN"></a></p><h3 id="代码演示"><a class="markdownIt-Anchor" href="#代码演示"></a> 代码演示：</h3><p><a name="cYEnU"></a></p><h4 id="myrequest"><a class="markdownIt-Anchor" href="#myrequest"></a> MyRequest：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRequest</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a request object wrapping the given request.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request the &#123;<span class="doctag">@link</span> HttpServletRequest&#125; to be wrapped.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the request is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将原始的Map替换为自定义的Map（遍历更改编码）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解决乱码问题后的Map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String[]&gt; getParameterMap() &#123;</span><br><span class="line">        Map&lt;String, String[]&gt; newMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, String[]&gt; oldMap = <span class="keyword">super</span>.getParameterMap();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (String str : oldMap.keySet()) &#123;</span><br><span class="line">                <span class="comment">//获取Values</span></span><br><span class="line">                String[] values = oldMap.get(str);</span><br><span class="line">                <span class="comment">//进行转码</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">                    values[i] = <span class="keyword">new</span> String(values[i].getBytes(<span class="string">&quot;ISO8859_1&quot;</span>), StandardCharsets.UTF_8);</span><br><span class="line">                &#125;</span><br><span class="line">                newMap.put(str, values);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getParameterNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Enumeration&lt;String&gt;) <span class="keyword">this</span>.getParameterMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getParameterValues(name)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getParameterValues(String name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getParameterMap().get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="u46bP"></a></p><h4 id="filter"><a class="markdownIt-Anchor" href="#filter"></a> Filter：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(filterName = &quot;CharacterEncodingFilter&quot;, value = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterEncodingFilter</span> <span class="keyword">extends</span> <span class="title">HttpFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//更换request对象</span></span><br><span class="line">        req = <span class="keyword">new</span> MyRequest((HttpServletRequest) req);</span><br><span class="line">        <span class="comment">//解决响应乱码</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        chain.doFilter(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="7NtiR"></a></p><h4 id="servlet"><a class="markdownIt-Anchor" href="#servlet"></a> Servlet：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(name = &quot;LoginServlet&quot;, urlPatterns = &quot;/LoginServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收参数：</span></span><br><span class="line">        String name = request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        String password = request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(name + <span class="string">&quot;：&quot;</span> + password);</span><br><span class="line"></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.println(name + <span class="string">&quot;  is online&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="GYBtZ"></a></p><h3 id="结果演示"><a class="markdownIt-Anchor" href="#结果演示"></a> 结果演示：</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582648069983-d9859b14-c6a6-4ec2-a755-043a6a745b55.png#align=left&amp;display=inline&amp;height=96&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=127&amp;originWidth=398&amp;size=14308&amp;status=done&amp;style=none&amp;width=301" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582648081699-a69b8b0b-7e96-4971-a2ab-7cd50caa2bfb.png#align=left&amp;display=inline&amp;height=94&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=111&amp;originWidth=344&amp;size=35081&amp;status=done&amp;style=none&amp;width=290" alt="image.png" /><br /><a name="tMrlb"></a></p><h1 id="访问权限过滤器"><a class="markdownIt-Anchor" href="#访问权限过滤器"></a> 访问权限过滤器</h1><p>有些网页需要登录才能访问，因此需要添加一个访问权限过滤器。<br /><a name="muLPW"></a></p><h2 id="代码演示-2"><a class="markdownIt-Anchor" href="#代码演示-2"></a> 代码演示：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/PermissionFilter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermissionFilter</span> <span class="keyword">extends</span> <span class="title">HttpFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                         FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// 设置请求的字符编码     </span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置返回请求的字符编码     </span></span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 转换ServletRequest为 HttpServletRequest     </span></span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">        <span class="comment">// 转换ServletResponse为HttpServletRequest     </span></span><br><span class="line">        HttpServletResponse res = (HttpServletResponse) response;</span><br><span class="line">        <span class="comment">// 获取Session     </span></span><br><span class="line">        HttpSession session = req.getSession();</span><br><span class="line">        <span class="comment">// 获取Session中存储的对象     </span></span><br><span class="line">        Object o = session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取当前请求的URI     </span></span><br><span class="line">        String url = req.getRequestURI();</span><br><span class="line">        <span class="comment">// 判断Session中的对象是否为空；判断请求的URI是否为不允许过滤的URI     </span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; !url.endsWith(<span class="string">&quot;login.jsp&quot;</span>)     <span class="comment">// 对URL地址为此结尾的文件不过滤     </span></span><br><span class="line">                &amp;&amp; !url.contains(<span class="string">&quot;login.do&quot;</span>)    <span class="comment">// 对URL地址中包含此字符串的文件不过滤     </span></span><br><span class="line">                &amp;&amp; !url.contains(<span class="string">&quot;/images/&quot;</span>)) &#123;</span><br><span class="line">            res.sendRedirect(req.getContextPath() + <span class="string">&quot;/login.jsp&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">            res.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-store&quot;</span>);</span><br><span class="line">            res.setDateHeader(<span class="string">&quot;Expires&quot;</span>, <span class="number">0</span>);</span><br><span class="line">            res.setHeader(<span class="string">&quot;Pragma&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">            res.flushBuffer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Servlet </category>
          
          <category> Filter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端基础 </tag>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie</title>
      <link href="/posts/cookie/"/>
      <url>/posts/cookie/</url>
      
        <content type="html"><![CDATA[<h1 id="cookie"><a class="markdownIt-Anchor" href="#cookie"></a> Cookie</h1><p><a name="HmDni"></a></p><h1 id="什么是cookie"><a class="markdownIt-Anchor" href="#什么是cookie"></a> 什么是Cookie</h1><p>Cookie，有时也用其复数形式 Cookies。类型为“小型文本文件”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息 。它是一个保存在客户机中的简单的文本文件, 这个文件与特定的 Web 文档关联在一起, 保存了该客户机访问这个Web 文档时的信息, 当客户机再次访问这个 Web 文档时这些信息可供该文档使用。由于“Cookie”具有可以保存在客户机上的神奇特性, 因此它可以帮助我们实现记录用户个人信息的功能, 而这一切都不必使用复杂的CGI等程序 。<br />举例来说, 一个 Web 站点可能会为每一个访问者产生一个唯一的ID, 然后以 Cookie 文件的形式保存在每个用户的机器上。如果使用浏览器访问 Web, 会看到所有保存在硬盘上的 Cookie。在这个文件夹里每一个文件都是一个由“名/值”对组成的文本文件,另外还有一个文件保存有所有对应的 Web 站点的信息。在这里的每个 Cookie 文件都是一个简单而又普通的文本文件。透过文件名, 就可以看到是哪个 Web 站点在机器上放置了Cookie(当然站点信息在文件里也有保存) 。<br /><a name="Qb8hI"></a></p><h1 id="chrome如何查看cookie"><a class="markdownIt-Anchor" href="#chrome如何查看cookie"></a> Chrome如何查看Cookie</h1><p><a name="6ioSn"></a></p><h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582364717819-09885169-c082-4c62-98ef-f84b37184dc7.png#align=left&amp;display=inline&amp;height=343&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=343&amp;originWidth=543&amp;size=41611&amp;status=done&amp;style=none&amp;width=543" alt="image.png" /><br /><a name="I17XS"></a></p><h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2><p>在Chrome浏览器中按下F12，打开开发者工具，选择&quot;Console(控制台)&quot;选项卡，输入document.cookie，回车就可以查看当前网站的Cookie了。输入document.cookie=“xxx=xxx”，就可以修改cookie的内容了。<br /><a name="nCA5H"></a></p><h2 id="方法三"><a class="markdownIt-Anchor" href="#方法三"></a> 方法三</h2><p>在Chrome地址栏中输入：chrome://settings/content/cookies，打开Cookie设置，可以查看&amp;删除Cookie。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582364904852-88ad7827-b795-4b4d-ab61-c8b265c2e3bf.png#align=left&amp;display=inline&amp;height=975&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=975&amp;originWidth=1203&amp;size=75477&amp;status=done&amp;style=none&amp;width=1203" alt="image.png" /><br /><a name="9bwTf"></a></p><h2 id="方法四"><a class="markdownIt-Anchor" href="#方法四"></a> 方法四</h2><p>下载的EditThisCookie扩展程序。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582365637206-a596380b-4e1c-40aa-92f7-2a0779e07fff.png#align=left&amp;display=inline&amp;height=797&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=911&amp;originWidth=1212&amp;size=174213&amp;status=done&amp;style=none&amp;width=1060" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582365722918-eef07f56-53f5-41e6-91da-35b4ab110300.png#align=left&amp;display=inline&amp;height=614&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=614&amp;originWidth=581&amp;size=34956&amp;status=done&amp;style=none&amp;width=581" alt="image.png" /><br /><a name="s9goa"></a></p><h1 id="javaee的cookie"><a class="markdownIt-Anchor" href="#javaee的cookie"></a> JavaEE的Cookie</h1><p>Cookie位于javax.servlet.http包下。<br /><a name="KLQTN"></a></p><h2 id="文档"><a class="markdownIt-Anchor" href="#文档"></a> 文档：</h2><blockquote><p>Creates a cookie, a small amount of information sent by a servlet to   a Web browser, saved by the browser, and later sent back to the server.  A cookie’s value can uniquely   identify a client, so cookies are commonly used for session management.<br />A cookie has a name, a single value, and optional attributes  such as a comment, path and domain qualifiers, a maximum age, and a  version number. Some Web browsers have bugs in how they handle the   optional attributes, so use them sparingly to improve the interoperability   of your servlets.<br />The servlet sends cookies to the browser by using the  <a href="http://tomcat.apache.org/tomcat-5.5-doc/servletapi/javax/servlet/http/HttpServletResponse.html#addCookie(javax.servlet.http.Cookie)"><code>HttpServletResponse.addCookie(javax.servlet.http.Cookie)</code></a> method, which adds  fields to HTTP response headers to send cookies to the   browser, one at a time. The browser is expected to   support 20 cookies for each Web server, 300 cookies total, and  may limit cookie size to 4 KB each.<br />The browser returns cookies to the servlet by adding   fields to HTTP request headers. Cookies can be retrieved  from a request by using the <a href="http://tomcat.apache.org/tomcat-5.5-doc/servletapi/javax/servlet/http/HttpServletRequest.html#getCookies()"><code>HttpServletRequest.getCookies()</code></a> method.  Several cookies might have the same name but different path attributes.<br />Cookies affect the caching of the Web pages that use them.   HTTP 1.0 does not cache pages that use cookies created with  this class. This class does not support the cache control  defined with HTTP 1.1.<br />This class supports both the Version 0 (by Netscape) and Version 1   (by RFC 2109) cookie specifications. By default, cookies are  created using Version 0 to ensure the best interoperability.</p></blockquote><p>创建一个cookie，少量信息通过servlet发送给 Web浏览器，由浏览器保存，然后发送回服务器。cookie的值可以唯一地标识客户机，因此cookies通常用于session管理。 cookie具有name、单个值和可选属性( 注释、路径和域限定符、最长期限和版本号)。一些Web浏览器在处理可选属性有bug，因此要谨慎使用它们以提高servlet的交互性。<br />servlet使用HttpServletResponse.addCookie（javax.servlet.http.Cookie）方法，添加cookies到HTTP响应头的字段发送到浏览器，一次一个。浏览器支持每个Web服务器20个Cookie，总共300个Cookie，以及 可能会将每个cookie的大小限制为4 KB。<br />浏览器添加Cookies到HTTP请求头的字段中。可以检索Cookies通过使用HttpServletRequest.getCookies（）方法。一些cookie可能具有相同的名称，但路径属性不同。              <br />Cookies会影响使用它们的网页的缓存。 HTTP 1.0不缓存使用与该类一起创建的cookie的页。此类不支持用HTTP 1.1定义的缓存控件。              <br />这个类同时支持版本0（由Netscape提供）和版本1（根据RFC 2109）cookie规范。默认情况下，cookies是使用版本0创建以确保最佳互操作性。<br /><a name="M8Ily"></a></p><h2 id="代码演示"><a class="markdownIt-Anchor" href="#代码演示"></a> 代码演示：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建Cookie</span></span><br><span class="line">        Cookie cookie1 = <span class="keyword">new</span> Cookie(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        Cookie cookie2 = <span class="keyword">new</span> Cookie(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;19&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在响应头中添加Cookie</span></span><br><span class="line">        response.addCookie(cookie1);</span><br><span class="line">        response.addCookie(cookie2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="dVNeM"></a></p><h2 id="结果演示"><a class="markdownIt-Anchor" href="#结果演示"></a> 结果演示：</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582380385538-4b86fd64-231e-48d7-907f-873aabfad18f.png#align=left&amp;display=inline&amp;height=614&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=614&amp;originWidth=581&amp;size=26761&amp;status=done&amp;style=none&amp;width=581" alt="image.png" /><br /><a name="IWIN4"></a></p><h3 id="同类资源"><a class="markdownIt-Anchor" href="#同类资源"></a> 同类资源：</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582380487302-ad5e5f95-150a-4572-b778-d12f35f78a27.png#align=left&amp;display=inline&amp;height=496&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=496&amp;originWidth=564&amp;size=25703&amp;status=done&amp;style=none&amp;width=564" alt="image.png" /><br />因此Cookie在默认情况下会和资源路径绑定，在同一资源路径下可以获取到Cookie。<br /><a name="52kNV"></a></p><h2 id="更改cookie绑定的路径"><a class="markdownIt-Anchor" href="#更改cookie绑定的路径"></a> 更改Cookie绑定的路径：</h2><p>默认情况下Cookie绑定的是资源路径，但是可以通过setPath更改。<br /><a name="KhTeQ"></a></p><h3 id="代码演示-2"><a class="markdownIt-Anchor" href="#代码演示-2"></a> 代码演示：</h3><p>注意：虽然Path不加项目名称也可以访问，不过规范下应该加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建Cookie</span></span><br><span class="line">        Cookie cookie1 = <span class="keyword">new</span> Cookie(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        Cookie cookie2 = <span class="keyword">new</span> Cookie(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;19&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定绑定路径</span></span><br><span class="line">        cookie1.setPath(request.getContextPath() + <span class="string">&quot;/aa/bb/TestServlet&quot;</span>);</span><br><span class="line">        cookie2.setPath(request.getContextPath() + <span class="string">&quot;/aa/bb/TestServlet2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在响应头中添加Cookie</span></span><br><span class="line">        response.addCookie(cookie1);</span><br><span class="line">        response.addCookie(cookie2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="EMlTm"></a></p><h3 id="结果演示-2"><a class="markdownIt-Anchor" href="#结果演示-2"></a> 结果演示：</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582380798819-3913168c-acce-49e6-bb7f-61bb1ef07e86.png#align=left&amp;display=inline&amp;height=466&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=466&amp;originWidth=564&amp;size=24910&amp;status=done&amp;style=none&amp;width=564" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582380815444-2c5331eb-0401-49bf-b1f7-ecd8f395410e.png#align=left&amp;display=inline&amp;height=466&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=466&amp;originWidth=564&amp;size=26131&amp;status=done&amp;style=none&amp;width=564" alt="image.png" /><br /><a name="lAGfr"></a></p><h2 id="设置cookie有效期"><a class="markdownIt-Anchor" href="#设置cookie有效期"></a> 设置Cookie有效期</h2><p>Cookie的有效期可以通过setMaxAge方法设置，值为整型值单位为秒。<br />小于零时与不设置相同，会存储Cookie到浏览器缓存。<br />等于零时生成后马上失效。<br />大于零时会存储在客户端的硬盘。<br /><a name="lWma9"></a></p><h1 id="使用cookie"><a class="markdownIt-Anchor" href="#使用cookie"></a> 使用Cookie</h1><p>Servlet可以通过getCookie获取Cookie，然后可以利用Cookie的值来进行条件判断等操作。<br /><a name="rNofv"></a></p><h2 id="代码演示-3"><a class="markdownIt-Anchor" href="#代码演示-3"></a> 代码演示：</h2><p><a name="xFWyo"></a></p><h3 id="someservlet"><a class="markdownIt-Anchor" href="#someservlet"></a> SomeServlet：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建Cookie</span></span><br><span class="line">        Cookie cookie1 = <span class="keyword">new</span> Cookie(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        Cookie cookie2 = <span class="keyword">new</span> Cookie(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;19&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在响应头中添加Cookie</span></span><br><span class="line">        response.addCookie(cookie1);</span><br><span class="line">        response.addCookie(cookie2);</span><br><span class="line"></span><br><span class="line">        response.sendRedirect(<span class="string">&quot;OtherServlet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="Q97xr"></a></p><h3 id="otherservlet"><a class="markdownIt-Anchor" href="#otherservlet"></a> OtherServlet：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">            System.out.println(cookie.getName() + <span class="string">&quot; : &quot;</span> + cookie.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="NvXsc"></a></p><h2 id="结果演示-3"><a class="markdownIt-Anchor" href="#结果演示-3"></a> 结果演示：</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582383535891-4437a8c6-4854-4ef2-99ed-e13b7d8d4e85.png#align=left&amp;display=inline&amp;height=92&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=92&amp;originWidth=511&amp;size=34386&amp;status=done&amp;style=none&amp;width=511" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582383547975-39ad5ce7-4044-49d0-847b-7e5ef45b79d5.png#align=left&amp;display=inline&amp;height=496&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=496&amp;originWidth=564&amp;size=25237&amp;status=done&amp;style=none&amp;width=564" alt="image.png" /><br /><a name="MCJBv"></a></p><h1 id="禁用cookie"><a class="markdownIt-Anchor" href="#禁用cookie"></a> 禁用Cookie</h1><p>因为Cookie可能存在用户名密码并且Cookie会存储在本地资源中，因此会有一定风险不得已要禁用Cookie。<br />但是禁止后对导致一些网站无法访问。</p>]]></content>
      
      
      <categories>
          
          <category> 零散知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端基础 </tag>
            
            <tag> 数据交互 </tag>
            
            <tag> 零碎知识点 </tag>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Session</title>
      <link href="/posts/session/"/>
      <url>/posts/session/</url>
      
        <content type="html"><![CDATA[<p><a name="6sn65"></a></p><h1 id="什么是session"><a class="markdownIt-Anchor" href="#什么是session"></a> 什么是Session</h1><p>Session和Cookie都是会话跟踪技术，区别是Session将会话保存到服务器端，Cookie是将会话保存在客户端。<br />Session对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web页时，如果该用户还没有会话，则Web服务器将自动创建一个 Session对象。当会话过期或被放弃后，服务器将终止该会话。Session 对象最常见的一个用法就是存储用户的首选项。例如，如果用户指明不喜欢查看图形，就可以将该信息存储在Session对象中。有关使用Session 对象的详细信息，请参阅“ASP应用程序”部分的“管理会话”。注意会话状态仅在支持cookie的浏览器中保留。<br /><a name="Oy4qe"></a></p><h1 id="javaee里的session"><a class="markdownIt-Anchor" href="#javaee里的session"></a> JavaEE里的Session</h1><p>在HttpServletRequest方法中有一个加getSession的方法：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582385476933-d74779dc-6708-463b-be6e-2e496d45b2e7.png#align=left&amp;display=inline&amp;height=31&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=42&amp;originWidth=949&amp;size=5354&amp;status=done&amp;style=none&amp;width=705" alt="image.png" /><br />它会返回当前Session，如果没有它会创建一个Session对象。<br />所谓的Session实际上是位于javax.servlet.http包下的HttpSession。<br />注意：Tomcat创建一个Session对象时，为当前Session对象生成了一个唯一编号，然后这个编号会存储在Cookie中并推送到浏览器的内存中，等到浏览器再次发送请求时，tomcat会通过浏览器发送的请求协议包中的Cookie的编号来判断该浏览器在服务端是否存在Session对象，因此Session和Cookie有着紧密的联系，<strong>不要禁用Cookie！！</strong><br /><a name="Se2Hf"></a></p><h2 id="httpsession官方文档"><a class="markdownIt-Anchor" href="#httpsession官方文档"></a> HttpSession官方文档：</h2><blockquote><p>Provides a way to identify a user across more than one page  request or visit to a Web site and to store information about that user.<br />The servlet container uses this interface to create a session  between an HTTP client and an HTTP server. The session persists  for a specified time period, across more than one connection or  page request from the user. A session usually corresponds to one   user, who may visit a site many times. The server can maintain a   session in many ways such as using cookies or rewriting URLs.<br />This interface allows servlets to</p><ul><li>View and manipulate information about a session, such as      the session identifier, creation time, and last accessed time</li><li>Bind objects to sessions, allowing user information to persist       across multiple user connections</li></ul></blockquote><blockquote><p>When an application stores an object in or removes an object from a  session, the session checks whether the object implements  <a href="http://tomcat.apache.org/tomcat-5.5-doc/servletapi/javax/servlet/http/HttpSessionBindingListener.html"><code>HttpSessionBindingListener</code></a>. If it does,   the servlet notifies the object that it has been bound to or unbound   from the session. Notifications are sent after the binding methods complete.   For session that are invalidated or expire, notifications are sent after  the session has been invalidated or expired.<br />When container migrates a session between VMs in a distributed container  setting, all session attributes implementing the <a href="http://tomcat.apache.org/tomcat-5.5-doc/servletapi/javax/servlet/http/HttpSessionActivationListener.html"><code>HttpSessionActivationListener</code></a> interface are notified.<br />A servlet should be able to handle cases in which  the client does not choose to join a session, such as when cookies are  intentionally turned off. Until the client joins the session,  <code>isNew</code> returns <code>true</code>.  If the client chooses   not to join  the session, <code>getSession</code> will return a different session  on each request, and <code>isNew</code> will always return  <code>true</code>.<br />Session information is scoped only to the current web application  (<code>ServletContext</code>), so information stored in one context  will not be directly visible in another.</p></blockquote><p>提供一种通过多个页面请求或访问网站来标识用户并存储有关该用户的信息的方法。              <br />servlet容器使用此接口在HTTP客户机和HTTP服务器之间创建Session。Session在指定的时间段内跨用户的多个连接或页请求保存。Session通常对应于一个用户，该用户可能多次访问站点。服务器可以通过多种方式维护Session，例如使用cookies或重写url。              <br />这个接口允许servlet去：</p><ul><li>查看和操作有关会话的信息，例如Session标识符、创建时间和上次访问时间</li><li>将对象绑定到Session，允许用户信息跨多个用户连接持久化</li></ul><p>当应用程序在Session中存储对象或从Session中移除对象时，Session将检查该对象是否实现HttpSessionBindingListener。如果是，servlet会通知对象它已经绑定到Session或从Session解除绑定。绑定方法完成后将发送通知。对于失效或过期的Session，在Session失效或过期后发送通知。              <br />当容器在分布式容器设置中迁移vm之间的Session时，将通知实现HttpSessionActivationListener接口的所有Session属性。              <br />servlet应该能够处理客户机不选择加入Session的情况，例如故意关闭cookies时。在客户端加入Session之前，isNew返回true。如果客户端选择不加入Session，getSession将在每个请求上返回不同的Session，isNew将始终返回true。              <br />Session信息的作用域仅限于当前web应用程序（ServletContext），因此存储在一个上下文中的信息在另一个上下文中将不直接可见。<br /><a name="Erpno"></a></p><h2 id="代码演示"><a class="markdownIt-Anchor" href="#代码演示"></a> 代码演示：</h2><p>一般情况下，若要向Session中写入数据，需要使用getSession(true)即getSession()方法。若要获取数据则需要使用getSession(false)。因为要避免在没有Session的时候创建新的Session而不是返回null。<br /><a name="6xfR6"></a></p><h3 id="someservlet"><a class="markdownIt-Anchor" href="#someservlet"></a> SomeServlet：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取Session对象</span></span><br><span class="line">        HttpSession session = request.getSession(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//设置编码打印属性</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">//获取表单中的值的名称</span></span><br><span class="line">        Enumeration&lt;String&gt; elements = request.getParameterNames();</span><br><span class="line">        <span class="comment">//遍历表单名称获取值</span></span><br><span class="line">        <span class="keyword">while</span> (elements.hasMoreElements()) &#123;</span><br><span class="line">            <span class="comment">//获取名称</span></span><br><span class="line">            String element = elements.nextElement();</span><br><span class="line">            <span class="comment">//获取值</span></span><br><span class="line">            String value = <span class="keyword">new</span> String(((String) request.getParameter(element)).getBytes(<span class="string">&quot;ISO_8859_1&quot;</span>), StandardCharsets.UTF_8);</span><br><span class="line">            <span class="comment">//将属性写入Session</span></span><br><span class="line">            session.setAttribute(element, value);</span><br><span class="line">            <span class="comment">//打印</span></span><br><span class="line">            response.getWriter().print(<span class="string">&quot;SomeServlet :&quot;</span> + element + <span class="string">&quot; ： &quot;</span> + value + <span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;OtherServlet&quot;</span>).include(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="iUZR3"></a></p><h3 id="otherservlet"><a class="markdownIt-Anchor" href="#otherservlet"></a> OtherServlet：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        <span class="comment">//获取Session</span></span><br><span class="line">        HttpSession session = req.getSession(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//判断Session是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (session == <span class="keyword">null</span>) &#123;</span><br><span class="line">            out.println(<span class="string">&quot;Session为空&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Enumeration&lt;String&gt; elements = session.getAttributeNames();</span><br><span class="line">            <span class="keyword">while</span> (elements.hasMoreElements()) &#123;</span><br><span class="line">                String str = elements.nextElement();</span><br><span class="line">                out.println(<span class="string">&quot;OtherServlet:  &quot;</span> + str + <span class="string">&quot;  :  &quot;</span> + session.getAttribute(str)+<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="TZj4G"></a></p><h2 id="结果演示"><a class="markdownIt-Anchor" href="#结果演示"></a> 结果演示：</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582391669840-fdd49eab-d484-4077-856a-1f659b8ec6ec.png#align=left&amp;display=inline&amp;height=184&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=253&amp;originWidth=430&amp;size=21910&amp;status=done&amp;style=none&amp;width=312" alt="image.png" /><br /><a name="fNfeI"></a></p><h1 id="session的工作原理"><a class="markdownIt-Anchor" href="#session的工作原理"></a> Session的工作原理</h1><p>如果是第一次取session，服务器会创建一个session对象（session本身是一个map集合），并且存入服务器的session集合中以sessionId为标识键，也就是根据sessionId即可取到对应session的引用。同时使用session时Servlet还获得了一个sessionId,在响应时把这个sessionId以cookie的形式发给了客户端。如果客户访问其它同一域的Servlet，这个sessionId会跟着请求上传到服务器。那么如果请求的另一个Servlet也要使用session,会先检查有没有这个保存sessionId的Cookie,如果有则直接到session集合中取对应的session引用返回给要使用的Servlet,所以，只要客户端存在这个sessionId，不管请求哪个Servlet，都可以拿到同一个session。所以Session就可以给不同的请求存储数据。<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/485026/1599036759801-2d06a9e1-9d9d-44c0-becf-fd35041adb3e.jpeg#align=left&amp;display=inline&amp;height=375&amp;margin=%5Bobject%20Object%5D&amp;originHeight=375&amp;originWidth=500&amp;size=0&amp;status=done&amp;style=none&amp;width=500" alt="" /><br /><a name="N1lV8"></a></p><h2 id="session过期"><a class="markdownIt-Anchor" href="#session过期"></a> Session过期</h2><p>要保证session能够跨请求存储数据必须保证下面两个条件必须满足<br />（1）客户浏览器不能关闭<br />因为session会给客户保存一个sessionId,这个id是作为临时cookie存在客户浏览器缓存当中，如果关闭浏览器，缓存就没了，sessionId自然也就消失了。重新打开浏览再请求，就是一个全新的请求，服务器会创建一个新的session,之前的session就没法用了。<br />（2）请求不能超过session的过期时间<br />服务器的session如果始终没有使用，保留着就是浪费服务器的资源，所以服务器会定期检查session的最后访问时间，如果这个时间超出session设置的过期时间，服务器就会销毁这个session,那么客户端即使把sessionId又传上来，服务器也找不到它的session了，只会再重新创建一个新的session。(超时时间默认30min)，也可以在web.xml中的session-config中配置.<br /><a name="IMFNQ"></a></p><h2 id="httpsession其他方法"><a class="markdownIt-Anchor" href="#httpsession其他方法"></a> HttpSession其他方法</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582393747502-6561add6-fccf-4e52-8e21-b20908a5eb91.png#align=left&amp;display=inline&amp;height=48&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=48&amp;originWidth=582&amp;size=6564&amp;status=done&amp;style=none&amp;width=582" alt="image.png" /><br />使Session立即失效，解绑所有的对象<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582393933288-4d21f0ab-b48e-4390-b0ae-ba9d4458039e.png#align=left&amp;display=inline&amp;height=537&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=715&amp;originWidth=1138&amp;size=130273&amp;status=done&amp;style=none&amp;width=854" alt="image.png" /><br />如图，暂就不一一列出。<br /><a name="W2HBm"></a></p><h2 id="cookie禁用后的session"><a class="markdownIt-Anchor" href="#cookie禁用后的session"></a> Cookie禁用后的Session</h2><p>由于客户端禁用Cookie与服务器无关，服务器会照常生成Cookie给客户端而且每次提交请求时服务器都会认为客户端的Session过期，因此服务器会不停的向客户端发送SessionId。<br />禁用后，跳转网页的时候也会出现问题，因此在sendRedirect方法这类跳转语句前要加上一个response.encodeRedirect(路径)就可以解决问题。但是禁用Cookie的时候SessionId会暴露在地址栏！<br /><a name="J2eV1"></a></p><h1 id="域属性空间范围"><a class="markdownIt-Anchor" href="#域属性空间范围"></a> 域属性空间范围</h1><p>JavaWeb编程的API中，存放三个可以存放域属性的空间范围对象，这三个对象中存储的域属性作用范围由大到小为：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582396867339-976ad48f-5589-416e-940b-89606a73eb51.png#align=left&amp;display=inline&amp;height=71&amp;margin=%5Bobject%20Object%5D&amp;originHeight=71&amp;originWidth=718&amp;size=0&amp;status=done&amp;style=none&amp;width=718" alt="" /><br />ServletContext即application，置于其中的域属性是整个应用范围，可以完成跨会话共享数据。<br />HttpSession，置于其中的域属性是会话范围的，可以完成跨请求共享数据<br />HttpServletRequest，置于其中的域属性是请求范围的，可以完成跨Servlet共享数据，但是这些Servlet必须在同一请求中<br />使用规则：在保证功能需求的前提下，优先使用小范围的，这样不仅可以节省服务器内存，还可以保证数据的安全性。</p>]]></content>
      
      
      <categories>
          
          <category> 零散知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端基础 </tag>
            
            <tag> 数据交互 </tag>
            
            <tag> 零碎知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>servlet核心知识3</title>
      <link href="/posts/servlet-3/"/>
      <url>/posts/servlet-3/</url>
      
        <content type="html"><![CDATA[<p><a name="Z4U3K"></a></p><h1 id="中文乱码问题解决"><a class="markdownIt-Anchor" href="#中文乱码问题解决"></a> 中文乱码问题解决</h1><p>通过未经配置过的Tomcat来Post表单，会在控制台出现中文乱码问题。<br /><a name="Syqyd"></a></p><h2 id="get不会乱码"><a class="markdownIt-Anchor" href="#get不会乱码"></a> Get不会乱码</h2><p>Get方式发送请求在请求协议包到达服务端后，由Tomcat负责解析参数内容，Tomcat默认采用UTF-8进行解析，服务端接收数据将不会产生中文变乱码的问题。<br /><a name="V416i"></a></p><h2 id="post乱码原因"><a class="markdownIt-Anchor" href="#post乱码原因"></a> Post乱码原因</h2><p>Post发送请求在请求协议包到达服务器后，请求体中的内容由请求对象负责解析，而请求对象默认采用ISO编码进行解析，所以在服务端会导致乱码。<br /><a name="KDuTq"></a></p><h2 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h2><p>在请求对象解析请求体中的内容之前设置解析字符集为UTF-8。<br />在doPost中加入：<code>req``.setCharacterEncoding(``**&quot;UTF-8&quot;**``)``;</code>语句即可，但是他只能解决POST中的乱码，对其他方式的乱码没有效果，兼具的方法可以直接操作返回的字符串，将乱码的字符串解码为byte数组，再将byte数组使用utf-8重新组成字符串，也可以在配置文件中更改详见：<a href="https://jingyan.baidu.com/article/c910274b39fbdc8d371d2d23.html">https://jingyan.baidu.com/article/c910274b39fbdc8d371d2d23.html</a><br /><a name="9wd6W"></a></p><h1 id="向客户端发送数据"><a class="markdownIt-Anchor" href="#向客户端发送数据"></a> 向客户端发送数据</h1><p>ServletResponse接口有一个方法getWriter，用于获取到一个输出流对象PrintWriter，该输出流对象是专门用于客户端浏览器中输出字符数据的，称为标准输出流。<br /><a name="q1JW3"></a></p><h2 id="write和print区别"><a class="markdownIt-Anchor" href="#write和print区别"></a> write和print区别</h2><ul><li>print()和println()是JspWriter类中定义的方法，write()则是Writer类中定义的。</li><li>print()和println()方法可将各种类型的数据转换成字符串的形式输出，而write()方法只能输出字符、字符数组和字符串等与字符相关的数据。</li><li>如果字符串对象的值为null，print()和println()方法将输出内容为“null”的字符串，而write()方法则是抛出NullPointerException异常。</li><li>write()方法只能写入字符串或unicode码写入到响应体，print()任可以将各种类型（包括Object）的数据通过默认编码转换成bytes字节形式，这些字节都通过write(int c)方法被输出。如果写入一个数字使用write()方法，系统会将数字转换为对应的unicode码写入，write（50）会被打印出&quot;2&quot;。<br /><a name="bgwjI"></a></li></ul><h2 id="print和println区别"><a class="markdownIt-Anchor" href="#print和println区别"></a> print和println区别：</h2><p>println()虽然看似是换行，但转成网页之后，这种换行被认为是空格，所以输出的仍然是一行，用空格分隔，但右键点击页面查看源代码时，能看出换行起作用了。<br />所以在页面上需要换行的话，需要用<code>&lt;br/&gt;</code>。<br /><a name="8gdch"></a></p><h2 id="编码问题"><a class="markdownIt-Anchor" href="#编码问题"></a> 编码问题</h2><p>contentType是指body的内容格式，比如xml，json等。<br />characterEncoding指的是body的编码格式，比如utf-8,gbk等。<br />setCharacterEncoding(…) 方法设置的编码格式最终会追加到contentType这个key的值上，比如 “Content-Type”= &quot;text/html;charset=utf-8”。也就是说在设置contentType的同时，也可以设置内容的编码格式。<br />如果未设置编码格式，比如setContentType（“text/html”），那么可以通过setCharacterEncoding（“utf-8”） 方法来追加。<br />contentType对应的就是header里的一个Content-Type，就是一个键值对，http协议规定了很多键值对，每个键值对起不同的作用。<br />注意：两种方法都要在printWriter使用之前使用<br /><a name="61q6G"></a></p><h3 id="代码演示"><a class="markdownIt-Anchor" href="#代码演示"></a> 代码演示：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//设置编码</span></span><br><span class="line">        <span class="comment">//方法一：</span></span><br><span class="line">        <span class="comment">//response.setContentType(&quot;text/html;charset=utf-8&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法二：</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出文字</span></span><br><span class="line">        response.getWriter().append(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        <span class="comment">//获取标准输出流</span></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        <span class="comment">//输出文字</span></span><br><span class="line">        out.println(<span class="string">&quot;你好世界！&quot;</span>);</span><br><span class="line">        out.write(<span class="string">&quot;你好中国！&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a name="wEOTJ"></a></p><h3 id="结果演示"><a class="markdownIt-Anchor" href="#结果演示"></a> 结果演示：</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582185196196-d435c586-e93c-48b4-a54b-4ac0b9460357.png#align=left&amp;display=inline&amp;height=45&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=45&amp;originWidth=292&amp;size=2605&amp;status=done&amp;style=none&amp;width=292" alt="image.png" /><br /><a name="tkqHS"></a></p><h2 id="插队问题"><a class="markdownIt-Anchor" href="#插队问题"></a> 插队问题：</h2><p>详见：<a href="https://blog.csdn.net/weixin_38958597/article/details/82693273">https://blog.csdn.net/weixin_38958597/article/details/82693273</a><br /><a name="mltEg"></a></p><h1 id="请求转发与重定向"><a class="markdownIt-Anchor" href="#请求转发与重定向"></a> 请求转发与重定向</h1><p>通过HttpServletRequest获取到RequestDispactcher对象的forward方法，可以完成请求转发功能。而通过HttpServletResponse和SendRedirect方法，可以完成重定向。<br /><a name="GQWw6"></a></p><h2 id="转发"><a class="markdownIt-Anchor" href="#转发"></a> 转发：</h2><p>由服务器端进行的页面跳转<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582186850829-1df4bd05-cc0d-4ca4-a952-e3358e3a40d1.png#align=left&amp;display=inline&amp;height=525&amp;margin=%5Bobject%20Object%5D&amp;originHeight=525&amp;originWidth=787&amp;size=0&amp;status=done&amp;style=none&amp;width=787" alt="" /><br /><a name="foQbo"></a></p><h3 id="转发方式"><a class="markdownIt-Anchor" href="#转发方式"></a> 转发方式：</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582188030551-f9a7ecbc-913d-4a2f-9978-304e7d5b93db.png#align=left&amp;display=inline&amp;height=89&amp;margin=%5Bobject%20Object%5D&amp;originHeight=89&amp;originWidth=782&amp;size=0&amp;status=done&amp;style=none&amp;width=782" alt="" /><br /><a name="D9y7G"></a></p><h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3><ol><li>请求所转发到的资源中可以直接获取到请求中所携带的数据。<br /></li><li>只有1次请求，收到一次响应。</li><li>浏览器地址栏显示为用户所提交的请求路径。</li><li>只能跳转到当前应用的资源中。<br /><a name="ZNGR9"></a></li></ol><h3 id="代码演示-2"><a class="markdownIt-Anchor" href="#代码演示-2"></a> 代码演示：</h3><p><a name="yEHqm"></a></p><h4 id="someservlet"><a class="markdownIt-Anchor" href="#someservlet"></a> SomeServlet:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取提交内容</span></span><br><span class="line">        String name = request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        String strAge = request.getParameter(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> age = Integer.parseInt(strAge);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向域中添加内容</span></span><br><span class="line">        request.setAttribute(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转发请求</span></span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/OtherServlet&quot;</span>).forward(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="z1dzE"></a></p><h4 id="otherservlet"><a class="markdownIt-Anchor" href="#otherservlet"></a> OtherServlet：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Enumeration&lt;String&gt; names = req.getParameterNames();</span><br><span class="line">        <span class="keyword">while</span> (names.hasMoreElements()) &#123;</span><br><span class="line">            String name = names.nextElement();</span><br><span class="line">            System.out.println(name + <span class="string">&quot;:&quot;</span> + <span class="keyword">new</span> String(req.getParameter(name).getBytes(<span class="string">&quot;ISO_8859_1&quot;</span>), StandardCharsets.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        out.write(<span class="string">&quot;OtherServlet is Running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="tGkao"></a></p><h4 id="结果演示-2"><a class="markdownIt-Anchor" href="#结果演示-2"></a> 结果演示：</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582189968967-ca6c372e-eaec-4e7c-9eaa-a79f898916de.png#align=left&amp;display=inline&amp;height=137&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=137&amp;originWidth=414&amp;size=10917&amp;status=done&amp;style=none&amp;width=414" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582189978127-435e03a0-3e20-48cd-93b5-f62ed148f5f2.png#align=left&amp;display=inline&amp;height=73&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=73&amp;originWidth=223&amp;size=10092&amp;status=done&amp;style=none&amp;width=223" alt="image.png" /><br /><a name="SYDwI"></a></p><h2 id="重定向"><a class="markdownIt-Anchor" href="#重定向"></a> 重定向：</h2><p>由浏览器端进行的页面跳转<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582186867780-08426907-60b1-4939-a1ec-676ad04cce47.png#align=left&amp;display=inline&amp;height=530&amp;margin=%5Bobject%20Object%5D&amp;originHeight=530&amp;originWidth=790&amp;size=0&amp;status=done&amp;style=none&amp;width=790" alt="" /><br /><a name="gXMun"></a></p><h3 id="定向方式"><a class="markdownIt-Anchor" href="#定向方式"></a> 定向方式</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582195661951-8b7a3159-8306-4c70-8806-6943086cb2d1.png#align=left&amp;display=inline&amp;height=73&amp;margin=%5Bobject%20Object%5D&amp;originHeight=96&amp;originWidth=702&amp;size=0&amp;status=done&amp;style=none&amp;width=531" alt="" /><br /><a name="Pkp8Y"></a></p><h3 id="特点-2"><a class="markdownIt-Anchor" href="#特点-2"></a> 特点</h3><ol><li>请求所转发到的资源中不能直接获取到请求中所携带的数据。</li><li>两次请求，两次响应</li><li>浏览器地址栏显示的为重定向的请求路径，而非用户提交请求的路径。正因如此，重定向可以防止表单重复提交。</li><li>重定向不仅可以跳转到当前应用的其他资源，也可以跳转到其他应用中资源。<br /><a name="IvZCJ"></a></li></ol><h3 id="代码演示-3"><a class="markdownIt-Anchor" href="#代码演示-3"></a> 代码演示：</h3><p><a name="CwKxk"></a></p><h4 id="someservlet-2"><a class="markdownIt-Anchor" href="#someservlet-2"></a> SomeServlet：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取提交内容</span></span><br><span class="line">        String name = request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        String strAge = request.getParameter(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> age = Integer.parseInt(strAge);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向域中添加内容</span></span><br><span class="line">        request.setAttribute(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重定向</span></span><br><span class="line">        response.sendRedirect(<span class="string">&quot;/OtherServlet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="qtsV6"></a></p><h4 id="otherservlet-2"><a class="markdownIt-Anchor" href="#otherservlet-2"></a> OtherServlet：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(req.getAttribute(<span class="string">&quot;age&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Enumeration&lt;String&gt; names = req.getParameterNames();</span><br><span class="line">        <span class="keyword">while</span> (names.hasMoreElements()) &#123;</span><br><span class="line">            String name = names.nextElement();</span><br><span class="line">            System.out.println(name + <span class="string">&quot;:&quot;</span> + <span class="keyword">new</span> String(req.getParameter(name).getBytes(<span class="string">&quot;ISO_8859_1&quot;</span>), StandardCharsets.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        out.write(<span class="string">&quot;OtherServlet is Running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="lxTvX"></a></p><h4 id="结果演示-3"><a class="markdownIt-Anchor" href="#结果演示-3"></a> 结果演示：</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582197290791-764bf3c7-74f1-40a4-87b5-ed2ba5ca26e1.png#align=left&amp;display=inline&amp;height=69&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=137&amp;originWidth=481&amp;size=12272&amp;status=done&amp;style=none&amp;width=240.5" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582197271112-9e309991-3308-4d00-8d4d-7ac571c92e9f.png#align=left&amp;display=inline&amp;height=43&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=54&amp;originWidth=182&amp;size=6076&amp;status=done&amp;style=none&amp;width=145" alt="image.png" /><br />显然是获取不到数据的。<br /><a name="cRD19"></a></p><h3 id="接收数据的重定向"><a class="markdownIt-Anchor" href="#接收数据的重定向"></a> 接收数据的重定向</h3><p>如果想要传递数据应该如此修改：<br />注意编码<br /><a name="U8aoc"></a></p><h4 id="someservlet-3"><a class="markdownIt-Anchor" href="#someservlet-3"></a> SomeServlet：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取提交内容</span></span><br><span class="line">        String name = request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        String strAge = request.getParameter(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> age = Integer.parseInt(strAge);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向域中添加内容</span></span><br><span class="line">        request.setAttribute(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重定向</span></span><br><span class="line">        response.sendRedirect(<span class="string">&quot;/OtherServlet?name=&quot;</span> + URLEncoder.encode(name, <span class="string">&quot;UTF-8&quot;</span>) + <span class="string">&quot;&amp;age=&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="FzI8z"></a></p><h4 id="otherservlet-3"><a class="markdownIt-Anchor" href="#otherservlet-3"></a> OtherServlet:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Enumeration&lt;String&gt; names = req.getParameterNames();</span><br><span class="line">        <span class="keyword">while</span> (names.hasMoreElements()) &#123;</span><br><span class="line">            String name = names.nextElement();</span><br><span class="line">            System.out.println(name + <span class="string">&quot;:&quot;</span> + <span class="keyword">new</span> String(req.getParameter(name).getBytes(<span class="string">&quot;ISO_8859_1&quot;</span>), StandardCharsets.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        out.write(<span class="string">&quot;OtherServlet is Running!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="VtsHB"></a></p><h2 id="对比分析"><a class="markdownIt-Anchor" href="#对比分析"></a> 对比分析：</h2><p><a name="V3vkT"></a></p><h3 id="重定向和转发的区别"><a class="markdownIt-Anchor" href="#重定向和转发的区别"></a> 重定向和转发的区别</h3><table><thead><tr><th><strong>区别</strong></th><th><strong>转发forward()</strong></th><th><strong>重定向sendRedirect()</strong></th></tr></thead><tbody><tr><td><strong>根目录</strong></td><td>包含项目访问地址</td><td>没有项目访问地址</td></tr><tr><td><strong>地址栏</strong></td><td>不会发生变化</td><td>会发生变化</td></tr><tr><td><strong>哪里跳转</strong></td><td>服务器端进行的跳转</td><td>浏览器端进行的跳转</td></tr><tr><td><strong>请求域中数据</strong></td><td>不会丢失</td><td>会丢失</td></tr></tbody></table><p><a name="7q88Y"></a></p><h3 id="个人观点"><a class="markdownIt-Anchor" href="#个人观点"></a> 个人观点</h3><p>我个人认为这两种的区别就是合作与分工的区别，转发是合作处理，将自己处理好的东西递交给另一个Servlet进行处理；重定向是分工处理，自己处理好以后让下一个Servlet处理。<br /><a name="CFqbw"></a></p><h3 id="自问自答"><a class="markdownIt-Anchor" href="#自问自答"></a> 自问自答</h3><p>问：什么时候使用转发，什么时候使用重定向？<br /></p><ol><li>若需要跳转到其他应用选择重定向。</li><li>若是处理表单数据的Servlet要跳转到其他Servlet选择重定向，防止表单重复提交。</li><li>若对某一请求进行处理的Servlet的执行需要消耗大量的服务器资源（CPU、内存）选择重定向</li><li>其他情况选择转发。</li></ol><p><a name="wD6kA"></a></p><h1 id="include和forward区别"><a class="markdownIt-Anchor" href="#include和forward区别"></a> include和forward区别</h1><p>RequestDispatcher只有两个方法：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582267822414-492cd611-a462-414e-9184-f441b6e21e58.png#align=left&amp;display=inline&amp;height=86&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=114&amp;originWidth=940&amp;size=21061&amp;status=done&amp;style=none&amp;width=708" alt="image.png" /><br />这两个主要表现在标准输出流的开启时间不同：</p><ul><li>forward是把一个request从一个Servlet传递到另一个Server上的资源（servlet、JSP或者HTML）。表示转发，则控制权也同时交给了另一个组件，所以最终由另一组件返回响应。所以此时写入到out的数据是不会写入到客户端浏览器中的。</li><li>include是把资源（servlet、JSP或者HTML）文件放在response中。表示包含，则控制权还在自己身上，所以最终还是由自己返回响应。<br /><a name="QUX5z"></a></li></ul><h2 id="举例"><a class="markdownIt-Anchor" href="#举例"></a> 举例：</h2><p><a name="cBhYs"></a></p><h3 id="forward"><a class="markdownIt-Anchor" href="#forward"></a> forward:</h3><p>Servlet1：out.println(“1”);<br />Servlet2：out.println(“2”);<br />Servlet1调用forward会跳转到Servlet2输出2<br /><a name="PQquu"></a></p><h4 id="图解"><a class="markdownIt-Anchor" href="#图解"></a> 图解</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582282066507-65009087-d172-4128-b8fc-319b2bb8c03b.png#align=left&amp;display=inline&amp;height=540&amp;margin=%5Bobject%20Object%5D&amp;originHeight=540&amp;originWidth=619&amp;size=0&amp;status=done&amp;style=none&amp;width=619" alt="" /><br /><a name="yASc5"></a></p><h3 id="include"><a class="markdownIt-Anchor" href="#include"></a> include:</h3><p>Servlet1：out.println(“1”);<br />Servlet2：out.println(“2”);<br />Servlet1调用include会留在Servlet1输出2后输出1<br /><a name="Xv8ME"></a></p><h4 id="图解-2"><a class="markdownIt-Anchor" href="#图解-2"></a> 图解</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582282101260-bb2574d1-ae5f-4b9a-a6ba-3231db70a853.png#align=left&amp;display=inline&amp;height=540&amp;margin=%5Bobject%20Object%5D&amp;originHeight=540&amp;originWidth=640&amp;size=0&amp;status=done&amp;style=none&amp;width=640" alt="" /><br /><a name="pK22R"></a></p><h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论：</h2><p>使用forward进行请求转发时，使用forward的Servlet不应向Response中写入数据。若写入数据，则应使用include进行转发。<br /></p>]]></content>
      
      
      <categories>
          
          <category> Servlet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端基础 </tag>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>servlet核心知识2</title>
      <link href="/posts/servlet-2/"/>
      <url>/posts/servlet-2/</url>
      
        <content type="html"><![CDATA[<p><a name="yri3x"></a></p><h1 id="dopost和doget"><a class="markdownIt-Anchor" href="#dopost和doget"></a> doPost和doGet</h1><p>要将doPst和doGet，首先要分析POST和GET的区别<br /><a name="Wnf2s"></a></p><h2 id="post和get"><a class="markdownIt-Anchor" href="#post和get"></a> POST和GET</h2><p>GET - 从指定的资源请求数据。<br />POST - 向指定的资源提交要被处理的数据<br /><a name="T25KY"></a></p><h3 id="get"><a class="markdownIt-Anchor" href="#get"></a> GET</h3><p>请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：<br />/test/demo_form.asp?name1=value1&amp;name2=value2<br />有关 GET 请求的其他一些注释：</p><ul><li>GET 请求可被缓存</li><li>GET 请求保留在浏览器历史记录中</li><li>GET 请求可被收藏为书签</li><li>GET 请求不应在处理敏感数据时使用</li><li>GET 请求有长度限制</li><li>GET 请求只应当用于取回数据<br /><a name="dq0Zo"></a></li></ul><h3 id="post"><a class="markdownIt-Anchor" href="#post"></a> POST</h3><p>请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：<br />POST /test/demo_form.asp HTTP/1.1<br />Host: w3schools.com<br />name1=value1&amp;name2=value2<br />有关 POST 请求的其他一些注释：</p><ul><li>POST 请求不会被缓存</li><li>POST 请求不会保留在浏览器历史记录中</li><li>POST 不能被收藏为书签</li><li>POST 请求对数据长度没有要求<br /><a name="51hmv"></a></li></ul><h3 id="比较post和get"><a class="markdownIt-Anchor" href="#比较post和get"></a> 比较POST和GET</h3><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">GET</th><th style="text-align:left">POST</th></tr></thead><tbody><tr><td style="text-align:left">后退按钮/刷新</td><td style="text-align:left">无害</td><td style="text-align:left">数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td></tr><tr><td style="text-align:left">书签</td><td style="text-align:left">可收藏为书签</td><td style="text-align:left">不可收藏为书签</td></tr><tr><td style="text-align:left">缓存</td><td style="text-align:left">能被缓存</td><td style="text-align:left">不能缓存</td></tr><tr><td style="text-align:left">编码类型</td><td style="text-align:left">application/x-www-form-urlencoded</td><td style="text-align:left">application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td></tr><tr><td style="text-align:left">历史</td><td style="text-align:left">参数保留在浏览器历史中。</td><td style="text-align:left">参数不会保存在浏览器历史中。</td></tr><tr><td style="text-align:left">对数据长度的限制</td><td style="text-align:left">是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td><td style="text-align:left">无限制。</td></tr><tr><td style="text-align:left">对数据类型的限制</td><td style="text-align:left">只允许 ASCII 字符。</td><td style="text-align:left">没有限制。也允许二进制数据。</td></tr><tr><td style="text-align:left">安全性</td><td style="text-align:left">与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。<br />在发送密码或其他敏感信息时绝不要使用 GET ！</td><td style="text-align:left">POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr><tr><td style="text-align:left">可见性</td><td style="text-align:left">数据在 URL 中对所有人都是可见的。</td><td style="text-align:left">数据不会显示在 URL 中。</td></tr></tbody></table><p><a name="ljFU0"></a></p><h2 id="dopost和doget-2"><a class="markdownIt-Anchor" href="#dopost和doget-2"></a> doPost和doGet</h2><p>这两种方法有本质的区别，get只有一个流，参数附加在url后，大小个数有严格限制且只能是字符串。post的参数是通过另外的流传递的，不通过url，所以可以很大，也可以传递二进制数据，如文件的上传。 在servlet开发中，以doGet()和doPost()分别处理get和post方法。 <br /><a name="cilaQ"></a></p><h3 id="doget"><a class="markdownIt-Anchor" href="#doget"></a> doGet</h3><p>GET 调用用于获取服务器信息，并将其做为响应返回给客户端。当经由Web浏览器或通过HTML、JSP直接访问Servlet的URL时，一般用GET调用。 GET调用在URL里显示正传送给SERVLET的数据，这在系统的安全方面可能带来一些问题，比如用户登录，表单里的用户名和密码需要发送到服务器端， 若使用Get调用，就会在浏览器的URL中显示用户名和密码。<br /><a name="vbrW3"></a></p><h3 id="dopost"><a class="markdownIt-Anchor" href="#dopost"></a> doPost</h3><p>它用于客户端把数据传送到服务器端，也会有副作用。但好处是可以隐藏传送给服务器的任何数据。Post适合发送大量的数据。<br /><a name="XnJUY"></a></p><h3 id="调用原理及其他问题"><a class="markdownIt-Anchor" href="#调用原理及其他问题"></a> 调用原理及其他问题</h3><p>当发出客户端请求的时候，调用service 方法并传递一个请求和响应对象。Servlet首先判断该请求是GET 操作还是POST 操作。然后它调用下面的一个方法：doGet 或 doPost。因此可以把方法写在doGet()方法中,在doPost()方法中调用执行,这样,无论你提交的是post还是get方法都可以执行。<br />servlet代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">servlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span> <span class="keyword">throws</span> IOException,ServletException </span>&#123;</span><br><span class="line">      request.setCaracterEncoding(“gb2312”);<span class="comment">//汉字转码</span></span><br><span class="line">      PrintWriter out = response.getWriter();</span><br><span class="line">      out.println(<span class="string">&quot;The Parameter are ：&quot;</span>+request.getParameter(<span class="string">&quot;name1&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span> <span class="keyword">throws</span> IOException,ServletException </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.goGet(request,response);<span class="comment">//调用doGet()方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="zazbc"></a></p><h4 id="安全"><a class="markdownIt-Anchor" href="#安全"></a> 安全</h4><p>GET调用在URL里显示正传送给SERVLET的数据，这在系统的安全方面可能带来问题，例如用户名和密码等<br />POST就可以在一定程度上解决此类问题<br /><a name="787dx"></a></p><h4 id="服务器接收方式"><a class="markdownIt-Anchor" href="#服务器接收方式"></a> 服务器接收方式</h4><p>服务器随机接受GET方法的数据，一旦断电等原因，服务器也不知道信息是否发送完毕<br />而POST方法，服务器先接受数据信息的长度，然后再接受数据<br /><a name="7Fu2q"></a></p><h4 id="form运行方式"><a class="markdownIt-Anchor" href="#form运行方式"></a> form运行方式</h4><p>当form框里面的method为get时，执行doGet方法<br />当form框里面的method为post时，执行doPost方法<br /><a name="pHQkR"></a></p><h4 id="容量限制"><a class="markdownIt-Anchor" href="#容量限制"></a> 容量限制</h4><p>GET方法后面的信息量字节大小不要超过1.3K，而Post则没有限制<br /><a name="K4mlX"></a></p><h2 id="区别总结"><a class="markdownIt-Anchor" href="#区别总结"></a> 区别总结</h2><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；<br />而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。<br />1. GET与POST都有自己的语义，不能随便混用。<br />2. 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。<br />3. 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。<br /><a name="KEegm"></a></p><h1 id="request和response"><a class="markdownIt-Anchor" href="#request和response"></a> Request和Response</h1><p>Web服务器收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象、和代表响应的response对象。<br />当需要获取客户机提交过来的数据时，用request对象， 当需要向客户机输出数据，用esponse对象。<br /><a name="iAeH7"></a></p><h2 id="请求响应流程"><a class="markdownIt-Anchor" href="#请求响应流程"></a> 请求响应流程</h2><ol><li>浏览器发送请求</li><li>服务器接收请求,创建两个对象(request和response),将请求的信息封装request对象</li><li>找到对应的servlet,将这两个对象传递给servlet</li><li>Servlet收到请求,执行service方法,处理自己的业务逻辑,生成动态的内容,将内容返回给服务器</li><li>服务器收到内容之后,进行拆分,生成响应信息,返回给浏览器</li><li>浏览器解析相应信息<br /><a name="e27Mx"></a></li></ol><h2 id="response"><a class="markdownIt-Anchor" href="#response"></a> Response</h2><p><a name="L0mvl"></a></p><h3 id="操作响应行"><a class="markdownIt-Anchor" href="#操作响应行"></a> 操作响应行</h3><p>格式:协议/版本 状态码 状态码说明<br />例如:HTTP/1.1 200 OK<br />在http响应行中，包括协议,版本号,以及有一个很重要的值，它叫做响应状态码.响应行中我们主要就是操作这些状态码,它可以有五种类型取值:<br />100-199<br />200-299<br />300-399<br />400-499<br />500-599<br /><a name="rCsDh"></a></p><h4 id="常用状态码"><a class="markdownIt-Anchor" href="#常用状态码"></a> 常用状态码：</h4><ul><li>200：请求成功（其后是对GET和POST请求的应答文档。）</li><li>302：所请求的页面已经临时转移至新的url。(重定向)(配合location响应头使用)</li><li>304：未按预期修改文档。(让浏览器读缓存)客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since(什么时候修改的))头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</li><li>404：没有找到文件或目录。(用户操作错误)</li><li>405：请求中指定的方法不被允许</li><li>500：请求未完成。服务器遇到不可预知的情况(代码错误)</li><li>504：网关错误.<br /><a name="D3QL8"></a></li></ul><h4 id="httpservletresponse操作状态码方法"><a class="markdownIt-Anchor" href="#httpservletresponse操作状态码方法"></a> HttpServletResponse操作状态码方法：</h4><p>void setStatus(int sc): 设置状态代码.针对于非错误的状态码<br />例如:setstatus （200）<br />void sendError(int status,String msg) throws IOException 设置错误状态码及信息<br />例如:response.sendError(404);报404错误<br />response.sendError(404,一不小心走丢了…);报错误并且有错误信息<br /><a name="EU1O2"></a></p><h3 id="response操作响应头"><a class="markdownIt-Anchor" href="#response操作响应头"></a> response操作响应头</h3><p>http响应头的格式是 key/value的格式，可以有多个value值，以”,”分开。<br />例如:<br />Content-Encoding: gzip<br />Content-Length: 123<br />Content-Language: zh-cn<br />Content-Type: text/html; charset=GB2312<br />Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT<br /><a name="cBmHI"></a></p><h4 id="操作响应头-api"><a class="markdownIt-Anchor" href="#操作响应头-api"></a> 操作响应头 API</h4><p>public void setHeader(String name,String value)<br />用给定名称和值设置响应头。如果已经设置了头，则新值将重写以前的值(设置字符串形式的响应头 注意:若设置过,会覆盖)<br />public void addHeader(String name, String value)<br />用给定名称和值添加响应头。此方法允许响应头有多个值(追加字符串形式的响应头 注意:若没有设置过则设置,若设置过则追加)<br />public void setIntHeader(String name, int value)<br />用给定名称和整数值设置响应头。如果已经设置了头，则新值将重写以前的值。(设置整型的响应头)<br />public void addIntHeader(String name, int value)<br />用给定名称和整数值添加响应头。此方法允许响应头有多个值。(添加整型的响应头)<br />public voidsetDateHeader(String name, long date)<br />用给定名称和日期值设置响应头。该日期根据距历元时间的毫秒数指定。如果已经设置了头，则新值将重写以前的值。(设置时间类型的响应头)<br />public void addDateHeader(String key, long date)<br />用给定名称和日期值添加响应头。该日期根据距历元时间的毫秒数指定。此方法允许响应头有多个值。(添加时间类型的响应头)<br /><a name="hyggG"></a></p><h2 id="request"><a class="markdownIt-Anchor" href="#request"></a> Request</h2><p>HttpServletRequest对象用于封装http请求，对于http请求它有三部分组成，http请求行，http请求头及请求正文。<br /><a name="JLucg"></a></p><h3 id="request操作请求行"><a class="markdownIt-Anchor" href="#request操作请求行"></a> request操作请求行</h3><p>格式:请求方式 请求资源 协议/版本<br />例如:GET /day10 HTTP/1.1<br /><a name="ie3vx"></a></p><h4 id="常用请求行api"><a class="markdownIt-Anchor" href="#常用请求行api"></a> 常用请求行API</h4><ul><li>public String getMethod()：获取请求方式例如 GET、POST</li><li>public String getRequestURI()：获取去请求资源(不带参数) 是uri 例如:/day10/r</li><li>public String getProtocol()：获取协议的名称和版本。（例如 HTTP/1.1）</li><li>public String getQueryString()：返回包含在请求 URL 中路径后面的查询字符串。如果 URL 没有查询字符串，则此方法返回 null。<br /><a name="SWaua"></a></li></ul><h3 id="request操作请求头"><a class="markdownIt-Anchor" href="#request操作请求头"></a> request操作请求头</h3><p>格式:key/value(value可以为多个)<br /><a name="B6VZ9"></a></p><h4 id="常用请求头api"><a class="markdownIt-Anchor" href="#常用请求头api"></a> 常用请求头API</h4><ul><li>public String getHeader(String name) 获取字符串格式的请求头，以 String 的形式返回指定请求头的值。</li><li>public java.util.Enumeration<E> getHeaders(String name)获取多个值的请求头，以 String 对象的 Enumeration 的形式返回指定请求头的所有值。</li><li>public java.util.Enumeration<E> getHeaderNames()获取所有请求头的名称，返回此请求包含的所有头名称的枚举。如果该请求没有头，则此方法返回一个空枚举。</li><li>public int getIntHeader(String name) 获取整型格式的请求头，以 int 的形式返回指定请求头的值。如果该请求没有指定名称的头，则此方法返回 -1。如果无法将头转换为整数，则此方法抛出 NumberFormatException。</li><li>public long getDateHeader(String name)获取时间类型的请求头，以表示 Date 对象的 long 值的形式返回指定请求头的值<br /><a name="ueNth"></a></li></ul><h3 id="request获取参数中文出现乱码"><a class="markdownIt-Anchor" href="#request获取参数中文出现乱码"></a> request获取参数中文出现乱码</h3><p><a name="D66SF"></a></p><h4 id="原因"><a class="markdownIt-Anchor" href="#原因"></a> 原因:</h4><p>汉字在不同的编码表中的码值不一样，那么在使用不同的编码表进行解码与编码操作时，就会出现乱码问题.<br />浏览器在提交的时候使用utf-8编码，Tomcat得到请求参数是使用iso8859-1进行了解码，封装到了request中。<br /><a name="6qSI7"></a></p><h4 id="解决"><a class="markdownIt-Anchor" href="#解决"></a> 解决：</h4><p>先使用iso8859-1进行解码，在使用utf-8进行编码<br />每个参数都要new才行(get,post方法都可行)<br />username= new String(username.getBytes(“iso8859-1”),”utf-8”);<br />如果请求方式是POST,<br />可以直接使用request.setCharacterEncoding(“utf-8”);就可以解决。<br /><a name="uDJfO"></a></p><h1 id="请求筛选"><a class="markdownIt-Anchor" href="#请求筛选"></a> 请求筛选</h1><p>在众多网站中提交表单时，需要将表单提交后跳转到指定界面称为POST的方法，倘若直接用GET方法访问跳转的页面方法则会导致未登录就进入操作界面从而引发一系列可怕后果，因此需要在提交数据时判断请求的GET/POST方法来遏制这种不好的后果。<br />POST和GET是HTTP协议，又根据public interface HttpServletRequest extends ServletRequest得知HttpServletRequest是ServletRequest的子类，且HttpServletRequest中getMethod方法可以获取提交方式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        HttpServletRequest request= (HttpServletRequest) req;</span><br><span class="line">        HttpServletResponse response= (HttpServletResponse) res;</span><br><span class="line">        <span class="comment">//获取提交方式</span></span><br><span class="line">        System.out.println(request.getMethod());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此请求筛选代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String POST = <span class="string">&quot;POST&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">        HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line">        <span class="comment">//获取提交方式</span></span><br><span class="line">        String method = request.getMethod();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (POST.equals(method)) &#123;</span><br><span class="line">            doPost(request, response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            doGet(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//TODO 对于get的处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//TODO 对于post的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="iMDKo"></a></p><h2 id="自定义httpservlet"><a class="markdownIt-Anchor" href="#自定义httpservlet"></a> 自定义HttpServlet</h2><p>因为类似这样需要过滤请求的类很多，因此考虑创建出一个父类来简化其他的Servlet的代码量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String POST = <span class="string">&quot;POST&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">        HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line"></span><br><span class="line">        service(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取提交方式</span></span><br><span class="line">        String method = request.getMethod();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (POST.equals(method)) &#123;</span><br><span class="line">            doPost(request, response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            doGet(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="Yj30a"></a></p><h3 id="实现servlet"><a class="markdownIt-Anchor" href="#实现servlet"></a> 实现Servlet：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//TODO get操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//TODO post操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，只需要在子类实现两个方法即可，避免了大量的代码浪费。<br /><a name="1ejJl"></a></p><h2 id="httpservlet源码"><a class="markdownIt-Anchor" href="#httpservlet源码"></a> HttpServlet源码</h2><p>HttpServlet也是javax.servlet.http中原厂自带的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String METHOD_DELETE = <span class="string">&quot;DELETE&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String METHOD_HEAD = <span class="string">&quot;HEAD&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String METHOD_GET = <span class="string">&quot;GET&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String METHOD_OPTIONS = <span class="string">&quot;OPTIONS&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String METHOD_POST = <span class="string">&quot;POST&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String METHOD_PUT = <span class="string">&quot;PUT&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String METHOD_TRACE = <span class="string">&quot;TRACE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HEADER_IFMODSINCE = <span class="string">&quot;If-Modified-Since&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HEADER_LASTMOD = <span class="string">&quot;Last-Modified&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LSTRING_FILE =</span><br><span class="line">        <span class="string">&quot;javax.servlet.http.LocalStrings&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ResourceBundle lStrings =</span><br><span class="line">        ResourceBundle.getBundle(LSTRING_FILE);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// NOOP</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String protocol = req.getProtocol();</span><br><span class="line">        String msg = lStrings.getString(<span class="string">&quot;http.method_get_not_supported&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (protocol.endsWith(<span class="string">&quot;1.1&quot;</span>)) &#123;</span><br><span class="line">            resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doHead</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DispatcherType.INCLUDE.equals(req.getDispatcherType())) &#123;</span><br><span class="line">            doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            NoBodyResponse response = <span class="keyword">new</span> NoBodyResponse(resp);</span><br><span class="line">            doGet(req, response);</span><br><span class="line">            response.setContentLength();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String protocol = req.getProtocol();</span><br><span class="line">        String msg = lStrings.getString(<span class="string">&quot;http.method_post_not_supported&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (protocol.endsWith(<span class="string">&quot;1.1&quot;</span>)) &#123;</span><br><span class="line">            resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPut</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String protocol = req.getProtocol();</span><br><span class="line">        String msg = lStrings.getString(<span class="string">&quot;http.method_put_not_supported&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (protocol.endsWith(<span class="string">&quot;1.1&quot;</span>)) &#123;</span><br><span class="line">            resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(HttpServletRequest req,</span></span></span><br><span class="line"><span class="function"><span class="params">                            HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String protocol = req.getProtocol();</span><br><span class="line">        String msg = lStrings.getString(<span class="string">&quot;http.method_delete_not_supported&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (protocol.endsWith(<span class="string">&quot;1.1&quot;</span>)) &#123;</span><br><span class="line">            resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method[] getAllDeclaredMethods(Class&lt;?&gt; c) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c.equals(javax.servlet.http.HttpServlet.class)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method[] parentMethods = getAllDeclaredMethods(c.getSuperclass());</span><br><span class="line">        Method[] thisMethods = c.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((parentMethods != <span class="keyword">null</span>) &amp;&amp; (parentMethods.length &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">            Method[] allMethods =</span><br><span class="line">                <span class="keyword">new</span> Method[parentMethods.length + thisMethods.length];</span><br><span class="line">            System.arraycopy(parentMethods, <span class="number">0</span>, allMethods, <span class="number">0</span>,</span><br><span class="line">                             parentMethods.length);</span><br><span class="line">            System.arraycopy(thisMethods, <span class="number">0</span>, allMethods, parentMethods.length,</span><br><span class="line">                             thisMethods.length);</span><br><span class="line"></span><br><span class="line">            thisMethods = allMethods;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> thisMethods;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOptions</span><span class="params">(HttpServletRequest req,</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Method[] methods = getAllDeclaredMethods(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> ALLOW_GET = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> ALLOW_HEAD = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> ALLOW_POST = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> ALLOW_PUT = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> ALLOW_DELETE = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> ALLOW_TRACE = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> ALLOW_OPTIONS = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tomcat specific hack to see if TRACE is allowed</span></span><br><span class="line">        Class&lt;?&gt; clazz = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = Class.forName(<span class="string">&quot;org.apache.catalina.connector.RequestFacade&quot;</span>);</span><br><span class="line">            Method getAllowTrace = clazz.getMethod(<span class="string">&quot;getAllowTrace&quot;</span>, (Class&lt;?&gt;[]) <span class="keyword">null</span>);</span><br><span class="line">            ALLOW_TRACE = ((Boolean) getAllowTrace.invoke(req, (Object[]) <span class="keyword">null</span>)).booleanValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException | NoSuchMethodException | SecurityException |</span><br><span class="line">                IllegalAccessException | IllegalArgumentException | InvocationTargetException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore. Not running on Tomcat. TRACE is always allowed.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// End of Tomcat specific hack</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;methods.length; i++) &#123;</span><br><span class="line">            Method m = methods[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m.getName().equals(<span class="string">&quot;doGet&quot;</span>)) &#123;</span><br><span class="line">                ALLOW_GET = <span class="keyword">true</span>;</span><br><span class="line">                ALLOW_HEAD = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (m.getName().equals(<span class="string">&quot;doPost&quot;</span>))</span><br><span class="line">                ALLOW_POST = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (m.getName().equals(<span class="string">&quot;doPut&quot;</span>))</span><br><span class="line">                ALLOW_PUT = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (m.getName().equals(<span class="string">&quot;doDelete&quot;</span>))</span><br><span class="line">                ALLOW_DELETE = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String allow = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (ALLOW_GET)</span><br><span class="line">            allow=METHOD_GET;</span><br><span class="line">        <span class="keyword">if</span> (ALLOW_HEAD)</span><br><span class="line">            <span class="keyword">if</span> (allow==<span class="keyword">null</span>) allow=METHOD_HEAD;</span><br><span class="line">            <span class="keyword">else</span> allow += <span class="string">&quot;, &quot;</span> + METHOD_HEAD;</span><br><span class="line">        <span class="keyword">if</span> (ALLOW_POST)</span><br><span class="line">            <span class="keyword">if</span> (allow==<span class="keyword">null</span>) allow=METHOD_POST;</span><br><span class="line">            <span class="keyword">else</span> allow += <span class="string">&quot;, &quot;</span> + METHOD_POST;</span><br><span class="line">        <span class="keyword">if</span> (ALLOW_PUT)</span><br><span class="line">            <span class="keyword">if</span> (allow==<span class="keyword">null</span>) allow=METHOD_PUT;</span><br><span class="line">            <span class="keyword">else</span> allow += <span class="string">&quot;, &quot;</span> + METHOD_PUT;</span><br><span class="line">        <span class="keyword">if</span> (ALLOW_DELETE)</span><br><span class="line">            <span class="keyword">if</span> (allow==<span class="keyword">null</span>) allow=METHOD_DELETE;</span><br><span class="line">            <span class="keyword">else</span> allow += <span class="string">&quot;, &quot;</span> + METHOD_DELETE;</span><br><span class="line">        <span class="keyword">if</span> (ALLOW_TRACE)</span><br><span class="line">            <span class="keyword">if</span> (allow==<span class="keyword">null</span>) allow=METHOD_TRACE;</span><br><span class="line">            <span class="keyword">else</span> allow += <span class="string">&quot;, &quot;</span> + METHOD_TRACE;</span><br><span class="line">        <span class="keyword">if</span> (ALLOW_OPTIONS)</span><br><span class="line">            <span class="keyword">if</span> (allow==<span class="keyword">null</span>) allow=METHOD_OPTIONS;</span><br><span class="line">            <span class="keyword">else</span> allow += <span class="string">&quot;, &quot;</span> + METHOD_OPTIONS;</span><br><span class="line"></span><br><span class="line">        resp.setHeader(<span class="string">&quot;Allow&quot;</span>, allow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doTrace</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> responseLength;</span><br><span class="line"></span><br><span class="line">        String CRLF = <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">        StringBuilder buffer = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;TRACE &quot;</span>).append(req.getRequestURI())</span><br><span class="line">            .append(<span class="string">&quot; &quot;</span>).append(req.getProtocol());</span><br><span class="line"></span><br><span class="line">        Enumeration&lt;String&gt; reqHeaderEnum = req.getHeaderNames();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( reqHeaderEnum.hasMoreElements() ) &#123;</span><br><span class="line">            String headerName = reqHeaderEnum.nextElement();</span><br><span class="line">            buffer.append(CRLF).append(headerName).append(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">                .append(req.getHeader(headerName));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buffer.append(CRLF);</span><br><span class="line"></span><br><span class="line">        responseLength = buffer.length();</span><br><span class="line"></span><br><span class="line">        resp.setContentType(<span class="string">&quot;message/http&quot;</span>);</span><br><span class="line">        resp.setContentLength(responseLength);</span><br><span class="line">        ServletOutputStream out = resp.getOutputStream();</span><br><span class="line">        out.print(buffer.toString());</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String method = req.getMethod();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">            <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">            <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// servlet doesn&#x27;t support if-modified-since, no reason</span></span><br><span class="line">                <span class="comment">// to go through further expensive logic</span></span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> ifModifiedSince;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException iae) &#123;</span><br><span class="line">                    <span class="comment">// Invalid date header - proceed as if none was set</span></span><br><span class="line">                    ifModifiedSince = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ifModifiedSince &lt; (lastModified / <span class="number">1000</span> * <span class="number">1000</span>)) &#123;</span><br><span class="line">                    <span class="comment">// If the servlet mod time is later, call doGet()</span></span><br><span class="line">                    <span class="comment">// Round down to the nearest second for a proper compare</span></span><br><span class="line">                    <span class="comment">// A ifModifiedSince of -1 will always be less</span></span><br><span class="line">                    maybeSetLastModified(resp, lastModified);</span><br><span class="line">                    doGet(req, resp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">            <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">            maybeSetLastModified(resp, lastModified);</span><br><span class="line">            doHead(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class="line">            doPost(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">            doPut(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">            doDelete(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">            doOptions(req,resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">            doTrace(req,resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Note that this means NO servlet supports whatever</span></span><br><span class="line">            <span class="comment">// method was requested, anywhere on this server.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            String errMsg = lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">            Object[] errArgs = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">            errArgs[<span class="number">0</span>] = method;</span><br><span class="line">            errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line"></span><br><span class="line">            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maybeSetLastModified</span><span class="params">(HttpServletResponse resp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">long</span> lastModified)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (resp.containsHeader(HEADER_LASTMOD))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (lastModified &gt;= <span class="number">0</span>)</span><br><span class="line">            resp.setDateHeader(HEADER_LASTMOD, lastModified);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        HttpServletRequest  request;</span><br><span class="line">        HttpServletResponse response;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            request = (HttpServletRequest) req;</span><br><span class="line">            response = (HttpServletResponse) res;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(lStrings.getString(<span class="string">&quot;http.non_http&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        service(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致思路和刚才自定义的思路类似，不过这里不得不吐槽一下service里面的大量if else 的确略笨重。<br /><a name="0cxb0"></a></p><h3 id="servlet实现"><a class="markdownIt-Anchor" href="#servlet实现"></a> Servlet实现：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;posting&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        doGet(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="TGayZ"></a></p><h1 id="请求的生命周期"><a class="markdownIt-Anchor" href="#请求的生命周期"></a> 请求的生命周期</h1><p>发送给浏览器信息如图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582122436148-34e3cecb-26f1-4051-93da-72f88fd66647.png#align=left&amp;display=inline&amp;height=470&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=567&amp;originWidth=831&amp;size=45789&amp;status=done&amp;style=none&amp;width=689" alt="image.png" /><br />当客户端浏览器将请求发送到服务器后，服务器会根据HTTP请求进行解析。同时，服务器会创建HttpServletRequest的实现类RequestFacade的对象，即请求对象。然后在调用对应的set方法，将解析出的数据封装到请求中。此时HttpServletRequset实例就创建并初始化完毕了。也就是说，请求对象是由服务器（tomcat）创建的。<br />当服务器向客户端发送响应后，HttpRequest实例对象被服务器销毁。<br /><a name="eOaGR"></a></p><h1 id="请求参数的获取"><a class="markdownIt-Anchor" href="#请求参数的获取"></a> 请求参数的获取</h1><p>当数据发送到服务器，服务器要对参数进行解析。HttpServletRequest对于请求中所携带的参数是以map的形式接受的，并且map的key为String，value为String数组。之所以是这种形式是因为一个name可以对应多个value，而一个value只能对应一个name。<br /><a name="ZeECW"></a></p><h2 id="代码演示"><a class="markdownIt-Anchor" href="#代码演示"></a> 代码演示：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//指定名称请求数据值获取</span></span><br><span class="line">        String name = request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        String strAge = request.getParameter(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Integer age = Integer.parseInt(strAge);</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + name + <span class="string">&quot; 年龄：&quot;</span> + age);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有请求的名称</span></span><br><span class="line">        Enumeration&lt;String&gt; names = request.getParameterNames();</span><br><span class="line">        <span class="comment">//遍历枚举</span></span><br><span class="line">        <span class="keyword">while</span> (names.hasMoreElements()) &#123;</span><br><span class="line">            String tempName = names.nextElement();</span><br><span class="line">            String element = request.getParameter(tempName);</span><br><span class="line">            System.out.println(tempName + <span class="string">&quot;:&quot;</span> + element);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] hobby = request.getParameterValues(<span class="string">&quot;hobby&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String str : hobby) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取存放请求的Map</span></span><br><span class="line">        Map&lt;String, String[]&gt; map = request.getParameterMap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="E1OMc"></a></p><h2 id="效果演示"><a class="markdownIt-Anchor" href="#效果演示"></a> 效果演示：</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582136903551-2d31532e-02ef-449d-af96-e8ca4a371ef3.png#align=left&amp;display=inline&amp;height=140&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=161&amp;originWidth=223&amp;size=23826&amp;status=done&amp;style=none&amp;width=194" alt="image.png" /><br /><a name="Wpgx2"></a></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h2><ol><li>请求参数是存放在Map中的</li><li>这个Map的Key为请求参数的名称，为String类型。Map的Value为请求参数的所有值，为String[]类型。</li><li>使用最多的是getParameter方法，其等价于getParametervalues()[0]。<br /><a name="JRj0i"></a></li></ol><h1 id="域属性"><a class="markdownIt-Anchor" href="#域属性"></a> 域属性</h1><p>在Request中也存在域属性空间，用于存放有名称的数据。该数据只在当前Request请求中进行访问。一般常用在请求转发方案中，将request对象给别的servlet用来参与这一次请求转发操作中所设计的Servlet提供共享数据。<br /><a name="kykUJ"></a></p><h2 id="someservlet"><a class="markdownIt-Anchor" href="#someservlet"></a> SomeServlet:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//设置属性</span></span><br><span class="line">        request.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">//获得属性</span></span><br><span class="line">        System.out.println(request.getAttribute(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">//获得其他的servlet</span></span><br><span class="line">        RequestDispatcher dispatcher = request.getRequestDispatcher(<span class="string">&quot;/OtherServlet&quot;</span>);</span><br><span class="line">        <span class="comment">//发送request到另一个dispatcher</span></span><br><span class="line">        dispatcher.forward(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="zCUnD"></a></p><h2 id="otherservlet"><a class="markdownIt-Anchor" href="#otherservlet"></a> OtherServlet:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Other:&quot;</span> + req.getAttribute(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问域名：<a href="http://localhost:8080/RegisterServlet">http://localhost:8080/RegisterServlet</a><br /><a name="DSXTu"></a></p><h2 id="结果演示"><a class="markdownIt-Anchor" href="#结果演示"></a> 结果演示：</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582171296896-61831c7c-2d19-42ed-96fc-c6f08331b3e8.png#align=left&amp;display=inline&amp;height=77&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=77&amp;originWidth=211&amp;size=10805&amp;status=done&amp;style=none&amp;width=211" alt="image.png" /><br /><a name="qOBxm"></a></p><h1 id="访问路径问题"><a class="markdownIt-Anchor" href="#访问路径问题"></a> 访问路径问题</h1><p>URL，统一资源定位符。URI，统一资源标识符。通常都分为两部分：资源路径、资源名称。根据资源路径是否可以独立完成资源准确定定位来区分绝对和相对路径。<br /><a name="Ma3l0"></a></p><h2 id="绝对路径"><a class="markdownIt-Anchor" href="#绝对路径"></a> 绝对路径</h2><p>Web应用的绝对路径是指带访问协议的路径，即URL。<br /><a name="RtjKO"></a></p><h2 id="相对路径"><a class="markdownIt-Anchor" href="#相对路径"></a> 相对路径</h2><p>相对路径必须结合参照路径才可以组成可以准确定位资源的绝对路径。<br />根据相对路径是否以/开头，且路径出现的文件的不同，其默认的参数路径是不同的。<br /><a name="STjtx"></a></p><h2 id="以斜杠开头的路径"><a class="markdownIt-Anchor" href="#以斜杠开头的路径"></a> 以斜杠开头的路径</h2><p>又分为：前台路径、后台路径<br /><a name="J1d2e"></a></p><h3 id="前台路径"><a class="markdownIt-Anchor" href="#前台路径"></a> 前台路径</h3><p>有浏览器解析执行的代码中包含的路径，如html、css等。前台路径的参照路径是web服务器的根路径即http://localhost:8080<br /><a name="SuG77"></a></p><h3 id="后台路径"><a class="markdownIt-Anchor" href="#后台路径"></a> 后台路径</h3><p>由服务器解析执行的代码及文件中包含的路径，如java、xml等。后台路径的参照路径是web应用的根路径。如http://localhost:8080/primary<br /><a name="Q0u0o"></a></p><h4 id="特例"><a class="markdownIt-Anchor" href="#特例"></a> 特例：</h4><p>当代码中出现response的sendRedircet方法进行重定向时，若其参照路径是以斜杠开头，其参照路径不是web应用的根路径，而是web服务器的根路径。<br />重定向是由浏览器来重复发送请求，而请求转发的请求时服务器来发的。浏览器发请求，就会有浏览器来不全参照路径。服务器内部发请求，则由浏览器补全。<br /><a name="vrHjn"></a></p><h2 id="以路径名称开头"><a class="markdownIt-Anchor" href="#以路径名称开头"></a> 以路径名称开头</h2><p>无论是什么位置，其参照路径都是当前访问路径的资源路径。</p>]]></content>
      
      
      <categories>
          
          <category> Servlet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端基础 </tag>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>servlet核心知识1</title>
      <link href="/posts/servlet-1/"/>
      <url>/posts/servlet-1/</url>
      
        <content type="html"><![CDATA[<p><a name="UFBPG"></a></p><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p><a name="vNLr9"></a></p><h2 id="什么是servlet"><a class="markdownIt-Anchor" href="#什么是servlet"></a> 什么是Servlet</h2><p>宏观的讲，servlet是连接web服务器与java程序的协议是一种通信规范，这个规范是以一套接口的形式体现的。<br />微观的讲，Servlet是接口实现类的一个实例对象，是运行在服务器上的一段Java小程序，即Server Applet。他主要功能是根据客户端提交的请求，调用服务器相关的Java代码，完成对请求的处理与运算。<br /><a name="a7HE0"></a></p><h2 id="web访问流程图"><a class="markdownIt-Anchor" href="#web访问流程图"></a> web访问流程图：</h2><p>浏览器–HTTP–&gt;web服务器tomcat–&gt;servlet–&gt;服务器端程序–JDBC–&gt;数据库MySQL<br /><a name="fzZIQ"></a></p><h2 id="编写动态资源步骤"><a class="markdownIt-Anchor" href="#编写动态资源步骤"></a> 编写动态资源步骤</h2><ol><li>编写一个Java类，实现javax.servlet.Servlet接口。</li><li>将这个Java类部署到web服务器中<br /><a name="UY3Gd"></a></li></ol><h2 id="servlet生命周期"><a class="markdownIt-Anchor" href="#servlet生命周期"></a> Servlet生命周期</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/485026/1598766084408-d5b892c2-9b72-46bf-9b1f-8ca0e21e4c26.jpeg#align=left&amp;display=inline&amp;height=273&amp;margin=%5Bobject%20Object%5D&amp;originHeight=273&amp;originWidth=474&amp;size=0&amp;status=done&amp;style=none&amp;width=474" alt="" /><br /><a name="qORia"></a></p><h2 id="servlet特点"><a class="markdownIt-Anchor" href="#servlet特点"></a> Servlet特点</h2><ol><li>Servlet是单例多线程的。</li><li>一个Servlet实例只会执行一次无参构造器与init方法，并且是在第一次访问时执行。</li><li>用户每提交一次对当前Servlet的请求，就会执行一次service方法。</li><li>一个Servlet实例只会执行一次destory方法，在应用停止时执行。</li><li>由于Servlet是单例多线程的，所以为了保证其线程安全性，一般情况下是不为Servlet类定义可修改的成员变量的。因为每个线程均可修改这个成员变量，会出现线程安全问题。</li><li>默认情况下，servlet在Web容器启动时是不会被实例化的。<br /><a name="4ZLCE"></a></li></ol><h3 id="线程安全问题"><a class="markdownIt-Anchor" href="#线程安全问题"></a> 线程安全问题</h3><p>Servlet是单例多线程并发访问的，所以其就有可能会出现线程安全问题。为了避免，对于Servlet的使用，一般是不声明成员变量的。若必须声明则通过同步机制synchroized避免。<br /><a name="M35Nu"></a></p><h1 id="url-partten"><a class="markdownIt-Anchor" href="#url-partten"></a> url-partten</h1><p>url-partten有如下四种匹配模式。<br /><a name="BOYtm"></a></p><h2 id="精确路径模式"><a class="markdownIt-Anchor" href="#精确路径模式"></a> 精确路径模式</h2><p>如果是按照<url-pattern>/demo/aaa/bbb/ccc</url-pattern>写的话，则用户必须按照/demo/aaa/bbb/ccc的精确路径来访问。<br />注意：一个servlet可以由多个url-pattern来匹配。<br /><a name="VmnOv"></a></p><h2 id="通配符路径模式"><a class="markdownIt-Anchor" href="#通配符路径模式"></a> 通配符路径模式</h2><p>按照<url-pattern>/demo/<em></url-pattern>方式写，其中</em>代表通配符，只要满足/demo/…即可访问对应的servlet。<br /><a name="xSvZg"></a></p><h2 id="全路径模式"><a class="markdownIt-Anchor" href="#全路径模式"></a> 全路径模式</h2><p>按照<url-pattern>/*</url-pattern>（或者<url-pattern>/</url-pattern>）方式写，与通配符路径类似，任何请求都能获取servlet。<br />不过其中/*与/是有区别的：</p><ul><li>/*可以拦截所有请求，无论是动态还是静态。</li><li>/只会拦截静态请求，对于动态请求不会做出反应。<br /><a name="Lohyc"></a></li></ul><h2 id="后缀名模式"><a class="markdownIt-Anchor" href="#后缀名模式"></a> 后缀名模式</h2><p>按照<url-pattern>*.do</url-pattern>方式写，只要以.do结尾的都会被拦截。<br /><a name="9mkND"></a></p><h2 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h2><ol><li>后缀名模式不能与其他模式混合使用。</li><li>当四种请求路径可能被一个请求出发时，则按照优先级进行匹配对应的url-partten。（匹配原则：路径优先后缀匹配原则、精确路径优先匹配原则、最长路径优先匹配原则）。<br /><a name="7RhbK"></a></li></ol><h1 id="注册servlet"><a class="markdownIt-Anchor" href="#注册servlet"></a> 注册Servlet</h1><p>在web.xml注册Servlet代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Servlet的名称（自己起的，不要重复）<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>Servlet的类路径（xx.xx.xx.xxservlet）<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Servlet的名称（与上面的一样）<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/url名字（自己起的，不要重复，注意/，不能丢）<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p><a name="3d973"></a></p><h2 id="映射关系形成方法"><a class="markdownIt-Anchor" href="#映射关系形成方法"></a> 映射关系形成方法：</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/485026/1582021090383-ec9ed025-b2ba-4287-a0be-66dfeb7c68d2.png#align=left&amp;display=inline&amp;height=253&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=395&amp;originWidth=886&amp;size=159155&amp;status=done&amp;style=none&amp;width=567" alt="image.png" /><br />第一个map是存放已被创建好的servlet实例引用，并且具有优先级被服务器提前创建<br />若第一个map中无法按照Url找到已被创建好的实例，则会到第二个map去找。<br />第二个map的key部分同样为uri，但是其value部分是web.xml中所有被写入的servlet-class全类名<br />，通过全类名和Url创建一个servlet实例，将其引用放到第一个map中。<br />注意：每个map中的url-pattern不能重复。<br /><a name="hp0jh"></a></p><h1 id="init获取配置信息"><a class="markdownIt-Anchor" href="#init获取配置信息"></a> init获取配置信息</h1><p>ServletConfig:代表当前Servlet在web.xml中的配置信息。其包含方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getServletName</span><span class="params">()</span>  -- 获取当前Servlet在web.xml中配置的名字</span></span><br><span class="line"><span class="function">String <span class="title">getInitParameter</span><span class="params">(String name)</span> -- 获取当前Servlet指定名称的初始化参数的值</span></span><br><span class="line"><span class="function">Enumeration <span class="title">getInitParameterNames</span><span class="params">()</span>  -- 获取当前Servlet所有初始化参数的名字组成的枚举</span></span><br><span class="line"><span class="function">ServletContext <span class="title">getServletContext</span><span class="params">()</span>  -- 获取代表当前web应用的ServletContext对象</span></span><br></pre></td></tr></table></figure><p>getServletConfig方法又返回{@link ServletConfig}对象，该对象包含初始化此servlet的启动参数。返回的ServletConfig对象是传递给init方法的对象。这就是init获取配置信息的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ServletConfig config;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.config = config;</span><br><span class="line">        System.out.println(<span class="string">&quot;config=&quot;</span> + config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a name="v3tUQ"></a></p><h1 id="自定义基本的genericservlet"><a class="markdownIt-Anchor" href="#自定义基本的genericservlet"></a> 自定义基本的GenericServlet</h1><p>Servlet是个接口类，显然不能独立完成业务，需要实现该接口类进行业务处理。<br /><a name="A0oUB"></a></p><h2 id="适配器模式的引入"><a class="markdownIt-Anchor" href="#适配器模式的引入"></a> 适配器模式的引入</h2><p>继承自Servlet接口就要实现四个方法，然而事实上并不需要service以外的那个三个方法频繁实现，这就要用到了适配器模式中的缺省适配器模式来减少代码冗杂，此外，即使要重写，在子类中也可以完成重写覆盖，不过不要忘记super。样例如下：<br /><a name="rEfY9"></a></p><h3 id="genericservlet"><a class="markdownIt-Anchor" href="#genericservlet"></a> GenericServlet：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="toXju"></a></p><h3 id="servlet实现"><a class="markdownIt-Anchor" href="#servlet实现"></a> Servlet实现：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Running Service&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在GenericServlet（父类）定义了getServletInfo方法，如果要获取Config信息，在子类DemoServlet即可通过这个方法直接调用获取获取。但是如果要获取Config中的参数的话，则需要不停的通过手动get在ServletConfig中获取，从而也会造成大量的代码冗余。<br /><a name="wlpvT"></a></p><h2 id="继承优化"><a class="markdownIt-Anchor" href="#继承优化"></a> 继承优化</h2><p>为了解决上述问题，直接让GenericServlet继承自ServletConfig，从而在父类中就实现了get方法，在service中直接调用即可。<br /><a name="toBf5"></a></p><h3 id="genericservlet-2"><a class="markdownIt-Anchor" href="#genericservlet-2"></a> GenericServlet：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span>, <span class="title">ServletConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServletConfig config;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.config = config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> config.getServletName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> config.getServletContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInitParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> config.getInitParameter(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getInitParameterNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> config.getInitParameterNames();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="PThZB"></a></p><h3 id="servlet实现-2"><a class="markdownIt-Anchor" href="#servlet实现-2"></a> Servlet实现：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Running Service&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getInitParameter(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="GSaEK"></a></p><h2 id="重写优化"><a class="markdownIt-Anchor" href="#重写优化"></a> 重写优化</h2><p>如果在Servlet实现中想要重写init这类方法，要时刻铭记加上super.init()来防止config未被初始化的问题发生，但是这个出错概率过高，因此要在父类中避免这种问题发生。<br /><a name="4eENh"></a></p><h3 id="genericservlet-3"><a class="markdownIt-Anchor" href="#genericservlet-3"></a> GenericServlet：</h3><p>为子类书写一个专门用于重写的方法，避免了发生错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.config = config;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a name="n3mqX"></a></p><h3 id="servlet实现-3"><a class="markdownIt-Anchor" href="#servlet实现-3"></a> Servlet实现：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Running Service&quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.println(<span class="keyword">this</span>.getInitParameter(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    System.out.println(<span class="keyword">this</span>.getServletContext());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---init is running---&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="k8aHC"></a></p><h1 id="系统自带genericservlet"><a class="markdownIt-Anchor" href="#系统自带genericservlet"></a> 系统自带GenericServlet</h1><p>前面一通改良的自定义的GenericServlet，其实系统自带，路径：javax.servlet.GenericServlet。<br /><a name="sYrQ4"></a></p><h2 id="源码"><a class="markdownIt-Anchor" href="#源码"></a> 源码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span>, <span class="title">ServletConfig</span>,</span></span><br><span class="line"><span class="class">        <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ServletConfig config;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// NOOP</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// NOOP by default</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInitParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getServletConfig().getInitParameter(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getInitParameterNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getServletConfig().getInitParameterNames();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getServletConfig().getServletContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.config = config;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// NOOP by default</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        getServletContext().log(getServletName() + <span class="string">&quot;: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message, Throwable t)</span> </span>&#123;</span><br><span class="line">        getServletContext().log(getServletName() + <span class="string">&quot;: &quot;</span> + message, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> config.getServletName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大抵与之前的自定义类相同，不过在自定义类之上还做出了优化，例如序列化等。</p>]]></content>
      
      
      <categories>
          
          <category> Servlet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端基础 </tag>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/hexo_helloworld/"/>
      <url>/posts/hexo_helloworld/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo入门 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
