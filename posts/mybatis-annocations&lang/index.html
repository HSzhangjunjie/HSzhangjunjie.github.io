<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>reflection包 | Jieker's Blog</title><meta name="description" content="reflection包   基础知识   装饰器模式 装饰器模式又称包装模式，是一种结构型模式。在使用装饰器模式对包装类进行扩展后不会影响原有类。通常使用的场景是在一个核心基本类的基础上提供大量的装饰类，从而使核心基本类经过不同的装饰类修饰后获得不同的功能。此外，装饰器类还可以叠加使用，从而使一个基本类同时具有多个装饰类的功能。装饰器模式归在本人的理解就是在一杯奶茶里加上波霸、芋圆、椰果后，这杯"><meta name="keywords" content="mybatis"><meta name="author" content="Zhang Junjie"><meta name="copyright" content="Zhang Junjie"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/url(https:/jie-blog.icu/img/Log.png)"><link rel="canonical" href="https://jie-blog.icu/posts/mybatis-annocations&amp;lang/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta property="og:type" content="article"><meta property="og:title" content="reflection包"><meta property="og:url" content="https://jie-blog.icu/posts/mybatis-annocations&amp;lang/"><meta property="og:site_name" content="Jieker's Blog"><meta property="og:description" content="reflection包   基础知识   装饰器模式 装饰器模式又称包装模式，是一种结构型模式。在使用装饰器模式对包装类进行扩展后不会影响原有类。通常使用的场景是在一个核心基本类的基础上提供大量的装饰类，从而使核心基本类经过不同的装饰类修饰后获得不同的功能。此外，装饰器类还可以叠加使用，从而使一个基本类同时具有多个装饰类的功能。装饰器模式归在本人的理解就是在一杯奶茶里加上波霸、芋圆、椰果后，这杯"><meta property="og:image" content="https://jie-blog.icu/img/mybatis/mybatis.jpg"><meta property="article:published_time" content="2020-11-04T03:54:22.000Z"><meta property="article:modified_time" content="2020-11-04T04:15:27.993Z"><meta name="twitter:card" content="summary"><link rel="manifest" href="/image/pwa/manifest.json"><link rel="apple-touch-icon" sizes="180x180" href="/image/pwa/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/image/pwa/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/image/pwa/16.png"><link rel="mask-icon" href="/image/pwa/safari-pinned-tab.svg" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"",enable_page_level_ads:"true"})</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: {"limitCount":50,"languages":{"author":"Jieker: Zhang Junjie","link":"链接: ","source":"来源: Jieker's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
      const now = new Date()
      const expiryDay = ttl * 86400000
      const item = {
        value: value,
        expiry: now.getTime() + expiryDay,
      }
      localStorage.setItem(key, JSON.stringify(item))
    },
  
  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!0,isSidebar:!0,postUpdate:"2020-11-04 12:15:27"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}</style></noscript><script>var activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")},autoChangeMode="false",t=saveToLocal.get("theme");if("1"===autoChangeMode){var isDarkMode=window.matchMedia("(prefers-color-scheme: dark)").matches,isLightMode=window.matchMedia("(prefers-color-scheme: light)").matches,isNotSpecified=window.matchMedia("(prefers-color-scheme: no-preference)").matches,hasNoSupport=!isDarkMode&&!isLightMode&&!isNotSpecified;if(void 0===t){if(isLightMode)activateLightMode();else if(isDarkMode)activateDarkMode();else if(isNotSpecified||hasNoSupport){var now=new Date,hour=now.getHours(),isNight=hour<=6||18<=hour;isNight?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())})}else"light"===t?activateLightMode():activateDarkMode()}else"2"===autoChangeMode?(isNight=(hour=(now=new Date).getHours())<=6||18<=hour,void 0===t?isNight?activateDarkMode():activateLightMode():"light"===t?activateLightMode():activateDarkMode()):"dark"===t?activateDarkMode():"light"===t&&activateLightMode()</script><script src="/js/daovoice.js"></script><link rel="stylesheet" href="footer.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/atom.xml" title="Jieker's Blog" type="application/atom+xml"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="./img/loading.gif" data-original="/img/picture.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">64</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">12</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">14</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i> <span>Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i> <span>Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i> <span>Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i> <span>About</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#reflection%E5%8C%85"><span class="toc-number">1.</span> <span class="toc-text">reflection包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">装饰器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">2.2.</span> <span class="toc-text">反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AD%90%E7%B1%BB"><span class="toc-number">2.3.</span> <span class="toc-text">Type接口及其子类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%B7%A5%E5%8E%82%E5%AD%90%E5%8C%85"><span class="toc-number">3.</span> <span class="toc-text">对象工厂子包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%99%A8%E5%AD%90%E5%8C%85"><span class="toc-number">4.</span> <span class="toc-text">执行器子包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#methodinvoker%E7%9A%84gettype"><span class="toc-number">4.1.</span> <span class="toc-text">MethodInvoker的getType</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#invoke%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.</span> <span class="toc-text">invoke的实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%AD%90%E5%8C%85"><span class="toc-number">5.</span> <span class="toc-text">属性子包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#propertiescopier"><span class="toc-number">5.1.</span> <span class="toc-text">PropertiesCopier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#propertynamer"><span class="toc-number">5.2.</span> <span class="toc-text">PropertyNamer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#propertytokenizer"><span class="toc-number">5.3.</span> <span class="toc-text">PropertyTokenizer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8%E5%AD%90%E5%8C%85"><span class="toc-number">6.</span> <span class="toc-text">对象包装器子包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#beanwrapper"><span class="toc-number">6.1.</span> <span class="toc-text">BeanWrapper</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%88%B6%E5%8C%85%E7%B1%BB"><span class="toc-number">7.</span> <span class="toc-text">父包类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%A0%B8%E5%BF%83%E7%B1%BB"><span class="toc-number">7.1.</span> <span class="toc-text">反射核心类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#reflection"><span class="toc-number">7.1.1.</span> <span class="toc-text">Reflection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defaultreflectorfactory"><span class="toc-number">7.1.2.</span> <span class="toc-text">DefaultReflectorFactory</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">7.2.</span> <span class="toc-text">反射包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#metaobject"><span class="toc-number">7.2.1.</span> <span class="toc-text">MetaObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#metaclass"><span class="toc-number">7.2.2.</span> <span class="toc-text">MetaClass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#systemmetaobject"><span class="toc-number">7.2.3.</span> <span class="toc-text">SystemMetaObject</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%8B%86%E5%8C%85%E7%B1%BB"><span class="toc-number">7.3.</span> <span class="toc-text">异常拆包类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#invocationtargetexception"><span class="toc-number">7.3.1.</span> <span class="toc-text">InvocationTargetException</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undeclaredthrowableexception"><span class="toc-number">7.3.2.</span> <span class="toc-text">UndeclaredThrowableException</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">7.3.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%90%8D%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">7.4.</span> <span class="toc-text">参数名解析器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">7.5.</span> <span class="toc-text">泛型解析器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%99%A8%E4%BD%9C%E7%94%A8"><span class="toc-number">7.5.1.</span> <span class="toc-text">解析器作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%99%A8%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">7.5.2.</span> <span class="toc-text">解析器原理分析</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image:url(https://jie-blog.icu/img/mybatis/mybatis.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Jieker's Blog</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i> <span>Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i> <span>Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i> <span>Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i> <span>About</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">reflection包</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-04T03:54:22.000Z" title="发表于 2020-11-04 11:54:22">2020-11-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-11-04T04:15:27.993Z" title="更新于 2020-11-04 12:15:27">2020-11-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/mybatis/">mybatis</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/mybatis/%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%8C%85/">基础功能包</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="reflection包"><a class="markdownIt-Anchor" href="#reflection包"></a> reflection包</h1><p><a name="vA04i"></a></p><h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1><p><a name="Pw5mh"></a></p><h2 id="装饰器模式"><a class="markdownIt-Anchor" href="#装饰器模式"></a> 装饰器模式</h2><p>装饰器模式又称包装模式，是一种结构型模式。在使用装饰器模式对包装类进行扩展后不会影响原有类。通常使用的场景是在一个核心基本类的基础上提供大量的装饰类，从而使核心基本类经过不同的装饰类修饰后获得不同的功能。此外，装饰器类还可以叠加使用，从而使一个基本类同时具有多个装饰类的功能。<br>装饰器模式归在本人的理解就是在一杯奶茶里加上波霸、芋圆、椰果后，这杯奶茶变成了一杯加料的“奶茶”。好比FileInputStream和InputStream的关系。<br><a name="7LE5V"></a></p><h2 id="反射"><a class="markdownIt-Anchor" href="#反射"></a> 反射</h2><p>通过Java的反射能够在类的运行过程中知道这个类有哪些属性和方法。此外，还可以修改属性、调用方法、建立类的实例。例如平常进行的复制操作就可以利用反射书写一个适用于任何类的对象的赋值工作。<br>反射主要提供了以下几个功能：</p><ul><li>在运行时判断任意一个对象所属的类。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时修改任意一个对象的成员变量。</li><li>在运行时调用任意一个对象的方法。<br><a name="lqoZy"></a></li></ul><h2 id="type接口及其子类"><a class="markdownIt-Anchor" href="#type接口及其子类"></a> Type接口及其子类</h2><p>在反射中经常会遇到一个位于java.lang.reflect包下的Type接口，该接口子类类图如下：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1601365504161-8d341197-8b6a-42c1-ab12-762df6a6052a.png#align=left&amp;display=inline&amp;height=147&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=294&amp;originWidth=1262&amp;size=581414&amp;status=done&amp;style=none&amp;width=631" alt="image.png"></p><ul><li>Class类：它代表运行的Java程序中的类和接口。</li><li>WildcardType接口：它代表通配符表达式。例如：“？”，“？ extends Number”。</li><li>TypeVariable接口：它代表参数化的类型，例如：“Map&lt;K，V&gt;”中的K，V。</li><li>ParameterizedType接口：它代表参数化的类型。例如：“Collection<string>”就是参数化类型。</string></li><li>GenericArrayType接口：它代表包含ParameterizedType或者TypeVariable元素的列表。<br><a name="YSlQP"></a></li></ul><h1 id="对象工厂子包"><a class="markdownIt-Anchor" href="#对象工厂子包"></a> 对象工厂子包</h1><p>reflection包下的factory子包就是一个对象工厂子包，该对象常用来基于反射生产出各种对象，子包结构：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1601365848909-95047bfd-6944-44cc-8aa4-b02c99110907.png#align=left&amp;display=inline&amp;height=68&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=109&amp;originWidth=316&amp;size=14545&amp;status=done&amp;style=none&amp;width=197" alt="image.png"><br>观察ObjectFacory接口，有如下三个方法：</p><ul><li><code>void setProperties(Properties properties)</code>：设置工厂属性</li><li><code>&lt;T&gt; T create(Class&lt;T&gt; type)</code>：传入到下一个create</li><li><code>&lt;T&gt; T create(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</code>：传入目标类型、参数类型列表、参数值列表，根据相应的含参构造方法生成这个类型的实例。</li><li><code>&lt;T&gt; boolean isCollection(Class&lt;T&gt; type)</code>：判断传入的类型是否是一个集合类。</li></ul><p>DefaultObjectFactory类实现了该接口，其create最终返回的是instantiateClass方法生成的对象，其方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>  &lt;T&gt; <span class="function">T <span class="title">instantiateClass</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 构造方法对象</span></span><br><span class="line">    Constructor&lt;T&gt; constructor;</span><br><span class="line">    <span class="comment">// 判断是否不含参或者参数列表为null</span></span><br><span class="line">    <span class="keyword">if</span> (constructorArgTypes == <span class="keyword">null</span> || constructorArgs == <span class="keyword">null</span>) &#123;</span><br><span class="line">      constructor = type.getDeclaredConstructor();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 返回空构造函数生成对象</span></span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="comment">// 如果访问异常，判断构造函数访问属性可否修改</span></span><br><span class="line">        <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) &#123;</span><br><span class="line">          <span class="comment">// 修改构造函数访问属性</span></span><br><span class="line">          constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">          <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据输入参数类型找到对应的构造器</span></span><br><span class="line">    constructor = type.getDeclaredConstructor(constructorArgTypes.toArray(<span class="keyword">new</span> Class[constructorArgTypes.size()]));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 采用有参构造函数创建实例并返回</span></span><br><span class="line">      <span class="keyword">return</span> constructor.newInstance(constructorArgs.toArray(<span class="keyword">new</span> Object[constructorArgs.size()]));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) &#123;</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance(constructorArgs.toArray(<span class="keyword">new</span> Object[constructorArgs.size()]));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 收集所有参数类型</span></span><br><span class="line">    String argTypes = Optional.ofNullable(constructorArgTypes).orElseGet(Collections::emptyList)</span><br><span class="line">        .stream().map(Class::getSimpleName).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">    <span class="comment">// 收集所有参数</span></span><br><span class="line">    String argValues = Optional.ofNullable(constructorArgs).orElseGet(Collections::emptyList)</span><br><span class="line">        .stream().map(String::valueOf).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">&quot;Error instantiating &quot;</span> + type + <span class="string">&quot; with invalid types (&quot;</span> + argTypes + <span class="string">&quot;) or values (&quot;</span> + argValues + <span class="string">&quot;). Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外该实现类里还有一个resolveInterface方法，其作用是判断如果传入的类型是容器接口的话，返回相应的容器对象，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveInterface(Class&lt;?&gt; type) &#123;</span><br><span class="line">  Class&lt;?&gt; classToCreate;</span><br><span class="line">  <span class="keyword">if</span> (type == List.class || type == Collection.class || type == Iterable.class) &#123;</span><br><span class="line">    classToCreate = ArrayList.class;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Map.class) &#123;</span><br><span class="line">    classToCreate = HashMap.class;</span><br><span class="line">  &#125; else if (type == SortedSet.class) &#123; // issue #510 Collections Support</span><br><span class="line">    classToCreate = TreeSet.class;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Set.class) &#123;</span><br><span class="line">    classToCreate = HashSet.class;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    classToCreate = type;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> classToCreate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="duvQU"></a></p><h1 id="执行器子包"><a class="markdownIt-Anchor" href="#执行器子包"></a> 执行器子包</h1><p>reflection包下的invoker子包是执行器的子包，该子包中的类能够基于反射实现对象方法的调用和对象属性的读写，该包下的类图如下：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1601366988466-8ad4d0f5-6c8d-4f7a-b5c6-7dcff3ef3098.png#align=left&amp;display=inline&amp;height=182&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=364&amp;originWidth=1126&amp;size=630938&amp;status=done&amp;style=none&amp;width=563" alt="image.png"><br>Invoker的三种实现分别用于处理环境如下：</p><ul><li>GetFieldInvoker：负责对象属性的读操作。</li><li>SetFiledInvoker：负责对象属性的写操作。</li><li>MethodInvoker：负责对象其他方法的操作。</li></ul><p>此外，Invoker接口中定义的两个抽象方法的功能分别是：</p><ul><li>invoker：执行方法，该方法负责完成对象方法的调用和对象属性的读写。在三个实现类中，分别是属性读写操作、属性赋值操作、方法触发操作。</li><li>getType：用来获取方法。它对于GetFieldInvoker、SetFiledInvoker的含义是获取目标属性类型，而MethodInvoker取略有不同，详见下文。<br><a name="GCbzN"></a></li></ul><h2 id="methodinvoker的gettype"><a class="markdownIt-Anchor" href="#methodinvoker的gettype"></a> MethodInvoker的getType</h2><p>该类的getType源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getType() &#123;</span><br><span class="line">  <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅仅是返回一个type对象，其对象又是在其构造方法中定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MethodInvoker</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.method = method;</span><br><span class="line"><span class="comment">// 有且仅有一个参数时</span></span><br><span class="line">   <span class="keyword">if</span> (method.getParameterTypes().length == <span class="number">1</span>) &#123;</span><br><span class="line">     type = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     type = method.getReturnType();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当有且仅有一个参数时，type为输入参数的类型，否则type将为返回值类型。<br><a name="ef7BF"></a></p><h2 id="invoke的实现"><a class="markdownIt-Anchor" href="#invoke的实现"></a> invoke的实现</h2><p>这里以GetFieldInvoker为示例，其实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object target, Object[] args)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 直接获取反射目标对象的值</span></span><br><span class="line">    <span class="keyword">return</span> field.get(target);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    <span class="comment">// 如果属性的访问性可以修改</span></span><br><span class="line">    <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) &#123;</span><br><span class="line">      <span class="comment">// 修改访问属性</span></span><br><span class="line">      field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">return</span> field.get(target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><a name="RkJTo"></a></p><h1 id="属性子包"><a class="markdownIt-Anchor" href="#属性子包"></a> 属性子包</h1><p>reflection包下的properties子包是属性的子包，该子包中的类用来完成与对象属性相关的操作，其包结构如下：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1601367880256-db406b71-8690-4b05-8f40-46765dfc1c2d.png#align=left&amp;display=inline&amp;height=81&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=106&amp;originWidth=272&amp;size=14096&amp;status=done&amp;style=none&amp;width=208" alt="image.png"><br><a name="i1U8m"></a></p><h2 id="propertiescopier"><a class="markdownIt-Anchor" href="#propertiescopier"></a> PropertiesCopier</h2><p>其中，PropertiesCopier负责复制属性的值，该类中的唯一方法就是实现拷贝功能的方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyBeanProperties</span><span class="params">(Class&lt;?&gt; type, Object sourceBean, Object destinationBean)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 两个对象同属的类</span></span><br><span class="line">  Class&lt;?&gt; parent = type;</span><br><span class="line">  <span class="keyword">while</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取该类的全部属性</span></span><br><span class="line">    <span class="keyword">final</span> Field[] fields = parent.getDeclaredFields();</span><br><span class="line">    <span class="comment">// 遍历属性</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 调用set方法进行赋值</span></span><br><span class="line">          field.set(destinationBean, field.get(sourceBean));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">          <span class="comment">// 判断是否有属性访问权限</span></span><br><span class="line">          <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) &#123;</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            field.set(destinationBean, field.get(sourceBean));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// Nothing useful to do, will only fail on final fields, which will be ignored.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parent = parent.getSuperclass();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：该方法无法完成继承得来的属性的赋值，因为copyBeanProperties方法在赋值的时候不包含继承属性。<br><a name="MY2un"></a></p><h2 id="propertynamer"><a class="markdownIt-Anchor" href="#propertynamer"></a> PropertyNamer</h2><p>该类用于提供属性名称相关的操作功能，其正常运行的前提下是对象的属性符合JavaBean命名规范。<br><a name="x1caz"></a></p><h2 id="propertytokenizer"><a class="markdownIt-Anchor" href="#propertytokenizer"></a> PropertyTokenizer</h2><p>该类是一个属性标记器，当传入一个形如“student[sId].name”的字符串时，标记器会将其拆开放入到各个属性中。<br><a name="81yad"></a></p><h1 id="对象包装器子包"><a class="markdownIt-Anchor" href="#对象包装器子包"></a> 对象包装器子包</h1><p>reflection包下的wrapper子包是对象包装器的子包，该子包中的类使用装饰器模式对各种类型的对象进行进一步封装，使其增加新的功能。包内类图：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1601448001468-5b168440-ce42-4f74-9f73-4a0eaea7ef81.png#align=left&amp;display=inline&amp;height=305&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=610&amp;originWidth=1107&amp;size=855226&amp;status=done&amp;style=none&amp;width=553.5" alt="image.png"><br>其中DefaultObjectWrapperFactory是对象包装器工厂接口的实现，但是这个类中并没有任何功能。因此用户可以通过这个接口定义自己的工厂实现类。<br><a name="pNTCp"></a></p><h2 id="beanwrapper"><a class="markdownIt-Anchor" href="#beanwrapper"></a> BeanWrapper</h2><p>ObjectWrapper接口是所有对象包装器的总接口，下面将以BeanWrapper为例介绍一下包装器的实现，但是此前要先了解一下MetaObject和MetaClass类：</p><ul><li>MetaObject：涵盖对象中更多细节信息和功能的一个类，又称元对象。</li><li>MetaClass：涵盖了类型中更多细节信息和功能的类，称为元类。</li></ul><p>BeanWrapper有三个重要的属性，其中metaObject属性是由父类BaseWrappper继承而来的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被包装对象的元对象（继承自父类BaseWrapper）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> MetaObject metaObject;</span><br><span class="line"><span class="comment">// 被包装的对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object object;</span><br><span class="line"><span class="comment">// 被包装对象所属类的元类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MetaClass metaClass;</span><br></pre></td></tr></table></figure><p>类中方法的解释：</p><ul><li>get：获得被包装对象某个属性的值。</li><li>set：设置被包装对象某个属性的值。</li><li>findProperty：找到对应属性的名称。</li><li>getGetterNames：获得所有的属性get方法的名字。</li><li>getSetterNames：获得所有的属性set方法的名字。</li><li>getSetterType：获得指定属性的set方法的类型。</li><li>getGetterType：获得指定属性的get方法的类型。</li><li>hasSetter：判断某个属性是否有对应的set方法。</li><li>hasGetter：判断某个属性是否有对应的get方法。</li><li>instantiatePropertyValue：实例化某个属性的值。</li></ul><p>因此，一个Bean经过BeanWrapper包装后就可以暴露出很多易用的方法，从而实现对属性、方法的一系列操作。<br><a name="z8pZE"></a></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>类似于BeanWrapper，CollectionWrapper、MapWrapper也可以通过这样的包装使Collection和Map暴露出很多易用的方法。<br>BaseWrapper作为MapWrapper和BeanWrapper的父类，提供了两个有用的基础方法为set和get使用。<br><a name="4u9Mv"></a></p><h1 id="父包类"><a class="markdownIt-Anchor" href="#父包类"></a> 父包类</h1><p><a name="BXLDN"></a></p><h2 id="反射核心类"><a class="markdownIt-Anchor" href="#反射核心类"></a> 反射核心类</h2><p>reflection包中最核心的类就是Reflector类。<br>Refection的相关类类图：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1601450359300-46397827-be8f-4554-96a2-58fed10099ae.png#align=left&amp;display=inline&amp;height=150&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=299&amp;originWidth=866&amp;size=390074&amp;status=done&amp;style=none&amp;width=433" alt="image.png"><br><a name="jsJNi"></a></p><h3 id="reflection"><a class="markdownIt-Anchor" href="#reflection"></a> Reflection</h3><p>该类将一个类反射解析后会将该类的属性、方法等一一归类放到下述各个属性中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要被反射解析的类  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line"><span class="comment">// 能够读的属性列表，即有get方法的属性列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] readablePropertyNames;</span><br><span class="line"><span class="comment">// 能够写的属性列表，即有set方法的属性列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] writablePropertyNames;</span><br><span class="line"><span class="comment">// set方法映射表。键为属性名，值为set方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Invoker&gt; setMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// get方法映射表。键为属性名，值为get方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Invoker&gt; getMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// set方法输入类型。键为属性名，值为对应的该属性的set方法的类型（set方法第一个参数的类型）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; setTypes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// get方法输出类型。键为属性名，值为对应的该属性的get方法的类型（get方法返回值的类型）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; getTypes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="keyword">private</span> Constructor&lt;?&gt; defaultConstructor;</span><br><span class="line"><span class="comment">// 大小无关的属性映射表。键为属性全大写值，值为属性名。</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, String&gt; caseInsensitivePropertyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>Reflection类反射解析一个类的过程是由构造函数触发的，构造函数源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Reflector</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 要被反射解析的类</span></span><br><span class="line">  type = clazz;</span><br><span class="line">  <span class="comment">// 设置无参构造函数属性</span></span><br><span class="line">  addDefaultConstructor(clazz);</span><br><span class="line">  <span class="comment">// 解析所有的getter</span></span><br><span class="line">  addGetMethods(clazz);</span><br><span class="line">  <span class="comment">// 解析所有的setter</span></span><br><span class="line">  addSetMethods(clazz);</span><br><span class="line">  <span class="comment">// 解析所有的属性</span></span><br><span class="line">  addFields(clazz);</span><br><span class="line">  <span class="comment">// 设置可读参数</span></span><br><span class="line">  readablePropertyNames = getMethods.keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// 设置可写参数</span></span><br><span class="line">  writablePropertyNames = setMethods.keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// 将可读可写参数放入大小写无关的属性映射表</span></span><br><span class="line">  <span class="keyword">for</span> (String propName : readablePropertyNames) &#123;</span><br><span class="line">    caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (String propName : writablePropertyNames) &#123;</span><br><span class="line">    caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的几个方法实现较为基础，暂不做分析。<br><a name="ReqH3"></a></p><h3 id="defaultreflectorfactory"><a class="markdownIt-Anchor" href="#defaultreflectorfactory"></a> DefaultReflectorFactory</h3><p>ReflectorFactory是Reflector的接口工厂，DefaultReflectorFactory是该接口的实现，于是将分析DefaultReflectorFactory类。<br>该类中只有一个业务相关的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Reflector <span class="title">findForClass</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否允许缓存</span></span><br><span class="line">  <span class="keyword">if</span> (classCacheEnabled) &#123;</span><br><span class="line">    <span class="comment">// synchronized (type) removed see issue #461</span></span><br><span class="line">    <span class="comment">// 生产输入参数Type的反射器对象并放入缓存</span></span><br><span class="line">    <span class="keyword">return</span> reflectorMap.computeIfAbsent(type, Reflector::<span class="keyword">new</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Reflector(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="2bgpx"></a></p><h2 id="反射包装类"><a class="markdownIt-Anchor" href="#反射包装类"></a> 反射包装类</h2><p>之前在wrapper涉及到的两个基础类：MetaClass和MetaObject这里将详细分析。<br><a name="HoWcP"></a></p><h3 id="metaobject"><a class="markdownIt-Anchor" href="#metaobject"></a> MetaObject</h3><p>MetaObject被称为元对象，是一个针对普通Object对象的包装类，其属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object originalObject;</span><br><span class="line"><span class="comment">// 对象包装器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ObjectWrapper objectWrapper;</span><br><span class="line"><span class="comment">// 对象工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ObjectFactory objectFactory;</span><br><span class="line"><span class="comment">// 对象包装器工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ObjectWrapperFactory objectWrapperFactory;</span><br><span class="line"><span class="comment">// 反射工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReflectorFactory reflectorFactory;</span><br></pre></td></tr></table></figure><p>该类提供很多和objectWrapper一样的方法：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1601452010427-e85d7658-a737-4b16-a09c-f1a3e3e49c2d.png#align=left&amp;display=inline&amp;height=164&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=327&amp;originWidth=495&amp;size=76636&amp;status=done&amp;style=none&amp;width=247.5" alt="image.png"><br>并且在实现的时候调用了objectWrapper的响应方法。<br>然而在objectWrapper的实现中却调用了MetaClass对象的相应方法。<br><a name="YUEZC"></a></p><h3 id="metaclass"><a class="markdownIt-Anchor" href="#metaclass"></a> MetaClass</h3><p>MetaClass被称为元类，它是针对类的进一步封装，内部集成了类可能使用的反射器和反射工厂。<br><a name="0BB5j"></a></p><h3 id="systemmetaobject"><a class="markdownIt-Anchor" href="#systemmetaobject"></a> SystemMetaObject</h3><p>该类中限定了一些默认值，源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemMetaObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectFactory DEFAULT_OBJECT_FACTORY = <span class="keyword">new</span> DefaultObjectFactory();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectWrapperFactory DEFAULT_OBJECT_WRAPPER_FACTORY = <span class="keyword">new</span> DefaultObjectWrapperFactory();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MetaObject NULL_META_OBJECT = MetaObject.forObject(NullObject.class, DEFAULT_OBJECT_FACTORY, DEFAULT_OBJECT_WRAPPER_FACTORY, <span class="keyword">new</span> DefaultReflectorFactory());</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SystemMetaObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Prevent Instantiation of Static Class</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NullObject</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MetaObject <span class="title">forObject</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MetaObject.forObject(object, DEFAULT_OBJECT_FACTORY, DEFAULT_OBJECT_WRAPPER_FACTORY, <span class="keyword">new</span> DefaultReflectorFactory());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中forObject方法只能使用默认MetaObject工厂。<br><a name="dqzQN"></a></p><h2 id="异常拆包类"><a class="markdownIt-Anchor" href="#异常拆包类"></a> 异常拆包类</h2><p>该类的设计比较有趣，ExcepetionUtil是一个异常工具类，他提供了一个拆包异常的工具方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Throwable <span class="title">unwrapThrowable</span><span class="params">(Throwable wrapped)</span> </span>&#123;</span><br><span class="line">  Throwable unwrapped = wrapped;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (unwrapped <span class="keyword">instanceof</span> InvocationTargetException) &#123;</span><br><span class="line">      <span class="comment">// 拆包获得内部异常</span></span><br><span class="line">      unwrapped = ((InvocationTargetException) unwrapped).getTargetException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unwrapped <span class="keyword">instanceof</span> UndeclaredThrowableException) &#123;</span><br><span class="line">      <span class="comment">// 拆包获得内部异常</span></span><br><span class="line">      unwrapped = ((UndeclaredThrowableException) unwrapped).getUndeclaredThrowable();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> unwrapped;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类将InvocationTargetException和UndeclaredThrowableException两个异常进行拆包来得到真正的异常类。<br>这里InvocationTargetException属于必检异常，UndeclaredThrowableException属于免检异常，他们都不属于Mybatis，来自java.lang.reflect包。<br>反射过程中抛出的异常是无法确定是哪种异常，因此通常都会以Throwable抛出。Throwable又可以分为必检型和免检型，因此就要交给这两个异常分别处理：<br><a name="jlTRv"></a></p><h3 id="invocationtargetexception"><a class="markdownIt-Anchor" href="#invocationtargetexception"></a> InvocationTargetException</h3><p>反射操作的目标方法中出现异常时都会统一的包装成一个必检异常InvocationTargetException，在InvocationTargetException内部的target保存了原始的异常。<br>内部核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationTargetException</span> <span class="keyword">extends</span> <span class="title">ReflectiveOperationException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4085088731926701167L</span>;</span><br><span class="line">    <span class="keyword">private</span> Throwable target;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvocationTargetException</span><span class="params">(Throwable target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((Throwable)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Throwable <span class="title">getTargetException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="1fPcs"></a></p><h3 id="undeclaredthrowableexception"><a class="markdownIt-Anchor" href="#undeclaredthrowableexception"></a> UndeclaredThrowableException</h3><p>在代码实现的时候，如果子类想要抛出必检异常，那么父类必定要声明过这个必检异常。同样的，如果代理类和被代理类实现了共同的接口，则代理类方法中抛出的必检异常必须是在共同接口声明过的。<br>可是当代理类想抛出异常时，其共同的接口或父类并没有声明该必检异常，那又该如何处理。<br>答案就是将这个必检异常包装成免检异常UndeclaredThrowableException，所以说UndeclaredThrowableException并不代表着真实的免检异常，其内部也可能包裹着必检异常InvocationTargetException。<br><a name="IU6N3"></a></p><h3 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3><p>经过分析UndeclaredThrowableException和InvocationTargetException后可以了解为什么要在ExceptionUtil中会有一个while(true)，因为只有这样才能把这两个包装类拆包拆出真正的异常。<br><a name="aBJJp"></a></p><h2 id="参数名解析器"><a class="markdownIt-Anchor" href="#参数名解析器"></a> 参数名解析器</h2><p>ParamNameResolver是一个参数名解析器，用来按顺序列出方法中的虚参，并对实参进行命名标注。<br>其内部参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法输入参数的参数次序表，键为参数次序，值为参数名称或者参数@Param注解的值  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; names;</span><br><span class="line"><span class="comment">// 该方法输入参数中是否含有@Param</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasParamAnnotation;</span><br></pre></td></tr></table></figure><p>其主要方法有ParamNameResolver构造函数和getNamedParams方法，暂不做解析。<br><a name="Y7kWy"></a></p><h2 id="泛型解析器"><a class="markdownIt-Anchor" href="#泛型解析器"></a> 泛型解析器</h2><p><a name="0O0EW"></a></p><h3 id="解析器作用"><a class="markdownIt-Anchor" href="#解析器作用"></a> 解析器作用</h3><p>TypeParameterResolver是一个泛型参数解析器，下面用一段简单的代码演示其功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用TypeParameterResolver分析User类中getInfo方法输出结果的具体类型</span></span><br><span class="line">            Type type1 = TypeParameterResolver.resolveReturnType(User.class.getMethod(&quot;getInfo&quot;), User.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;User类中getInfo方法的输出结果类型 :\n&quot;</span> + type1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用TypeParameterResolver分析Student类中getInfo方法输出结果的具体类型</span></span><br><span class="line">            Type type2 = TypeParameterResolver.resolveReturnType(User.class.getMethod(&quot;getInfo&quot;), Student.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;Student类中getInfo方法的输出结果类型 :\n&quot;</span> + type2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1601454537014-490989df-40ce-40e3-bbc8-0e9ba5ed4f9a.png#align=left&amp;display=inline&amp;height=92&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=183&amp;originWidth=1027&amp;size=193417&amp;status=done&amp;style=none&amp;width=513.5" alt="image.png"><br>显然，其作用就是帮助Mybatis解析出属性返回值、输入参数的泛型的具体类型。<br><a name="autgF"></a></p><h3 id="解析器原理分析"><a class="markdownIt-Anchor" href="#解析器原理分析"></a> 解析器原理分析</h3><p>其对外提供了三个方法：</p><ul><li>resolveFieldType：解析属性的泛型</li><li>resolveReturnType：解析方法的返回值泛型</li><li>resolveParamTypes：解析方法输入参数的泛型</li></ul><p>这三个方法实现方法大致相同，先选择一个最难的resolveParamTypes进行解析。<br>其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Type[] resolveParamTypes(Method method, Type srcType) &#123;</span><br><span class="line">  <span class="comment">// 取出方法所有的参数</span></span><br><span class="line">  Type[] paramTypes = method.getGenericParameterTypes();</span><br><span class="line">  <span class="comment">// 定义目标方法的类或接口</span></span><br><span class="line">  Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line">  <span class="comment">// 创建解析结果的集合</span></span><br><span class="line">  Type[] result = <span class="keyword">new</span> Type[paramTypes.length];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paramTypes.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 对输入的每个参数调用resolveType方法解析结果</span></span><br><span class="line">    result[i] = resolveType(paramTypes[i], srcType, declaringClass);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resolveType需要传入三个参数：</p><ul><li>Type type：指要分析的字段或者参数的类型。这里要分析的是getInfo的输出参数，即List<t>。</t></li><li>Type srcType：指要分析的字段或者参数所属的类。这里要分析的是Student类中的getInfo方法，故所属的类是Student</li><li>Class_&lt;<em>?</em>&gt; _declaringClass：指要分析的字段或者参数的类。getInfo方法在User类中被定义，故这里是User类。</li></ul><p>其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Type <span class="title">resolveType</span><span class="params">(Type type, Type srcType, Class&lt;?&gt; declaringClass)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是类型变量，如Map&lt;K,V&gt;的 K，V</span></span><br><span class="line">  <span class="keyword">if</span> (type <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">    <span class="keyword">return</span> resolveTypeVar((TypeVariable&lt;?&gt;) type, srcType, declaringClass);</span><br><span class="line">  <span class="comment">// 如果是参数化类型，如Collection&lt;String&gt;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">    <span class="keyword">return</span> resolveParameterizedType((ParameterizedType) type, srcType, declaringClass);</span><br><span class="line">  <span class="comment">// 如果是包含ParameterizedType或者TypeVariable元素的列表</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type <span class="keyword">instanceof</span> GenericArrayType) &#123;</span><br><span class="line">    <span class="keyword">return</span> resolveGenericArrayType((GenericArrayType) type, srcType, declaringClass);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，resolveType会根据不同的参数类型调用不同的子方法处理。<br>追随端点来到相应的resolveParameterizedType方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ParameterizedType <span class="title">resolveParameterizedType</span><span class="params">(ParameterizedType parameterizedType, Type srcType, Class&lt;?&gt; declaringClass)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取变量的原始类型，本次为List</span></span><br><span class="line">  Class&lt;?&gt; rawType = (Class&lt;?&gt;) parameterizedType.getRawType();</span><br><span class="line">  <span class="comment">// 获取类型参数，本例只有一个T</span></span><br><span class="line">  Type[] typeArgs = parameterizedType.getActualTypeArguments();</span><br><span class="line">  <span class="comment">// 类型参数的实际类型</span></span><br><span class="line">  Type[] args = <span class="keyword">new</span> Type[typeArgs.length];</span><br><span class="line">  <span class="comment">// 依次处理每一个类型参数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; typeArgs.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 类型参数是类型变量，本次符合</span></span><br><span class="line">    <span class="keyword">if</span> (typeArgs[i] <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">      args[i] = resolveTypeVar((TypeVariable&lt;?&gt;) typeArgs[i], srcType, declaringClass);</span><br><span class="line">    <span class="comment">// 类型参数是参数化类型，例如List&lt;List&lt;T&gt;&gt;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeArgs[i] <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">      args[i] = resolveParameterizedType((ParameterizedType) typeArgs[i], srcType, declaringClass);</span><br><span class="line">    <span class="comment">// 类型参数是通配符泛型，例如&lt;? extends XXX&gt;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeArgs[i] <span class="keyword">instanceof</span> WildcardType) &#123;</span><br><span class="line">      args[i] = resolveWildcardType((WildcardType) typeArgs[i], srcType, declaringClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 类型参数时确定类型，例如 Conllection&lt;String&gt;</span></span><br><span class="line">      args[i] = typeArgs[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ParameterizedTypeImpl(rawType, <span class="keyword">null</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟踪resolveTypeVar：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Type <span class="title">resolveTypeVar</span><span class="params">(TypeVariable&lt;?&gt; typeVar, Type srcType, Class&lt;?&gt; declaringClass)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 解析出来的类型参数结果</span></span><br><span class="line">   Type result;</span><br><span class="line">   Class&lt;?&gt; clazz;</span><br><span class="line">   <span class="comment">// 该类型参数是一个Class，本例符合</span></span><br><span class="line">   <span class="keyword">if</span> (srcType <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">     clazz = (Class&lt;?&gt;) srcType;</span><br><span class="line">   <span class="comment">// 该类型属于参数化类型</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (srcType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">     ParameterizedType parameterizedType = (ParameterizedType) srcType;</span><br><span class="line">     <span class="comment">// 获取参数化类型的原始类型</span></span><br><span class="line">     clazz = (Class&lt;?&gt;) parameterizedType.getRawType();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;The 2nd arg must be Class or ParameterizedType, but was: &quot;</span> + srcType.getClass());</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 变量所属的类和定义变量的类一致。本例中T属于Student定义属于User</span></span><br><span class="line">   <span class="keyword">if</span> (clazz == declaringClass) &#123;</span><br><span class="line">     <span class="comment">// 确定边界上限（边界类型，本次Number）</span></span><br><span class="line">     Type[] bounds = typeVar.getBounds();</span><br><span class="line">     <span class="keyword">if</span> (bounds.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> bounds[<span class="number">0</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> Object.class;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 获取所属类的父类</span></span><br><span class="line">   Type superclass = clazz.getGenericSuperclass();</span><br><span class="line">   <span class="comment">// 扫描父类，确定边界（边界类型，本次Number）</span></span><br><span class="line">   result = scanSuperTypes(typeVar, srcType, declaringClass, clazz, superclass);</span><br><span class="line">   <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 获取变量所属类的接口</span></span><br><span class="line">   Type[] superInterfaces = clazz.getGenericInterfaces();</span><br><span class="line">   <span class="comment">// 遍历父接口确定边界</span></span><br><span class="line">   <span class="keyword">for</span> (Type superInterface : superInterfaces) &#123;</span><br><span class="line">     result = scanSuperTypes(typeVar, srcType, declaringClass, clazz, superInterface);</span><br><span class="line">     <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> Object.class;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>此外还有resolveTypeVar和resolveGenericArrayType方法。<br>方法就是resolveParameterizedType的简化版。<br>resolveGenericArrayType源码解析如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Type <span class="title">resolveGenericArrayType</span><span class="params">(GenericArrayType genericArrayType, Type srcType, Class&lt;?&gt; declaringClass)</span> </span>&#123;</span><br><span class="line">  Type componentType = genericArrayType.getGenericComponentType();</span><br><span class="line">  Type resolvedComponentType = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 元素类型是类的变量，例如T[]</span></span><br><span class="line">  <span class="keyword">if</span> (componentType <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">    resolvedComponentType = resolveTypeVar((TypeVariable&lt;?&gt;) componentType, srcType, declaringClass);</span><br><span class="line">  <span class="comment">// 元素类型是泛型列表，例如T[][]</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (componentType <span class="keyword">instanceof</span> GenericArrayType) &#123;</span><br><span class="line">    resolvedComponentType = resolveGenericArrayType((GenericArrayType) componentType, srcType, declaringClass);</span><br><span class="line">  <span class="comment">// 元素类型是参数化类型，例如Collection&lt;T&gt;[]</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (componentType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">    resolvedComponentType = resolveParameterizedType((ParameterizedType) componentType, srcType, declaringClass);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是Class类</span></span><br><span class="line">  <span class="keyword">if</span> (resolvedComponentType <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">    <span class="keyword">return</span> Array.newInstance((Class&lt;?&gt;) resolvedComponentType, <span class="number">0</span>).getClass();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GenericArrayTypeImpl(resolvedComponentType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined">Zhang Junjie</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://jie-blog.icu/posts/mybatis-annocations&amp;lang/">https://jie-blog.icu/posts/mybatis-annocations&amp;lang/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jie-blog.icu" target="_blank">Jieker's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/mybatis/">mybatis</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5f4e5a0be7fabc7b" async="async"></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="./img/loading.gif" data-original="/img/wechat.png" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="./img/loading.gif" data-original="/img/alipay.jpg" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/mybatis-annocations&amp;lang/"><img class="prev-cover" src="./img/loading.gif" data-original="https://jie-blog.icu/img/mybatis/mybatis.jpg" onerror='onerror=null,src="/img/404.jpg"'><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">annocations包与lang包</div></div></a></div><div class="next-post pull-right"><a href="/posts/mybatis-exceptions/"><img class="next-cover" src="./img/loading.gif" data-original="https://jie-blog.icu/img/mybatis/mybatis.jpg" onerror='onerror=null,src="/img/404.jpg"'><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">exceptions包</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image:url(https://jie-blog.icu/img/mybatis/mybatis.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020<i id="heartbeat" class="fa fas fa-heartbeat"></i> Zhang Junjie</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">welcome to my <a href="https://jie-blog.icu/">blog</a>!</div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></head></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'XOcW2XseURBSH0ajeHVGv0iN-gzGzoHsz',
      appKey: 'iJPxPr2bJjhcx7m3zC49NyQC',
      placeholder: '記得留下你的暱稱和郵箱....可以快速收到回復',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,document.body.addEventListener("input",POWERMODE)</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  'meta[name=description]',
  '#config_change',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  $('script[data-pjax]').each(function () {
    $(this).parent().append($(this).remove())
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', '', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})


document.addEventListener('pjax:send', function () {
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  $(window).off('scroll')

  //reset readmode
  $('body').hasClass('read-mode') && $('body').removeClass('read-mode')

})</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=i;var e=n.imageLazyLoadSetting.isSPA,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)void 0,0<=(t=r[a].getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight+240||document.documentElement.clientHeight+240)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e()},n.src=i}()}i(),n.addEventListener("scroll",function(){var t,e;t=i,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script></body></html>