<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>操作系统之I/O设备 | Jieker's Blog</title><meta name="description" content="操作系统之I&#x2F;O设备   概述 I&#x2F;O就是输入输出，IO设备就是可以将数据输入到计算机或者接收计算机输出数据的外部设备，属于计算机的硬件部分。UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。   I&#x2F;O设备分类 I&#x2F;O设备分类可以用三种分类方法，分别是按照使用特性分、按照传输速率分和按照信息交换的单位划分。   使用特性划分 使用特性划分又可以分为"><meta name="keywords" content="操作系统"><meta name="author" content="Zhang Junjie"><meta name="copyright" content="Zhang Junjie"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/url(https:/jie-blog.icu/img/Log.png)"><link rel="canonical" href="https://jie-blog.icu/posts/operating_system_input/output/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta property="og:type" content="article"><meta property="og:title" content="操作系统之I/O设备"><meta property="og:url" content="https://jie-blog.icu/posts/operating_system_input/output/"><meta property="og:site_name" content="Jieker's Blog"><meta property="og:description" content="操作系统之I&#x2F;O设备   概述 I&#x2F;O就是输入输出，IO设备就是可以将数据输入到计算机或者接收计算机输出数据的外部设备，属于计算机的硬件部分。UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。   I&#x2F;O设备分类 I&#x2F;O设备分类可以用三种分类方法，分别是按照使用特性分、按照传输速率分和按照信息交换的单位划分。   使用特性划分 使用特性划分又可以分为"><meta property="og:image" content="https://jie-blog.icu/img/Operating_System/system.png"><meta property="article:published_time" content="2020-09-15T11:30:41.000Z"><meta property="article:modified_time" content="2020-09-15T11:32:06.140Z"><meta name="twitter:card" content="summary"><link rel="manifest" href="/image/pwa/manifest.json"><link rel="apple-touch-icon" sizes="180x180" href="/image/pwa/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/image/pwa/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/image/pwa/16.png"><link rel="mask-icon" href="/image/pwa/safari-pinned-tab.svg" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"",enable_page_level_ads:"true"})</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: {"limitCount":50,"languages":{"author":"Jieker: Zhang Junjie","link":"链接: ","source":"来源: Jieker's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
      const now = new Date()
      const expiryDay = ttl * 86400000
      const item = {
        value: value,
        expiry: now.getTime() + expiryDay,
      }
      localStorage.setItem(key, JSON.stringify(item))
    },
  
  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!0,isSidebar:!0,postUpdate:"2020-09-15 19:32:06"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}</style></noscript><script>var activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")},autoChangeMode="false",t=saveToLocal.get("theme");if("1"===autoChangeMode){var isDarkMode=window.matchMedia("(prefers-color-scheme: dark)").matches,isLightMode=window.matchMedia("(prefers-color-scheme: light)").matches,isNotSpecified=window.matchMedia("(prefers-color-scheme: no-preference)").matches,hasNoSupport=!isDarkMode&&!isLightMode&&!isNotSpecified;if(void 0===t){if(isLightMode)activateLightMode();else if(isDarkMode)activateDarkMode();else if(isNotSpecified||hasNoSupport){var now=new Date,hour=now.getHours(),isNight=hour<=6||18<=hour;isNight?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())})}else"light"===t?activateLightMode():activateDarkMode()}else"2"===autoChangeMode?(isNight=(hour=(now=new Date).getHours())<=6||18<=hour,void 0===t?isNight?activateDarkMode():activateLightMode():"light"===t?activateLightMode():activateDarkMode()):"dark"===t?activateDarkMode():"light"===t&&activateLightMode()</script><script src="/js/daovoice.js"></script><link rel="stylesheet" href="footer.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/atom.xml" title="Jieker's Blog" type="application/atom+xml"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="./img/loading.gif" data-original="/img/picture.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">64</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">12</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">16</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i> <span>Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i> <span>Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i> <span>Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i> <span>About</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8Bio%E8%AE%BE%E5%A4%87"><span class="toc-number">1.</span> <span class="toc-text">操作系统之I&#x2F;O设备</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E8%AE%BE%E5%A4%87%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">I&#x2F;O设备分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%89%B9%E6%80%A7%E5%88%92%E5%88%86"><span class="toc-number">2.1.1.</span> <span class="toc-text">使用特性划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87%E5%88%86"><span class="toc-number">2.1.2.</span> <span class="toc-text">按传输速率分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BF%A1%E6%81%AF%E4%BA%A4%E6%8D%A2%E5%8D%95%E4%BD%8D%E5%88%86"><span class="toc-number">2.1.3.</span> <span class="toc-text">按信息交换单位分</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#io%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">I&#x2F;O控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">3.1.</span> <span class="toc-text">I&#x2F;O控制器的组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%BA%E6%A2%B0%E9%83%A8%E4%BB%B6"><span class="toc-number">3.1.1.</span> <span class="toc-text">机械部件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E5%AD%90%E9%83%A8%E4%BB%B6"><span class="toc-number">3.1.2.</span> <span class="toc-text">电子部件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">3.2.</span> <span class="toc-text">I&#x2F;O控制器的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%97%E5%92%8C%E8%AF%86%E5%88%ABcpu%E5%8F%91%E5%87%BA%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-number">3.2.1.</span> <span class="toc-text">接受和识别CPU发出的命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91cpu%E6%8A%A5%E5%91%8A%E8%AE%BE%E5%A4%87%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">3.2.2.</span> <span class="toc-text">向CPU报告设备的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2"><span class="toc-number">3.2.3.</span> <span class="toc-text">数据交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%AF%86%E5%88%AB"><span class="toc-number">3.2.4.</span> <span class="toc-text">地址识别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E6%8E%A7%E5%88%B6%E5%99%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.</span> <span class="toc-text">I&#x2F;O控制器结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8Fio%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%E7%8B%AC%E7%AB%8B%E7%BC%96%E5%9D%80"><span class="toc-number">3.3.1.</span> <span class="toc-text">内存映像I&#x2F;O和寄存器独立编址</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#io%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">I&#x2F;O控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">程序直接控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.1.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">中断驱动方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">4.2.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dma%E6%96%B9%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">DMA方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dma%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">4.3.1.</span> <span class="toc-text">DMA控制器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">4.3.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.</span> <span class="toc-text">通道控制方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">4.4.1.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">软件的层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%B1%82%E8%BD%AF%E4%BB%B6"><span class="toc-number">5.1.</span> <span class="toc-text">用户层软件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6"><span class="toc-number">5.2.</span> <span class="toc-text">设备独立性软件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E8%A1%A8"><span class="toc-number">5.2.1.</span> <span class="toc-text">逻辑设备表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%8D%E5%90%8C%E7%9A%84%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">为什么需要不同的驱动程序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">5.3.</span> <span class="toc-text">设备驱动程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">5.4.</span> <span class="toc-text">中断处理程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%BC%94%E7%A4%BA"><span class="toc-number">5.5.</span> <span class="toc-text">流程演示</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#io%E6%A0%B8%E5%BF%83%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD"><span class="toc-number">6.</span> <span class="toc-text">I&#x2F;O核心子系统功能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AFspooling"><span class="toc-number">6.1.</span> <span class="toc-text">假脱机技术（SPOOLing）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF"><span class="toc-number">6.1.1.</span> <span class="toc-text">什么是脱机技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF"><span class="toc-number">6.1.2.</span> <span class="toc-text">什么是假脱机技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%BA%95"><span class="toc-number">6.1.2.1.</span> <span class="toc-text">输入井</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E4%BA%95"><span class="toc-number">6.1.2.2.</span> <span class="toc-text">输出井</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E8%B0%83%E5%BA%A6"><span class="toc-number">6.2.</span> <span class="toc-text">I&#x2F;O调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E4%BF%9D%E6%8A%A4"><span class="toc-number">6.3.</span> <span class="toc-text">设备保护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-number">6.4.</span> <span class="toc-text">设备的分配与回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E6%97%B6%E8%80%83%E8%99%91%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="toc-number">6.4.1.</span> <span class="toc-text">分配时考虑的因素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%9A%84%E5%9B%BA%E6%9C%89%E5%B1%9E%E6%80%A7"><span class="toc-number">6.4.1.1.</span> <span class="toc-text">设备的固有属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">6.4.1.2.</span> <span class="toc-text">设备的分配算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">6.4.1.3.</span> <span class="toc-text">设备分配中的安全性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D%E5%92%8C%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-number">6.4.2.</span> <span class="toc-text">静态分配和动态分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">6.4.3.</span> <span class="toc-text">设备分配管理中的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">6.4.4.</span> <span class="toc-text">设备分配的步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E6%AD%A5%E9%AA%A4%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">6.4.5.</span> <span class="toc-text">设备分配步骤的改进</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">缓冲区管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">7.1.</span> <span class="toc-text">缓冲区的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%BC%93%E5%AD%98"><span class="toc-number">7.2.</span> <span class="toc-text">单缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2"><span class="toc-number">7.3.</span> <span class="toc-text">双缓冲</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E7%BC%93%E5%86%B2%E5%8C%BA%E5%9C%A8%E9%80%9A%E4%BF%A1%E6%97%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.4.</span> <span class="toc-text">两种缓冲区在通信时的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">7.5.</span> <span class="toc-text">循环缓冲区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0"><span class="toc-number">7.6.</span> <span class="toc-text">缓冲池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4"><span class="toc-number">7.6.1.</span> <span class="toc-text">执行步骤</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image:url(https://jie-blog.icu/img/Operating_System/system.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Jieker's Blog</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i> <span>Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i> <span>Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i> <span>Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i> <span>About</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">操作系统之I/O设备</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-15T11:30:41.000Z" title="发表于 2020-09-15 19:30:41">2020-09-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-15T11:32:06.140Z" title="更新于 2020-09-15 19:32:06">2020-09-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="操作系统之io设备"><a class="markdownIt-Anchor" href="#操作系统之io设备"></a> 操作系统之I/O设备</h1><p><a name="R8WGO"></a></p><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>I/O就是输入输出，IO设备就是可以将数据输入到计算机或者接收计算机输出数据的外部设备，属于计算机的硬件部分。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599968367174-ce374900-829a-440a-b005-751be266ad40.png#align=left&amp;display=inline&amp;height=208&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=265&amp;originWidth=601&amp;size=142776&amp;status=done&amp;style=none&amp;width=471" alt="image.png"><br>UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。<br><a name="Pqlyz"></a></p><h2 id="io设备分类"><a class="markdownIt-Anchor" href="#io设备分类"></a> I/O设备分类</h2><p>I/O设备分类可以用三种分类方法，分别是按照使用特性分、按照传输速率分和按照信息交换的单位划分。<br><a name="sy7UT"></a></p><h3 id="使用特性划分"><a class="markdownIt-Anchor" href="#使用特性划分"></a> 使用特性划分</h3><p>使用特性划分又可以分为人机交互类外部设备、存储设备和网络通信设备。<br>其中人机交互外部设备传输速率最慢，存储设备最快，网络通信设备适中。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599968632250-639b0214-2afa-47d2-afdb-215801e2c906.png#align=left&amp;display=inline&amp;height=175&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=249&amp;originWidth=758&amp;size=127098&amp;status=done&amp;style=none&amp;width=534" alt="image.png"><br><a name="jzEZA"></a></p><h3 id="按传输速率分"><a class="markdownIt-Anchor" href="#按传输速率分"></a> 按传输速率分</h3><p>按传输速率可以划分为低速、中速和高速设备。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599968697833-83e501eb-8aad-4c44-82d8-35c30922b2ee.png#align=left&amp;display=inline&amp;height=176&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=236&amp;originWidth=711&amp;size=97506&amp;status=done&amp;style=none&amp;width=529" alt="image.png"><br><a name="HuyHU"></a></p><h3 id="按信息交换单位分"><a class="markdownIt-Anchor" href="#按信息交换单位分"></a> 按信息交换单位分</h3><p>按信息交换单位可划分为块设备和字符设备。<br>其中块设备传输速率高，可寻址即对它可随机的读、写任一块。<br>字符设备传输速率较慢，不可寻址，在输入输出时常采用中断驱动方式。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599968831902-3dac54e2-824f-4267-8a8c-c2ff23bc3de6.png#align=left&amp;display=inline&amp;height=176&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=205&amp;originWidth=505&amp;size=64478&amp;status=done&amp;style=none&amp;width=433" alt="image.png"><br><a name="usnYz"></a></p><h1 id="io控制器"><a class="markdownIt-Anchor" href="#io控制器"></a> I/O控制器</h1><p><a name="3UjyR"></a></p><h2 id="io控制器的组成"><a class="markdownIt-Anchor" href="#io控制器的组成"></a> I/O控制器的组成</h2><p>I/O设备由机械部件和电子部件组成。<br><a name="WAuJP"></a></p><h3 id="机械部件"><a class="markdownIt-Anchor" href="#机械部件"></a> 机械部件</h3><p>I/O设备的机械部件主要用来执行具体的I/O操作。如常见的鼠标、键盘、LED显示屏、移动硬盘的磁臂、磁盘盘面等。<br>I/O设备的电子部件通常是一块插入主板扩充槽的印刷电路板。<br><a name="hU5BX"></a></p><h3 id="电子部件"><a class="markdownIt-Anchor" href="#电子部件"></a> 电子部件</h3><p>CPU无法直接控制I/O设备的机械部件，因此还要有一个电子部件作为CPU和I/O设备机械部件之间的中介，用于实现CPU对设备的控制。这个部件就是I/O控制器，又称设备控制器。CPU可控制I/O控制器，又由I/O控制器来控制设备的机械部件。<br><a name="U4Itp"></a></p><h2 id="io控制器的功能"><a class="markdownIt-Anchor" href="#io控制器的功能"></a> I/O控制器的功能</h2><p>其总共拥有如下四个功能：<br><a name="LyVyY"></a></p><h3 id="接受和识别cpu发出的命令"><a class="markdownIt-Anchor" href="#接受和识别cpu发出的命令"></a> 接受和识别CPU发出的命令</h3><p>如CPU发来的read/wirte命令，I/O控制器会有相应的控制寄存器来存放命令和参数。<br><a name="eNGL4"></a></p><h3 id="向cpu报告设备的状态"><a class="markdownIt-Anchor" href="#向cpu报告设备的状态"></a> 向CPU报告设备的状态</h3><p>I/O控制器中会有相应的状态寄存器用于记录I/O设备的当前状态，如：1表示空闲，0表示忙碌。<br><a name="ej9OQ"></a></p><h3 id="数据交换"><a class="markdownIt-Anchor" href="#数据交换"></a> 数据交换</h3><p>I/O控制器中会设置相应的数据寄存器。输出时，数据寄存器用于暂存CPU发来的数据，之后再由控制器发送设备。输入时，数据寄存器用于暂存设备发来的数据，之后CPU从寄存器中取走数据。<br><a name="F7o7e"></a></p><h3 id="地址识别"><a class="markdownIt-Anchor" href="#地址识别"></a> 地址识别</h3><p>类似于内存的地址，为了区分设备控制器中的各个寄存器，也许要给各个寄存器，也许要给各个寄存器设置一个特定的地址。I/O控制器通过CPU提供的地址来判断CPU要读写的是哪个寄存器。<br><a name="lU3Kc"></a></p><h2 id="io控制器结构"><a class="markdownIt-Anchor" href="#io控制器结构"></a> I/O控制器结构</h2><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599975121635-a454816f-d2e3-43c1-ba3a-ff9bb15f2bca.png#align=left&amp;display=inline&amp;height=305&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=432&amp;originWidth=734&amp;size=154862&amp;status=done&amp;style=none&amp;width=519" alt="image.png"><br>注意：</p><ol><li>一个I/O控制器可能会对应多个设备。</li><li>数据寄存器、控制寄存器、状态寄存器可能有多个（如：每个控制器/状态寄存器对应一个具体的设备），且这些寄存器都要有对应的地址才方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为内存映像I/O。其他计算机采用I/O专用地址，即寄存器独立编址。<br><a name="2FssT"></a></li></ol><h3 id="内存映像io和寄存器独立编址"><a class="markdownIt-Anchor" href="#内存映像io和寄存器独立编址"></a> 内存映像I/O和寄存器独立编址</h3><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599975544113-b4559ee0-5a37-4bb4-85f2-29e720571d3a.png#align=left&amp;display=inline&amp;height=309&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=364&amp;originWidth=723&amp;size=129477&amp;status=done&amp;style=none&amp;width=613" alt="image.png"><br><a name="gHL5Q"></a></p><h1 id="io控制方式"><a class="markdownIt-Anchor" href="#io控制方式"></a> I/O控制方式</h1><p>I/O设备的数据读写有如下四种控制方式：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599975696963-f4925b66-f5d2-47a6-ad99-685e46f6f713.png#align=left&amp;display=inline&amp;height=136&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=271&amp;originWidth=226&amp;size=36116&amp;status=done&amp;style=none&amp;width=113" alt="image.png"><br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599978106061-da85f714-6b79-4afd-a17f-cb1966b00922.png#align=left&amp;display=inline&amp;height=287&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=416&amp;originWidth=808&amp;size=210679&amp;status=done&amp;style=none&amp;width=557" alt="image.png"><br><a name="hoWfu"></a></p><h2 id="程序直接控制方式"><a class="markdownIt-Anchor" href="#程序直接控制方式"></a> 程序直接控制方式</h2><p>以读操作为例，其操作流程如下：</p><ol><li>CPU向控制器发出指令， 于是设备启动并且状态寄存器设为1.</li><li>轮询检查控制器的状态（即不断的执行程序的循环，若状态位一直是1，说明设备还没准备好要输入数据，因此CPU会不断的轮询检查）</li><li>输入设备准备好数据后将数据传送给控制器并报告自身状态。</li><li>控制器将数据放入数据寄存器中，并将状态改为0（已就绪）</li><li>CPU发现设备已经就绪，于是将数据寄存器中的内容读入到CPU的寄存器中，然后把CPU寄存器中的内容放入到内存。</li><li>如还要继续读出擦操作，CPU继续发出指令。</li></ol><p>程序代码：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599976036806-53554c79-0492-41fd-b4f8-d44c8690bf74.png#align=left&amp;display=inline&amp;height=243&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=340&amp;originWidth=422&amp;size=110283&amp;status=done&amp;style=none&amp;width=301" alt="image.png"><br>流程图：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599976108878-a1b5ab64-6092-48f3-935f-6dfded44f4a9.png#align=left&amp;display=inline&amp;height=436&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=452&amp;originWidth=361&amp;size=87531&amp;status=done&amp;style=none&amp;width=348" alt="image.png"><br><a name="d4o23"></a></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>该方法实现简单，加上实现循环检查的一系列指令即可（因此称为“程序直接控制方式”）<br>数据流向：<br>读操作（数据输入）：I/O设备-&gt;CPU-&gt;内存<br>写操作（数据输出）：内存-&gt;CPU-&gt;I/O设备<br>显然，每次读写都需要CPU的帮助<br>CPU干预很频繁，I/O操作开始之前、完成之后需要CPU介入，甚至在等待I/O完成过程中CPU还需要不断地轮询检查。每次读/写仅操作一个字。<br>因此，其缺点是CPU和I/O设备只能串行工作，CPU需要一直轮询检查，长期忙等，CPU利用率低。<br><a name="Nmoyj"></a></p><h2 id="中断驱动方式"><a class="markdownIt-Anchor" href="#中断驱动方式"></a> 中断驱动方式</h2><p>引入中断机制，用于I/O设备速度慢，因此CPU发出读/写命令后可将等待I/O的进程阻塞，先切换到别的进程执行。当I/O完成后，控制器回向CPU发送一个中断信号，CPU检测到中断信号后会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。处理中断的过程中，CPU从I/O设备控制器读一个字的数据传送到CPU寄存器，在写入主存。接着，CPU恢复等待I/O的进程（或其他进程）的运行环境然后再执行。<br>注意：</p><ul><li>CPU会在每个指令周期的末尾检查中断</li><li>中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。显然，如果中断发生频率太高也会降低系统性能。</li></ul><p>流程图：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599976855535-189473c7-b158-40ae-8073-a0888da39623.png#align=left&amp;display=inline&amp;height=327&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=413&amp;originWidth=294&amp;size=38172&amp;status=done&amp;style=none&amp;width=233" alt="image.png"><br><a name="8zZOs"></a></p><h3 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3><p>与程序直接控制方式相比，在中断驱动方式中，I/O控制器会通过中断信号主动报告I/O已完成，CPU不需要不断的轮询。CPU和I/O设备可以并行工作，CPU利用率显著提升。<br>每次I/O操作开始之前、完成之后需要CPU接入，等待I/O完成的过程中CPU可以切换到其他的进程执行。每次读/写一个字。<br>数据流向：<br>读操作（数据输入）：I/O设备-&gt;CPU-&gt;内存<br>写操作（数据输出）：内存-&gt;CPU-&gt;I/O设备<br>综上，其缺点为：每个字在I/O设备之间的传输都需要经过CPU，而频繁的中断处理会消耗比较多的CPU时间。<br><a name="wGGr8"></a></p><h2 id="dma方式"><a class="markdownIt-Anchor" href="#dma方式"></a> DMA方式</h2><p>与中断驱动方式相比，DMA方式（Direct Memory Access，直接存储器存储，主要用于设备的I/O控制）有如下几个改进：</p><ul><li>数据传送单位是“块”</li><li>数据的流向是从设备直接放入内存或者从内存直接到设备。不再需要CPU中转。</li><li>仅在传送一个或多个数据块的开始或结束时才需要CPU的干预。</li></ul><p>流程图：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599977296598-7e08c259-db46-4f10-be55-dfe0adfc6b84.png#align=left&amp;display=inline&amp;height=151&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=247&amp;originWidth=722&amp;size=100367&amp;status=done&amp;style=none&amp;width=440" alt="image.png"><br><a name="Okh5p"></a></p><h3 id="dma控制器"><a class="markdownIt-Anchor" href="#dma控制器"></a> DMA控制器</h3><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599977354856-7129c428-4315-4a13-b2de-f3c4b625538d.png#align=left&amp;display=inline&amp;height=171&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=264&amp;originWidth=814&amp;size=43625&amp;status=done&amp;style=none&amp;width=527" alt="image.png"><br>DR（Data Register 数据寄存器）：暂存从设备到内存或从内存到设备的数据。<br>MAR（Memory Address Register，内存地址寄存器）：在输入时，MAR表示数据应该放在内存的什么位置，输出时MAR表示要输出的数据放在内存中的什么位置。<br>DC（Data Counter 数据计数器）：表示剩余要读/写的字节数。<br>CR（Command Register，命令/状态寄存器）：用于存放CPU发来的I/O命令，或设备的状态信息。<br><a name="SrPpa"></a></p><h3 id="总结-3"><a class="markdownIt-Anchor" href="#总结-3"></a> 总结</h3><p>数据以块为单位，CPU介入频率进一步降低。数据的传输不再需要经过CPU再写入内存，数据传输效率进一步增加。CPU和I/O设备的并行性得到提升。<br>但是其缺点是CPU每发出一个I/O指令，只能读/写一个或多个连续的数据块，如果要读/写多个和离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条I/O指令，进行多次中断处理才能完成。<br><a name="NC4lY"></a></p><h2 id="通道控制方法"><a class="markdownIt-Anchor" href="#通道控制方法"></a> 通道控制方法</h2><p>通道是一种硬件，可以当作简化版的CPU，其可以识别并执行一系列的通道指令。<br>执行流程如下：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599977910044-22291a90-235f-41b8-86d2-ff0a12534620.png#align=left&amp;display=inline&amp;height=237&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=361&amp;originWidth=804&amp;size=128319&amp;status=done&amp;style=none&amp;width=527" alt="image.png"><br><a name="Jy5Yp"></a></p><h3 id="总结-4"><a class="markdownIt-Anchor" href="#总结-4"></a> 总结</h3><p>与CPU相比通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与CPU共享内存。<br>在这个环境下CPU、通道、I/O设备可以并行的工作，资源利用率高。<br>但是实现比较复杂，需要专门的通道硬件支持。<br><a name="VnpzA"></a></p><h1 id="软件的层次结构"><a class="markdownIt-Anchor" href="#软件的层次结构"></a> 软件的层次结构</h1><p>软件的层次结构如下：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599978167148-2e9de087-8903-4f66-8854-3bf9c8f2154e.png#align=left&amp;display=inline&amp;height=225&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=449&amp;originWidth=941&amp;size=153318&amp;status=done&amp;style=none&amp;width=470.5" alt="image.png">   <br>直接涉及到硬件具体细节、且与终端无关的操作肯定是在设备驱动层完成的，没有设计硬件的、对各种设备都需要进行的管理工作都是在设备独立性软件层进行的。<br><a name="6DhFd"></a></p><h2 id="用户层软件"><a class="markdownIt-Anchor" href="#用户层软件"></a> 用户层软件</h2><p>用户层软件实现了与用户交互的接口，用户可以直接使用该层提供的、与I/O操作相关的库函数对设备进行操作。例如：printf(“hello, world!”);<br>用户层软件将用户请求翻译成格式化的I/O请求，并通过“系统调用”请求操作系统内核的服务。例如：printf(“hello, world!”); 会被翻译成等价的write系统调用，当然，用户层软件也会在系统调用是填入相应的参数。<br>Windiws操作系统向外提供的一系列系统调用由于操作系统调用的格式严格、使用麻烦，因此在用户层上封装了一系列更方便的库函数接口供用户使用。<br><a name="80AXY"></a></p><h2 id="设备独立性软件"><a class="markdownIt-Anchor" href="#设备独立性软件"></a> 设备独立性软件</h2><p>设备独立性软件又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。<br>其主要功能：</p><ul><li>向上层提供统一的调用接口，如read/write系统调用。</li><li>设备的保护，其原理类似于文件保护。设备被看做是一种特殊的文件，不同用户对各个文件的访问权限是不一样的，同理对设备的访问权限也是不一样的。</li><li>差错处理。设备独立性软件需要对一些设备的错误进行处理。</li><li>设备的分配与回收。</li><li>数据缓冲区管理。可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异。</li><li>建立逻辑设备名到物理设备名的映射关系，根据设备类型选择调用相应的驱动。<ul><li>用户或用户层软件发出I/O操作相关系统调用的系统调用时，需要指明此次要操作的I/O设备的逻辑设备名，例如打印机1、打印机2等等。</li><li>设备独立性软件需要通过“逻辑设备表（LUT,Logical Unit Table）”来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序。<br><a name="0ef5w"></a></li></ul></li></ul><h3 id="逻辑设备表"><a class="markdownIt-Anchor" href="#逻辑设备表"></a> 逻辑设备表</h3><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599978967376-4b5d6029-3358-40af-a728-6c094189ee02.png#align=left&amp;display=inline&amp;height=160&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=240&amp;originWidth=609&amp;size=64990&amp;status=done&amp;style=none&amp;width=405" alt="image.png"><br>操作系统可以采用两种方式管理逻辑设备表（LUT）<br>第一种方式是整个系统只设置一张LUT，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单个用户的操作系统。<br>第二种方式是为每个用户设置一张LUT，各个用户使用的逻辑设备名称可以重复，是用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。<br><a name="4LXUP"></a></p><h4 id="为什么需要不同的驱动程序"><a class="markdownIt-Anchor" href="#为什么需要不同的驱动程序"></a> 为什么需要不同的驱动程序</h4><p>对比下述两张图：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599979254681-83b4afcd-0b23-4c56-ac69-9f3913bcec38.png#align=left&amp;display=inline&amp;height=301&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=463&amp;originWidth=847&amp;size=96217&amp;status=done&amp;style=none&amp;width=550" alt="image.png"><br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599979306493-5eb3a1bc-b0bd-4e0f-8149-503e02e89e3b.png#align=left&amp;display=inline&amp;height=306&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=472&amp;originWidth=843&amp;size=110130&amp;status=done&amp;style=none&amp;width=546" alt="image.png"><br>不同设备的内部硬件特性可能也不同，这些特性只有厂家才知道，因此厂家必须提供与设备相对应的驱动程序，CPU执行驱动程序的指令序列来完成设备寄存器、检查设备状态等工作。<br><a name="ydA1S"></a></p><h2 id="设备驱动程序"><a class="markdownIt-Anchor" href="#设备驱动程序"></a> 设备驱动程序</h2><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599979663757-63020a2d-971b-441e-b6b7-a5b655529c9c.png#align=left&amp;display=inline&amp;height=480&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=960&amp;originWidth=1410&amp;size=169139&amp;status=done&amp;style=none&amp;width=705" alt="image.png"><br>主要负责对硬件设备的具体控制，将上层发出的一系列命令（如：write、read等）转化为特定的设备了解的一系列操作，包括设置设备寄存器、检查设备状态等。<br>不同的I/O设备有着不同的硬件特性，具体细节只有厂家才知道，因此厂家要根据设备的硬件特性设计并提供相应的驱动程序。<br>注：驱动程序一般会以一个独立进程的方式存在。<br><a name="8ivvI"></a></p><h2 id="中断处理程序"><a class="markdownIt-Anchor" href="#中断处理程序"></a> 中断处理程序</h2><p>当I/O任务完成时，I/O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。中断处理程序处理流程如下：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599979766704-d0c5bc97-71a4-4426-abb7-4b78d2d81b41.png#align=left&amp;display=inline&amp;height=210&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=242&amp;originWidth=363&amp;size=46814&amp;status=done&amp;style=none&amp;width=315" alt="image.png"><br><a name="yLcHd"></a></p><h2 id="流程演示"><a class="markdownIt-Anchor" href="#流程演示"></a> 流程演示</h2><ol><li>用户通过调用用户层软件提供的库函数发出I/O请求</li><li>用户层软件通过系统调用请求设备独立性软件层的服务</li><li>设备独立性软件层根据LUT调用设备对应的驱动程序</li><li>驱动程序向I/O控制器发出具体命令</li><li>等待I/O完成的进程应该被阻塞，因此需要进程切换，而进程切换必然需要终端操作。<br><a name="Bawuk"></a></li></ol><h1 id="io核心子系统功能"><a class="markdownIt-Anchor" href="#io核心子系统功能"></a> I/O核心子系统功能</h1><p>设备独立性软件层、设备驱动程序层和中断处理程序层属于操作系统的内核部分，即I/O系统或称I/O核心子系统，因此I/O核心字系统要实现的功能就是中间三层要实现的功能。<br>其核心功能所在分区如图：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599980508664-a2fa5cca-2f25-45e9-a156-03f0287712c0.png#align=left&amp;display=inline&amp;height=213&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=426&amp;originWidth=959&amp;size=281991&amp;status=done&amp;style=none&amp;width=479.5" alt="image.png"><br><a name="ArKKs"></a></p><h2 id="假脱机技术spooling"><a class="markdownIt-Anchor" href="#假脱机技术spooling"></a> 假脱机技术（SPOOLing）</h2><p>需要请求磁盘设备的设备独立性软件的服务，因此一般来说假脱机技术是在用户层软件实现的，但是在新版教材中把假脱机技术归在了I/O核心子系统的功能。<br><a name="h5psE"></a></p><h3 id="什么是脱机技术"><a class="markdownIt-Anchor" href="#什么是脱机技术"></a> 什么是脱机技术</h3><p>在手工阶段，主机直接从I/O设备获得数据，由于设备速度按慢，主机速度快。人机速度矛盾明显，主机要浪费很多时间来等待设备。<br>所以在批处理阶段引入了脱机输入/输出技术，通过外围机的控制，慢速输入设备的数据线被输入到更快速的磁带上，之后主机可以从快速的磁带上读入数据，从而减缓速度矛盾。另一方面，即使CPU在忙碌也可以提前将数据输入到磁带，即使慢速的输出设备正在忙碌也可以提前将数据输出到磁带。<br>因此，脱机即脱离主机控制进行输入/输出操作。<br><a name="hazKE"></a></p><h3 id="什么是假脱机技术"><a class="markdownIt-Anchor" href="#什么是假脱机技术"></a> 什么是假脱机技术</h3><p>假脱机技术又称SPOOLing技术，是用软件的方式模拟脱机技术。SPOOLing系统的组成如下：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599981344173-6dfe5d4a-289a-45c7-bae6-f0fa73f1918d.png#align=left&amp;display=inline&amp;height=294&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=588&amp;originWidth=1160&amp;size=320535&amp;status=done&amp;style=none&amp;width=580" alt="image.png"><br>在输入/出进程的控制下，输入/出缓冲区用于暂时从输入/出设备输入/出的数据，之后再转存到输入/出井中。<br>注意：输入缓冲区和输出缓冲区是在内存中的缓冲区。<br><a name="eWmu4"></a></p><h4 id="输入井"><a class="markdownIt-Anchor" href="#输入井"></a> 输入井</h4><p>模拟脱机输入时的磁带，用于收容I/O设备输入的数据。<br><a name="OnN3m"></a></p><h4 id="输出井"><a class="markdownIt-Anchor" href="#输出井"></a> 输出井</h4><p>模拟脱机输出时的磁带，用于收容用户进程输出的数据。<br><a name="lP5fr"></a></p><h2 id="io调度"><a class="markdownIt-Anchor" href="#io调度"></a> I/O调度</h2><p>用某种算法确定一个好的顺序来处理各个I/O请求。<br>如：磁盘调度（先来先去服务算法、最短寻道优先算法、SCAN算法、C-SCAN算法、LOOK算法、C-LOOK算法）。当多个磁盘I/O请求到来时，用某种调度算法确定满足I/O请求的顺序。<br>同理，打印机等设备也可以用先来先服务算法、优先算法、短作业优先等算法来确定I/O调度顺序。<br><a name="MMxxn"></a></p><h2 id="设备保护"><a class="markdownIt-Anchor" href="#设备保护"></a> 设备保护</h2><p>操作系统需要实现文件保护功能，不同的用户对各个文件有不同的访问权限，如：只读、读和写等。<br>在UNIX系统中，设备被看作是一种特殊的文件，每个设备也会有对应的FCB，当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此来实现设备保护功能。<br><a name="qHbQd"></a></p><h2 id="设备的分配与回收"><a class="markdownIt-Anchor" href="#设备的分配与回收"></a> 设备的分配与回收</h2><p><a name="GoBub"></a></p><h3 id="分配时考虑的因素"><a class="markdownIt-Anchor" href="#分配时考虑的因素"></a> 分配时考虑的因素</h3><p>设备分配时应该考虑的因素有设备的固有属性、设备的分配算法、设备分配中的安全性。<br><a name="N4nHV"></a></p><h4 id="设备的固有属性"><a class="markdownIt-Anchor" href="#设备的固有属性"></a> 设备的固有属性</h4><p>设备的固有属性可分为三种：独占设备、共享设备、虚拟设备。</p><ul><li>独占设备：一个时间段只能分配给一个进程（如打印机）</li><li>共享设备：可同时分配给多个进程使用（如磁盘），宏观上往往是宏观上同时共享使用设备，而微观上是交替使用。</li><li>虚拟设备：采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用。（如采用SPOOLing技术实现的共享打印机）<br><a name="MNfOc"></a></li></ul><h4 id="设备的分配算法"><a class="markdownIt-Anchor" href="#设备的分配算法"></a> 设备的分配算法</h4><p>设备的分配算法可以使用先来先服务、优先级高者优先、短任务优先等算法。<br><a name="2dFjj"></a></p><h4 id="设备分配中的安全性"><a class="markdownIt-Anchor" href="#设备分配中的安全性"></a> 设备分配中的安全性</h4><p>从进程运行的安全性考虑，设备分配有两种方法：<br>安全分配方式：<br>为进程分配一个设备后就将阻塞，本次I/O完成后才将进程唤醒。一个时段内每个进程只能使用一个设备。<br>优点：破坏了请求和保持条件，不会产生死锁。<br>缺点：对于一个进程来说，CPU和I/O设备只能串行工作。<br>不安全分配方式：<br>进程发出I/O请求后，系统为其分配I/O设备，进程可继续执行，之后还可以发出新的I/O请求，只有某个I/O请求得不到满足时才将进程阻塞。一个进程可以同时使用多个设备。<br>优点：进程的计算任务和I/O任务可以并行处理，让进程迅速推进。<br>缺点：可能会发生死锁。<br><a name="Q93NE"></a></p><h3 id="静态分配和动态分配"><a class="markdownIt-Anchor" href="#静态分配和动态分配"></a> 静态分配和动态分配</h3><p>静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源。破坏了请求和保持条件，不会发生死锁。<br>动态分配：进程运行过程中动态申请设备资源。<br><a name="ffRm6"></a></p><h3 id="设备分配管理中的数据结构"><a class="markdownIt-Anchor" href="#设备分配管理中的数据结构"></a> 设备分配管理中的数据结构</h3><p>设备、控制器、通道的关系如图：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599982511496-c13f5850-8f5b-42bb-a7f3-5b85fd36e4d5.png#align=left&amp;display=inline&amp;height=179&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=246&amp;originWidth=672&amp;size=50899&amp;status=done&amp;style=none&amp;width=489" alt="image.png"><br>设备控制表（DTC）：系统为每个设备配置一张DTC，用于记录设备情况。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599982555247-9af146e5-9a56-45fb-9907-2e2a2fc0dd8b.png#align=left&amp;display=inline&amp;height=155&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=218&amp;originWidth=691&amp;size=110881&amp;status=done&amp;style=none&amp;width=491" alt="image.png"><br>注：系统会根据阻塞原因不同将进程PCB挂到不同的阻塞队列。<br>控制器控制表（COCT）：每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作管理。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599982653577-b3aa74dd-de19-4f41-885d-24b82decd920.png#align=left&amp;display=inline&amp;height=131&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=186&amp;originWidth=726&amp;size=80066&amp;status=done&amp;style=none&amp;width=510" alt="image.png"><br>通道控制表（CHCT）：每个通道都会对应一张CHCT，操作系统根据CHCT信息对通道进行操作和管理。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599982701722-772182f2-d403-456d-bf84-991a2f047319.png#align=left&amp;display=inline&amp;height=158&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=202&amp;originWidth=746&amp;size=80147&amp;status=done&amp;style=none&amp;width=584" alt="image.png"><br>系统设备表（SDT）：记录了系统中全部设备的情况，每个设备都对应一个表目。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599982752025-4d464d24-1244-4590-9ed8-8aba6926c613.png#align=left&amp;display=inline&amp;height=134&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=199&amp;originWidth=643&amp;size=45176&amp;status=done&amp;style=none&amp;width=432" alt="image.png"><br><a name="yrBe6"></a></p><h3 id="设备分配的步骤"><a class="markdownIt-Anchor" href="#设备分配的步骤"></a> 设备分配的步骤</h3><ol><li>根据进程请求的设备名查找SDT（注：物理设备名是进程请求分配设备时提供的参数）</li><li>根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程。</li><li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li><li>根据COCT找到CHCT，若通道忙碌泽江金城PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</li></ol><p>只有设备、控制器、通道三者都分配成功时此设备分配才算成功，之后便可启动I/O设备进行数据传输。<br><a name="RilLL"></a></p><h3 id="设备分配步骤的改进"><a class="markdownIt-Anchor" href="#设备分配步骤的改进"></a> 设备分配步骤的改进</h3><p>上述步骤有如下几个缺点：</p><ul><li>用户编程时必须使用物理设备名，底层细节对用户不透明，不方便编程。</li><li>若换了一个物理设备，则程序无法进行。</li><li>若程序进程请求的物理设备正在忙碌，则及时系统中还有同类型的设备，进程也必须阻塞等待。</li></ul><p>改进方法：建立逻辑设备名与物理设备名的映射机制，用户编程只需要提供逻辑设备名即可。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599983281112-3dfcdf0c-195a-43d5-8444-88788e74b463.png#align=left&amp;display=inline&amp;height=190&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=283&amp;originWidth=830&amp;size=71199&amp;status=done&amp;style=none&amp;width=557" alt="image.png"><br>逻辑设备表（LUT）建立了逻辑设备名和物理设备名的映射关系。<br>某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在LUT增加相应表项。<br>如果之后用户进程再次通过相同的逻辑请求使用设备，则操作系统通过LUT表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序的入口地址。<br>LUT表设置问题：<br>整个系统只有一张LUT：各个用户所用的逻辑设备名不允许重复<br>每个用户一张LUT：不同的用户的设备名可以重复。<br><a name="P50x3"></a></p><h1 id="缓冲区管理"><a class="markdownIt-Anchor" href="#缓冲区管理"></a> 缓冲区管理</h1><p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可以利用内存作为缓冲区。<br>使用硬件作为缓冲区的成本比较高，容量也比较小，一般仅用在对速度要求十分高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）<br>一般情况下，更多是利用内存作为缓存区，设备独立性软件的缓冲区管理就是要组织管理好这些缓冲区。<br><a name="xBSuM"></a></p><h2 id="缓冲区的作用"><a class="markdownIt-Anchor" href="#缓冲区的作用"></a> 缓冲区的作用</h2><p>其主要作用如下：</p><ul><li>缓和CPU与I/O设备之间的速度不匹配的矛盾。</li><li>减少对CPU的中断频率，放宽对CPU中断响应时间的限制。</li><li>解决数据颗粒度不匹配的问题。例如，输出进程每次可以生成一块数据，但是I/O设备每次只能输出一个字符。</li><li>提高CPU与I/O设备之间的并行性。</li></ul><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599983956994-e5e90d79-902c-4ac2-b5a5-3b78a3b51075.png#align=left&amp;display=inline&amp;height=184&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=223&amp;originWidth=346&amp;size=34391&amp;status=done&amp;style=none&amp;width=285" alt="image.png"><br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599983964724-adbe044a-89f2-44f7-8f61-bcfea2074c2d.png#align=left&amp;display=inline&amp;height=191&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=270&amp;originWidth=579&amp;size=63719&amp;status=done&amp;style=none&amp;width=410" alt="image.png"><br><a name="i4Rr8"></a></p><h2 id="单缓存"><a class="markdownIt-Anchor" href="#单缓存"></a> 单缓存</h2><p>假设某用户进程请求某种模块设备读入若干块的数据，若采用单缓存的策略，操作系统会在主存中为其分配一个缓冲区。<br>注意：当缓冲区数据非空时，不能往缓冲区中入数据，只能从缓冲区把数据传出，当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满后才能从缓冲区吧数据传出。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984283080-cab8e813-55e1-4892-ab45-f3a9949ed121.png#align=left&amp;display=inline&amp;height=259&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=319&amp;originWidth=530&amp;size=61674&amp;status=done&amp;style=none&amp;width=431" alt="image.png"><br>时间表变化图：<br>T&gt;C<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984334973-1b68b2ce-ab38-47dc-a0cb-2760a868605f.png#align=left&amp;display=inline&amp;height=217&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=338&amp;originWidth=860&amp;size=103940&amp;status=done&amp;style=none&amp;width=552" alt="image.png"><br>T&lt;C<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984373185-ffd3755b-0995-47b4-84df-da71e37fb0ed.png#align=left&amp;display=inline&amp;height=205&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=345&amp;originWidth=929&amp;size=110857&amp;status=done&amp;style=none&amp;width=553" alt="image.png"><br>平均耗时：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984435223-30e9f13c-cc23-4943-aceb-e18782be60c3.png#align=left&amp;display=inline&amp;height=242&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=353&amp;originWidth=835&amp;size=88961&amp;status=done&amp;style=none&amp;width=572" alt="image.png"><br><a name="bXD7m"></a></p><h2 id="双缓冲"><a class="markdownIt-Anchor" href="#双缓冲"></a> 双缓冲</h2><p>假设某用户进程请求某种模块设备读入若干块的数据，若采用双缓存的策略，操作系统会在主存中为其分配两个缓冲区。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984548270-3e658a64-1fa1-4b20-b7b2-d09b0b5d7aef.png#align=left&amp;display=inline&amp;height=244&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=352&amp;originWidth=866&amp;size=80104&amp;status=done&amp;style=none&amp;width=601" alt="image.png"><br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984575653-9a2552d3-befa-4991-8a39-0651285f3e4c.png#align=left&amp;display=inline&amp;height=216&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=332&amp;originWidth=785&amp;size=129225&amp;status=done&amp;style=none&amp;width=510" alt="image.png"><br>显然，采用双缓冲策略处理一个数据块平均耗时为Max(T,C+M)<br><a name="YAWfy"></a></p><h2 id="两种缓冲区在通信时的区别"><a class="markdownIt-Anchor" href="#两种缓冲区在通信时的区别"></a> 两种缓冲区在通信时的区别</h2><p>两台机器之间通信时，可以配置缓冲区用于数据的发送和接受。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984682990-63b7fcb0-bd41-47b2-bc80-12f28f1e2492.png#align=left&amp;display=inline&amp;height=168&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=271&amp;originWidth=697&amp;size=69199&amp;status=done&amp;style=none&amp;width=433" alt="image.png"><br>显然，若两个相互通信的机器只设置单缓冲区，在任一个时刻只能实现数据的单向传输。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984780846-d0cae697-dfd0-4607-803a-b30813005cd3.png#align=left&amp;display=inline&amp;height=223&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=282&amp;originWidth=515&amp;size=32175&amp;status=done&amp;style=none&amp;width=407" alt="image.png"><br>若两个相互通信的机器设置双缓冲区，则同一时刻可以实现双向的数据传输。<br>注：管道通信中的管道其实就是缓冲区，要实现数据双向传输必须要设置两个管道。<br><a name="p6wwR"></a></p><h2 id="循环缓冲区"><a class="markdownIt-Anchor" href="#循环缓冲区"></a> 循环缓冲区</h2><p>将多个大小相等的缓冲区链接成一个循环队列。<br>注：以下图示中，橙色未一充满数据的缓冲区，绿色表示空缓冲区。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599984919280-8da997c8-9d60-40cd-9144-c82fcc0ead96.png#align=left&amp;display=inline&amp;height=211&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=306&amp;originWidth=564&amp;size=40321&amp;status=done&amp;style=none&amp;width=388" alt="image.png"><br><a name="UtQQt"></a></p><h2 id="缓冲池"><a class="markdownIt-Anchor" href="#缓冲池"></a> 缓冲池</h2><p>缓冲池由系统中公用的缓冲区组成，这些缓冲区按使用状况可划分为空缓冲队列、装满输入数据缓冲队列（输入队列）、装满输出数据的缓冲队列（输出队列）。<br>另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了两种工作缓冲区：用于收容输入数据的工作缓冲区（hin）、用于提取输入数据的工作缓冲区（sin）、用户收容输出数据的工作缓冲区（hout）、用于提取输出数据的工作缓冲区（sout）<br><a name="ydiDs"></a></p><h3 id="执行步骤"><a class="markdownIt-Anchor" href="#执行步骤"></a> 执行步骤</h3><ul><li>输入进程请求输入数据<ul><li>从空缓冲队列中取出一块作为收容输入数据的工作缓冲区（hin），充满数据后将缓冲区挂到输入队列队尾。</li></ul></li><li>计算进程想要取得一块输入数据<ul><li>从输入队列中取得一块冲满输入数据的缓冲区作为“提取输入数据的工作缓冲区（sin）”。缓冲区读空后挂到空缓冲区队列。</li></ul></li><li>计算进程想要准备好的数据冲入缓冲区<ul><li>从空缓冲队列中取出一块作为“收容输出数据的工作缓冲区（hout）”。数据冲满后将缓冲区挂到输出队列队尾。</li></ul></li><li>输出进程请求输出数据<ul><li>从输出队列中取得一块充满输出数据的缓冲区作为“提取输出数据的工作缓冲区（sout）”。缓冲区读空后挂到空缓冲区队列。</li></ul></li></ul></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined">Zhang Junjie</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://jie-blog.icu/posts/operating_system_input/output/">https://jie-blog.icu/posts/operating_system_input/output/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jie-blog.icu" target="_blank">Jieker's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5f4e5a0be7fabc7b" async="async"></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="./img/loading.gif" data-original="/img/wechat.png" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="./img/loading.gif" data-original="/img/alipay.jpg" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/hashmap/"><img class="prev-cover" src="./img/loading.gif" data-original="https://jie-blog.icu/img/hashmap.png" onerror='onerror=null,src="/img/404.jpg"'><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">hashMap 核心与原理分析</div></div></a></div><div class="next-post pull-right"><a href="/posts/operating_system_disk/"><img class="next-cover" src="./img/loading.gif" data-original="https://jie-blog.icu/img/Operating_System/system.png" onerror='onerror=null,src="/img/404.jpg"'><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统之磁盘</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image:url(https://jie-blog.icu/img/Operating_System/system.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020<i id="heartbeat" class="fa fas fa-heartbeat"></i> Zhang Junjie</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">welcome to my <a href="https://jie-blog.icu/">blog</a>!</div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></head></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'XOcW2XseURBSH0ajeHVGv0iN-gzGzoHsz',
      appKey: 'iJPxPr2bJjhcx7m3zC49NyQC',
      placeholder: '記得留下你的暱稱和郵箱....可以快速收到回復',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,document.body.addEventListener("input",POWERMODE)</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  'meta[name=description]',
  '#config_change',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  $('script[data-pjax]').each(function () {
    $(this).parent().append($(this).remove())
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', '', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})


document.addEventListener('pjax:send', function () {
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  $(window).off('scroll')

  //reset readmode
  $('body').hasClass('read-mode') && $('body').removeClass('read-mode')

})</script></div><script>window.imageLazyLoadSetting={isSPA:!1,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=i;var e=n.imageLazyLoadSetting.isSPA,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)void 0,0<=(t=r[a].getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight+240||document.documentElement.clientHeight+240)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e()},n.src=i}()}i(),n.addEventListener("scroll",function(){var t,e;t=i,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html>