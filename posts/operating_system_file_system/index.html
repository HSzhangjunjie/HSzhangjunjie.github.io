<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>操作系统之文件系统 | Jieker's Blog</title><meta name="description" content="操作系统之文件系统   概述 文件——就是一组有意义的信息&#x2F;数据集合。   文件属性  文件名：由创建文件的用户决定文件名，主要是为了方便用户找到文 件，同一目录下不允许有重名文件。 标识符：一个系统内的各文件标识 符唯一，对用户来说毫无可读性， 因此标识符只是操作系统用于区分 各个文件的一种内部名称。 类型：指明文件的类型 位置：文件存放的路径（让用户使用）、在外存中的地址（操作系统 使用，对"><meta name="keywords" content="操作系统"><meta name="author" content="Zhang Junjie"><meta name="copyright" content="Zhang Junjie"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/url(https:/jie-blog.icu/img/Log.png)"><link rel="canonical" href="https://jie-blog.icu/posts/operating_system_file_system/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta property="og:type" content="article"><meta property="og:title" content="操作系统之文件系统"><meta property="og:url" content="https://jie-blog.icu/posts/operating_system_file_system/"><meta property="og:site_name" content="Jieker's Blog"><meta property="og:description" content="操作系统之文件系统   概述 文件——就是一组有意义的信息&#x2F;数据集合。   文件属性  文件名：由创建文件的用户决定文件名，主要是为了方便用户找到文 件，同一目录下不允许有重名文件。 标识符：一个系统内的各文件标识 符唯一，对用户来说毫无可读性， 因此标识符只是操作系统用于区分 各个文件的一种内部名称。 类型：指明文件的类型 位置：文件存放的路径（让用户使用）、在外存中的地址（操作系统 使用，对"><meta property="og:image" content="https://jie-blog.icu/img/Operating_System/system.png"><meta property="article:published_time" content="2020-09-15T11:27:17.000Z"><meta property="article:modified_time" content="2020-09-15T11:28:49.053Z"><meta name="twitter:card" content="summary"><link rel="manifest" href="/image/pwa/manifest.json"><link rel="apple-touch-icon" sizes="180x180" href="/image/pwa/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/image/pwa/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/image/pwa/16.png"><link rel="mask-icon" href="/image/pwa/safari-pinned-tab.svg" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"",enable_page_level_ads:"true"})</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: {"limitCount":50,"languages":{"author":"Jieker: Zhang Junjie","link":"链接: ","source":"来源: Jieker's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
      const now = new Date()
      const expiryDay = ttl * 86400000
      const item = {
        value: value,
        expiry: now.getTime() + expiryDay,
      }
      localStorage.setItem(key, JSON.stringify(item))
    },
  
  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!0,isSidebar:!0,postUpdate:"2020-09-15 19:28:49"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}</style></noscript><script>var activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")},autoChangeMode="false",t=saveToLocal.get("theme");if("1"===autoChangeMode){var isDarkMode=window.matchMedia("(prefers-color-scheme: dark)").matches,isLightMode=window.matchMedia("(prefers-color-scheme: light)").matches,isNotSpecified=window.matchMedia("(prefers-color-scheme: no-preference)").matches,hasNoSupport=!isDarkMode&&!isLightMode&&!isNotSpecified;if(void 0===t){if(isLightMode)activateLightMode();else if(isDarkMode)activateDarkMode();else if(isNotSpecified||hasNoSupport){var now=new Date,hour=now.getHours(),isNight=hour<=6||18<=hour;isNight?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())})}else"light"===t?activateLightMode():activateDarkMode()}else"2"===autoChangeMode?(isNight=(hour=(now=new Date).getHours())<=6||18<=hour,void 0===t?isNight?activateDarkMode():activateLightMode():"light"===t?activateLightMode():activateDarkMode()):"dark"===t?activateDarkMode():"light"===t&&activateLightMode()</script><script src="/js/daovoice.js"></script><link rel="stylesheet" href="footer.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/atom.xml" title="Jieker's Blog" type="application/atom+xml"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="./img/loading.gif" data-original="/img/picture.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">64</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">12</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">14</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i> <span>Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i> <span>Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i> <span>Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i> <span>About</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.</span> <span class="toc-text">操作系统之文件系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">文件属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">文件组织形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%8A%9F%E8%83%BD"><span class="toc-number">2.3.</span> <span class="toc-text">文件操作功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="toc-number">2.3.1.</span> <span class="toc-text">删除文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">2.3.2.</span> <span class="toc-text">写文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-number">2.3.3.</span> <span class="toc-text">读文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6"><span class="toc-number">2.3.4.</span> <span class="toc-text">创建文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="toc-number">2.3.5.</span> <span class="toc-text">打开文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="toc-number">2.3.6.</span> <span class="toc-text">关闭文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8"><span class="toc-number">2.4.</span> <span class="toc-text">文件存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD"><span class="toc-number">2.5.</span> <span class="toc-text">文件管理功能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">文件的逻辑结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E7%BB%93%E6%9E%84%E5%88%86"><span class="toc-number">3.1.</span> <span class="toc-text">按结构分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.1.</span> <span class="toc-text">无结构文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.2.</span> <span class="toc-text">有结构文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F%E5%88%86"><span class="toc-number">3.2.</span> <span class="toc-text">按组织方式分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.1.</span> <span class="toc-text">顺序文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">顺序存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">链式存储</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.2.</span> <span class="toc-text">索引文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.3.</span> <span class="toc-text">索引顺序文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E7%B4%A2%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">检索效率分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.4.</span> <span class="toc-text">多级索引顺序文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="toc-number">4.</span> <span class="toc-text">文件目录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">4.1.</span> <span class="toc-text">文件控制块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%9B%AE%E5%BD%95%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.1.</span> <span class="toc-text">对目录常用的操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.</span> <span class="toc-text">目录结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.1.</span> <span class="toc-text">单级目录结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.2.</span> <span class="toc-text">两级目录结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">当前目录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.3.</span> <span class="toc-text">无环图目录结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%BB%93%E7%82%B9fcb%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">4.2.4.</span> <span class="toc-text">索引结点（FCB的改进）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">文件的物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">5.1.</span> <span class="toc-text">连续分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.1.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D"><span class="toc-number">5.2.</span> <span class="toc-text">链接分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E9%93%BE%E6%8E%A5"><span class="toc-number">5.2.1.</span> <span class="toc-text">隐式链接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E9%93%BE%E6%8E%A5"><span class="toc-number">5.2.2.</span> <span class="toc-text">显式链接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D"><span class="toc-number">5.3.</span> <span class="toc-text">索引分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E6%96%B9%E6%A1%88"><span class="toc-number">5.3.1.</span> <span class="toc-text">链接方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%B1%82%E7%B4%A2%E5%BC%95"><span class="toc-number">5.3.2.</span> <span class="toc-text">多层索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">5.3.3.</span> <span class="toc-text">混合索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">5.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">文件的存储空间管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">空闲表法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">空闲链表法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E7%9B%98%E5%9D%97%E9%93%BE"><span class="toc-number">6.2.1.</span> <span class="toc-text">空闲盘块链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E7%9B%98%E5%8C%BA%E9%93%BE"><span class="toc-number">6.2.2.</span> <span class="toc-text">空闲盘区链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E7%A4%BA%E5%9B%BE%E6%B3%95"><span class="toc-number">6.2.3.</span> <span class="toc-text">位示图法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E7%BB%84%E9%93%BE%E6%8E%A5%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">成组链接法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">7.</span> <span class="toc-text">文件的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6-2"><span class="toc-number">7.1.</span> <span class="toc-text">创建文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6-2"><span class="toc-number">7.2.</span> <span class="toc-text">删除文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6-2"><span class="toc-number">7.3.</span> <span class="toc-text">打开文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6-2"><span class="toc-number">7.4.</span> <span class="toc-text">关闭文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6-2"><span class="toc-number">7.5.</span> <span class="toc-text">读文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6-2"><span class="toc-number">7.6.</span> <span class="toc-text">写文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-number">8.</span> <span class="toc-text">文件共享</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F"><span class="toc-number">8.1.</span> <span class="toc-text">基于索引节点的共享方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%AC%A6%E5%8F%B7%E9%93%BE%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F"><span class="toc-number">8.2.</span> <span class="toc-text">基于符号链的共享方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="toc-number">9.</span> <span class="toc-text">文件保护</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%A3%E4%BB%A4%E4%BF%9D%E6%8A%A4"><span class="toc-number">9.1.</span> <span class="toc-text">口令保护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E4%BF%9D%E6%8A%A4"><span class="toc-number">9.2.</span> <span class="toc-text">加密保护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">9.3.</span> <span class="toc-text">访问控制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93"><span class="toc-number">10.</span> <span class="toc-text">系统的层次结构总结</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image:url(https://jie-blog.icu/img/Operating_System/system.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Jieker's Blog</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i> <span>Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i> <span>Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i> <span>Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i> <span>About</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">操作系统之文件系统</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-15T11:27:17.000Z" title="发表于 2020-09-15 19:27:17">2020-09-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-15T11:28:49.053Z" title="更新于 2020-09-15 19:28:49">2020-09-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="操作系统之文件系统"><a class="markdownIt-Anchor" href="#操作系统之文件系统"></a> 操作系统之文件系统</h1><p><a name="yYAyL"></a></p><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>文件——就是一组有意义的信息/数据集合。<br><a name="PYlGN"></a></p><h2 id="文件属性"><a class="markdownIt-Anchor" href="#文件属性"></a> 文件属性</h2><ul><li>文件名：由创建文件的用户决定文件名，主要是为了方便用户找到文 件，同一目录下不允许有重名文件。</li><li>标识符：一个系统内的各文件标识 符唯一，对用户来说毫无可读性， 因此标识符只是操作系统用于区分 各个文件的一种内部名称。</li><li>类型：指明文件的类型</li><li>位置：文件存放的路径（让用户使用）、在外存中的地址（操作系统 使用，对用户不可见）</li><li>大小：指明文件大小</li><li>创建时间、上次修改时间</li><li>文件所有者信息</li><li>保护信息：对文件进行保护的访问控制信息<br><a name="sgnOi"></a></li></ul><h2 id="文件组织形式"><a class="markdownIt-Anchor" href="#文件组织形式"></a> 文件组织形式</h2><p>无结构文件（如文本文件）——由一些二进制或字符流组成，又称“流式文件”<br>有结构文件（如数据库表）——由一组相似的记录组成，又称“记录式文件”<br><a name="n2MY1"></a></p><h2 id="文件操作功能"><a class="markdownIt-Anchor" href="#文件操作功能"></a> 文件操作功能</h2><p>可用几个基本操作完成更复杂的操作，比如：“复制文件”： 先创建一个新的空文件，再把源文件读入内存，再将内存中的数据写到新文件中。<br><a name="9bown"></a></p><h3 id="删除文件"><a class="markdownIt-Anchor" href="#删除文件"></a> 删除文件</h3><p>可以“删除文件”（点了“删除”之后， 图形化交互进程通过操作系统提供的 “删除文件”功能，即 delete 系统调用， 将文件数据从外存中删除）<br><a name="FhswD"></a></p><h3 id="写文件"><a class="markdownIt-Anchor" href="#写文件"></a> 写文件</h3><p>可以“写文件”，将更改过的文件数据写回外存（在“记事本”应用程序中编辑文件内容，点击“保存”后， “记事本”应用程序通过操作系统提供 的“写文件”功能，即 write 系统调用， 将文件数据从内存写回外存）<br><a name="0wWfA"></a></p><h3 id="读文件"><a class="markdownIt-Anchor" href="#读文件"></a> 读文件</h3><p>可以“读文件”，将文件数据读 内存，才能让CPU处理（双击后，“记事本”应用程序通过操作系统 提供的“读文件”功能，即 read 系 统调用，将文件数据从外存读入内存，并显示在屏幕上）<br><a name="WtqpT"></a></p><h3 id="创建文件"><a class="markdownIt-Anchor" href="#创建文件"></a> 创建文件</h3><p>可以“创建文件”， （点击新建后，图形化交互进程在背后调 用了“create 系统调用”）<br><a name="whzMl"></a></p><h3 id="打开文件"><a class="markdownIt-Anchor" href="#打开文件"></a> 打开文件</h3><p>读/写文件之前，需要“打开文件”<br><a name="4HxXX"></a></p><h3 id="关闭文件"><a class="markdownIt-Anchor" href="#关闭文件"></a> 关闭文件</h3><p>读/写文件结束之后， 需要“关闭文件”<br><a name="TWWBv"></a></p><h2 id="文件存储"><a class="markdownIt-Anchor" href="#文件存储"></a> 文件存储</h2><p>操作系统以“块”为单位为文件分配存储空间，因此即使一个文件大小只有10B，但它依然需要占用 1KB 的磁盘块。外存中的数据读入内存时同样以块为单位。<br>类似于内存分为一个个“内存块”，外存会分为一个个“块/磁盘块/物理 块”。每个磁盘块的大小是相等的，每块一般包含2的整数幂个地址（如 本例中，一块包含 210 个地址，即 1KB）。同样类似的是，文件的逻辑地址也可以分为（逻辑块号，块内地址），操作系统同样需要将逻辑地址转 换为外存的物理地址（物理块号，块内地址）的形式。块内地址的位数取 决于磁盘块的大小<br>与内存一样，外存也是由一个个存储单元组成的，每个存储单元可以 存储一定量的数据（如 1B）。每个 存储单元对应一个物理地址<br><a name="mkRHl"></a></p><h2 id="文件管理功能"><a class="markdownIt-Anchor" href="#文件管理功能"></a> 文件管理功能</h2><p>文件共享：使多个用户可以共享使用一个文件<br>文件保护：如何保证不同的用户对文件有不同的操作权限<br><a name="ljjXO"></a></p><h1 id="文件的逻辑结构"><a class="markdownIt-Anchor" href="#文件的逻辑结构"></a> 文件的逻辑结构</h1><p>所谓的“逻辑结构”，就是指在用户看来， 文件内部的数据应该是如何组织起来的。而 “物理结构”指的是在操作系统看来，文件的数据是如何存放在外存中的。<br>按文件是否有结构分类，可以分为无结构文件、有结构文件两种。<br>根据有结构文件中的各 条记录在逻辑上如何组织，可以分为三类：顺序文件、索引文件、索引顺序文件。<br><a name="uIfnX"></a></p><h2 id="按结构分"><a class="markdownIt-Anchor" href="#按结构分"></a> 按结构分</h2><p><a name="ENEQU"></a></p><h3 id="无结构文件"><a class="markdownIt-Anchor" href="#无结构文件"></a> 无结构文件</h3><p>无结构文件：文件内部的数据就是一系列二进制流或字符流组成。又称“流式文件”。如： Windows 操作系统中的 .txt 文件。<br>文件内部的数据其实就是一系列字符流，没有明显的结构特性。因此也不用探讨无结构文件的“逻辑结构”问题。<br><a name="sW02f"></a></p><h3 id="有结构文件"><a class="markdownIt-Anchor" href="#有结构文件"></a> 有结构文件</h3><p>由一组相似的记录组成，又称“记录式文件”。每条记录又若干个数据项组成。如： 数据库表文件。一般来说，每条记录有一个数据项可作为关键字（作为识别不同记录的ID）。根据各条记录的长度（占用的 存储空间）是否相等，又可分为定长记录和可变长记录两种。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599826000748-1039a343-7e76-4ecd-9432-56a7fea55a56.png#align=left&amp;display=inline&amp;height=256&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=339&amp;originWidth=755&amp;size=192681&amp;status=done&amp;style=none&amp;width=571" alt="image.png"><br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599826149433-bb0403f6-e99e-499c-82aa-740ec40dccf2.png#align=left&amp;display=inline&amp;height=266&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=310&amp;originWidth=435&amp;size=101725&amp;status=done&amp;style=none&amp;width=373" alt="image.png"><br>这个有结构文件由可变长记录组成，由于各 个学生的特长存在很大区别，因此“特长” 这个数据项的长度不确定，这就导致了各条 记录的长度也不确定。当然，没有特长的学 生甚至可以去掉“特长”数据项。<br><a name="OAr6n"></a></p><h2 id="按组织方式分"><a class="markdownIt-Anchor" href="#按组织方式分"></a> 按组织方式分</h2><p><a name="uvQ9g"></a></p><h3 id="顺序文件"><a class="markdownIt-Anchor" href="#顺序文件"></a> 顺序文件</h3><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599826700883-18c2b9bd-ac4a-412f-83ea-fa56f7f0ed77.png#align=left&amp;display=inline&amp;height=84&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=139&amp;originWidth=661&amp;size=53855&amp;status=done&amp;style=none&amp;width=400" alt="image.png"><br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599826495705-0eeef89e-8865-42a3-a690-c244f40d4d32.png#align=left&amp;display=inline&amp;height=124&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=179&amp;originWidth=794&amp;size=105315&amp;status=done&amp;style=none&amp;width=552" alt="image.png"><br>文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。<br>定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取；若能再保证记录的顺序结构，则可实现快速检索 （即根据关键字快速找到对应记录）<br><a name="WScKQ"></a></p><h4 id="顺序存储"><a class="markdownIt-Anchor" href="#顺序存储"></a> 顺序存储</h4><p>逻辑上相邻的记录 物理上也相邻（类似于顺序表）<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599826361798-f730b8f5-386e-4f6a-8ed7-a639f5a052a9.png#align=left&amp;display=inline&amp;height=32&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=44&amp;originWidth=310&amp;size=7548&amp;status=done&amp;style=none&amp;width=225" alt="image.png"><br><a name="4gLwF"></a></p><h4 id="链式存储"><a class="markdownIt-Anchor" href="#链式存储"></a> 链式存储</h4><p>逻辑上相邻 的记录物理上不一定相邻 （类似于链表）<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599826382338-43ba5d0b-6ade-4b22-891c-d088cbf90d26.png#align=left&amp;display=inline&amp;height=130&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=130&amp;originWidth=283&amp;size=10849&amp;status=done&amp;style=none&amp;width=283" alt="image.png"><br><a name="aW3qB"></a></p><h3 id="索引文件"><a class="markdownIt-Anchor" href="#索引文件"></a> 索引文件</h3><p>索引表本身是定长记录的顺序文件。因此可以快速找到第 i 个记录对应的索引项。 可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。 每当要增加/删除一个记录时，需要对索引表进行 修改。由于索引文件有很快的检索速度，因此主 要用于对信息处理的及时性要求比较高的场合。<br>另外，可以用不同的数据项建立多个索引表。如： 学生信息表中，可用关键字“学号”建立一张索 引表。也可用“姓名”建立一张索引表。这样就 可以根据“姓名”快速地检索文件了。<br><a name="OhmvB"></a></p><h3 id="索引顺序文件"><a class="markdownIt-Anchor" href="#索引顺序文件"></a> 索引顺序文件</h3><p>索引文件每个记录对应一个索引表项，因此索引表可能会很大。 比如：文件的每个记录平均只占 8B，而每个索引表项占32个字节，那么索引 表都要比文件内容本身大4倍，这样对存储空间的利用率就太低了。<br>索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立 一张索引表，但不同的是：并不是每个记录对应一个索引表项，而是一组记录对应一个 索引表项<br>索引顺序文件的索引项也不需要按关键字顺序排列，这样可以极大地方便新表项的插入<br><a name="sHCnW"></a></p><h4 id="检索效率分析"><a class="markdownIt-Anchor" href="#检索效率分析"></a> 检索效率分析</h4><p>若一个顺序文件有10000个记录，则根据关键字检索文件，只能从头开始顺序查找（这里指的并不是定长记录、顺序结构 的顺序文件），平均须查找 5000 个记录。<br>若采用索引顺序文件结构，可把 10000 个记录分为 √10000 = 100 组，每组 100 个记录。则需要先顺序查找 索引表找到分组（共100个分组，因此索引表长度为 100，平均需要查 50 次），找到分组后，再在分组中 顺序查找记录（每个分组100 个记录，因此平均需要查 50 次）。可见，采用索引顺序文件结构后，平均查 找次数减少为 50+50 = 100 次。<br>若文件共有 10^6个记录，则可分为 1000 个分组，每个分组 1000 个记录。根据关键字检索一个记录 平均需要查找 500+500 = 1000 次。这个查找次数依然很多<br><a name="X5Qeb"></a></p><h3 id="多级索引顺序文件"><a class="markdownIt-Anchor" href="#多级索引顺序文件"></a> 多级索引顺序文件</h3><p>为了进一步提高检索效率，可以为顺序文件建立多级索引表。例如，对于一个含 10^6个记录的文件，可先 为该文件建立一张低级索引表，每 100 个记录为一组，故低级索引表中共有 10000 个表项（即10000个定长 记录），再把这 10000 个定长记录分组，每组100个，为其建立顶级索引表，故顶级索引表中共有 100 个表项。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599827035523-19717f14-d0bf-4840-8ca0-fd4b7fb3038c.png#align=left&amp;display=inline&amp;height=249&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=338&amp;originWidth=858&amp;size=123521&amp;status=done&amp;style=none&amp;width=633" alt="image.png"><br><a name="gLArm"></a></p><h1 id="文件目录"><a class="markdownIt-Anchor" href="#文件目录"></a> 文件目录</h1><p>windows目录结构如下：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599832160265-5eaee9a3-084f-4f11-bda5-a81545c92583.png#align=left&amp;display=inline&amp;height=378&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=756&amp;originWidth=1200&amp;size=109914&amp;status=done&amp;style=none&amp;width=600" alt="image.png"><br>这种结构的文件之间的组织结 构清晰，易于查找。编程时也可以很方便的用文件路径找到一个文件。<br>如： FILE *fp; fp=fopen(“F:\data\myfile.dat”); 用户可以轻松实现“按名存取”。<br><a name="YEHAX"></a></p><h2 id="文件控制块"><a class="markdownIt-Anchor" href="#文件控制块"></a> 文件控制块</h2><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599836889846-8bf15d90-d492-490b-8f38-edac0f9afdc1.png#align=left&amp;display=inline&amp;height=322&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=395&amp;originWidth=869&amp;size=223949&amp;status=done&amp;style=none&amp;width=708" alt="image.png"><br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599839657564-0b1ad476-f4a2-45ec-9809-7a6e53034f78.png#align=left&amp;display=inline&amp;height=246&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=297&amp;originWidth=569&amp;size=76232&amp;status=done&amp;style=none&amp;width=472" alt="image.png"><br>FCB 实现了文件名和文件之间的映射。使用户（用户程序）可以实现“按名存取”。<br>FCB 的有序集合称为“文件目录”，一个FCB就是一个文件目录项。 FCB 中包含了文件的基本信息（文件名、物理地址、逻辑结构、物理结构等），存取控制信息（是否可读/可写、禁止访问的用户名单等），使用信息（如文件的建立时间、修改时间等）。 最重要，最基本的还是 文件名、文件存放的物理地址。<br><a name="rheDY"></a></p><h3 id="对目录常用的操作"><a class="markdownIt-Anchor" href="#对目录常用的操作"></a> 对目录常用的操作</h3><p>搜索：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项<br>创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项<br>删除文件：当删除一个文件时，需要在目录中删除相应的目录项<br>显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性<br>修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项（如：文件重命名）<br><a name="vn2NW"></a></p><h2 id="目录结构"><a class="markdownIt-Anchor" href="#目录结构"></a> 目录结构</h2><p><a name="iAGDt"></a></p><h3 id="单级目录结构"><a class="markdownIt-Anchor" href="#单级目录结构"></a> 单级目录结构</h3><p>早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项。单级目录实现了“按名存取”，但是不允许文件重名。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599839899805-9130f735-8117-4062-a6c2-0b3e8385a3f7.png#align=left&amp;display=inline&amp;height=344&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=344&amp;originWidth=312&amp;size=38073&amp;status=done&amp;style=none&amp;width=312" alt="image.png"><br>在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件 对应的目录项插入目录表中。<br>显然，单级目录结构不适用于多用户操作系统。<br><a name="img6o"></a></p><h3 id="两级目录结构"><a class="markdownIt-Anchor" href="#两级目录结构"></a> 两级目录结构</h3><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599840346470-83950c43-d4d4-49ea-a281-8a1e1933f12f.png#align=left&amp;display=inline&amp;height=318&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=373&amp;originWidth=869&amp;size=162537&amp;status=done&amp;style=none&amp;width=742" alt="image.png"><br>又称树形目录结构，早期的多用户操作系统，采用两级目录结构。分为主文件目录（MFD，Master File Directory）和用户文件目录（UFD，User Flie Directory）。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599840596104-c7142d0a-3fef-4015-9c5c-a17e5f3ab763.png#align=left&amp;display=inline&amp;height=158&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=244&amp;originWidth=792&amp;size=72734&amp;status=done&amp;style=none&amp;width=513" alt="image.png"><br>用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串。各级目录之间 用“/”隔开。从根目录出发的路径称为绝对路径。<br>例如：自拍.jpg 的绝对路径是 “/照片/2015-08/自拍.jpg” 系统根据绝对路径一层一层地找到下一级目录。刚开始从外存读入根目录的目录表；找到“照片”目录的 存放位置后，从外存读入对应的目录表；再找到“2015-08”目录的存放位置，再从外存读入对应目录表；<br>最后才找到文件“自拍.jpg”的存放位置。整个过程需要3次读磁盘I/O操作。<br>很多时候，用户会连续访问同一目录内的多个文件（比如：接连查看“2015-08”目录内的多个照片文件）， 显然，每次都从根目录开始查找，是很低效的。因此可以设置一个“当前目录”。<br><a name="MaeQM"></a></p><h4 id="当前目录"><a class="markdownIt-Anchor" href="#当前目录"></a> 当前目录</h4><p>例如，此时已经打开了“照片”的目录文件，也就是说，这张目录表已调入内存，那么可以把它设置为 “当前目录”。当用户想要访问某个文件时，可以使用从当前目录出发的“相对路径” 。<br>在 Linux 中，“.”表示当前目录，因此如果“照片”是当前目录，则”自拍.jpg”的相对路径    为： “./2015-08/自拍.jpg”。从当前路径出发，只需要查询内存中的“照片”目录表，即可知道”2015-08”目录 表的存放位置，从外存调入该目录，即可知道“自拍.jpg”存放的位置了。<br>可见，引入“当前目录”和“相对路径”后，磁盘I/O的次数减少了。这就ᨀ升了访问文件的效率。<br>用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串。各级目录之间 用“/”隔开。从根目录出发的路径称为绝对路径。例如：自拍.jpg 的绝对路径是 “/照片/2015-08/自 拍.jpg”<br>每次都从根目录开始查找，是很低效的。因此可以设置一个“当前目录”。例如，此时已经打开了“照片” 的目录文件，也就是说，这张目录表已调入内存，那么可以把它设置为“当前目录”。当用户想要访问某 个文件时，可以使用从当前目录出发的“相对路径” 。 在 Linux 中，“.”表示当前目录，因此如果“照片”是当前目录，则”自拍.jpg”的相对路径为： “./2015-08/自拍.jpg”。<br>树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但 是，树形结构不便于实现文件的共享。为此，提出了“无环图目录结构”。<br><a name="IYlxt"></a></p><h3 id="无环图目录结构"><a class="markdownIt-Anchor" href="#无环图目录结构"></a> 无环图目录结构</h3><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599841753977-d91b6d18-d5a0-48a0-b46d-d7fc35e0e445.png#align=left&amp;display=inline&amp;height=220&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=302&amp;originWidth=861&amp;size=94833&amp;status=done&amp;style=none&amp;width=628" alt="image.png"><br>可以用不同的文件名指向同一个文件，甚至可以指向同一个目录（共享同一目录下的所有内容）。 需要为每个共享结点设置一个共享计数器，用于记录此时有多少个地方在共享该结点。用户提出删除结 点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除共享结点。 只有共享计数器减为0时，才删除结点。<br>注意：共享文件不同于复制文件。在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个 用户修改了文件数据，那么所有用户都可以看到文件数据的变化。<br><a name="yPdJw"></a></p><h3 id="索引结点fcb的改进"><a class="markdownIt-Anchor" href="#索引结点fcb的改进"></a> 索引结点（FCB的改进）</h3><p>其实在查找各级目录的过程中 只需要用到“文件名”这个信 息，只有文件名匹配时，才需 要读出文件的其他信息。因此 可以考虑让目录表“瘦身”来 提升效率。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599841886489-25bd4c82-40d6-456e-b440-6445e9364f24.png#align=left&amp;display=inline&amp;height=156&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=205&amp;originWidth=506&amp;size=49959&amp;status=done&amp;style=none&amp;width=386" alt="image.png"><br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599841929530-4fc756f9-a1bf-4900-8507-e34f8e3d9819.png#align=left&amp;display=inline&amp;height=143&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=206&amp;originWidth=532&amp;size=41272&amp;status=done&amp;style=none&amp;width=369" alt="image.png"><br>假设一个FCB是64B，磁盘块的大 小为1KB，则每个盘块中只能存放 16个FCB。若一个文件目录中共有 640个目录项，则共需要占用 640/16 = 40 个盘块。因此按照某 文件名检索该目录，平均需要查 询320 个目录项，平均需要启动磁 盘20次（每次磁盘I/O读入一块）。<br>若使用索引结点机制，文件名占14B，索引结点指针站2B，则每 个盘块可存放64个目录项，那么按文件名检索目录平均只需要 读入 320/64 = 5 个磁盘块。显然，这将大大提升文件检索速度。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599842001580-8b83a93e-fc9b-4dab-87df-441455bd38ce.png#align=left&amp;display=inline&amp;height=163&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=221&amp;originWidth=519&amp;size=35388&amp;status=done&amp;style=none&amp;width=382" alt="image.png"><br>当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括 文件在外存中的存放位置，根据“存放位置”即可找到文件。<br>存放在外存中的索引结点称为“磁盘索引结点”，当索引结点放入内存后称为“内存索引结点”。 相比之下内存索引结点中需要增加一些信息，比如：文件是否被修改、此时有几个进程正在访问该文件 等。<br><a name="sCZzl"></a></p><h1 id="文件的物理结构"><a class="markdownIt-Anchor" href="#文件的物理结构"></a> 文件的物理结构</h1><p>文件的物理结构即文件的分配方式，文件的分配方式又分为连续分配、链接分配和索引分配。<br>类似于内存分页，磁盘中的存储单元也会被分为一个个“块/磁盘块/物理块”。很多操作系统中，磁盘块的大小与内存块、页面的大小相同。内存与磁盘之间的数据交换（即 读/写操作、磁盘I/O）都是以 “块”为单位进行的。即每次读入一块，或每次写出一块。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599872068240-9d79eff4-100f-44b0-bacf-9e4eec562ad5.png#align=left&amp;display=inline&amp;height=260&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=369&amp;originWidth=708&amp;size=97204&amp;status=done&amp;style=none&amp;width=498" alt="image.png"><br>在内存管理中，进程的逻辑地址空间被分为一个一个页面。同样的，在外存管理中，为了方便对文件数据的管理，文件的逻辑地 址空间也被分为了一个一个的文件“块”。 于是文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式。<br><a name="fTAgH"></a></p><h2 id="连续分配"><a class="markdownIt-Anchor" href="#连续分配"></a> 连续分配</h2><p>连续分配方式要求每个文件在磁盘上占有一组连续的块。<br>用户给出要访问的逻辑块号，操作系统 找到该文件对应的目录项（FCB）… 物理块号 = 起始块号 + 逻辑块号 当然，还需要检查用户提供的逻辑块号 是否合法（逻辑块号 ≥长度就不合法）。可以直接算出逻辑块号对应的物理 块号，因此连续分配支持顺序访问和直接访问（即随机访问）<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599872280037-7913642b-cccc-4afc-ab72-12f6b2a64e63.png#align=left&amp;display=inline&amp;height=267&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=398&amp;originWidth=539&amp;size=74483&amp;status=done&amp;style=none&amp;width=362" alt="image.png"><br>读取某个磁盘块时，需要移动磁头。访问的两个磁 盘块相隔越远，移动磁头所需时间就越长。因此，连续分配的文件在顺序读/写时速度最快。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599872372104-946bd88b-2cf8-41c1-8487-eba23b2a785b.png#align=left&amp;display=inline&amp;height=280&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=382&amp;originWidth=589&amp;size=66564&amp;status=done&amp;style=none&amp;width=432" alt="image.png"><br>若此时文件A要拓展，需要再增加一个磁盘块（总共需要连续的4个磁盘块）。 由于采用连续结构，因此文件A占用的磁盘块必须是连续的。 因此只能将文件A全部“迁移”到绿色区域。 所以，物理上采用连续分配的文件不方便拓展。<br><a name="XMfy0"></a></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599872475326-28e5236a-5775-4c9f-acce-e9fdd4c7e533.png#align=left&amp;display=inline&amp;height=246&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=346&amp;originWidth=510&amp;size=47788&amp;status=done&amp;style=none&amp;width=362" alt="image.png"><br>物理上采用连续分配， 存储空间利用率低，会产生 难以利用的磁盘碎片 可以用紧凑来处理碎片，但 是需要耗费很大的时间代价。<br>优点：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快<br>缺点：不方便文件拓展；存储空间利用率低，会产生磁盘碎片<br><a name="go5cQ"></a></p><h2 id="链接分配"><a class="markdownIt-Anchor" href="#链接分配"></a> 链接分配</h2><p>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。其又分为隐式链接和显式链接两种。<br><a name="auGlx"></a></p><h3 id="隐式链接"><a class="markdownIt-Anchor" href="#隐式链接"></a> 隐式链接</h3><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599872682048-d0845a64-bf01-4eda-9fe5-a0838c9d9dd5.png#align=left&amp;display=inline&amp;height=306&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=436&amp;originWidth=490&amp;size=102502&amp;status=done&amp;style=none&amp;width=344" alt="image.png"><br>用户给出要访问的逻辑块号 i，操作系统找到该文件对应的目录项（FCB），从目录项中找到起始块号（即0号块），将0号逻辑块读入内存，由此知道1号逻辑块存放的物理块号，于是读入1号逻辑块，再找到2号逻辑块的存放位置，以此类推。 因此，读入i号逻辑块，总共需要 i+1 次磁盘 I/O。<br>采用链式分配（隐式链接）方式的文件，只支持顺序访问，不支持随机访问，查 找效率低。另外，指向下一个盘块的指针也 需要耗费少量的存储空间。<br>若此时要拓展文件，则可以随便 找一个空闲磁盘块，挂到文件的 磁盘块链尾，并修改文件的FCB，因此采用隐式链接的链接分配方式，很方便文件拓展。 另外，所有的空闲磁盘块都可以被利用，不会有碎片问题， 外存利用率高。<br><a name="thOYg"></a></p><h4 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h4><p>除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录 包括文件第一块的指针和最后一块的指针。<br>优点：很方便文件拓展，不会有碎片问题，外存利用率高。<br>缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量 的存储空间。<br><a name="d4Tgz"></a></p><h3 id="显式链接"><a class="markdownIt-Anchor" href="#显式链接"></a> 显式链接</h3><p>把用于链接文件各物理块的指针显式地存放在一张表中。即 文件分配表（FAT，File Allocation Table）。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599872943166-cab1f85e-3a83-4fd8-ba34-642f3ec3b1f6.png#align=left&amp;display=inline&amp;height=309&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=418&amp;originWidth=528&amp;size=64881&amp;status=done&amp;style=none&amp;width=390" alt="image.png"><br><br><br>假设某个新创建的文件“aaa”依 次存放在磁盘块 2-&gt;5-&gt;0 -&gt;1<br>假设某个新创建的文件“bbb”依次存放在磁盘块 4-&gt;23-&gt;3<br>注意：一个磁盘仅设置一张FAT。 开机时，将FAT读入内存，并常驻 内存。 FAT 的各个表项在物理上 连续存储，且每一个表项长度相 同，因此“物理块号”字段可以 是隐含的。<br>用户给出要访问的逻辑块号 i，操作系统找到该文件对应的目录项 （FCB），从目录项中找到起始块号，若i&gt;0，则查询内存中的文件分配表FAT， 往后找到 i 号逻辑块对应的物理块号。逻辑块号转换成物理块号的过 程不需要读磁盘操作。<br>采用链式分配（显式链接）方式的文件，支持顺序访问，也支 持随机访问（想访问 i 号逻辑块时，并不需要依次访问之前的 0 ~ i-1 号逻辑块），由于块号转换的过程不需要访问磁盘，因此相比于隐式 链接来说，访问速度快很多。<br>显然，显式链接也不会产生外部碎片，也可以很方便地对文件进行拓 展。<br><a name="mYtdo"></a></p><h4 id="总结-3"><a class="markdownIt-Anchor" href="#总结-3"></a> 总结</h4><p>把用于链接文件各物理块的指针显式地存放在一张表中，即 文件分配表（FAT，File Allocation Table）。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内存。<br>优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接 来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。<br>缺点：文件分配表的需要占用一定的存储空间。<br><a name="9HHKW"></a></p><h2 id="索引分配"><a class="markdownIt-Anchor" href="#索引分配"></a> 索引分配</h2><p>索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文 件的各个逻辑块对应的物理块（索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间 的映射关系）。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599873449525-d3c63abe-0a39-4a00-9650-64ff1f087c05.png#align=left&amp;display=inline&amp;height=286&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=367&amp;originWidth=523&amp;size=86521&amp;status=done&amp;style=none&amp;width=407" alt="image.png"><br>假设某个新创建的文件“aaa”的数据依次存放在磁盘块 2-&gt;5-&gt;13-&gt;9 。 7号磁盘块作为“aaa”的索引块， 索引块中保存了索引表的内容。<br>注：在显式链接的链式分配方式中，文 件分配表FAT 是一个磁盘对应一张。而 索引分配方式中，索引表是一个文件对 应一张。<br>可以用固定的长度表示物理块号（如： 假设磁盘总容量为1TB=240B，磁盘块大 小为1KB，则共有 230个磁盘块，则可用 4B 表示磁盘块号），因此，索引表中 的“逻辑块号”可以是隐含的。<br>用户给出要访问的逻辑块号 i，操作系统找 到该文件对应的目录项（FCB）,从目录项中可知索引表存放位置，将索引表 从外存读入内存，并查找索引表即可只 i 号 逻辑块在外存中的存放位置。<br>可见，索引分配方式可以支持随机访问。 文件拓展也很容易实现（只需要给文件分配 一个空闲块，并增加一个索引表项即可） 但是索引表需要占用一定的存储空间。<br>若每个磁盘块1KB，一个索 引表项4B，则一个磁盘块只 能存放 256 个索引项。如果一个文件的大小超过了256 块，那么一个磁盘块是装不下 文件的整张索引表的，因此引出了链接方案、多层索引、混合索引的解决方案。<br><a name="YN9Wb"></a></p><h3 id="链接方案"><a class="markdownIt-Anchor" href="#链接方案"></a> 链接方案</h3><p>如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599873745310-6e5bcaa6-f981-4f1a-8bae-04104575e801.png#align=left&amp;display=inline&amp;height=292&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=386&amp;originWidth=512&amp;size=50281&amp;status=done&amp;style=none&amp;width=387" alt="image.png"><br>假设磁盘块大小为1KB，一个索引表 项占4B，则一个磁盘块只能存放256 个索引项。<br>若一个文件大小为 256<em>256KB = 65,536 KB = 64MB 该文件共有 256</em>256 个块，也就对应 256*256个索引项，也就需要 256 个 索引块来存储，这些索引块用链接方案连起来。<br>若想要访问文件的最后一个逻辑块， 就必须找到最后一个索引块（第256 个索引块），而各个索引块之间是用 指针链接起来的，因此必须先顺序地 读入前 255 个索引块。<br><a name="ibefz"></a></p><h3 id="多层索引"><a class="markdownIt-Anchor" href="#多层索引"></a> 多层索引</h3><p>建立多层索引（原理类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据 文件大小的要求再建立第三层、第四层索引块。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599873865528-4f3bdfb6-88c3-455f-9764-22b233a3a3af.png#align=left&amp;display=inline&amp;height=366&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=389&amp;originWidth=442&amp;size=61051&amp;status=done&amp;style=none&amp;width=416" alt="image.png"><br>假设磁盘块大小为1KB，一个索引表项占4B，则一个 磁盘块只能存放256 个索引项。<br>若某文件采用两层索引，则该文件的最大长度可以到 256<em>256</em>1KB = 65,536 KB = 64MB 可根据逻辑块号算出应该查找索引表中的哪个表项。 如：要访问 1026 号逻辑块，则 1026/256 = 4，1026%256 = 2<br>因此可以先将一级索引表调入内存，查询 4 号表项， 将其对应的二级索引表调入内存，再查询二级索引表 的2号表项即可知道 1026 号逻辑块存放的磁盘块号了。 访问目标数据块，需要3次磁盘I/O。采用 K 层索引结构，且顶级索引表未调入 内存，则访问一个数据块只需要 K + 1 次 读磁盘操作。<br>若采用三层索引，则文件的最大长度为 256<em>256</em>256*1KB = 16GB 类似的，访问目标数据块，需要4次磁盘I/O。<br><a name="CUoxX"></a></p><h3 id="混合索引"><a class="markdownIt-Anchor" href="#混合索引"></a> 混合索引</h3><p>多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接 指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表） 。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599874002172-45342705-242d-43fc-b462-cb24fcd9ddf5.png#align=left&amp;display=inline&amp;height=235&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=362&amp;originWidth=668&amp;size=43963&amp;status=done&amp;style=none&amp;width=433" alt="image.png"><br>这种结构的索引支持的最大文件长度为65800KB。<br><a name="Sn2SQ"></a></p><h2 id="总结-4"><a class="markdownIt-Anchor" href="#总结-4"></a> 总结</h2><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599874094352-0c171eeb-704c-41c7-bebd-d8f7a4fc39a6.png#align=left&amp;display=inline&amp;height=237&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=349&amp;originWidth=835&amp;size=256474&amp;status=done&amp;style=none&amp;width=568" alt="image.png"><br>“文件的某种逻辑结构支持随机存取/随机访问”是指：采用 这种逻辑结构的文件，可以根据记录号直接算出该记录对应 的逻辑地址 （逻辑块号，块内地址）。<br><a name="bsSDz"></a></p><h1 id="文件的存储空间管理"><a class="markdownIt-Anchor" href="#文件的存储空间管理"></a> 文件的存储空间管理</h1><p>安装操作系统的必经步骤就是磁盘分区，即存储空间的划分，将物理地址划分为一个个的文件卷（逻辑卷、逻辑盘）。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599874318211-32cdb647-bc74-4390-8608-06b0caac7272.png#align=left&amp;display=inline&amp;height=222&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=309&amp;originWidth=764&amp;size=84226&amp;status=done&amp;style=none&amp;width=550" alt="image.png"><br><a name="131up"></a></p><h2 id="空闲表法"><a class="markdownIt-Anchor" href="#空闲表法"></a> 空闲表法</h2><p>该方法适用于连续分配方式的存储空间管理。<br>与内存管理中的动态分区分配类似，唯一个文件分配连续的存储空间，同样可以采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个分区。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599874544520-b34c12cc-63b9-4d26-93bf-48e685964921.png#align=left&amp;display=inline&amp;height=244&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=312&amp;originWidth=711&amp;size=58263&amp;status=done&amp;style=none&amp;width=556" alt="image.png"><br><a name="vRUbT"></a></p><h2 id="空闲链表法"><a class="markdownIt-Anchor" href="#空闲链表法"></a> 空闲链表法</h2><p>操作系统保存着链头、链尾指针。<br>若文件申请K个盘块，则可以采用首次适应、最佳适应等算法从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区分配给文件。若没有适合的连续空闲块也可以将不同盘区的潘快同时分配给一个文件，注意分配后可能需要修改相应的链指针、盘区大小等数据。<br>若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为一个单独的空闲盘区挂在链尾。<br>空闲链表又可以分为空闲盘块链、空闲盘区链。<br><a name="pExGi"></a></p><h3 id="空闲盘块链"><a class="markdownIt-Anchor" href="#空闲盘块链"></a> 空闲盘块链</h3><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599874668487-4ca972fa-529b-4e44-98e2-106dc971d67b.png#align=left&amp;display=inline&amp;height=287&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=300&amp;originWidth=261&amp;size=35961&amp;status=done&amp;style=none&amp;width=250" alt="image.png"><br><a name="00D3I"></a></p><h3 id="空闲盘区链"><a class="markdownIt-Anchor" href="#空闲盘区链"></a> 空闲盘区链</h3><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599874679352-d94a93e8-0f10-4899-8f0b-8144e2fd1e6f.png#align=left&amp;display=inline&amp;height=305&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=308&amp;originWidth=367&amp;size=50185&amp;status=done&amp;style=none&amp;width=364" alt="image.png"><br><a name="OZdXd"></a></p><h3 id="位示图法"><a class="markdownIt-Anchor" href="#位示图法"></a> 位示图法</h3><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599875375451-2ef28de0-192f-493e-90fb-c6a52dac6c5c.png#align=left&amp;display=inline&amp;height=273&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=407&amp;originWidth=717&amp;size=72374&amp;status=done&amp;style=none&amp;width=481" alt="image.png"><br>每个二进制对应一个盘块，在本例中，0代表盘块空闲，1代表盘块已分配。位示图一般用连续的字来表示。如本例中一个字的字长为16位，字中的每一位对应一个盘块。因此可以用（字号，位号）对应一个盘块号。<br>（字号，位号）=（i，j）的二进制位对应的盘块号b=ni+j<br>b盘块对应的字号i=b/n，位号j=b%n<br>若文件需要K个块，则按照以下步骤进行分配：</p><ol><li>顺序扫描位示图，找到K个相邻或不相邻的0</li><li>根据字号、位图算出对应的盘块号，将相应盘块号分配给文件</li><li>将相应位设置为1</li></ol><p>回收方式按照以下步骤进行：</p><ol><li>根据回收的盘位号计算出相应的字号、位号。</li><li>将响应二进制位设为0<br><a name="gjEuw"></a></li></ol><h2 id="成组链接法"><a class="markdownIt-Anchor" href="#成组链接法"></a> 成组链接法</h2><p>空闲链表法、空闲表法不适用于大型文件系统，因为空闲表或空闲链表可能过大，UNIX采用了成组链接法对磁盘的空闲块进行管理。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599875777382-7e01c0fc-3ff9-49c7-8cc4-30dd4c36413c.png#align=left&amp;display=inline&amp;height=206&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=240&amp;originWidth=307&amp;size=16712&amp;status=done&amp;style=none&amp;width=264" alt="image.png"><br>文件卷的目录中专门用一个磁盘块作为超级块，当系统启动时，需要将超级块读入内存，并且要保证内存与外存的超级快数据一致。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599875917323-5775ce11-7770-4664-b1b8-6f6738b219be.png#align=left&amp;display=inline&amp;height=241&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=376&amp;originWidth=675&amp;size=63294&amp;status=done&amp;style=none&amp;width=433" alt="image.png"><br>如果需要100个空闲块，会按照以下步骤进行分配：</p><ol><li>检查第一个分组的块数是否足够，100=100则为足够。</li><li>分配第一个分组的100个空闲块，然是由于300号快内存放了下一组信息，因此300好快的数据需要复制到超级块中。</li></ol><p>如果每个分组最到位100个空闲块，此时第一个分组已经拥有100个块还要回收，需要将超级快中的数据复制到新的回收快中，并修改超级块的内容，让新的块成为第一个分组。<br><a name="PsOIf"></a></p><h1 id="文件的基本操作"><a class="markdownIt-Anchor" href="#文件的基本操作"></a> 文件的基本操作</h1><p>文件的基本操作分为如下几个功能：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599876232679-2ae6cae6-e233-4215-a073-dbe327016e9e.png#align=left&amp;display=inline&amp;height=202&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=404&amp;originWidth=364&amp;size=97437&amp;status=done&amp;style=none&amp;width=182" alt="image.png"><br><a name="mv3Fb"></a></p><h2 id="创建文件-2"><a class="markdownIt-Anchor" href="#创建文件-2"></a> 创建文件</h2><p>电脑上可以通过如下操作进行创建文件：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599876395511-f50411e4-82bf-48a4-b66d-3f3e2aaf073b.png#align=left&amp;display=inline&amp;height=281&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=562&amp;originWidth=770&amp;size=483918&amp;status=done&amp;style=none&amp;width=385" alt="image.png"><br>在进行Create系统调用时需要提供如下几个参数：</p><ul><li>所需的内存空间大小</li><li>文件存放路径</li><li>文件名</li></ul><p>其在创建文件时，主要进行了如下两个操作：</p><ul><li>在外存中找到文件所需的空间（结合空闲链表法、位示图、成组链接法等管理策略）</li><li>根据文件存放路径的信息找到该目录对应的目录文件，在目录中创建该文件对应的目录项。目录项中包含了文件名、文件在外存中存放位置等信息。<br><a name="GpvRc"></a></li></ul><h2 id="删除文件-2"><a class="markdownIt-Anchor" href="#删除文件-2"></a> 删除文件</h2><p>电脑上可以通过如下操作进行删除文件：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599876906859-18144f00-0415-4106-a3c5-5bd4b52a7d4f.png#align=left&amp;display=inline&amp;height=332&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=663&amp;originWidth=366&amp;size=35809&amp;status=done&amp;style=none&amp;width=183" alt="image.png"><br>进行Delete系统调用时，需要提供几个主要参数：</p><ul><li>文件存放路径</li><li>文件名</li></ul><p>在Delete系统调用时，主要做了如下几件事：</p><ul><li>根据文件存放路径找到对应的目录文件，从目录中找到文件名对应的目录项。</li><li>根据该目录项记录的文件在外村存放位置、文件大小等信息，回收文件占用的磁盘块。（根据空闲表法、空闲链表法、位图法等管理策略的不同做出不同的处理）</li><li>从目录中删除文件对应的目录项。<br><a name="ddRqH"></a></li></ul><h2 id="打开文件-2"><a class="markdownIt-Anchor" href="#打开文件-2"></a> 打开文件</h2><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599877278097-31bcb91c-dec2-40d7-aad8-3aad46673b88.png#align=left&amp;display=inline&amp;height=328&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=468&amp;originWidth=593&amp;size=78386&amp;status=done&amp;style=none&amp;width=416" alt="image.png"><br>执行Open系统调用打开文件，需要以下几个主要参数：</p><ul><li>文件存放路径</li><li>文件名</li><li>文件的操作类型（r：只读，rw：读写等）</li></ul><p>操作系统在调用函数时，主要做了以下几件事：</p><ul><li>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项，并检查该用户是否由指定的操作权限。</li><li>将目录项复制到内存中的打开文件表中。并将对应表中的编号返回给用户，之后用户使用打开文件表的编号来指明操作的文件。</li></ul><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599877557471-ccfcda6f-b58a-439e-b4eb-b57256658e92.png#align=left&amp;display=inline&amp;height=343&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=498&amp;originWidth=846&amp;size=217312&amp;status=done&amp;style=none&amp;width=583" alt="image.png"><br><a name="MRP07"></a></p><h2 id="关闭文件-2"><a class="markdownIt-Anchor" href="#关闭文件-2"></a> 关闭文件</h2><p>关闭文件主要做了以下几件事：</p><ul><li>将进程的打开文件表响应表项删除</li><li>回收分配给该文件的内存空间等资源</li><li>系统打开文件表的打开计数器count减一，若count=0，则删除对应表项。</li></ul><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599877720626-32def3cd-fee3-46fb-abec-3c4152ca2e62.png#align=left&amp;display=inline&amp;height=243&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=485&amp;originWidth=822&amp;size=102753&amp;status=done&amp;style=none&amp;width=411" alt="image.png"><br><a name="vQIgN"></a></p><h2 id="读文件-2"><a class="markdownIt-Anchor" href="#读文件-2"></a> 读文件</h2><p>系统的read调用完成写操作，需要指明是哪个文件、读入多少数据和药存放的内存位置即可。<br>系统在处理read系统调用时，会从读指针指向外存中，将用户指定大小的数据读入用户指定的内存区域中。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599877869415-04db04ce-6c5f-4a42-953d-99fdd2578097.png#align=left&amp;display=inline&amp;height=322&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=430&amp;originWidth=771&amp;size=118038&amp;status=done&amp;style=none&amp;width=578" alt="image.png"><br><a name="LGx5w"></a></p><h2 id="写文件-2"><a class="markdownIt-Anchor" href="#写文件-2"></a> 写文件</h2><p>进程使用write完成写操作，需要指明是哪个文件、写出多少数据和写回外存的数据放在内存的位置即可。<br>操作系统在处理write系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599878054614-65c3fc38-48c4-476d-a1df-5029e8dd26db.png#align=left&amp;display=inline&amp;height=298&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=426&amp;originWidth=736&amp;size=120887&amp;status=done&amp;style=none&amp;width=515" alt="image.png"><br><a name="SDVum"></a></p><h1 id="文件共享"><a class="markdownIt-Anchor" href="#文件共享"></a> 文件共享</h1><p>系统为用户提供文件共享功能，可以让多个用户共享的使用同一个文件。<br>注意：</p><ul><li>多个用户共享同一个文件，意味着系统中只有一份文件数据，并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化。</li><li>如果是多个用户都复制了同一个文件，那么系统中会有好几分文件数据，其中一个用户修改了自己那份数据对其他用户没有影响。</li></ul><p>文件共享分为基于索引节点的共享方式（硬链接）和基于符号链的共享方式（软链接）。<br><a name="n0Yv6"></a></p><h2 id="基于索引节点的共享方式"><a class="markdownIt-Anchor" href="#基于索引节点的共享方式"></a> 基于索引节点的共享方式</h2><p>索引节点是一种文件目录瘦身策略，由于索引文件时只需用到文件名，因此可以将除了文件名以外的其他信息放到索引节点中。这样目录项只需要包含文件名、索引节点指针。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599878416647-08497fe2-d547-4e64-8b27-eb8d5790185e.png#align=left&amp;display=inline&amp;height=143&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=220&amp;originWidth=809&amp;size=47896&amp;status=done&amp;style=none&amp;width=527" alt="image.png"><br>索引节点中设置一个连接计数变量count，用于标识链接到本索引节点上的用户目录项数。<br>若count=2，说明此事有两个用户目录项连接到该索引节点上，或者说有两个用户在共享此文件，若某个用户决定删除这个文件，则只要把用户目录中与该文件对应的目录项删除，则索引节点的count减一。<br>若count&gt;0，说明还有别的用户使用该文件，则不能删除文件数据，否则会导致指针悬空。<br>当count=0时说明系统负责删除文件。<br><a name="dvJ9P"></a></p><h2 id="基于符号链的共享方式"><a class="markdownIt-Anchor" href="#基于符号链的共享方式"></a> 基于符号链的共享方式</h2><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599878722831-12631b1f-4c86-4b5a-a6a7-8daddc2b1638.png#align=left&amp;display=inline&amp;height=247&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=357&amp;originWidth=802&amp;size=104581&amp;status=done&amp;style=none&amp;width=554" alt="image.png"><br>当User3访问ccc时，操作系统判断文件ccc属于Link类型文件，于是会根据其中的记录路径层层查找目录，最终找到User1的目录表中的aaa表项，于是就找到了文件1的索引信道。<br>所谓的快捷方式就是软链接的表现。<br><a name="1Kg9x"></a></p><h1 id="文件保护"><a class="markdownIt-Anchor" href="#文件保护"></a> 文件保护</h1><p>文件保护用来保护文件的数据安全，其分为口令保护、加密保护、访问控制。<br><a name="WMPtV"></a></p><h2 id="口令保护"><a class="markdownIt-Anchor" href="#口令保护"></a> 口令保护</h2><p>为文件设置一个口令，用户请求访问该文件时必须提供口令。<br>口令一般存放在文件对应的FCB或索引节点中，用户访问文件前需要先输入口令，操作系统会将用户提供的口令与FCB中存储的口令进行对比，如果正确则允许用户访问文件。<br>优点：保存口令的空间开销并不多，验证口令的开销也很少。<br>缺点：正确的口令存放在系统内部不够安全。<br><a name="Tn26d"></a></p><h2 id="加密保护"><a class="markdownIt-Anchor" href="#加密保护"></a> 加密保护</h2><p>使用某个密码对文件进行加密，再访问文件时需要提供正确的密码才能对文件正确的解密，常用的加密算法：异或加密。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599879185234-846c4306-7c0d-4a94-806d-7aa6b745e520.png#align=left&amp;display=inline&amp;height=162&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=226&amp;originWidth=722&amp;size=63487&amp;status=done&amp;style=none&amp;width=519" alt="image.png"><br>优点：保密性强，不需要在系统中存储密码。<br>缺点：编解码花费时间较长。<br><a name="HmLZZ"></a></p><h2 id="访问控制"><a class="markdownIt-Anchor" href="#访问控制"></a> 访问控制</h2><p>在每个文件的FCB或索引节点中增加一个访问控制列表，该表中记录了个用户可对用户执行哪些操作。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599879310154-1176e305-3a4a-43e0-abf2-7b530ebfa37e.png#align=left&amp;display=inline&amp;height=201&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=287&amp;originWidth=733&amp;size=97478&amp;status=done&amp;style=none&amp;width=513" alt="image.png"><br>精简的访问列表以组为单位，标记各族用户可以对用户执行哪些操作。当某用户想要访问文件时，系统会检查用户所属文组来确定是否有相应的权限。<br><a name="xYIV9"></a></p><h1 id="系统的层次结构总结"><a class="markdownIt-Anchor" href="#系统的层次结构总结"></a> 系统的层次结构总结</h1><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599879466091-a204042b-a0c4-4cfe-9cab-a8949956837f.png#align=left&amp;display=inline&amp;height=329&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=369&amp;originWidth=754&amp;size=206236&amp;status=done&amp;style=none&amp;width=672" alt="image.png"><br>举个理解来回忆文件系统的层次结构，假设用户请求删除文件“D:/表格/学生信息表.xlsx”的最后100条记录。</p><ul><li>用户需要通过操作系统系统提供的接口发出上述请求——用户接口</li><li>由于用户提供的是文件的存放路径，因此需要操作系统一层一层的查找目录找到对应的目录项——文件目录系统</li><li>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限——存取控制模块（存取控制验证层）</li><li>验证了用户的访问权限之后，需要把用户提供的记录号转变为对应的逻辑地址——逻辑文件系统与文件信息缓冲区</li><li>知道了目标记录的逻辑地址后，需要转换成实际的物理地址——物理文件系统</li><li>要删除这条记录，必定要对磁盘设备发出请求——设备管理程序模块</li><li>删除这些记录后，会有一些盘块空闲，因此要对这些盘块进行回收——辅助分配模块</li></ul></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined">Zhang Junjie</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://jie-blog.icu/posts/operating_system_file_system/">https://jie-blog.icu/posts/operating_system_file_system/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jie-blog.icu" target="_blank">Jieker's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5f4e5a0be7fabc7b" async="async"></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="./img/loading.gif" data-original="/img/wechat.png" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="./img/loading.gif" data-original="/img/alipay.jpg" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/operating_system_disk/"><img class="prev-cover" src="./img/loading.gif" data-original="https://jie-blog.icu/img/Operating_System/system.png" onerror='onerror=null,src="/img/404.jpg"'><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">操作系统之磁盘</div></div></a></div><div class="next-post pull-right"><a href="/posts/operating_system_virtual_memory/"><img class="next-cover" src="./img/loading.gif" data-original="https://jie-blog.icu/img/Operating_System/system.png" onerror='onerror=null,src="/img/404.jpg"'><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统之虚拟内存</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image:url(https://jie-blog.icu/img/Operating_System/system.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020<i id="heartbeat" class="fa fas fa-heartbeat"></i> Zhang Junjie</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">welcome to my <a href="https://jie-blog.icu/">blog</a>!</div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></head></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'XOcW2XseURBSH0ajeHVGv0iN-gzGzoHsz',
      appKey: 'iJPxPr2bJjhcx7m3zC49NyQC',
      placeholder: '記得留下你的暱稱和郵箱....可以快速收到回復',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,document.body.addEventListener("input",POWERMODE)</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  'meta[name=description]',
  '#config_change',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  $('script[data-pjax]').each(function () {
    $(this).parent().append($(this).remove())
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', '', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})


document.addEventListener('pjax:send', function () {
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  $(window).off('scroll')

  //reset readmode
  $('body').hasClass('read-mode') && $('body').removeClass('read-mode')

})</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script><script>window.imageLazyLoadSetting={isSPA:!1,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=i;var e=n.imageLazyLoadSetting.isSPA,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)void 0,0<=(t=r[a].getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight+240||document.documentElement.clientHeight+240)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e()},n.src=i}()}i(),n.addEventListener("scroll",function(){var t,e;t=i,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script></body></html>