<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>操作系统之进程 | Jieker's Blog</title><meta name="description" content="操作系统之进程   概述 任务管理器如下图：程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。进程（Process）：是动态的，是程序的一次执行过程。同一个程序多次执行会对应多个进程。   进程的特征 程序是静态的，进程是动态的，相比于程序，进程拥有以下特征：   计算机组成 更确切的说，应该是“进程实体(进程映像)的组成”。其中PCB是给操作系统用的。 程序段、数据段是给进"><meta name="keywords" content="操作系统"><meta name="author" content="Zhang Junjie"><meta name="copyright" content="Zhang Junjie"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/url(https:/jie-blog.icu/img/Log.png)"><link rel="canonical" href="https://jie-blog.icu/posts/operating_system_process/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta property="og:type" content="article"><meta property="og:title" content="操作系统之进程"><meta property="og:url" content="https://jie-blog.icu/posts/operating_system_process/"><meta property="og:site_name" content="Jieker's Blog"><meta property="og:description" content="操作系统之进程   概述 任务管理器如下图：程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。进程（Process）：是动态的，是程序的一次执行过程。同一个程序多次执行会对应多个进程。   进程的特征 程序是静态的，进程是动态的，相比于程序，进程拥有以下特征：   计算机组成 更确切的说，应该是“进程实体(进程映像)的组成”。其中PCB是给操作系统用的。 程序段、数据段是给进"><meta property="og:image" content="https://jie-blog.icu/img/Operating_System/system.png"><meta property="article:published_time" content="2020-09-15T11:15:56.000Z"><meta property="article:modified_time" content="2020-09-15T11:27:01.173Z"><meta name="twitter:card" content="summary"><link rel="manifest" href="/image/pwa/manifest.json"><link rel="apple-touch-icon" sizes="180x180" href="/image/pwa/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/image/pwa/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/image/pwa/16.png"><link rel="mask-icon" href="/image/pwa/safari-pinned-tab.svg" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"",enable_page_level_ads:"true"})</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: {"limitCount":50,"languages":{"author":"Jieker: Zhang Junjie","link":"链接: ","source":"来源: Jieker's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
      const now = new Date()
      const expiryDay = ttl * 86400000
      const item = {
        value: value,
        expiry: now.getTime() + expiryDay,
      }
      localStorage.setItem(key, JSON.stringify(item))
    },
  
  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!0,isSidebar:!0,postUpdate:"2020-09-15 19:27:01"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}</style></noscript><script>var activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")},autoChangeMode="false",t=saveToLocal.get("theme");if("1"===autoChangeMode){var isDarkMode=window.matchMedia("(prefers-color-scheme: dark)").matches,isLightMode=window.matchMedia("(prefers-color-scheme: light)").matches,isNotSpecified=window.matchMedia("(prefers-color-scheme: no-preference)").matches,hasNoSupport=!isDarkMode&&!isLightMode&&!isNotSpecified;if(void 0===t){if(isLightMode)activateLightMode();else if(isDarkMode)activateDarkMode();else if(isNotSpecified||hasNoSupport){var now=new Date,hour=now.getHours(),isNight=hour<=6||18<=hour;isNight?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())})}else"light"===t?activateLightMode():activateDarkMode()}else"2"===autoChangeMode?(isNight=(hour=(now=new Date).getHours())<=6||18<=hour,void 0===t?isNight?activateDarkMode():activateLightMode():"light"===t?activateLightMode():activateDarkMode()):"dark"===t?activateDarkMode():"light"===t&&activateLightMode()</script><script src="/js/daovoice.js"></script><link rel="stylesheet" href="footer.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/atom.xml" title="Jieker's Blog" type="application/atom+xml"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="./img/loading.gif" data-original="/img/picture.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">44</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">12</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">14</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i> <span>Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i> <span>Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i> <span>Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i> <span>About</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">操作系统之进程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">2.1.</span> <span class="toc-text">进程的特征</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90"><span class="toc-number">3.</span> <span class="toc-text">计算机组成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#pcb"><span class="toc-number">3.1.</span> <span class="toc-text">PCB</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pcb%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.1.</span> <span class="toc-text">PCB概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%AE%B5%E5%92%8C%E6%95%B0%E6%8D%AE%E6%AE%B5%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="toc-number">3.1.2.</span> <span class="toc-text">程序段和数据段的产生</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-number">4.</span> <span class="toc-text">进程的组织</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">进程的组织方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text">链接方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.2.</span> <span class="toc-text">索引方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">5.1.</span> <span class="toc-text">如何实现进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%80%E6%B0%94%E5%91%B5%E6%88%90"><span class="toc-number">5.1.1.</span> <span class="toc-text">为什么要“一气呵成”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.1.2.</span> <span class="toc-text">原子性的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E8%AF%AD%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">原语类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9B%B8%E5%85%B3%E5%8E%9F%E8%AF%AD"><span class="toc-number">5.2.1.</span> <span class="toc-text">进程创建相关原语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2%E7%9B%B8%E5%85%B3%E5%8E%9F%E8%AF%AD"><span class="toc-number">5.2.2.</span> <span class="toc-text">进程终止相关原语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%98%BB%E5%A1%9E%E5%92%8C%E5%94%A4%E9%86%92%E7%9A%84%E5%8E%9F%E8%AF%AD"><span class="toc-number">5.2.3.</span> <span class="toc-text">进程阻塞和唤醒的原语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E7%9A%84%E5%8E%9F%E8%AF%AD"><span class="toc-number">5.2.4.</span> <span class="toc-text">进程切换的原语</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E8%AF%AD%E8%BD%AC%E6%8D%A2%E5%9B%BE"><span class="toc-number">5.3.</span> <span class="toc-text">原语转换图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">6.</span> <span class="toc-text">进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8"><span class="toc-number">6.1.</span> <span class="toc-text">共享存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B1%E4%BA%AB"><span class="toc-number">6.1.1.</span> <span class="toc-text">基于数据结构共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%AD%98%E5%82%A8%E5%8C%BA%E5%85%B1%E4%BA%AB"><span class="toc-number">6.1.2.</span> <span class="toc-text">基于存储区共享</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1"><span class="toc-number">6.2.</span> <span class="toc-text">管道通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">6.3.</span> <span class="toc-text">消息传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">6.3.1.</span> <span class="toc-text">直接通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">6.3.2.</span> <span class="toc-text">间接通信方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">7.</span> <span class="toc-text">线程的概念和特点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%95%E5%87%BA"><span class="toc-number">7.1.</span> <span class="toc-text">线程的引出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E6%80%A7%E5%92%8C%E4%BC%98%E7%82%B9"><span class="toc-number">7.1.1.</span> <span class="toc-text">线程的特性和优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.2.</span> <span class="toc-text">什么是线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">7.3.</span> <span class="toc-text">线程的实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8Buser-level-thread-ult"><span class="toc-number">7.3.1.</span> <span class="toc-text">用户级线程（User-Level Thread, ULT）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8Bkernel-level-thread-klt-%E5%8F%88%E7%A7%B0%E5%86%85%E6%A0%B8%E6%94%AF%E6%8C%81%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.3.2.</span> <span class="toc-text">内核级线程（Kernel-Level Thread, KLT, 又称“内核支持的线程”）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">7.3.3.</span> <span class="toc-text">组合使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.3.4.</span> <span class="toc-text">多线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.3.4.1.</span> <span class="toc-text">一对一模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.3.4.2.</span> <span class="toc-text">多对一模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.3.4.3.</span> <span class="toc-text">多对多模型</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image:url(https://jie-blog.icu/img/Operating_System/system.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Jieker's Blog</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i> <span>Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i> <span>Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i> <span>Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i> <span>About</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">操作系统之进程</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-15T11:15:56.000Z" title="发表于 2020-09-15 19:15:56">2020-09-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-15T11:27:01.173Z" title="更新于 2020-09-15 19:27:01">2020-09-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="操作系统之进程"><a class="markdownIt-Anchor" href="#操作系统之进程"></a> 操作系统之进程</h1><p><a name="e1nnw"></a></p><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>任务管理器如下图：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599212600999-8644da9c-68e2-42d9-b0ef-d60f46d32e0a.png#align=left&amp;display=inline&amp;height=372&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=744&amp;originWidth=1070&amp;size=92296&amp;status=done&amp;style=none&amp;width=535" alt="image.png"><br>程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。<br>进程（Process）：是动态的，是程序的一次执行过程。同一个程序多次执行会对应多个进程。<br><a name="kWv0Z"></a></p><h2 id="进程的特征"><a class="markdownIt-Anchor" href="#进程的特征"></a> 进程的特征</h2><p>程序是静态的，进程是动态的，相比于程序，进程拥有以下特征：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599213836986-7618c585-e1e6-467d-b725-a88136c107b6.png#align=left&amp;display=inline&amp;height=318&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=635&amp;originWidth=1568&amp;size=404039&amp;status=done&amp;style=none&amp;width=784" alt="image.png"><br><a name="UIPjV"></a></p><h1 id="计算机组成"><a class="markdownIt-Anchor" href="#计算机组成"></a> 计算机组成</h1><p>更确切的说，应该是“进程实体(进程映像)的组成”。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599213178682-a3f02d8c-9058-41e1-9aab-c4b529cc2378.png#align=left&amp;display=inline&amp;height=255&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=510&amp;originWidth=1532&amp;size=148785&amp;status=done&amp;style=none&amp;width=766" alt="image.png"><br>其中PCB是给操作系统用的。 程序段、数据段是给进程自己用的。<br>程序段、数据段、PCB三部分组成了进程实体（进程映像） 引入进程实体的概念后，可把进程定义为： 进程是进程实体的运行过程，是系统进行资源分配和调度（一个进程被“调度”，就是指操作系统决定让这个进程上CPU运行）的一个独立单位。<br><a name="98mmL"></a></p><h2 id="pcb"><a class="markdownIt-Anchor" href="#pcb"></a> PCB</h2><p>如上图，每个进程都有专属的PID，当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”就是PID（Process ID，进程ID）。<br>除此以外，其还会记录进程所属用户ID（UID），基本的进程描述信息，可以让操作系统区分各个进程。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599212730059-1b34d031-535e-461f-a96e-40aaf4148329.png#align=left&amp;display=inline&amp;height=59&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=117&amp;originWidth=1062&amp;size=12703&amp;status=done&amp;style=none&amp;width=531" alt="image.png"><br>还要记录给进程分配了哪些资源（如：分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件）（可用于实现操作系统对资源的管理）、要记录进程的运行情况（如：CPU使用时间、磁盘使用情况、网络流量使用情况等）（可用于实现操作系统对进程的控制、调度）。<br>这些信息都被保存在一个数据结构PCB （Process Control Block）中，即进程控制块操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在PCB中。<br><a name="iA9OT"></a></p><h3 id="pcb概念"><a class="markdownIt-Anchor" href="#pcb概念"></a> PCB概念</h3><p>操作系统对进程进行管理工作所需的信息都存在PCB中，PCB是进程存在的唯一标志。<br>PCB是进程存在的唯 一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599213103222-be9b99a4-33ec-410b-afff-f6c61d0f87de.png#align=left&amp;display=inline&amp;height=285&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=570&amp;originWidth=1584&amp;size=195775&amp;status=done&amp;style=none&amp;width=792" alt="image.png"><br>同时挂三个QQ号，会对应三个QQ 进程，它们的PCB、数据段各不相同，但程序段的内容都是相同的 （都是运行着相同的QQ程序）。<br><a name="lTypu"></a></p><h3 id="程序段和数据段的产生"><a class="markdownIt-Anchor" href="#程序段和数据段的产生"></a> 程序段和数据段的产生</h3><p>程序段是指程序代码（指令序列），数据段是指运行过程中产生的各种数据。<br>程序运行的过程其实就是CPU执行一条一条的机器指令的过程。如下图即单条指令翻译过程：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599213283819-61c6e5d1-c139-49a4-b0ae-7572b2454167.png#align=left&amp;display=inline&amp;height=98&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=196&amp;originWidth=1040&amp;size=68172&amp;status=done&amp;style=none&amp;width=520" alt="image.png"><br>因此推断程序执行流程如下：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599213390418-85e6bc78-1ef7-4b55-a8c0-a5da1f3a4460.png#align=left&amp;display=inline&amp;height=364&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=728&amp;originWidth=1525&amp;size=241406&amp;status=done&amp;style=none&amp;width=762.5" alt="image.png"><br>一个进程实体（进程映像）由PCB、程序段、数据段组成。 进程是动态的，进程实体（进程映像）是静态的。 进程实体反应了进程在某一时刻的状态（如：x++后，x=2）。<br><a name="GrfT7"></a></p><h1 id="进程的组织"><a class="markdownIt-Anchor" href="#进程的组织"></a> 进程的组织</h1><p>在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。<br>注：进程的组成讨论的是一个进程内部由哪些部分构成的问题，而进程的组织讨论的是多个进程之间的组织方式问题。<br><a name="AdpLA"></a></p><h2 id="进程的组织方式"><a class="markdownIt-Anchor" href="#进程的组织方式"></a> 进程的组织方式</h2><p>其组织方式有两种，一种是索引方式，另一种就是链接方式。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599213930177-79884b3d-768d-4a37-9882-c3d475a8a0ea.png#align=left&amp;display=inline&amp;height=163&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=325&amp;originWidth=1340&amp;size=209323&amp;status=done&amp;style=none&amp;width=670" alt="image.png"><br><a name="SJ89p"></a></p><h3 id="链接方式"><a class="markdownIt-Anchor" href="#链接方式"></a> 链接方式</h3><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599213985145-6237609d-228f-48a9-bd96-4ffea052b9b3.png#align=left&amp;display=inline&amp;height=348&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=541&amp;originWidth=1070&amp;size=146777&amp;status=done&amp;style=none&amp;width=688" alt="image.png"><br><a name="itTYI"></a></p><h3 id="索引方式"><a class="markdownIt-Anchor" href="#索引方式"></a> 索引方式</h3><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599214003578-53fcd1fc-8d2a-44db-a617-8bb19730c866.png#align=left&amp;display=inline&amp;height=349&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=505&amp;originWidth=988&amp;size=68718&amp;status=done&amp;style=none&amp;width=682" alt="image.png"><br><a name="zMPqA"></a></p><h1 id="进程控制"><a class="markdownIt-Anchor" href="#进程控制"></a> 进程控制</h1><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现 进程状态转换等功能。<br>进程转化流程：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599216033517-37594efe-63ef-4c0d-a7ff-1620cfc27479.png#align=left&amp;display=inline&amp;height=175&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=305&amp;originWidth=1156&amp;size=56226&amp;status=done&amp;style=none&amp;width=664" alt="image.png"><br><a name="hDWSK"></a></p><h2 id="如何实现进程控制"><a class="markdownIt-Anchor" href="#如何实现进程控制"></a> 如何实现进程控制</h2><p>进程控制是通过使用“原语”实现的。<br>之前讲过，原语使内核中的关键的一部分：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599216088116-b8b0e0e1-d388-42ce-82ad-0cdbbd0a4db2.png#align=left&amp;display=inline&amp;height=294&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=495&amp;originWidth=1184&amp;size=133348&amp;status=done&amp;style=none&amp;width=704" alt="image.png"><br><a name="RVSLn"></a></p><h3 id="为什么要一气呵成"><a class="markdownIt-Anchor" href="#为什么要一气呵成"></a> 为什么要“一气呵成”</h3><p>如果不能“一气呵成”，就有可能导致操作系 统中的某些关键数据结构信息不统一的情况， 这会影响操作系统进行别的管理工作。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599216330604-8dc1bea9-bedd-4df4-b97d-d9688987530d.png#align=left&amp;display=inline&amp;height=255&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=398&amp;originWidth=1082&amp;size=183730&amp;status=done&amp;style=none&amp;width=694" alt="image.png"><br><a name="DKsvj"></a></p><h3 id="原子性的实现"><a class="markdownIt-Anchor" href="#原子性的实现"></a> 原子性的实现</h3><p>可以用 “关中断指令”和“开中断指令”这两个特权指令实现原子性。<br>正常情况：CPU每执行完一条指令都会例行检查是否有中断信号需要处理，如果有， 则暂停运行当前这段程序，转而执行相应的中断处理程序。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599216480233-d06187d6-706f-4c3e-a77e-089fd910e8df.png#align=left&amp;display=inline&amp;height=344&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=465&amp;originWidth=633&amp;size=89935&amp;status=done&amp;style=none&amp;width=468" alt="image.png"><br>CPU执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后才会恢复检查。 这样，关中断、开中断之间的这些指令序列就是不可被中断的，这就实现了“原子性”<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599216535162-81d9b236-d3db-497f-b444-bd0a0f3308ab.png#align=left&amp;display=inline&amp;height=328&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=433&amp;originWidth=597&amp;size=65353&amp;status=done&amp;style=none&amp;width=452" alt="image.png"><br><a name="XUDb9"></a></p><h2 id="原语类型"><a class="markdownIt-Anchor" href="#原语类型"></a> 原语类型</h2><p>无论哪个进程控制原语，要做的无非三类事情：</p><ul><li>更新PCB中的信息<ul><li>所有的进程控制原语一定都会修改进程状态标志</li><li>剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li><li>某进程开始运行前必然要恢复期运行环境</li></ul></li><li>将PCB插入合适的队列</li><li>分配/回收资源<br><a name="VSArr"></a></li></ul><h3 id="进程创建相关原语"><a class="markdownIt-Anchor" href="#进程创建相关原语"></a> 进程创建相关原语</h3><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599216626772-896930a6-5ad3-46ba-8fe8-c630990f5768.png#align=left&amp;display=inline&amp;height=360&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=497&amp;originWidth=1214&amp;size=230253&amp;status=done&amp;style=none&amp;width=879" alt="image.png"><br><a name="Z3rm6"></a></p><h3 id="进程终止相关原语"><a class="markdownIt-Anchor" href="#进程终止相关原语"></a> 进程终止相关原语</h3><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599216681520-6878afde-3340-472b-bce1-396b8d31037e.png#align=left&amp;display=inline&amp;height=362&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=542&amp;originWidth=1181&amp;size=258874&amp;status=done&amp;style=none&amp;width=789" alt="image.png"><br><a name="D6k0p"></a></p><h3 id="进程阻塞和唤醒的原语"><a class="markdownIt-Anchor" href="#进程阻塞和唤醒的原语"></a> 进程阻塞和唤醒的原语</h3><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599216716635-862d5039-4126-4b92-b769-b8bc596d2b8d.png#align=left&amp;display=inline&amp;height=380&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=524&amp;originWidth=1231&amp;size=274363&amp;status=done&amp;style=none&amp;width=893" alt="image.png"><br><a name="f5MP7"></a></p><h3 id="进程切换的原语"><a class="markdownIt-Anchor" href="#进程切换的原语"></a> 进程切换的原语</h3><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599217734216-976345c1-de44-4da6-b481-3f9daec33570.png#align=left&amp;display=inline&amp;height=341&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=549&amp;originWidth=1111&amp;size=238632&amp;status=done&amp;style=none&amp;width=690" alt="image.png"><br><a name="B2aTL"></a></p><h2 id="原语转换图"><a class="markdownIt-Anchor" href="#原语转换图"></a> 原语转换图</h2><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599218323463-925854e5-3b83-4db5-94dc-f0ddbdb36c27.png#align=left&amp;display=inline&amp;height=421&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=699&amp;originWidth=1183&amp;size=332831&amp;status=done&amp;style=none&amp;width=713" alt="image.png"><br><a name="ozkCh"></a></p><h1 id="进程通信"><a class="markdownIt-Anchor" href="#进程通信"></a> 进程通信</h1><p>顾名思义，进程通信就是指进程之间的信息交换。 进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599218774690-b1767483-49e8-4c80-a3da-8db329ef98b7.png#align=left&amp;display=inline&amp;height=354&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=541&amp;originWidth=673&amp;size=62784&amp;status=done&amp;style=none&amp;width=440" alt="image.png"><br>为了保证安全，一个进程不能直接访问另 一个进程的地址空间。 但是进程之间的信息交换又是必须实现的。 为了保证进程间的安全通信，操作系统提供了一些方法：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599218788636-41f507e4-c2f4-4007-89a8-fa3e34b0bd28.png#align=left&amp;display=inline&amp;height=144&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=217&amp;originWidth=535&amp;size=33531&amp;status=done&amp;style=none&amp;width=355" alt="image.png"><br><a name="LzHFY"></a></p><h2 id="共享存储"><a class="markdownIt-Anchor" href="#共享存储"></a> 共享存储</h2><p>两个进程对共享空间的访问必须是互斥的（互斥访问通过操作系统提供的工具实现）。操作系统只负责提供共享空间和同步互斥工具（如P、V操作）<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599219471111-c5b5aed1-b72a-4e69-add1-bf0a50b0dcdd.png#align=left&amp;display=inline&amp;height=325&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=551&amp;originWidth=1003&amp;size=58901&amp;status=done&amp;style=none&amp;width=592" alt="image.png"><br>共享存储又分为两种方式：基于数据结构共享和基于存储区共享。<br><a name="Gh1G9"></a></p><h3 id="基于数据结构共享"><a class="markdownIt-Anchor" href="#基于数据结构共享"></a> 基于数据结构共享</h3><p>基于数据结构的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式。<br><a name="ZRsu1"></a></p><h3 id="基于存储区共享"><a class="markdownIt-Anchor" href="#基于存储区共享"></a> 基于存储区共享</h3><p>基于存储区的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制， 而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。<br><a name="0I9Gx"></a></p><h2 id="管道通信"><a class="markdownIt-Anchor" href="#管道通信"></a> 管道通信</h2><p>“管道”是指用于连接读写进程的一个共享文件，又名pipe 文件。其实就是在内存中开辟 一个大小固定的缓冲区。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599219513182-075f2e89-0e2f-4b5b-b6f6-787f7719628d.png#align=left&amp;display=inline&amp;height=133&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=265&amp;originWidth=1263&amp;size=67015&amp;status=done&amp;style=none&amp;width=631.5" alt="image.png"></p><ul><li>管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</li><li>各进程要互斥地访问管道。</li><li>数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据 取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。</li><li>如果没写满，就不允许读。如果没读空，就不允许写。</li><li>数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。<br><a name="SKVZN"></a></li></ul><h2 id="消息传递"><a class="markdownIt-Anchor" href="#消息传递"></a> 消息传递</h2><p>进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。<br>下图是消息的格式：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599219672069-46e2119d-9f46-4b0b-b492-c700f4cb80c3.png#align=left&amp;display=inline&amp;height=144&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=251&amp;originWidth=717&amp;size=83157&amp;status=done&amp;style=none&amp;width=410" alt="image.png"><br>消息传递分为直接通信方式和间接通信方式。<br><a name="0ZMxi"></a></p><h3 id="直接通信方式"><a class="markdownIt-Anchor" href="#直接通信方式"></a> 直接通信方式</h3><p>消息直接挂到接收进程的消息缓冲队列上。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599219681993-27f0af3e-fc3a-4e83-a979-9ead63b616dc.png#align=left&amp;display=inline&amp;height=241&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=332&amp;originWidth=462&amp;size=40844&amp;status=done&amp;style=none&amp;width=336" alt="image.png"><br><a name="G9PFn"></a></p><h3 id="间接通信方式"><a class="markdownIt-Anchor" href="#间接通信方式"></a> 间接通信方式</h3><p>消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”。Eg：计网中的电子邮件系统。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599219707180-158219f2-9bbf-4bb8-a98b-5876297af0fd.png#align=left&amp;display=inline&amp;height=163&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=276&amp;originWidth=726&amp;size=42361&amp;status=done&amp;style=none&amp;width=428" alt="image.png"><br><a name="5hlOU"></a></p><h1 id="线程的概念和特点"><a class="markdownIt-Anchor" href="#线程的概念和特点"></a> 线程的概念和特点</h1><p>进程是程序的一次执行。这些功能显然需要用不同的几段程序才能实现，并且这几段程序还要并发运行。<br>比如下述有三个进程来实现三个功能：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599219852120-ae449e3f-52b3-4d7b-a0cf-c893a5a24979.png#align=left&amp;display=inline&amp;height=115&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=181&amp;originWidth=885&amp;size=41811&amp;status=done&amp;style=none&amp;width=562" alt="image.png"><br>其内部如下：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599220036923-d1d69cc0-25f9-493c-a5eb-1dda82ee8542.png#align=left&amp;display=inline&amp;height=333&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=546&amp;originWidth=954&amp;size=150933&amp;status=done&amp;style=none&amp;width=582" alt="image.png"><br>当切换进程时，需要保存/恢复进程运行环境， 还需要切换内存地址空间（更新快表、更新缓存）开销很大。<br><a name="ylS7g"></a></p><h2 id="线程的引出"><a class="markdownIt-Anchor" href="#线程的引出"></a> 线程的引出</h2><p>有的进程可能需要“同时”做很多事，而传统 的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599220194317-60601251-4438-4cc3-8a17-1e9e5c72a9ab.png#align=left&amp;display=inline&amp;height=357&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=591&amp;originWidth=1016&amp;size=189134&amp;status=done&amp;style=none&amp;width=614" alt="image.png"><br>引入线程后，进程是资源分配的基本单位。而线程几乎不拥有资源，只拥有极少量的资源 （线程控制块TCB、寄存器信息、堆栈等）<br><a name="o2Cs8"></a></p><h3 id="线程的特性和优点"><a class="markdownIt-Anchor" href="#线程的特性和优点"></a> 线程的特性和优点</h3><p>进程间并发，开销很大<br>线程间并发，开销更小<br>引入线程机制后，并发带来的系统开销降低，系统并发性提升<br>注意：从属于不同进程的线程间切换，也会导致进程的切换，开销也大。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599220333044-ae118df9-de0c-4b64-b58f-d179fefd6527.png#align=left&amp;display=inline&amp;height=285&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=569&amp;originWidth=1178&amp;size=230936&amp;status=done&amp;style=none&amp;width=589" alt="image.png"><br><a name="61huc"></a></p><h2 id="什么是线程"><a class="markdownIt-Anchor" href="#什么是线程"></a> 什么是线程</h2><p>可以把线程理解为“轻量级进程”。 线程是一个基本的CPU执行单元， 也是程序执行流的最小单位。引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配 给进程的）。 线程则作为处理机的分配单元。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599220500105-74cc7e8c-9e0f-4c0b-809f-50fd3791c7df.png#align=left&amp;display=inline&amp;height=443&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=597&amp;originWidth=715&amp;size=135240&amp;status=done&amp;style=none&amp;width=531" alt="image.png"><br><a name="dmIpR"></a></p><h2 id="线程的实现方式"><a class="markdownIt-Anchor" href="#线程的实现方式"></a> 线程的实现方式</h2><p><a name="0fGPI"></a></p><h3 id="用户级线程user-level-thread-ult"><a class="markdownIt-Anchor" href="#用户级线程user-level-thread-ult"></a> 用户级线程（User-Level Thread, ULT）</h3><p>历史背景：早期的操作系统（如：早期Unix）只支持进程，不支持线程。当时的“线程”是由线程库实现的。<br>用户级线程由应用程序通过线程库实现。 所有的线程管理工作都由应用程序负责（包括线程切换）用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。 在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用户级线程对用户不透明，对操作系统透明） 可以这样理解，“用户级线程”就是“从用户视角看能看到的线程”。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599220570573-92d55ef6-369e-4dde-a1dd-0b84e65cdff2.png#align=left&amp;display=inline&amp;height=318&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=452&amp;originWidth=583&amp;size=45155&amp;status=done&amp;style=none&amp;width=410" alt="image.png"><br>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高<br>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。<br><a name="2SZBv"></a></p><h3 id="内核级线程kernel-level-thread-klt-又称内核支持的线程"><a class="markdownIt-Anchor" href="#内核级线程kernel-level-thread-klt-又称内核支持的线程"></a> 内核级线程（Kernel-Level Thread, KLT, 又称“内核支持的线程”）</h3><p>内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。可以这样理解，“内核级线程”就是“从操作系统内核视角看能看到的线程”。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599220616504-8cb14264-80b1-4899-8fa7-5731601fdf5e.png#align=left&amp;display=inline&amp;height=389&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=515&amp;originWidth=536&amp;size=62126&amp;status=done&amp;style=none&amp;width=405" alt="image.png"><br>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。<br>缺点：一个用户进程会占用多个内核级线程， 线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。<br><a name="WsFnX"></a></p><h3 id="组合使用"><a class="markdownIt-Anchor" href="#组合使用"></a> 组合使用</h3><p>在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将n个用户级线程映射到m 个内核级线程上（ n &gt;= m）<br>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。<br>例如：下图这个模型中，该进程 由两个内核级线程，三个用户级线程，在用户看来，这个进程中有三个线程。但即使该进程在一 个4核处理机的计算机上运行，也 最多只能被分配到两个核，最多 只能有两个用户线程并行执行。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599220697082-db115fd8-b05c-4376-b8cf-7caa3ad96b0d.png#align=left&amp;display=inline&amp;height=420&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=477&amp;originWidth=509&amp;size=64885&amp;status=done&amp;style=none&amp;width=448" alt="image.png"><br><a name="pgXNI"></a></p><h3 id="多线程模型"><a class="markdownIt-Anchor" href="#多线程模型"></a> 多线程模型</h3><p>在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引 出了“多线程模型”问题。<br><a name="k4e56"></a></p><h4 id="一对一模型"><a class="markdownIt-Anchor" href="#一对一模型"></a> 一对一模型</h4><p>一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599220901945-58ef57b1-88aa-4791-b798-e8e59988d990.png#align=left&amp;display=inline&amp;height=312&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=443&amp;originWidth=503&amp;size=57797&amp;status=done&amp;style=none&amp;width=354" alt="image.png"><br>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核 处理机上并行执行。<br>缺点：一个用户进程会占用多个内核级线程， 线程切换由操作系统内核完成，需要切换到 核心态，因此线程管理的成本高，开销大。<br><a name="sNeMC"></a></p><h4 id="多对一模型"><a class="markdownIt-Anchor" href="#多对一模型"></a> 多对一模型</h4><p>多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599220815877-5d10f90f-dca0-4e5b-9a25-d8966f2aa988.png#align=left&amp;display=inline&amp;height=326&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=442&amp;originWidth=492&amp;size=49131&amp;status=done&amp;style=none&amp;width=363" alt="image.png"><br>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高<br>缺点：当一个用户级线程被阻塞后，整个进 程都会被阻塞，并发度不高。多个线程不可 在多核处理机上并行运行<br><a name="ZFIg7"></a></p><h4 id="多对多模型"><a class="markdownIt-Anchor" href="#多对多模型"></a> 多对多模型</h4><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1599220978986-d9a2675b-81db-48ab-a7cf-2e71dc8b7f25.png#align=left&amp;display=inline&amp;height=349&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=456&amp;originWidth=492&amp;size=61608&amp;status=done&amp;style=none&amp;width=377" alt="image.png"><br>n 用户及线程映射到 m 个内核级线程（n &gt;= m）。每个用户进程对应 m 个 内核级线程。 克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined">Zhang Junjie</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://jie-blog.icu/posts/operating_system_process/">https://jie-blog.icu/posts/operating_system_process/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jie-blog.icu" target="_blank">Jieker's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5f4e5a0be7fabc7b" async="async"></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="./img/loading.gif" data-original="/img/wechat.png" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="./img/loading.gif" data-original="/img/alipay.jpg" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/operating_system_dispatch/"><img class="prev-cover" src="./img/loading.gif" data-original="https://jie-blog.icu/img/Operating_System/system.png" onerror='onerror=null,src="/img/404.jpg"'><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">操作系统之处理机调度</div></div></a></div><div class="next-post pull-right"><a href="/posts/operating_system_menu/"><img class="next-cover" src="./img/loading.gif" data-original="https://jie-blog.icu/img/Operating_System/system.png" onerror='onerror=null,src="/img/404.jpg"'><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统知识架构</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image:url(https://jie-blog.icu/img/Operating_System/system.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020<i id="heartbeat" class="fa fas fa-heartbeat"></i> Zhang Junjie</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">welcome to my <a href="https://jie-blog.icu/">blog</a>!</div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></head></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'XOcW2XseURBSH0ajeHVGv0iN-gzGzoHsz',
      appKey: 'iJPxPr2bJjhcx7m3zC49NyQC',
      placeholder: '記得留下你的暱稱和郵箱....可以快速收到回復',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,document.body.addEventListener("input",POWERMODE)</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  'meta[name=description]',
  '#config_change',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  $('script[data-pjax]').each(function () {
    $(this).parent().append($(this).remove())
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', '', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})


document.addEventListener('pjax:send', function () {
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  $(window).off('scroll')

  //reset readmode
  $('body').hasClass('read-mode') && $('body').removeClass('read-mode')

})</script></div><script>window.imageLazyLoadSetting={isSPA:!1,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=i;var e=n.imageLazyLoadSetting.isSPA,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)void 0,0<=(t=r[a].getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight+240||document.documentElement.clientHeight+240)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e()},n.src=i}()}i(),n.addEventListener("scroll",function(){var t,e;t=i,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html>