<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>cache包 | Jieker's Blog</title><meta name="description" content="cache包 Mybatis缓存使得每次数据库查询请求都会先经过缓存系统的过滤，只有在没有命中缓存的情况下才会去查询物理数据库。其中cache包就是Mybatis缓存能力的提供者，但是它只提供缓存能力，不涉及具体缓存功能的使用。   Java的引用 Java的引用一共有四种情况（JVM有说过）：  强引用是最传统的引用定义，是指在程序代码之中普遍存在的引用赋值，即类似：Object obj&#x3D;ne"><meta name="keywords" content="mybatis"><meta name="author" content="Zhang Junjie"><meta name="copyright" content="Zhang Junjie"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/url(https:/jie-blog.icu/img/Log.png)"><link rel="canonical" href="https://jie-blog.icu/posts/mybatis-cache/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta property="og:type" content="article"><meta property="og:title" content="cache包"><meta property="og:url" content="https://jie-blog.icu/posts/mybatis-cache/"><meta property="og:site_name" content="Jieker's Blog"><meta property="og:description" content="cache包 Mybatis缓存使得每次数据库查询请求都会先经过缓存系统的过滤，只有在没有命中缓存的情况下才会去查询物理数据库。其中cache包就是Mybatis缓存能力的提供者，但是它只提供缓存能力，不涉及具体缓存功能的使用。   Java的引用 Java的引用一共有四种情况（JVM有说过）：  强引用是最传统的引用定义，是指在程序代码之中普遍存在的引用赋值，即类似：Object obj&#x3D;ne"><meta property="og:image" content="https://jie-blog.icu/img/mybatis/mybatis.jpg"><meta property="article:published_time" content="2020-11-04T04:08:26.000Z"><meta property="article:modified_time" content="2020-11-04T04:15:30.044Z"><meta name="twitter:card" content="summary"><link rel="manifest" href="/image/pwa/manifest.json"><link rel="apple-touch-icon" sizes="180x180" href="/image/pwa/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/image/pwa/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/image/pwa/16.png"><link rel="mask-icon" href="/image/pwa/safari-pinned-tab.svg" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"",enable_page_level_ads:"true"})</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: {"limitCount":50,"languages":{"author":"Jieker: Zhang Junjie","link":"链接: ","source":"来源: Jieker's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
      const now = new Date()
      const expiryDay = ttl * 86400000
      const item = {
        value: value,
        expiry: now.getTime() + expiryDay,
      }
      localStorage.setItem(key, JSON.stringify(item))
    },
  
  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!0,isSidebar:!0,postUpdate:"2020-11-04 12:15:30"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}</style></noscript><script>var activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")},autoChangeMode="false",t=saveToLocal.get("theme");if("1"===autoChangeMode){var isDarkMode=window.matchMedia("(prefers-color-scheme: dark)").matches,isLightMode=window.matchMedia("(prefers-color-scheme: light)").matches,isNotSpecified=window.matchMedia("(prefers-color-scheme: no-preference)").matches,hasNoSupport=!isDarkMode&&!isLightMode&&!isNotSpecified;if(void 0===t){if(isLightMode)activateLightMode();else if(isDarkMode)activateDarkMode();else if(isNotSpecified||hasNoSupport){var now=new Date,hour=now.getHours(),isNight=hour<=6||18<=hour;isNight?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())})}else"light"===t?activateLightMode():activateDarkMode()}else"2"===autoChangeMode?(isNight=(hour=(now=new Date).getHours())<=6||18<=hour,void 0===t?isNight?activateDarkMode():activateLightMode():"light"===t?activateLightMode():activateDarkMode()):"dark"===t?activateDarkMode():"light"===t&&activateLightMode()</script><script src="/js/daovoice.js"></script><link rel="stylesheet" href="footer.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/atom.xml" title="Jieker's Blog" type="application/atom+xml"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="./img/loading.gif" data-original="/img/picture.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">64</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">12</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">16</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i> <span>Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i> <span>Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i> <span>Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i> <span>About</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#cache%E5%8C%85"><span class="toc-number">1.</span> <span class="toc-text">cache包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">Java的引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#referencequeue"><span class="toc-number">2.1.</span> <span class="toc-text">ReferenceQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="toc-number">2.1.1.</span> <span class="toc-text">代码演示：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90"><span class="toc-number">2.1.2.</span> <span class="toc-text">结果分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cache%E5%8C%85%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">cache包结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cache%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.1.</span> <span class="toc-text">Cache接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%94%AE"><span class="toc-number">4.</span> <span class="toc-text">缓存键</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%94%AE%E5%8E%9F%E7%90%86"><span class="toc-number">4.1.</span> <span class="toc-text">缓存键原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%94%AE%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-number">4.2.</span> <span class="toc-text">缓存键的生成</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">5.</span> <span class="toc-text">缓存的实现类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">缓存装饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%BF%AE%E9%A5%B0%E5%99%A8"><span class="toc-number">6.1.</span> <span class="toc-text">同步修饰器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E4%BF%AE%E9%A5%B0%E5%99%A8"><span class="toc-number">6.2.</span> <span class="toc-text">日志修饰器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%85%E7%90%86%E4%BF%AE%E9%A5%B0%E5%99%A8"><span class="toc-number">6.3.</span> <span class="toc-text">清理修饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fifocache"><span class="toc-number">6.3.1.</span> <span class="toc-text">FifoCache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lrucache"><span class="toc-number">6.3.2.</span> <span class="toc-text">LruCache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weakcache"><span class="toc-number">6.3.3.</span> <span class="toc-text">WeakCache</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%BF%AE%E9%A5%B0%E5%99%A8"><span class="toc-number">6.4.</span> <span class="toc-text">阻塞修饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#blockingcache"><span class="toc-number">6.4.1.</span> <span class="toc-text">BlockingCache</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E6%B8%85%E7%90%86%E4%BF%AE%E9%A5%B0%E5%99%A8"><span class="toc-number">6.5.</span> <span class="toc-text">定时清理修饰器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E4%BF%AE%E9%A5%B0%E5%99%A8"><span class="toc-number">6.6.</span> <span class="toc-text">序列化修饰器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">7.</span> <span class="toc-text">缓存的创建</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%BC%93%E5%AD%98"><span class="toc-number">8.</span> <span class="toc-text">事务缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#transactionalcache"><span class="toc-number">8.1.</span> <span class="toc-text">TransactionalCache</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%AF%BB%E5%8F%96%E5%92%8C%E5%AD%98%E5%85%A5"><span class="toc-number">8.1.1.</span> <span class="toc-text">缓存读取和存入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E5%9B%9E%E6%BB%9A"><span class="toc-number">8.1.2.</span> <span class="toc-text">事务提交回滚</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4"><span class="toc-number">8.1.2.1.</span> <span class="toc-text">事务提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A"><span class="toc-number">8.1.2.2.</span> <span class="toc-text">事务回滚</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#entriesmissedincache%E4%BD%9C%E7%94%A8%E5%88%86%E6%9E%90"><span class="toc-number">8.1.2.3.</span> <span class="toc-text">entriesMissedInCache作用分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#transactionalcachemanager"><span class="toc-number">8.2.</span> <span class="toc-text">TransactionalCacheManager</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mybatis%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">9.</span> <span class="toc-text">Mybatis缓存机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">9.1.</span> <span class="toc-text">一级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#baseexecutor"><span class="toc-number">9.1.1.</span> <span class="toc-text">BaseExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">9.1.1.1.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">9.2.</span> <span class="toc-text">二级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cachingexecutor"><span class="toc-number">9.2.1.</span> <span class="toc-text">CachingExecutor</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image:url(https://jie-blog.icu/img/mybatis/mybatis.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Jieker's Blog</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i> <span>Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i> <span>Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i> <span>Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i> <span>About</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">cache包</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-04T04:08:26.000Z" title="发表于 2020-11-04 12:08:26">2020-11-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-11-04T04:15:30.044Z" title="更新于 2020-11-04 12:15:30">2020-11-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/mybatis/">mybatis</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/mybatis/%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C%E5%8C%85/">核心操作包</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="cache包"><a class="markdownIt-Anchor" href="#cache包"></a> cache包</h1><p>Mybatis缓存使得每次数据库查询请求都会先经过缓存系统的过滤，只有在没有命中缓存的情况下才会去查询物理数据库。其中cache包就是Mybatis缓存能力的提供者，但是它只提供缓存能力，不涉及具体缓存功能的使用。<br><a name="vbW6J"></a></p><h1 id="java的引用"><a class="markdownIt-Anchor" href="#java的引用"></a> Java的引用</h1><p>Java的引用一共有四种情况（JVM有说过）：</p><ul><li>强引用是最传统的引用定义，是指在程序代码之中普遍存在的引用赋值，即类似：<code>Object obj=new Object()</code>这种引用关系。只要强引用还在，GC就不会回收掉被引用的对象。</li><li>软引用是用来描述一些还有用，但非必须的对象。只要被软引用关联的对象，在系统发生内存溢出异常之前，都会被列入回收范围之中二次回收，如果此次回收还没有足够的内存才会抛出异常。</li><li>弱引用是用来描述非必须的对象，被弱引用关联的对象只能生存到下一次收集发生位置。当垃圾回收工作时，无论内存是否够用，该引用都会被回收。</li><li>虚引用又被称为“幽灵引用”或者“幻影引用”。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来构建一个对象实例。该引用的存在就是为了再回收时收到一个系统通知。<br><a name="aOpzw"></a></li></ul><h2 id="referencequeue"><a class="markdownIt-Anchor" href="#referencequeue"></a> ReferenceQueue</h2><p>ReferenceQueue本身是一个列表，可以在创建软引用或者弱引用的包装对象时传入该列表。当JVM回收被包装对象时会将其包装类加入ReferenceQueue中。<br><a name="Hpsgn"></a></p><h3 id="代码演示"><a class="markdownIt-Anchor" href="#代码演示"></a> 代码演示：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        simpleRef();</span><br><span class="line">        refWithReferenceQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simpleRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过等号直接建立的引用都是强引用</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过SoftReference建立的引用是软引用</span></span><br><span class="line">        SoftReference&lt;User&gt; softRefUser =<span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> User());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过WeakReference建立的引用是弱引用</span></span><br><span class="line">        WeakReference&lt;User&gt; weakRefUser = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> User());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">refWithReferenceQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建ReferenceQueue</span></span><br><span class="line">        ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来存储弱引用的目标对象</span></span><br><span class="line">        List&lt;WeakReference&gt; weakRefUserList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 创建大量的弱引用对象，交给weakRefUserList引用</span></span><br><span class="line">        <span class="comment">// 创建这么多的目的是为了让内存空间紧张</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ; i&lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建弱引用对象，并在此过程中传入ReferenceQueue</span></span><br><span class="line">            WeakReference&lt;User&gt; weakReference = <span class="keyword">new</span> WeakReference(<span class="keyword">new</span> User(Math.round(Math.random() * <span class="number">1000</span>)),referenceQueue);</span><br><span class="line">            <span class="comment">// 引用弱引用对象</span></span><br><span class="line">            weakRefUserList.add(weakReference);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakReference weakReference;</span><br><span class="line">        Integer count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理被回收的弱引用</span></span><br><span class="line">        <span class="keyword">while</span> ((weakReference = (WeakReference) referenceQueue.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 虽然弱引用存在，但是引用的目标对象已经为空</span></span><br><span class="line">            System.out.println(<span class="string">&quot;JVM 清理了：&quot;</span> + weakReference + <span class="string">&quot;, 从WeakReference中取出对象值为：&quot;</span> + weakReference.get());</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 被回收的弱引用总数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;weakReference中的元素数目为：&quot;</span> + count);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在弱引用的目标对象不被清理时，可以引用到目标对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;在不被清理的情况下，可以从WeakReference中取出对象值为：&quot;</span> +</span><br><span class="line">                <span class="keyword">new</span> WeakReference(<span class="keyword">new</span> User(Math.round(Math.random() * <span class="number">1000</span>)),referenceQueue).get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1603001666822-51129404-45d9-4486-88d5-ceb7b8f0c4d0.png#align=left&amp;display=inline&amp;height=148&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=295&amp;originWidth=1123&amp;size=371152&amp;status=done&amp;style=none&amp;width=561.5" alt="image.png"><br><a name="edHRI"></a></p><h3 id="结果分析"><a class="markdownIt-Anchor" href="#结果分析"></a> 结果分析</h3><p>由于User对象已经被清理了，而包装对象却被保留在了ReferenceQueue中，因此可以取出weakReference但是对象的值却为null<br><a name="pIwaY"></a></p><h1 id="cache包结构"><a class="markdownIt-Anchor" href="#cache包结构"></a> cache包结构</h1><p>cache包是典型的装饰器模式的应用案例，在imple包中存放了实现类，在decorators包中存放了众多的修饰器类。而Cache接口是实现类和装饰器类的共同的接口。其内部类图如下：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1603001990731-71819f7a-8ac0-404c-aa27-fad0988f9c1d.png#align=left&amp;display=inline&amp;height=342&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=684&amp;originWidth=993&amp;size=1165110&amp;status=done&amp;style=none&amp;width=496.5" alt="image.png"><br><a name="tN1Jm"></a></p><h2 id="cache接口"><a class="markdownIt-Anchor" href="#cache接口"></a> Cache接口</h2><p>该接口源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取缓存Id</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 向缓存写一条数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 向缓存中读取一条数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Object <span class="title">getObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 向缓存中删除一条数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Object <span class="title">removeObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 清空缓存</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取缓存数据数目</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取读写锁</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="bl2zh"></a></p><h1 id="缓存键"><a class="markdownIt-Anchor" href="#缓存键"></a> 缓存键</h1><p>Mybatis每秒过滤很多条数据库查询语句，这使Mybatis的缓存键要求就变得高，其要满足以下几点：</p><ul><li>无碰撞：必须保障两条不同的查询请求生成的键不同，这是最重要的也是必须要满足的要求，否则会导致命中错误的缓存，返回错误的结果。</li><li>高效比较：每次缓存查询操作都可能会引发键之间的多次比较，因此该操作必须是高效的。</li><li>高效生成：每次缓存查询和写入操作前都要生成缓存的键，因此该操作也是要高效的。<br><a name="fS0Iv"></a></li></ul><h2 id="缓存键原理"><a class="markdownIt-Anchor" href="#缓存键原理"></a> 缓存键原理</h2><p>Mybatis设计了CacheKey来作为缓存键，其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 乘数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> multiplier;</span><br><span class="line"><span class="comment">// 哈希值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hashcode;</span><br><span class="line"><span class="comment">// 求和校验值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> checksum;</span><br><span class="line"><span class="comment">// 更新次数  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;  </span><br><span class="line"><span class="comment">// 历史更新  </span></span><br><span class="line"><span class="keyword">private</span> List&lt;Object&gt; updateList;</span><br></pre></td></tr></table></figure><p>其更新操作源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> baseHashCode = object == <span class="keyword">null</span> ? <span class="number">1</span> : ArrayUtil.hashCode(object);</span><br><span class="line"></span><br><span class="line">  count++;</span><br><span class="line">  checksum += baseHashCode;</span><br><span class="line">  baseHashCode *= count;</span><br><span class="line"></span><br><span class="line">  hashcode = multiplier * hashcode + baseHashCode;</span><br><span class="line"></span><br><span class="line">  updateList.add(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，其比较方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 如果地址相等，那证明是同一个对象</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span> == object) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果不是CacheKey那一定不相等</span></span><br><span class="line">   <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> CacheKey)) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> CacheKey cacheKey = (CacheKey) object;</span><br><span class="line"><span class="comment">// 依次进行值比较</span></span><br><span class="line">   <span class="keyword">if</span> (hashcode != cacheKey.hashcode) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (checksum != cacheKey.checksum) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (count != cacheKey.count) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 查看历史是否有碰撞</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; updateList.size(); i++) &#123;</span><br><span class="line">     Object thisObject = updateList.get(i);</span><br><span class="line">     Object thatObject = cacheKey.updateList.get(i);</span><br><span class="line">     <span class="keyword">if</span> (!ArrayUtil.equals(thisObject, thatObject)) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>此外，该类还有一个属性如下：<br><code>public static final CacheKey NULL_CACHE_KEY = new NullCacheKey();</code><br>其代表空键，其构造方法调用的是CacheKey的默认构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.hashcode = DEFAULT_HASHCODE;</span><br><span class="line">  <span class="keyword">this</span>.multiplier = DEFAULT_MULTIPLYER;</span><br><span class="line">  <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.updateList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样保证了不会引发空指针异常。<br><a name="ByV8w"></a></p><h2 id="缓存键的生成"><a class="markdownIt-Anchor" href="#缓存键的生成"></a> 缓存键的生成</h2><p>查询时会根据当前查询条件生成一个对应的CacheKey，以BaseExecutor的query方法为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">  <span class="comment">// 生成缓存键</span></span><br><span class="line">  CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">  <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createCacheKey源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建CacheKey，将所有查询参数依次更新写入</span></span><br><span class="line">  CacheKey cacheKey = <span class="keyword">new</span> CacheKey();</span><br><span class="line">  cacheKey.update(ms.getId());</span><br><span class="line">  cacheKey.update(rowBounds.getOffset());</span><br><span class="line">  cacheKey.update(rowBounds.getLimit());</span><br><span class="line">  cacheKey.update(boundSql.getSql());</span><br><span class="line">  List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">  <span class="comment">// mimic DefaultParameterHandler logic</span></span><br><span class="line">  <span class="keyword">for</span> (ParameterMapping parameterMapping : parameterMappings) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">      Object value;</span><br><span class="line">      String propertyName = parameterMapping.getProperty();</span><br><span class="line">      <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">        value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">        value = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">        value = parameterObject;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">        value = metaObject.getValue(propertyName);</span><br><span class="line">      &#125;</span><br><span class="line">      cacheKey.update(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (configuration.getEnvironment() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// issue #176</span></span><br><span class="line">    cacheKey.update(configuration.getEnvironment().getId());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cacheKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的CacheKey对象中包含了查询的所有信息，包括查询语句的id、查询的翻页限制、数据总量、完整的SQL语句，这些信息保证了两次查询的一致性，可以同equals就可以判断是否一致。<br><a name="YIpA6"></a></p><h1 id="缓存的实现类"><a class="markdownIt-Anchor" href="#缓存的实现类"></a> 缓存的实现类</h1><p>cache接口的唯一实现类PerpetualCache，其内部实现十分简单，只有两个属性而已：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存的ID </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line"><span class="comment">// 存储要缓存的数据</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;Object, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p><a name="dWumK"></a></p><h1 id="缓存装饰器"><a class="markdownIt-Anchor" href="#缓存装饰器"></a> 缓存装饰器</h1><p>虽然Cache的实现类很简单，但是其可以通过众多的包装类增加很多功能，decorators包中的包装类可以分为如下几大类：</p><ul><li>同步装饰器：为缓存增加同步功能，如SynchronizedCache类。</li><li>日志装饰器：为缓存增加日志功能，如LoggingCache类。</li><li>清理装饰类：为缓存中的数据增加清理功能，如FifoCache、LruCache、WeakCache、SoftCache类。</li><li>阻塞装饰类：为缓存增加阻塞功能，如BlockingCache类。</li><li>定时清理装饰类：为缓存增加定时刷新功能，如ScheduledCache类。</li><li>序列化修饰类：为缓存增加序列化功能，如SerializedCache类。</li><li>事务修饰类：用于支持事务操作的装饰器，如TransactionalCache类。<br><a name="Q5RZM"></a></li></ul><h2 id="同步修饰器"><a class="markdownIt-Anchor" href="#同步修饰器"></a> 同步修饰器</h2><p>并发下可能会出现多个线程同时访问一个缓存的情况，Mybatis将保证缓存多线程安全这项工作交给了SynchronizedCache修饰器来完成，其内部实现十分简单，直接在方法外围加上了Synchronized关键词（实现简单，不做展示）。<br><a name="lFl3W"></a></p><h2 id="日志修饰器"><a class="markdownIt-Anchor" href="#日志修饰器"></a> 日志修饰器</h2><p>日志修饰器可以为缓存增加日志统计的功能，而需要统计的数据主要是缓存命中率，开发者可以依据这些指标来设置合适的缓存大小。<br>日志修饰器的实现也非常简单，即在查询的时候记录查询总次数和命中次数即可，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  requests++;</span><br><span class="line">  <span class="keyword">final</span> Object value = delegate.getObject(key);</span><br><span class="line">  <span class="comment">// 命中缓存</span></span><br><span class="line">  <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 命中次数+1</span></span><br><span class="line">    hits++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;Cache Hit Ratio [&quot;</span> + getId() + <span class="string">&quot;]: &quot;</span> + getHitRatio());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="4VSpt"></a></p><h2 id="清理修饰器"><a class="markdownIt-Anchor" href="#清理修饰器"></a> 清理修饰器</h2><p>缓存是以消耗内存空间为代价的，缓存空间总是有限的，因此可以为缓存增加合适的清理策略来最大化的利用缓存空间。<br>清理修饰器共有四种，对应着四种不同的策略：<br><a name="nQYM3"></a></p><h3 id="fifocache"><a class="markdownIt-Anchor" href="#fifocache"></a> FifoCache</h3><p>该类采用先进先出策略来清理缓存，其内部采用keyList属性存储了缓存数据的写入顺序，并且使用size属性存储了缓存数据的数量限制。当缓存中的数据达到限制时，FifoCache装饰器会将先放入缓存中的数据删除。其属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被修饰对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line"><span class="comment">// 按照写入顺序保存了缓存数据的键</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;Object&gt; keyList;</span><br><span class="line"><span class="comment">// 缓存空间大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>向缓存存入数据时会先判断数据数量是否已经超过了限制，如果超过了会对先写入的数据进行删除，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">  cycleKeyList(key);</span><br><span class="line">  delegate.putObject(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cycleKeyList</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  keyList.addLast(key);</span><br><span class="line">  <span class="keyword">if</span> (keyList.size() &gt; size) &#123;</span><br><span class="line">    Object oldestKey = keyList.removeFirst();</span><br><span class="line">    delegate.removeObject(oldestKey);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="bsBJ8"></a></p><h3 id="lrucache"><a class="markdownIt-Anchor" href="#lrucache"></a> LruCache</h3><p>近期最少使用算法，该算法会在缓存数据数量达到设置上限时将近期未使用的数据删除。其属性列表如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被装饰对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line"><span class="comment">// 使用LinkedHashMap来保存缓存数据的键</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;Object, Object&gt; keyMap;</span><br><span class="line"><span class="comment">// 最近最少使用的数据的键</span></span><br><span class="line"><span class="keyword">private</span> Object eldestKey;</span><br></pre></td></tr></table></figure><p>其构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(Cache delegate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">  setSize(<span class="number">1024</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了setSize方法来设置缓存空间的大小，setSize源码如下：.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">  keyMap = <span class="keyword">new</span> LinkedHashMap&lt;Object, Object&gt;(size, .<span class="number">75F</span>, <span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4267176411845948333L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Object, Object&gt; eldest)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> tooBig = size() &gt; size;</span><br><span class="line">      <span class="keyword">if</span> (tooBig) &#123;</span><br><span class="line">        eldestKey = eldest.getKey();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> tooBig;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里重写了LinkedHashMap的removeEldestEntry方法，该方法在插入数据后会自动触发，该方法实现了长度判断，如果溢出会将eldest的key放入到eldestKey。<br>此外，其还做了两件事：</p><ul><li>每次进行缓存查询时更新keyMap中键值的排序，将当前查询到的键值排序到最前面。</li><li>每次进行缓存写入操作时向keyMap写入新的键，并且在当前缓存中数据量超过设置的数据量时删除最久未访问的数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 查询操作</span></span><br><span class="line">  delegate.putObject(key, value);</span><br><span class="line">  <span class="comment">// 将key值放入keyMap，根据空间情况决定是否删除数据</span></span><br><span class="line">  cycleKeyList(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 触及一下当前被访问的键，说明其被访问了</span></span><br><span class="line">  keyMap.get(key);</span><br><span class="line">  <span class="comment">// 真正的查询操作</span></span><br><span class="line">  <span class="keyword">return</span> delegate.getObject(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cycleKeyList</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  keyMap.put(key, key);</span><br><span class="line">  <span class="keyword">if</span> (eldestKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">    delegate.removeObject(eldestKey);</span><br><span class="line">    eldestKey = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从cycleKeyList方法中可以看出LinkedHashMap中存储的键和值都是key，这是因为其目的仅仅是用来保存缓存数据被访问的情况而不是参与具体数据的保存。<br><a name="0HEMg"></a></p><h3 id="weakcache"><a class="markdownIt-Anchor" href="#weakcache"></a> WeakCache</h3><p>WeakCache装饰器通过将缓存数据包装成弱引用的数据，从而使得JVM可以清理掉缓存数据。其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强引用对象列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;Object&gt; hardLinksToAvoidGarbageCollection;</span><br><span class="line"><span class="comment">// 弱引用对象列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queueOfGarbageCollectedEntries;</span><br><span class="line"><span class="comment">// 被装饰对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line"><span class="comment">// 强引用对象的数目限制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> numberOfHardLinks;</span><br></pre></td></tr></table></figure><p>放入数据源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 清除垃圾回收队列中的元素</span></span><br><span class="line">  removeGarbageCollectedItems();</span><br><span class="line">  <span class="comment">// 向被装饰对象中放入的值是弱引用的句柄</span></span><br><span class="line">  delegate.putObject(key, <span class="keyword">new</span> WeakEntry(key, value, queueOfGarbageCollectedEntries));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>removeGarbageCollectedItems：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeGarbageCollectedItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  WeakEntry sv;</span><br><span class="line">  <span class="comment">// 轮询该垃圾回收器队列</span></span><br><span class="line">  <span class="keyword">while</span> ((sv = (WeakEntry) queueOfGarbageCollectedEntries.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 将该队列中涉及的键删除</span></span><br><span class="line">    delegate.removeObject(sv.key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取出缓存也会是数据的弱引用包装类。数据本身可能已经被JVM清理掉了，因此还要对取出做出判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Object result = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 假定被修饰对象只被该修饰器完全控制</span></span><br><span class="line">  WeakReference&lt;Object&gt; weakReference = (WeakReference&lt;Object&gt;) delegate.getObject(key);</span><br><span class="line">  <span class="comment">// 读取到弱引用句柄</span></span><br><span class="line">  <span class="keyword">if</span> (weakReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取到弱引用对象</span></span><br><span class="line">    result = weakReference.get();</span><br><span class="line">    <span class="comment">// 如果为空</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 清理弱引用对象</span></span><br><span class="line">      delegate.removeObject(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 将缓存数据写入强引用列表</span></span><br><span class="line">      hardLinksToAvoidGarbageCollection.addFirst(result);</span><br><span class="line">      <span class="comment">// 如果超出列表</span></span><br><span class="line">      <span class="keyword">if</span> (hardLinksToAvoidGarbageCollection.size() &gt; numberOfHardLinks) &#123;</span><br><span class="line">        <span class="comment">// 删除最后一个元素</span></span><br><span class="line">        hardLinksToAvoidGarbageCollection.removeLast();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止键值回收后无法删除，因此定义了内部类WeakEntry来为每一个弱引用设置一个强引用属性，来作为唯一标识符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakEntry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object key;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">WeakEntry</span><span class="params">(Object key, Object value, ReferenceQueue&lt;Object&gt; garbageCollectionQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(value, garbageCollectionQueue);</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="fvjKz"></a></p><h2 id="阻塞修饰器"><a class="markdownIt-Anchor" href="#阻塞修饰器"></a> 阻塞修饰器</h2><p>如果在数据库查询尚未结束时，Mybatis又收到一条完全相同的数据库查询请求，可以按照下述方法处理：<br>虽然缓存中没有对应的缓存结果，但是已经向数据库发起过一次请求，因此缓存应该先阻塞第二次查询请求。等待数据库查询结束后，将数据库的查询结果返回给第二次查询请求即可。<br><a name="zkmk7"></a></p><h3 id="blockingcache"><a class="markdownIt-Anchor" href="#blockingcache"></a> BlockingCache</h3><p>该类就是为缓存提供上述功能的，阻塞修饰器工作示意图如下：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1603108895033-555dc925-74d5-4b58-9005-1c9a0e3c82a4.png#align=left&amp;display=inline&amp;height=266&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=531&amp;originWidth=1122&amp;size=933136&amp;status=done&amp;style=none&amp;width=561" alt="image.png"><br>在使用阻塞修饰器装饰缓存后，缓存在收到多条相同的查询请求时会暂时阻塞住后面的查询，等待数据库结果返回时将所有请求一并返回。<br>该类的内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁时的运行等待时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line"><span class="comment">// 被装饰对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line"><span class="comment">// 锁的映射表。键为缓存记录的键，值为对应的锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Object, ReentrantLock&gt; locks;</span><br></pre></td></tr></table></figure><p>观察其方法得出，其对每一个记录都有一个对应的锁，而不是锁住整个缓存。与加锁相关的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出指定键的锁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ReentrantLock <span class="title">getLockForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> locks.computeIfAbsent(key, k -&gt; <span class="keyword">new</span> ReentrantLock());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取某个键的锁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">acquireLock</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 找出指定键的锁</span></span><br><span class="line">  Lock lock = getLockForKey(key);</span><br><span class="line">  <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">boolean</span> acquired = lock.tryLock(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">      <span class="keyword">if</span> (!acquired) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;Couldn&#x27;t get a lock in &quot;</span> + timeout + <span class="string">&quot; for the key &quot;</span> +  key + <span class="string">&quot; at the cache &quot;</span> + delegate.getId());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;Got interrupted while trying to acquire lock for key &quot;</span> + key, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 锁住</span></span><br><span class="line">    lock.lock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放某个对象的锁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 找出指定键的锁</span></span><br><span class="line">  ReentrantLock lock = locks.get(key);</span><br><span class="line">  <span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在读取缓存中的数据前需要获取该数据对应的锁，如果从缓存中获取到了对应的数据，则立即释放该锁；如果没有获取到对应的数据，则意味着接下来会进行数据库查询，直到数据库查询结束向缓存中写入该数据才会释放锁。相关源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向缓存中写入一条消息</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 向缓存中放入数据</span></span><br><span class="line">    delegate.putObject(key, value);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    releaseLock(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从缓存读消息</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取锁</span></span><br><span class="line">  acquireLock(key);</span><br><span class="line">  <span class="comment">// 读取结果</span></span><br><span class="line">  Object value = delegate.getObject(key);</span><br><span class="line">  <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 读取到结果后释放锁</span></span><br><span class="line">    releaseLock(key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果没有读取到数据，则返回null，准备进行数据库操作，等到写入缓存再释放锁</span></span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="lE41J"></a></p><h2 id="定时清理修饰器"><a class="markdownIt-Anchor" href="#定时清理修饰器"></a> 定时清理修饰器</h2><p>当调用clear方法时会清理缓存中的数据，但是这个操作不是自动执行的。<br>SecheduledCache修饰过的Cache可以按照一定的间隔时间来清理缓存中的数据。其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被修饰的对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line"><span class="comment">// 清理的间隔时间</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> clearInterval;</span><br><span class="line"><span class="comment">// 上次清理的时刻</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> lastClear;</span><br></pre></td></tr></table></figure><p>核心方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">clearWhenStale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (System.currentTimeMillis() - lastClear &gt; clearInterval) &#123;</span><br><span class="line">    clear();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  lastClear = System.currentTimeMillis();</span><br><span class="line">  delegate.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clearWhenStale方法会在getSize、getObject、putObject、removeObject调用时调用，如果没有被调用，那么clearWhenStale也不会被触发，也不会清理缓存。<br>这种非实时的方法节约了资源，也不会造成太大的误差。<br><a name="v1jsr"></a></p><h2 id="序列化修饰器"><a class="markdownIt-Anchor" href="#序列化修饰器"></a> 序列化修饰器</h2><p>对象放入缓存的是对象的引用，也就是说如果修改了一方，另一方也会发生变化。<br>为了保证外部读取缓存中的对象时每次读取的都是一个全新的拷贝而不是引用SerializedCache就诞生了。使用了该类后，每次向缓存写入数据实际上写入的就是对象的序列化串；每次读取数据时，实际上读取的就是序列化串反序列化后的值。<br>注意：被序列化的对象也要实现序列化。<br>核心原码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入一条数据</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object object)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存必须是可以序列化的</span></span><br><span class="line">  <span class="keyword">if</span> (object == <span class="keyword">null</span> || object <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">    delegate.putObject(key, serialize((Serializable) object));</span><br><span class="line">  <span class="comment">// 如果不可序列化</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;SharedCache failed to make a copy of a non-serializable object: &quot;</span> + object);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取一条数据</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Object object = delegate.getObject(key);</span><br><span class="line">  <span class="comment">// 反序列化后返回</span></span><br><span class="line">  <span class="keyword">return</span> object == <span class="keyword">null</span> ? <span class="keyword">null</span> : deserialize((<span class="keyword">byte</span>[]) object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="R2Pyk"></a></p><h1 id="缓存的创建"><a class="markdownIt-Anchor" href="#缓存的创建"></a> 缓存的创建</h1><p>组件缓存的过程就是根据需求为缓存的基本实现增加各种装饰的过程，该过程在CacheBuilder完成，其入口方法是build，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Cache <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设置缓存的默认实现、默认装饰器</span></span><br><span class="line">  setDefaultImplementations();</span><br><span class="line">  <span class="comment">// 创建默认缓存</span></span><br><span class="line">  Cache cache = newBaseCacheInstance(implementation, id);</span><br><span class="line">  <span class="comment">// 设置缓存属性</span></span><br><span class="line">  setCacheProperties(cache);</span><br><span class="line">  <span class="comment">// 缓存的实现类是PerpetualCache而非用户自定义的实现类</span></span><br><span class="line">  <span class="keyword">if</span> (PerpetualCache.class.equals(cache.getClass())) &#123;</span><br><span class="line">    <span class="comment">// 逐级嵌套自定义的装饰器</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;? extends Cache&gt; decorator : decorators) &#123;</span><br><span class="line">      <span class="comment">// 生成的装饰器实例并装配。</span></span><br><span class="line">      cache = newCacheDecoratorInstance(decorator, cache);</span><br><span class="line">      <span class="comment">// 为装饰器设置属性</span></span><br><span class="line">      setCacheProperties(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为缓存增加标准装饰器</span></span><br><span class="line">    cache = setStandardDecorators(cache);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!LoggingCache.class.isAssignableFrom(cache.getClass())) &#123;</span><br><span class="line">    <span class="comment">// 增加日志装饰器</span></span><br><span class="line">    cache = <span class="keyword">new</span> LoggingCache(cache);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果外部没有指定实现类的话，缓存默认的实现类是PerpetualCache类，默认的清理装饰器是LruCache，详见setDefaultImplementations源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setDefaultImplementations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (implementation == <span class="keyword">null</span>) &#123;</span><br><span class="line">    implementation = PerpetualCache.class;</span><br><span class="line">    <span class="keyword">if</span> (decorators.isEmpty()) &#123;</span><br><span class="line">      decorators.add(LruCache.class);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这里只是简单地放入，并没实际的装配。<br>接下来的newCacheDecoratorInstance生成缓存的实现，并主机包装用户自定义的装饰器。最后会通过setStandardDecorators方法增加标准的装饰器。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Cache <span class="title">setStandardDecorators</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    MetaObject metaCache = SystemMetaObject.forObject(cache);</span><br><span class="line">    <span class="comment">// 设置缓存大小</span></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="keyword">null</span> &amp;&amp; metaCache.hasSetter(<span class="string">&quot;size&quot;</span>)) &#123;</span><br><span class="line">      metaCache.setValue(<span class="string">&quot;size&quot;</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果定义了清理间隔，则使用清理装饰器装饰缓存</span></span><br><span class="line">    <span class="keyword">if</span> (clearInterval != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cache = <span class="keyword">new</span> ScheduledCache(cache);</span><br><span class="line">      ((ScheduledCache) cache).setClearInterval(clearInterval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果允许读写，则用序列化装饰器</span></span><br><span class="line">    <span class="keyword">if</span> (readWrite) &#123;</span><br><span class="line">      cache = <span class="keyword">new</span> SerializedCache(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用日志装饰器</span></span><br><span class="line">    cache = <span class="keyword">new</span> LoggingCache(cache);</span><br><span class="line">    <span class="comment">// 使用同步装饰器</span></span><br><span class="line">    cache = <span class="keyword">new</span> SynchronizedCache(cache);</span><br><span class="line">    <span class="comment">// 如果被阻塞了则使用阻塞装饰器</span></span><br><span class="line">    <span class="keyword">if</span> (blocking) &#123;</span><br><span class="line">      cache = <span class="keyword">new</span> BlockingCache(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回被装饰的结果</span></span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;Error building standard cache decorators.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="9sv6c"></a></p><h1 id="事务缓存"><a class="markdownIt-Anchor" href="#事务缓存"></a> 事务缓存</h1><p>事务不仅可以指代封装在一起的多条语句，还可以用来指代一条普通的语句。如果没有显式的声明事务，那么一条语句本身就是一个事务。<br>如果事务中的语句进行数据库查询操作后直接放入了缓存，如果该事务进行了回滚，那么缓存中的数据就可能和数据库产生不一致。因此TransactionalCache包装类使用entriesToAddOnCommit属性将事务中产生的数据暂时保存起来，事务操作中产生的数据需要在事务提交时写入缓存，而在事务回滚时直接销毁。<br>TransactionalCache类也支持将缓存范围限定在事务以内，只需要将clearOnCommit设定为true即可。只要事务结束就会直接将暂时保存的数据销毁掉，而不是写入缓存。<br><a name="lT2iQ"></a></p><h2 id="transactionalcache"><a class="markdownIt-Anchor" href="#transactionalcache"></a> TransactionalCache</h2><p>该类的内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被装饰的对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line"><span class="comment">// 事务提交后是否直接缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> clearOnCommit;</span><br><span class="line"><span class="comment">// 事务提交时需要写入缓存的数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Object&gt; entriesToAddOnCommit;</span><br><span class="line"><span class="comment">// 缓存查询未命中的数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Object&gt; entriesMissedInCache;</span><br></pre></td></tr></table></figure><p><a name="Ji3ax"></a></p><h3 id="缓存读取和存入"><a class="markdownIt-Anchor" href="#缓存读取和存入"></a> 缓存读取和存入</h3><p>读取缓存时是真正从缓存中获取的，而写入数据却只是暂存在TransactionalCache内部。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从缓存中读取数据</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中读取数据</span></span><br><span class="line">    Object object = delegate.getObject(key);</span><br><span class="line">    <span class="comment">// 缓存未命中</span></span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 记录未命中数据</span></span><br><span class="line">      entriesMissedInCache.add(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果开启了缓存范围限定</span></span><br><span class="line">    <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 返回查询结果</span></span><br><span class="line">      <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 写入一条数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object object)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 放入到entriesToAddOnCommit中暂存</span></span><br><span class="line">    entriesToAddOnCommit.put(key, object);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><a name="eko5x"></a></p><h3 id="事务提交回滚"><a class="markdownIt-Anchor" href="#事务提交回滚"></a> 事务提交回滚</h3><p><a name="45xsj"></a></p><h4 id="事务提交"><a class="markdownIt-Anchor" href="#事务提交"></a> 事务提交</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事务提交</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果设置了缓存范围限定</span></span><br><span class="line">    <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">      <span class="comment">// 清理缓存</span></span><br><span class="line">      delegate.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将未写入缓存的数据写入缓存</span></span><br><span class="line">    flushPendingEntries();</span><br><span class="line">    <span class="comment">// 清理环境</span></span><br><span class="line">    reset();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>flushPendingEntries源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushPendingEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将entriesToAddOnCommit中的数据写入缓存</span></span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;</span><br><span class="line">    delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将entriesToAddOnCommit中的数据写入缓存</span></span><br><span class="line">  <span class="keyword">for</span> (Object entry : entriesMissedInCache) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!entriesToAddOnCommit.containsKey(entry)) &#123;</span><br><span class="line">      delegate.putObject(entry, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reset源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  clearOnCommit = <span class="keyword">false</span>;</span><br><span class="line">  entriesToAddOnCommit.clear();</span><br><span class="line">  entriesMissedInCache.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="86ILn"></a></p><h4 id="事务回滚"><a class="markdownIt-Anchor" href="#事务回滚"></a> 事务回滚</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 删除缓存未命中数据</span></span><br><span class="line">  unlockMissedEntries();</span><br><span class="line">  reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unlockMissedEntries源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlockMissedEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Object entry : entriesMissedInCache) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      delegate.removeObject(entry);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      log.warn(<span class="string">&quot;Unexpected exception while notifiying a rollback to the cache adapter.&quot;</span></span><br><span class="line">          + <span class="string">&quot;Consider upgrading your cache adapter to the latest version.  Cause: &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="m5ft2"></a></p><h4 id="entriesmissedincache作用分析"><a class="markdownIt-Anchor" href="#entriesmissedincache作用分析"></a> entriesMissedInCache作用分析</h4><p>源码易得entriesMissedInCache的作用是往缓存里添加null的数据，其作用可以结合BlockingCache来看，如果缓存查询得到的结果为null会导致该数据上锁，从而阻塞后续对该数据的操作。而事务回滚后，entriesMissedInCache通过保存的这些键值可以在事务结束时对数据解锁。源码原理如unlockMissedEntries，其调用BlockingCache的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">removeObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// despite of its name, this method is called only to release locks</span></span><br><span class="line">  releaseLock(key);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="QQy8D"></a></p><h2 id="transactionalcachemanager"><a class="markdownIt-Anchor" href="#transactionalcachemanager"></a> TransactionalCacheManager</h2><p>该类是用来管理一个事务中的多个缓存的，其中transactionalCaches保存了多个缓存和对应的经过缓存装饰器装饰后的缓存，如下所示：<br><code>private final Map&lt;Cache, TransactionalCache&gt; transactionalCaches = new HashMap&lt;&gt;();</code><br>其提交回滚源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">    txCache.commit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">    txCache.rollback();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="ADLT0"></a></p><h1 id="mybatis缓存机制"><a class="markdownIt-Anchor" href="#mybatis缓存机制"></a> Mybatis缓存机制</h1><p>cache包中并没设计缓存的具体使用，在executor包中，Mybatis基于cache包中提供的缓存实现了二级缓存。<br>Executor是执行器接口，其负责进行数据查询等操作，其类图如下：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1603269192495-27c116a6-a543-46e9-9e4b-36dd1db5546a.png#align=left&amp;display=inline&amp;height=207&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=413&amp;originWidth=998&amp;size=607326&amp;status=done&amp;style=none&amp;width=499" alt="image.png"><br>之后会对其进行详解，这里只对其两个子类功能进行分析：</p><ul><li>CachingExecutor：是一个装饰器类，它能够为执行器实现类增加缓存功能。</li><li>BaseExecutor是一个基类，它有四个子类，而其中ClosedExecutor没有实际功能，因此这里就只有三个实际执行器。</li></ul><p>两级缓存执行流程如下：<br><img src="./img/loading.gif" data-original="https://cdn.nlark.com/yuque/0/2020/png/485026/1603275800970-802ad58f-f927-4284-ba69-ef404b9b93ea.png#align=left&amp;display=inline&amp;height=324&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=647&amp;originWidth=747&amp;size=663804&amp;status=done&amp;style=none&amp;width=373.5" alt="image.png"><br><a name="P9Sbc"></a></p><h2 id="一级缓存"><a class="markdownIt-Anchor" href="#一级缓存"></a> 一级缓存</h2><p>Mybatis的一级缓存又叫本地缓存，其有两个配置项：</p><ul><li>配置在setting节点下，可选项有SESSION和STATEMENT分别对应一次会话和一条语句，其默认为SESSION。<ul><li>配置样式：<code>&lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt;</code></li></ul></li><li>在映射文件的数据库操作节点内增加flushCache属性项，为true时会在该数据库操作执行前清空一、二级缓存。默认为false。<ul><li>配置样式：<code>&lt;select id=&quot;selectUser_A&quot; resultMap=&quot;userMapByConstructor&quot; flushCache=&quot;false&quot;&gt;</code><br><a name="O8KR3"></a></li></ul></li></ul><h3 id="baseexecutor"><a class="markdownIt-Anchor" href="#baseexecutor"></a> BaseExecutor</h3><p>一级缓存主要由该类实现，其内部相关属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询操作的结果缓存</span></span><br><span class="line"><span class="keyword">protected</span> PerpetualCache localCache;</span><br><span class="line"><span class="comment">// Callable查询的输出参数缓存</span></span><br><span class="line"><span class="keyword">protected</span> PerpetualCache localOutputParameterCache;</span><br></pre></td></tr></table></figure><p>这两个属性都是基础的PerpetualCache类型，因为其都是Executor的属性，因此不可能超出其作用范围，而Executor归属于SqlSession，因此第一级缓存最大的作用与就是SqlSession即一次会话。<br>其query包括了整个缓存原理，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="comment">// 执行器已经关闭</span></span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查询栈为空且要求清空缓存</span></span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    <span class="comment">// 清除一级缓存</span></span><br><span class="line">    clearLocalCache();</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    queryStack++;</span><br><span class="line">    <span class="comment">// 尝试从本地获取缓存</span></span><br><span class="line">    list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 本地缓存中有结果，对于Callable语句还需要绑定到IN/OUTPUT参数上</span></span><br><span class="line">      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 本地缓存没有结果，需要查询数据库</span></span><br><span class="line">      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    queryStack--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 懒加载处理</span></span><br><span class="line">    <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">      deferredLoad.load();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// issue #601</span></span><br><span class="line">    deferredLoads.clear();</span><br><span class="line">    <span class="comment">// 如果作用域是STATEMENT则清空本地缓存</span></span><br><span class="line">    <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">      <span class="comment">// issue #482</span></span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据库操作用的INSERT、UPDATE、DALETE都对应了该类中的update方法，在该方法里会引发一级缓存的更新，该方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing an update&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="comment">// 执行器已关闭</span></span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清空本地缓存</span></span><br><span class="line">  clearLocalCache();</span><br><span class="line">  <span class="comment">// 返回调用子类操作</span></span><br><span class="line">  <span class="keyword">return</span> doUpdate(ms, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="pmc7X"></a></p><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p>可见BaseExecutor的作用范围有限，其内部的两个参数也不支持装饰器修饰，因此不支持容量配置等操作。<br><a name="nRiWV"></a></p><h2 id="二级缓存"><a class="markdownIt-Anchor" href="#二级缓存"></a> 二级缓存</h2><p>二级缓存作用范围是一个命名空间（配置文件），并且可以实现多命名空间共享。其配置项共有四个：</p><ul><li>第一个配置项在settings下，默认值为true，即支持二级缓存。<ul><li>配置演示：<code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</code></li></ul></li><li>第二个配置在映射文件内，即通过缓存的创建映射创建，同时也可以通过ref引入。</li><li>第三个配置在数据库操作节点内的useCache属性，通过它可以设置是否启用二级缓存。对于SELECT而言，useCache默认为true，对于其他节点来说没有意义。</li><li>第四个配置为flushCache属性项，和一级节点一致。<br><a name="v029Z"></a></li></ul><h3 id="cachingexecutor"><a class="markdownIt-Anchor" href="#cachingexecutor"></a> CachingExecutor</h3><p>二级缓存主要由该类实现，他只是一个装饰器类，其能通过装饰实际执行器来增加二级缓存的功能。Configuration类中的newExecutor方法Mybatis会根据配置文件中的二级缓存开关配置用CachingExecutor类修饰实际的执行器。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">  Executor executor;</span><br><span class="line">  <span class="comment">// 根据数据库类型创建实际执行器</span></span><br><span class="line">  <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据setting判断是否开启缓存</span></span><br><span class="line">  <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">    <span class="comment">// 使用CachingExecutor装饰执行器</span></span><br><span class="line">    executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 未执行器增加拦截器</span></span><br><span class="line">  executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">  <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然一条语句也是一个事务，那么事务缓存管理器可以应用在有事务的场景，也可以应用在没有事务的场景。<br>其内部属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被装饰得执行器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor delegate;</span><br><span class="line"><span class="comment">// 事务缓存管理器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TransactionalCacheManager tcm = <span class="keyword">new</span> TransactionalCacheManager();</span><br></pre></td></tr></table></figure><p>其核心query源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 获取MappedStatement对应的缓存，可能的结果有：该命名空间的缓存、共享的其他命名空间的缓存、无缓存</span></span><br><span class="line">  Cache cache = ms.getCache();</span><br><span class="line">  <span class="comment">// 如果映射文件未设置&lt;cache&gt;或&lt;cache-ref&gt;，则此处cache变量为null</span></span><br><span class="line">  <span class="comment">// 存在映射</span></span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据要求判断语句执行前是否要清除二级缓存</span></span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 二级缓存不支持含有输出参数的Callable的语句</span></span><br><span class="line">      ensureNoOutParams(ms, boundSql);</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      <span class="comment">// 读取缓存结果</span></span><br><span class="line">      List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">      <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 交给执行器</span></span><br><span class="line">        list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        <span class="comment">// 缓存被包装执行器返回的结果</span></span><br><span class="line">        tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flushCacheIfRequired源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取缓存</span></span><br><span class="line">  Cache cache = ms.getCache();</span><br><span class="line">  <span class="comment">// 存在缓存且该操作语句要求执行前清除</span></span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    <span class="comment">// 清除事务中的缓存</span></span><br><span class="line">    tcm.clear(cache);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其update方法会调用flushCacheIfRequired方法，而对于这些语句isFlushCacheRequired恒为true，因此总会导致二级缓存清除。</p></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined">Zhang Junjie</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://jie-blog.icu/posts/mybatis-cache/">https://jie-blog.icu/posts/mybatis-cache/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jie-blog.icu" target="_blank">Jieker's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/mybatis/">mybatis</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5f4e5a0be7fabc7b" async="async"></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="./img/loading.gif" data-original="/img/wechat.png" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="./img/loading.gif" data-original="/img/alipay.jpg" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/mybatis-jdbc/"><img class="prev-cover" src="./img/loading.gif" data-original="https://jie-blog.icu/img/mybatis/mybatis.jpg" onerror='onerror=null,src="/img/404.jpg"'><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">jdbc包</div></div></a></div><div class="next-post pull-right"><a href="/posts/mybatis-datasource/"><img class="next-cover" src="./img/loading.gif" data-original="https://jie-blog.icu/img/mybatis/mybatis.jpg" onerror='onerror=null,src="/img/404.jpg"'><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">datasource包</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image:url(https://jie-blog.icu/img/mybatis/mybatis.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020<i id="heartbeat" class="fa fas fa-heartbeat"></i> Zhang Junjie</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">welcome to my <a href="https://jie-blog.icu/">blog</a>!</div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></head></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'XOcW2XseURBSH0ajeHVGv0iN-gzGzoHsz',
      appKey: 'iJPxPr2bJjhcx7m3zC49NyQC',
      placeholder: '記得留下你的暱稱和郵箱....可以快速收到回復',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,document.body.addEventListener("input",POWERMODE)</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  'meta[name=description]',
  '#config_change',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  $('script[data-pjax]').each(function () {
    $(this).parent().append($(this).remove())
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', '', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})


document.addEventListener('pjax:send', function () {
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  $(window).off('scroll')

  //reset readmode
  $('body').hasClass('read-mode') && $('body').removeClass('read-mode')

})</script></div><script>window.imageLazyLoadSetting={isSPA:!1,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=i;var e=n.imageLazyLoadSetting.isSPA,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)void 0,0<=(t=r[a].getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight+240||document.documentElement.clientHeight+240)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e()},n.src=i}()}i(),n.addEventListener("scroll",function(){var t,e;t=i,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html>